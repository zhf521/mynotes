import{_ as d,o as t,c as o,b as e}from"./app-e8e9fc6e.js";const c={},i=e('<h2 id="_1-三次握手、四次挥手" tabindex="-1"><a class="header-anchor" href="#_1-三次握手、四次挥手" aria-hidden="true">#</a> 1. 三次握手、四次挥手</h2><figure><img src="https://zhf-picture.oss-cn-qingdao.aliyuncs.com/my-img/小林coding计网-TCP篇01.png" alt="小林coding计网-TCP篇01.png" tabindex="0" loading="lazy"><figcaption>小林coding计网-TCP篇01.png</figcaption></figure><table><thead><tr><th>TCP</th><th>特点</th></tr></thead><tbody><tr><td>为什么需要TCP？</td><td>IP层不可靠，不保证网络包的交付和数据完整性<br>TCP确保无损坏、无间隔、非冗余、按序</td></tr><tr><td>连接的基本共识</td><td>Socket：IP号 + 端口号<br>序列号：解决乱序问题<br>窗口大小：流量控制</td></tr><tr><td>如何唯一确定？</td><td>四元组<br>地址字段在IP头，端口字段在TCP头</td></tr><tr><td>TCP最大连接数？</td><td>理论上<code>max = 客户端IP数 * 客户端端口数</code>，实际受FD和内存的限制</td></tr></tbody></table><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>连接和方式</td><td>面向连接、可靠、字节流</td><td>无连接、不可靠、数据报</td></tr><tr><td>连接对象</td><td>一对一（单播）</td><td>一对一、一对多、多对一、 多对多（单播、多播、广播）</td></tr><tr><td>拥塞控制</td><td>有拥塞控制</td><td>无</td></tr><tr><td>首部开销</td><td>至少20字节</td><td>8字节</td></tr><tr><td>分片机制</td><td>如果HTTP消息比<code>MSS</code>长，就要在<code>传输层</code>分片</td><td>UDP数据如果大于<code>MTU</code>，在<code>IP</code>层分片</td></tr><tr><td>使用场景</td><td>实时应用，包括： 音视频、多媒体<br>包总量少的通信，如<code>DNS</code>、<code>SNMP</code>等</td><td><code>FTP</code>文件传输、HTTP/S</td></tr></tbody></table><figure><img src="https://zhf-picture.oss-cn-qingdao.aliyuncs.com/my-img/小林coding计网-TCP篇02.png" alt="小林coding计网-TCP篇02.png" tabindex="0" loading="lazy"><figcaption>小林coding计网-TCP篇02.png</figcaption></figure><p>为什么是三次握手：</p><ol><li>避免历史连接：如果因为宕机重发，最好在「被动发起方」建立连接前阻止历史连接，就不会资源浪费，而这样就需要三次握手</li><li>同步双方初始序列号：<code>序列号</code>作用：不重复、不丢弃、按序传输</li><li>避免资源浪费：服务端每收到一个SYN只能建立一个连接（因为不知道客户端是否收到自己的ACK），可能有冗余连接</li></ol><p>初始化序列号不一样？</p><p>为了防止历史报文被下一个相同四元组的连接接收。有时前一条数据因故阻塞，恰好服务端断电重启了，再重新建立连接，之前阻塞的消息再到达后会出bug。总而言之，为了防止上一次连接的数据被下一次连接接收</p><p>TCP为什么需要MSS？</p><p>先看定义：</p><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 1500 字节</li><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度</li></ul><p>IP没有超时重传机制，如果有一个IP分片丢失，那么整个IP报文分片都得重传；所以为了传输效能，TCP建立连接时协商<code>MSS</code>值，由此分片后IP包也不回大于<code>MTU</code>，此后如果一个TCP分片丢失了，重发时也只是以MSS为单位</p><p>第一次握手丢失了，发生什么？</p><p>客户端重传第一次握手<code>SYN</code>报文。第一次超时重传是在1秒后，每次重传时间是上一次的2倍，第<code>5</code>次重传（重传次数由内核参数决定）后，会等待32秒，如果还没回应就断开连接</p><p>第二次握手丢失了，发生什么？</p><p>两边都会重传：客户端重传第一次握手<code>SYN</code>报文，最大重传次数由<code>tcp_syn_retries</code>内核参数决定。服务端重传第二次握手<code>SYN-ACK</code>报文，最大重传次数由<code>tcp_synack_retries</code>内核参数决定</p><p>第三次握手丢失了，发生什么？</p><p>服务端重传第二次握手<code>SYN-ACK</code>报文</p><p>SYN攻击：攻击者伪造不同IP发送<code>SYN</code>报文，服务端发出去的<code>ACK+SYN</code> 无应答，占满半连接队列</p><p>SYN攻击避免方式：</p><ol><li>修改Linux内核参数，控制队列大小和队满处理方式</li><li><code>tcp_syncokies</code>方法。半连接队列满了后，新收到的<code>SYN</code>包计算出cookie值，返回给客户端；再收到客户端的应答报文时，检查合法性后直接放入全连接队列</li></ol><figure><img src="https://zhf-picture.oss-cn-qingdao.aliyuncs.com/my-img/小林coding计网-TCP篇03.png" alt="小林coding计网-TCP篇03.png" tabindex="0" loading="lazy"><figcaption>小林coding计网-TCP篇03.png</figcaption></figure><p>为什么需要四次？</p><p>假设客户端主动关闭连接，客户端发送<code>FIN</code>时，仅仅表示客户端不发数据了，但还能接收数据。服务端可能还有数据处理发送，待不再发送时，才回<code>FIN</code>给客户端</p><p>第一次挥手丢失了，发生什么？ 重传第一次挥手<code>FIN</code>报文，最大次数由<code>tcp_orphan_retries</code>决定；超过最大次数后再等待两倍时间就会断开</p><p>第二次挥手丢失了，发生什么？ 重传第一次挥手<code>FIN</code>报文（<code>ACK</code>报文是不会重传的）。对于调用<code>close</code>关闭的连接，60秒内没有收到<code>FIN</code>报文，主动关闭方就会关闭连接</p><p>第三次挥手丢失了，发生什么？ 和第一次挥手丢失后有些类似，重传并等待第四次挥手，超过参数后断开连接</p><p>第四次挥手丢失了，发生什么？ 重传第三次挥手<code>FIN</code>报文。客户端接收到 <code>FIN</code> 后发送 <code>ACK</code> ，进入<code>TIME_WAIT</code>状态并等待<code>2MSL</code> 的时间。如果在 <code>2MSL</code> 时间内，因为客户端的 <code>ACK</code> 没有传输到服务端，客户端又接收到了服务端重发的 <code>FIN</code> 报文，那么 <code>2MSL</code> 时间将重新计时</p><p>为什么需要TIME_WAIT？</p><ol><li><code>2MSL</code>的时间足以让原来连接的数据包都自然消失，防止历史连接数据被相同四元组错误连接接收</li><li>保证正确关闭。如果没有<code>2MSL</code>，客户端直接<code>CLOSE</code>，如果服务端再向已关闭的客户端发送<code>FIN</code>报文，客户端会回 <code>RST</code> 报文，不属于正常关闭了</li></ol><table><thead><tr><th></th><th>客户端<code>TIME_WAIT</code>过多</th><th>服务端<code>TIME_WAIT</code>过多</th></tr></thead><tbody><tr><td>危害</td><td>占用端口资源，很难和目的<code>IP</code> + <code>Port</code> 一样的服务器建立连接，但只要是不同的服务器还是可以重复使用的</td><td>因为服务器只监听一个端口，不会导致端口资源受限；但是会占用系统资源，比如fd、内存、CPU等</td></tr></tbody></table><table><thead><tr><th>TCP</th><th>客户端出现故障</th><th>服务端出现故障</th></tr></thead><tbody><tr><td>建立连接后</td><td>socket设置<code>SO_KEEPALIVE</code>启动保活机制，定时检测客户端故障造成的死亡连接</td><td>服务端会发送<code>FIN</code>和客户端进行挥手</td></tr></tbody></table>',33),r=[i];function p(a,n){return t(),o("div",null,r)}const h=d(c,[["render",p],["__file","03-小林coding计网-TCP篇.html.vue"]]);export{h as default};
