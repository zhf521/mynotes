import{_ as t,o as d,c as e,b as o}from"./app-12358925.js";const i={},l=o('<h2 id="_1-常见面试题" tabindex="-1"><a class="header-anchor" href="#_1-常见面试题" aria-hidden="true">#</a> 1. 常见面试题</h2><h3 id="_1-1-http是什么" tabindex="-1"><a class="header-anchor" href="#_1-1-http是什么" aria-hidden="true">#</a> 1.1 HTTP是什么</h3><p>HTTP 是超文本传输协议</p><p>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」</p><h3 id="_1-2-http常见状态码" tabindex="-1"><a class="header-anchor" href="#_1-2-http常见状态码" aria-hidden="true">#</a> 1.2 HTTP常见状态码</h3><ul><li><code>1xx</code>：提示信息，协议处理的一种中间状态，表示接收的请求正在处理</li><li><code>2xx</code>：成功，服务器正常收到客户端的请求，并处理完毕 <ul><li><code>200 OK</code> 是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据</li><li><code>204 No Content</code>与 200 OK 基本相同，但响应头没有 body 数据</li><li><code>206 Partial Content</code> 应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分</li></ul></li><li><code>3xx</code>：重定向，表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源 <ul><li><code>301 Moved Permanently</code>永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问</li><li><code>302 Found</code>临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问</li><li>301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL</li><li><code>304 Not Modified</code>不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制</li></ul></li><li><code>4xx</code>：客户端错误，表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义 <ul><li><code>400 Bad Request</code>表示客户端请求的报文有错误，但只是个笼统的错误</li><li><code>403 Forbidden</code>表示服务器禁止访问资源，并不是客户端的请求出错</li><li><code>404 Not Found</code>表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端</li></ul></li><li><code>5xx</code>：服务器错误，表示客户端请求报文正确，但是服务器处理时内部发生了错误 <ul><li><code>500 Internal Server Error</code>与 400 类似，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道</li><li><code>501 Not Implemented</code>表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思</li><li><code>502 Bad Gateway</code>通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误</li><li><code>503 Service Unavailable</code>表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思</li></ul></li></ul><h3 id="_1-3-http常见字段" tabindex="-1"><a class="header-anchor" href="#_1-3-http常见字段" aria-hidden="true">#</a> 1.3 HTTP常见字段</h3><ul><li><code>Host </code>客户端发送请求时，用来指定服务器的域名</li><li><code>Content-Length</code>服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度</li><li><code>Connection</code> 最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 Connection 首部字段的值为 Keep-Alive</li><li><code>Content-Type</code>服务器回应时，告诉客户端，本次数据是什么格式。客户端请求的时候，可以使用 <code>Accept</code>字段声明自己可以接受哪些数据格式</li><li><code>Content-Encoding</code>表示服务器返回的数据使用了什么压缩格式。客户端在请求时，用 <code>Accept-Encoding</code>字段说明自己可以接受哪些压缩方法</li><li><code>ETag</code>一种将资源以字符串形式做唯一性标识的方式，服务器为每份资源分配对应的ETag值；资源更新时候，ETag值也更新。例如：Google中英文网页的URI虽然相同但对应的ETag不同</li></ul><h3 id="_1-4-get和post区别" tabindex="-1"><a class="header-anchor" href="#_1-4-get和post区别" aria-hidden="true">#</a> 1.4 GET和POST区别</h3><p><strong>安全</strong>：是指请求方法不会「破坏」服务器上的资源 <strong>幂等</strong>：多次执行相同的操作，结果都是「相同」的</p><table><thead><tr><th>方法</th><th><code>GET</code></th><th><code>POST</code></th></tr></thead><tbody><tr><td>语义</td><td>请求获取指定的资源（只读）</td><td>对指定的资源做出处理（新增或提交数据）</td></tr><tr><td>安全性</td><td>安全、幂等</td><td>不安全、不幂等</td></tr><tr><td>缓存</td><td>可被缓存</td><td>一般不会缓存</td></tr><tr><td>请求数据位置</td><td>一般写在URL中</td><td>一般写在报文 body 中</td></tr></tbody></table><p>如果不照RFC规范定义的语义来实现的话， 上述都不一定</p><p>它们是 HTTP 请求协议的请求方法，而 HTTP 又是基于TCP/IP的关于数据如何在万维网中如何通信的协议，所以 GET/POST 实际上都是 TCP 链接</p><h3 id="_1-5-强制缓存和协商缓存" tabindex="-1"><a class="header-anchor" href="#_1-5-强制缓存和协商缓存" aria-hidden="true">#</a> 1.5 强制缓存和协商缓存</h3><table><thead><tr><th>缓存技术</th><th>强制缓存</th><th>协商缓存</th></tr></thead><tbody><tr><td>特点</td><td>浏览器判断没过期，则使用缓存（浏览器主动）</td><td>状态码<code>304</code>，告知客户端是否可以使用缓存（与服务端协商）</td></tr><tr><td>字段</td><td><code>Cache-control</code>:相对时间（优先级高） <code>Expires</code>：绝对时间</td><td>请求<code>If-Modified-Since</code>和响应<code>Last-Modified</code>：如果在这个时间后更新了才接受 &amp; 响应资源最后修改时间<br>请求<code>If-None-Match</code>和响应<code>ETag</code>：和ETag不一致的时候才接受（ETag优先级高）</td></tr><tr><td>结果</td><td>如果最后修改时间较新，则返回最新资源 <code>200</code> 否则返回<code>304</code></td><td>如果资源变化了返回<code>200</code>，否则返回<code>304</code></td></tr></tbody></table><h3 id="_1-6-http1-1" tabindex="-1"><a class="header-anchor" href="#_1-6-http1-1" aria-hidden="true">#</a> 1.6 HTTP1.1</h3><p><strong>优点</strong>：</p><ol><li>简单</li><li>灵活易扩展（例如HTTPS和HTTP/3对TCP层的修改）</li><li>应用广泛，跨平台</li></ol><p><strong>缺点</strong>：</p><ol><li>无状态——Cookie解决</li><li>不安全 <ul><li>明文传输 - 被<strong>窃听</strong></li><li>不验证通信方身份 - 被<strong>冒充和伪装</strong></li><li>不校验报文完整性 - 被<strong>篡改</strong></li></ul></li></ol><p>和<code>HTTP1.0</code>相比的优势：</p><ol><li>长连接——减少重复操作的开销</li><li>管道网络传输——不等回应即可发送第二个请求，减少响应时间</li><li>队头阻塞</li></ol><h3 id="_1-7-https" tabindex="-1"><a class="header-anchor" href="#_1-7-https" aria-hidden="true">#</a> 1.7 HTTPS</h3><p>HTTP的通信接口部分用SSL/TLS协议代替 == HTTPS（即HTTP + 加密 + 认证 + 完整性保护）</p><table><thead><tr><th>协议</th><th>HTTP</th><th>HTTPS</th></tr></thead><tbody><tr><td>安全性</td><td>明文传输</td><td>TCP 和 HTTP 之间加入了 SSL/TLS 安全协议，加密传输报文</td></tr><tr><td>连接</td><td>三次握手</td><td>三次握手+SSL/TLS握手</td></tr><tr><td>端口号</td><td>80</td><td>443</td></tr></tbody></table><p>另外HTTPS需要向CA申请数字证书来确保服务器的身份</p><p>如何解决HTTP的安全问题：</p><ul><li>明文传输产生的<strong>窃听</strong>问题——信息加密 <code>（混合加密）</code></li><li>不验证身份产生的<strong>冒充</strong>问题——校验机制 <code>（证书）</code></li><li>不校验完整性产生的<strong>篡改</strong>问题——身份证书 <code>（摘要算法）</code></li></ul><p>常见非对称加密算法：RSA、DSA、ECC、DH</p><p>常见对称加密算法：DES、3DES、AES、RC（记：RC或者ES结尾的是对称）</p><h3 id="_1-8-http的演变" tabindex="-1"><a class="header-anchor" href="#_1-8-http的演变" aria-hidden="true">#</a> 1.8 HTTP的演变</h3><table><thead><tr><th>协议</th><th>HTTP/1.1</th><th>HTTP/2</th><th>HTTP/3(QUIC的特点)</th></tr></thead><tbody><tr><td>改进</td><td>1.<em><strong>长连接</strong></em><br>2.<em><strong>管道运输</strong></em>：一次发送多个请求 <br>3.废弃了两种<em><strong>请求方法</strong></em>LINK和UNLINK，新增了CONNECT、OPTIONS和TRACE<br>4.新增了大量状态码</td><td>1.头部压缩<br>2.<code>二</code>进制格式 <br>3.数据流：可以乱序发送，后stream ID组成HTTP信息 <br>4.多路复用，串行变成并发<br>5.服务器推送</td><td><code>TCP</code>-&gt;<code>UDP</code>+ <code>QUIC</code><br>1.无队头阻塞<br>2.更快的连接建立（QUIC包含TLS，只需1个RTT）<br>3.连接迁移</td></tr><tr><td>不足</td><td>1.<strong>头部冗长</strong>，未经压缩，浪费带宽，造成延迟<br>2.没有请求优先级，所以<strong>队头阻塞</strong>(HTTP层) <br>3.服务器只能被动接收客户端的请求</td><td>TCP层队头阻塞 TCP和TLS握手时延</td><td>普及慢，很多网络设备不识别QUIC</td></tr></tbody></table><figure><img src="https://zhf-picture.oss-cn-qingdao.aliyuncs.com/my-img/小林coding计网-HTTP篇01.png" alt="小林coeding计网-HTTP篇01.png" tabindex="0" loading="lazy"><figcaption>小林coeding计网-HTTP篇01.png</figcaption></figure><h2 id="_2-http1-1如何优化" tabindex="-1"><a class="header-anchor" href="#_2-http1-1如何优化" aria-hidden="true">#</a> 2. HTTP1.1如何优化</h2><table><thead><tr><th>三个角度</th><th>具体优化方法</th></tr></thead><tbody><tr><td>避免发送HTTP请求</td><td><code>缓存</code> 客户端第一次请求及数据保存在本地磁盘，形成&lt;key,value&gt;<br> 过期？在请求的<code>ETag</code>带上第一次请求中响应头部的摘要，服务器收到后会与本地资源的摘要作比较，如果相同则返回不含包体的<code>304 Not Modified</code></td></tr><tr><td>减少请求次数</td><td>1.减少重定向请求次数：利用中间的代理服务器知晓规则<br>2.合并请求：合并资源，如CSS、webpack<br>3.延迟发送请求：按需获取，滑动页面的时候再获取资源</td></tr><tr><td>减少服务器响应数据大小</td><td>无损压缩：gzip。请求<code>Accepy-Encoding</code>，响应<code>Content-Encoding</code>（文本、程序代码)<br>有损压缩：舍弃一些数据（质量）。请求<code>Accept</code>中的q质量因子（音视频、图片）</td></tr></tbody></table><h2 id="_3-https如何优化" tabindex="-1"><a class="header-anchor" href="#_3-https如何优化" aria-hidden="true">#</a> 3. HTTPS如何优化</h2><ol><li>硬件优化、软件优化：HTTPS 协议是计算密集型，而不是 I/O 密集型，所以不能把钱花在网卡、硬盘等地方，应该花在 <code>CPU</code> 上</li><li>协议优化 <ol><li>用ECDHE替换RSA，往返<code>1</code>RTT</li><li><code>TLS 1.2</code>-&gt;<code>TLS 1.3</code>，往返<code>1</code>RTT；在Hello时就发送椭圆曲线，且废除RSA和DH</li></ol></li><li>证书优化 <ol><li>证书选择：椭圆曲线证书比RSA密钥长度短</li><li>证书验证优化：<code>OCSP</code>(Online Certificate Status Protocal)、<code>OCSP Stapling</code></li></ol></li><li>密钥缓存（无前向安全，且易被重放攻击） <ol><li>Session ID：双方缓存密钥，Session ID和密钥相当于key-value。但是也有缺点，首先是每一个客户端都要保存密钥，其次是现在网站一般多服务器，不一定命中上次的服务器</li><li>Session Ticket：客户端负责缓存</li><li>Pre-shared Key：<code>TLS 1.3</code>重连只需要<code>0</code> RTT。重连时Ticket和HTTP一起发给服务端</li><li>解决重放攻击，应给密钥设定过期时间</li></ol></li></ol><h2 id="_4-http2提高传输效率、吞吐能力" tabindex="-1"><a class="header-anchor" href="#_4-http2提高传输效率、吞吐能力" aria-hidden="true">#</a> 4. HTTP2提高传输效率、吞吐能力</h2><ul><li><p>兼容HTTP1.1</p><ul><li>没有在URL改变协议名字，只在应用层做了改变，还是基于TCP传输，但是把HTTP分解成了<code>语义</code>和<code>语法</code>，语义没变，还是请求方法、状态码和头字段等，语法有很多改变</li></ul></li><li><p>头部压缩（解决头部冗长问题）</p><ul><li>HPACK<code>取代</code>gzip <ul><li>静态表：首先两端维护一个字典，用索引号<code>index</code>代替字段名（GET，200，https等），共61种高频字符串</li><li>动态表：发送新首部时在静态表里添加索引号</li><li>Huffman编码：关于首部字段的内容用哈夫曼编码代替，基于二进制编码，不需要\\r\\n，改用表示字符串长度的Value Length</li></ul></li></ul></li><li><p>二进制帧</p><ul><li>二进制+位运算</li></ul></li><li><p>并发传输（解决队头阻塞问题）</p><ul><li>多个Stream复用一条TCP连接，达到并发效果；每个帧头携带Stream ID，同一Stream内部的帧严格有序，方便接收后组装；还可以设置优先级，比方说先传递HTML再传递图片</li><li>包含关系：TCP连接 &gt; Stream &gt; Message &gt;Frame</li></ul></li><li><p>服务器主动推送（解决不支持服务器推送问题）</p></li></ul><p>但是HTTP2是基于TCP传输数据的，TCP是字节流协议，必须保证字节数据是完整连续的，内核才会将缓冲区的数据给HTTP应用，这方面存在阻塞，因此改用UDP，即HTTP3</p><h2 id="_5-http3" tabindex="-1"><a class="header-anchor" href="#_5-http3" aria-hidden="true">#</a> 5. HTTP3</h2><p>之前存在的问题：</p><ol><li>队头阻塞：TCP丢包时，整个TCP都要等待重传</li><li>握手延迟：发起HTTP请求时，需要经过TCP+TLS总计<code>3RTT</code>时延</li><li>网络迁移需要重新连接：4G切WiFi时要重新握手，因为IP地址和端口变动了</li></ol><p><code>QUIC</code>协议特点：</p><ol><li>无队头阻塞，Stream之间没有依赖</li><li>更快建立连接：QUIC包含TLS，只需要<code>1RTT</code>即可握手</li><li>连接迁移：通过<code>连接ID</code>标记两个端点，而不是IP地址和端口</li></ol><p>其他：<code>HPACK</code>升级-&gt;<code>QPACK</code>，静态表91项</p>',46),c=[l];function r(a,T){return d(),e("div",null,c)}const n=t(i,[["render",r],["__file","02-小林coding计网-HTTP篇.html.vue"]]);export{n as default};
