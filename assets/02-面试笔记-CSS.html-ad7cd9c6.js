import{_ as n,r as a,o,c,d as i,e as l,a as d,b as t}from"./app-64c1b973.js";const r={},s=t('<h2 id="_1-盒模型" tabindex="-1"><a class="header-anchor" href="#_1-盒模型" aria-hidden="true">#</a> 1. 盒模型</h2><p>浏览器的渲染引擎在对网页文档进行布局时，会按照 “CSS 基础盒模型” （CSS Basic Box Model）标准，将文档中的所有元素都表示为一个个矩形的盒子，再用 CSS 去决定这些盒子的大小尺寸、显示位置、以及其他属性（如颜色、背景、边框等）</p><p>CSS3中的盒模型有以下两种：标准盒子模型、IE盒子模型</p><p>盒模型都是由四个部分组成的，分别是margin（外边距）、border（边框）、padding（内边距）和content（内容）</p><p>标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同：</p><ul><li>标准盒模型的width和height属性的范围只包含了content</li><li>IE盒模型的width和height属性的范围包含了border、padding和content</li></ul><p>在 CSS3 中，我们可以通过设置 box-sizing 的值来决定具体使用何种盒模型：</p><ul><li>content-box 标准盒模型（默认值）</li></ul><ul><li>border-box 怪异盒模型（IE盒模型）</li></ul><h2 id="_2-css选择器及其优先级" tabindex="-1"><a class="header-anchor" href="#_2-css选择器及其优先级" aria-hidden="true">#</a> 2. CSS选择器及其优先级</h2>',10),h={href:"https://zhf521.github.io/mynotes/front-end/css-notes/02-CSS%E9%80%89%E6%8B%A9%E5%99%A8.html",target:"_blank",rel:"noopener noreferrer"},p=i("h2",{id:"_3-css样式引入方式",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#_3-css样式引入方式","aria-hidden":"true"},"#"),l(" 3. CSS样式引入方式")],-1),u={href:"https://zhf521.github.io/mynotes/front-end/css-notes/01-%E5%88%9D%E8%AF%86CSS.html#_2-css%E7%9A%84%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F",target:"_blank",rel:"noopener noreferrer"},_=t('<h2 id="_4-css中可继承与不可继承属性有哪些" tabindex="-1"><a class="header-anchor" href="#_4-css中可继承与不可继承属性有哪些" aria-hidden="true">#</a> 4. CSS中可继承与不可继承属性有哪些</h2><h3 id="_1-可继承属性" tabindex="-1"><a class="header-anchor" href="#_1-可继承属性" aria-hidden="true">#</a> 1. 可继承属性</h3><ul><li>字体系列属性 <ul><li>font-family：字体系列</li><li>font-weight：字体的粗细</li><li>font-size：字体的大小</li><li>font-style：字体的风格</li></ul></li><li>文本系列属性 <ul><li>text-indent：文本缩进</li><li>text-align：文本水平对齐</li><li>line-height：行高</li><li>word-spacing：单词之间的间距</li><li>letter-spacing：中文或者字母之间的间距</li><li>text-transform：控制文本大小写（即uppercase、lowercase、capitalize）</li><li>color：文本颜色</li></ul></li><li>元素可见性 <ul><li>visibility：控制元素显示隐藏</li></ul></li><li>列表布局属性 <ul><li>list-style：列表风格，包括list-style-type、list-style-image等</li></ul></li><li>光标属性 <ul><li>cursor：光标显示为何种形态</li></ul></li></ul><h3 id="_2-不可继承属性" tabindex="-1"><a class="header-anchor" href="#_2-不可继承属性" aria-hidden="true">#</a> 2. 不可继承属性</h3><ul><li>display</li><li>文本属性 <ul><li>vertical-align：垂直文本对齐</li><li>text-decoration：规定添加到文本的装饰</li><li>text-shadow：文本阴影效果</li><li>white-space：空白符的处理</li><li>unicode-bidi：设置文本的方向</li></ul></li><li>盒子模型的属性</li><li>背景属性</li><li>定位属性</li><li>生成内容属性</li><li>轮廓样式属性</li><li>页面样式属性</li><li>声音样式属性</li></ul><h2 id="_5-display的属性值及其作用" tabindex="-1"><a class="header-anchor" href="#_5-display的属性值及其作用" aria-hidden="true">#</a> 5. display的属性值及其作用</h2><table><thead><tr><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td>none</td><td>元素不显示，并且会从文档流中移除</td></tr><tr><td>block</td><td>块类型。默认宽度为父元素宽度，可设置宽高，换行显示</td></tr><tr><td>inline</td><td>行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示</td></tr><tr><td>inline-block</td><td>默认宽度为内容宽度，可以设置宽高，同行显示</td></tr><tr><td>list-item</td><td>像块类型元素一样显示，并添加样式列表标记</td></tr><tr><td>table</td><td>此元素会作为块级表格来显示</td></tr><tr><td>inherit</td><td>规定应该从父元素继承display属性的值</td></tr></tbody></table><h2 id="_6-display的block、inline和inline-block的区别" tabindex="-1"><a class="header-anchor" href="#_6-display的block、inline和inline-block的区别" aria-hidden="true">#</a> 6. display的block、inline和inline-block的区别</h2><ul><li>block：会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性</li><li>inline：元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin</li><li>inline-block：将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内</li></ul><h2 id="_7-隐藏元素的方法" tabindex="-1"><a class="header-anchor" href="#_7-隐藏元素的方法" aria-hidden="true">#</a> 7. 隐藏元素的方法</h2><ul><li>display: none：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件</li><li>visibility: hidden：元素在页面中仍占据空间，但是不会响应绑定的监听事件</li><li>opacity: 0：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件</li><li>position: absolute：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏</li><li>z-index: 负值：来使其他元素遮盖住该元素，以此来实现隐藏</li><li>clip/clip-path ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件</li><li>transform: scale(0,0)：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件</li></ul><h2 id="_8-link与-import的区别" tabindex="-1"><a class="header-anchor" href="#_8-link与-import的区别" aria-hidden="true">#</a> 8. link与@import的区别</h2><p>两者都是外部引用CSS的方式，区别如下：</p><ul><li><code>link</code>功能较多，可以定义<code>RSS</code>，而<code>@import</code>只能用于加载<code>CSS</code></li><li>当解析到<code>link</code>时，页面会同步加载所引用的 <code>css</code>，而<code>@import</code>所引用的 <code>css</code> 会等到页面加载完才被加载</li><li><code>@import</code>兼容性差</li><li><code>link</code>可以使用 <code>js</code> 动态引入，<code>@import</code>不行</li></ul><h2 id="_9-display-none与visibility-hidden的区别" tabindex="-1"><a class="header-anchor" href="#_9-display-none与visibility-hidden的区别" aria-hidden="true">#</a> 9. display:none与visibility:hidden的区别</h2><p><code>display:none</code>与<code>visibility:hidden</code>都可以使元素不可见，区别如下：</p><ul><li>渲染树中 <ul><li><code>display: none;</code>会使元素完全从渲染树中消失，不占据任何空间</li><li><code>visibility: hidden;</code>不会使元素从渲染树中消失，仍然占据空间，只是内容不可见</li></ul></li><li>继承性 <ul><li><code>display: none;</code>是非继承属性，子孙节点消失是因为元素本身从渲染树中消失，修改子孙节点的属性无法使其显示</li><li><code>visibility: hidden;</code>是继承属性，子孙节点消失是因为继承了<code>hidden</code>属性，通过设置<code>visibility: visible;</code>可以使子孙节点显示</li></ul></li><li>导致重排和重绘 <ul><li>修改具有常规流的元素的<code>display</code>属性通常会导致文档重排（重新计算元素的位置和大小）</li><li>修改<code>visibility</code>属性只会导致本元素的重绘（重新绘制元素的可见部分）</li></ul></li><li>读屏器（屏幕阅读软件） <ul><li>不会读取<code>display: none;</code>元素的内容</li><li>会读取<code>visibility: hidden;</code>元素的内容</li></ul></li></ul>',17);function b(y,S){const e=a("ExternalLinkIcon");return o(),c("div",null,[s,i("p",null,[l("详见："),i("a",h,[l("CSS选择器"),d(e)])]),p,i("p",null,[l("详见："),i("a",u,[l("CSS样式引入方式"),d(e)])]),_])}const m=n(r,[["render",b],["__file","02-面试笔记-CSS.html.vue"]]);export{m as default};
