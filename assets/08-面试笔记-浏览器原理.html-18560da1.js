import{_ as e,o as i,c as l,b as r}from"./app-722ccd50.js";const S={},a=r('<h2 id="_1-浏览器的渲染过程" tabindex="-1"><a class="header-anchor" href="#_1-浏览器的渲染过程" aria-hidden="true">#</a> 1. 浏览器的渲染过程</h2><h3 id="_1-1-基本过程" tabindex="-1"><a class="header-anchor" href="#_1-1-基本过程" aria-hidden="true">#</a> 1.1 基本过程</h3><ol><li><p>解析HTML的所有标签，深度遍历生成DOM树</p></li><li><p>解析CSS，构建层叠样式表模型CSSOM树</p></li><li><p>构建Render Tree（渲染树）</p><p>DOM和CSSOM根据一定的规则组合起来生成了Render Tree</p></li><li><p>布局（Layout）</p><p>确定各个元素的大小、位置。浏览器使用一种<strong>流式</strong>处理的方法，只需要<strong>一次绘制</strong>操作就可以布局所有的元素</p></li><li><p>绘制（Painting）</p><p>浏览器会遍历Render Tree渲染树，调用paint方法，将渲染树的各个节点绘制到屏幕上</p></li></ol><h3 id="_1-2-关于css、js阻塞问题" tabindex="-1"><a class="header-anchor" href="#_1-2-关于css、js阻塞问题" aria-hidden="true">#</a> 1.2 关于CSS、JS阻塞问题</h3><ul><li>CSS 加载会不会阻塞 JS 的加载？（不会）</li><li>CSS 加载会不会阻塞 JS 的执行？（会）</li><li>CSS 加载会不会阻塞 DOM 的解析？（不会）</li><li>CSS 加载会不会阻塞 DOM 的渲染？（会）</li><li>JS 加载会不会阻塞 DOM 的解析？（会）</li><li>JS 加载会不会阻塞 DOM 的渲染？（会）</li><li>JS 执行会不会阻塞 DOM 的解析？（会）</li><li>JS 执行会不会阻塞 DOM 的渲染？（会）</li></ul><p>关于 css，js 的阻塞问题，都跟浏览器的渲染进程有关。而渲染进程又是多线程的</p><ul><li>JS 引擎线程（单线程）：负责解析 Javascript 脚本，运行代码</li><li>GUI 渲染线程：负责渲染浏览器界面，解析 HTML，CSS，构建 DOM Tree，CSSOM Tree 和 Render Tree，布局和绘制等</li></ul><blockquote><p>注意：GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起，所以当 JS 加载和执行时，会阻塞住 DOM 的解析和渲染，导致白屏时间很长</p></blockquote><blockquote><p>DOM Tree 和 CSSOM Tree 是并行构建的，所以 CSS 加载不会阻塞 DOM 的解析；由于 Render Tree 是依赖于 DOM Tree 和 CSSOM Tree 的，因此，CSS 加载会阻塞 DOM 的渲染</p></blockquote><blockquote><p>GUI 渲染线程与 JS 引擎线程是互斥的，加载解析 CSS 时，JS 引擎会被挂起，所以 CSS 会阻塞 JS 的执行</p></blockquote><ol><li>如果遇到普通（sync）JavaScript脚本加载：文档解析的过程中，如果遇到JavaScript脚本，就会停止页面的解析进行下载，当脚本都执行完毕后，才会继续解析页面</li><li>如果遇到异步（async）JavaScript脚本加载：异步脚本会在HTML加载和解析完毕后执行</li><li>如果遇到设置了推迟的JavaScript脚本加载：文档解析时，遇到设置了defer的脚本，就会在后台进行下载，但是并不会阻止文档的渲染，当页面解析和渲染完毕后，会等到所有的defer脚本加载完毕并按照顺序执行完毕才会触发</li></ol><blockquote><p><strong>defer是“渲染完再执行”：<strong>依赖于页面中的DOM元素（文档是否解析完毕），或者被其他脚本文件</strong>依赖</strong></p><p>**async是“下载完就执行”：**并不关心页面中的DOM元素（文档是否解析完毕），并且也不会产生其他脚本需要的数据</p></blockquote>',12),t=[a];function o(c,n){return i(),l("div",null,t)}const p=e(S,[["render",o],["__file","08-面试笔记-浏览器原理.html.vue"]]);export{p as default};
