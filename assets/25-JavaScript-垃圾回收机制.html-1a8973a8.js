import{_ as a,o as e,c as i,b as r}from"./app-71568de9.js";const l={},h=r('<h2 id="_1-什么是垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#_1-什么是垃圾回收机制" aria-hidden="true">#</a> 1. 什么是垃圾回收机制</h2><p>垃圾回收机制（Garbage Collection）简称 GC</p><p>JavaScript 中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收，如果不再用到的内存没有及时释放，则会产生内存泄漏</p><h2 id="_2-内存的生命周期" tabindex="-1"><a class="header-anchor" href="#_2-内存的生命周期" aria-hidden="true">#</a> 2. 内存的生命周期</h2><p>JavaScript 环境中分配的内存，一般有如下生命周期：</p><ol><li>内存分配：当我们声明变量、函数、对象的时候，系统会自动为它们分配内存</li><li>内存使用：即读写内存，也就是使用变量、函数等</li><li>内存回收：使用完毕，由垃圾回收器自动回收不再使用的内存</li></ol><p>说明：</p><ul><li>全局变量一般不会回收（关闭页面回收）</li><li>一般情况下局部变量的值不用了，会被自动回收掉</li></ul><h2 id="_3-垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#_3-垃圾回收算法" aria-hidden="true">#</a> 3. 垃圾回收算法</h2><h3 id="_3-1-引用计数" tabindex="-1"><a class="header-anchor" href="#_3-1-引用计数" aria-hidden="true">#</a> 3.1 引用计数</h3><p>定义“内存不再使用”，就是看一个对象是否有指向它的引用，没有引用了就回收对象</p><p>算法：</p><ol><li>跟踪记录被引用的次数</li><li>如果被引用了一次，那么就记录次数 1，多次引用会累加</li><li>如果减少一个引用就减一</li><li>如果引用次数是 0，则释放内存</li></ol><p>存在问题： 嵌套引用（循环引用），如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄漏</p><h3 id="_3-2-标记清除法" tabindex="-1"><a class="header-anchor" href="#_3-2-标记清除法" aria-hidden="true">#</a> 3.2 标记清除法</h3><p>现代浏览器大多使用该方法</p><p>算法：标记清除法将“不再使用的对象”定义为“无法到达的对象”，就是从根部出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的，那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收</p>',17),t=[h];function _(c,d){return e(),i("div",null,t)}const o=a(l,[["render",_],["__file","25-JavaScript-垃圾回收机制.html.vue"]]);export{o as default};
