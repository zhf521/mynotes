import{_ as e,o as i,c as a,e as l}from"./app-3b86f382.js";const d={},t=l('<h2 id="_1-http-状态码" tabindex="-1"><a class="header-anchor" href="#_1-http-状态码" aria-hidden="true">#</a> 1. HTTP 状态码</h2><p>注意，无论是状态码规范，还是整个 HTTP 协议规范，都是前后端的一个<strong>约定</strong>，需要大家都来遵守</p><p>所谓约定或者规范，不是强制的，你可以不遵守</p><p>但是如果大家都遵守，你特立独行，就会慢慢的被孤立</p><p>所以，无论是这里的 HTTP 协议，还是开发中其他的事情。我们都要尽量去遵守业界的规范，参照业界的标准</p><h3 id="_1-状态码分类" tabindex="-1"><a class="header-anchor" href="#_1-状态码分类" aria-hidden="true">#</a> 1. 状态码分类</h3><ul><li>1xx 服务器收到请求</li><li>2xx 成功</li><li>3xx 重定向</li><li>4xx 客户端错误</li><li>5xx 服务器错误</li></ul><h3 id="_2-常见状态码" tabindex="-1"><a class="header-anchor" href="#_2-常见状态码" aria-hidden="true">#</a> 2. 常见状态码</h3><p>HTTP 协议中的状态码有很多，但只有一些是我们常用的</p><ul><li>200 成功</li><li>301 永久重定向（同时返回一个 location ，写明重定向的 url），例如一个网站的网址永久性的切换了</li><li>302 临时重定向（同时返回一个 location ，写明重定向的 url），例如短链跳转</li><li>304 资源未修改过</li><li>404 未找到资源</li><li>403 没有权限，例如需要登录之后才能请求</li><li>500 服务器内部错误，例如服务器代码异常</li><li>504 网关超时，例如上游服务器连接失败（服务器不是一台机器，可能会有很多台）</li></ul><h2 id="_2-http-methods" tabindex="-1"><a class="header-anchor" href="#_2-http-methods" aria-hidden="true">#</a> 2. HTTP methods</h2><h3 id="_1-常用-methods" tabindex="-1"><a class="header-anchor" href="#_1-常用-methods" aria-hidden="true">#</a> 1. 常用 methods</h3><p>之前，常用的方法就是 get 和 post</p><ul><li>get 从服务端获取数据</li><li>post 向服务端提交数据</li></ul><p>现在，随着技术更新，以及 Restful API 设计，有更多的 methods 被应用</p><ul><li>get 获取数据</li><li>post 新建数据</li><li>patch/put 更新数据</li><li>delete 删除数据</li></ul><h3 id="_2-restful-api" tabindex="-1"><a class="header-anchor" href="#_2-restful-api" aria-hidden="true">#</a> 2. Restful API</h3><p>Restful API 是前后端接口的一种设计规范，传统的 API 设计是把每个 API 当做一个功能，而Restful API 设计是把每个 API 当做一个资源标识</p><p>需要用到的手段：</p><ul><li>不使用 url 参数</li><li>使用 method 表示操作类型</li></ul><p>例如要获取一个列表：</p><ul><li>（不使用 url 参数）</li><li>传统 API 设计：<code>/api/list?pageIndex=2</code> —— 一个功能</li><li>Restful API 设计：<code>/api/list/2</code> —— 一个资源</li></ul><p>再例如要操作一个数据：</p><ul><li>传统 API 设计（每个 API 都是功能） <ul><li><code>/api/create-blog</code> ，post 请求</li><li><code>/api/udpate-blog?id=101</code>，post 请求</li><li><code>/api/get-blog?id=101</code>， get 请求</li></ul></li><li>Restful API 设计（每个 API 都是资源） <ul><li><code>/api/blog</code> ，post 请求</li><li><code>/api/blog/101</code> ，patch 请求</li><li><code>/api/blog/101</code> ，get 请求</li></ul></li></ul><h2 id="_3-http-headers" tabindex="-1"><a class="header-anchor" href="#_3-http-headers" aria-hidden="true">#</a> 3. HTTP headers</h2><h3 id="_1-request-headers" tabindex="-1"><a class="header-anchor" href="#_1-request-headers" aria-hidden="true">#</a> 1. request headers</h3><p>浏览器发送请求时，传递给服务端的信息：</p><ul><li>Accept 浏览器可接收的数据类型</li><li>Accept-Encoding 浏览器可接收的压缩算法，如 gzip</li><li>Accept-Language 浏览器可接收的语言，如 zh-CN</li><li>Connection: keep-alive 一次 TCP 连接重复使用</li><li>cookie</li><li>Host</li><li>User-Agent 浏览器信息</li><li>Content-type 发送数据的类型，常见的有 application/json，application/x-www-form-urlencoded，multipart/form-data，text/plain 等</li></ul><h3 id="_2-response-headers" tabindex="-1"><a class="header-anchor" href="#_2-response-headers" aria-hidden="true">#</a> 2. response headers</h3><ul><li>Content-Type 返回的数据类型，对应 Accept</li><li>Content-Length 数据大小</li><li>Content-Encoding 压缩算法，如 gzip ，对应 Accept-Encoding</li><li>Set-Cookie</li></ul><h3 id="_3-自定义-header" tabindex="-1"><a class="header-anchor" href="#_3-自定义-header" aria-hidden="true">#</a> 3. 自定义 header</h3><p>有些接口需要前端调用时，加一个自定义的 header</p><h2 id="_4-http-缓存" tabindex="-1"><a class="header-anchor" href="#_4-http-缓存" aria-hidden="true">#</a> 4. HTTP 缓存</h2><h3 id="_1-什么是缓存" tabindex="-1"><a class="header-anchor" href="#_1-什么是缓存" aria-hidden="true">#</a> 1. 什么是缓存</h3><p>缓存，即某些情况下，资源不是每次都去服务端获取，而是第一次获取之后缓存下来，下次再请求时，直接读取本地缓存，而不再去服务端请求</p><h3 id="_2-为什么需要缓存" tabindex="-1"><a class="header-anchor" href="#_2-为什么需要缓存" aria-hidden="true">#</a> 2. 为什么需要缓存</h3><p>核心需求，让网页更快的显示出来，即提高性能，计算机在执行计算时速度非常快，包括页面渲染，JS 执行等，但是加载资源却非常慢（相比于计算来说），而且受限于网络不可控，最好的办法就是缓存起来</p><h3 id="_3-哪些资源需要缓存" tabindex="-1"><a class="header-anchor" href="#_3-哪些资源需要缓存" aria-hidden="true">#</a> 3. 哪些资源需要缓存</h3><p>对于一个网页来说：</p><ul><li>HTML 页面不能缓存</li><li>业务数据不能缓存（例如一个博客项目，里面的博客信息）</li><li>静态资源可以缓存，JS、CSS、图片等（所有的静态资源累加起来，体积是很大的）</li></ul><h3 id="_4-缓存策略之强制缓存-客户端缓存" tabindex="-1"><a class="header-anchor" href="#_4-缓存策略之强制缓存-客户端缓存" aria-hidden="true">#</a> 4. 缓存策略之强制缓存，客户端缓存</h3><p><strong>Cache-Control</strong> (response headers 中) 表示该资源，被再次请求时的缓存情况</p><ul><li><code>max-age:31536000</code> 单位是 s ，该资源被强制缓存 1 年</li><li><code>no-cache</code> 不使用强制缓存，但不妨碍使用协商缓存</li><li><code>no-store</code> 禁用一起缓存，每次都从服务器获取最新的资源</li><li><code>private</code> 私有缓存（浏览器级缓存）</li><li><code>public</code> 共享缓存（代理级缓存）</li></ul><h3 id="_5-缓存策略之协商缓存-对比缓存-服务端缓存" tabindex="-1"><a class="header-anchor" href="#_5-缓存策略之协商缓存-对比缓存-服务端缓存" aria-hidden="true">#</a> 5. 缓存策略之协商缓存（对比缓存），服务端缓存</h3><p>当强制缓存失效，请求会被发送到服务端。此时，服务端也不一定每次都要返回资源，如果客户端资源还有效的话</p><p>第一，<strong>Last-Modified</strong>（Response Headers）和 <strong>If-Modified-Since</strong>（Request Headers）</p><ul><li>Last-Modified 服务端返回资源的最后修改时间</li><li>If-Modified-Since 再次请求时带着最后修改时间</li><li>服务器根据时间判断资源是否被修改（如未被修改则返回 304，失败则返回新资源和新的缓存规则）</li></ul><p>第二，<strong>Etag</strong>（Response Headers）和 <strong>If-None-Match</strong>（Request Headers）</p><ul><li>Etag 服务端返回的资源唯一标识（类似人的指纹，唯一，生成规则由服务器端决定，结果就是一个字符串）</li><li>If-None-Match 再次请求时带着这个标识</li><li>服务端根据资源和这个标识是否 match （成功则返回 304，失败则返回新资源和新的缓存规则）</li></ul><p>如果两者一起使用，则<strong>优先使用 Etag</strong> 规则。因为 Last-Modified 只能精确到秒级别</p><h3 id="_6-刷新操作对应不同的缓存策略" tabindex="-1"><a class="header-anchor" href="#_6-刷新操作对应不同的缓存策略" aria-hidden="true">#</a> 6. 刷新操作对应不同的缓存策略</h3><p>三种操作：</p><ul><li>正常操作：地址栏输入 url ，点击链接，前进后退等</li><li>手动刷新：F5 或者点击刷新按钮</li><li>强制刷新：ctrl + F5</li></ul><p>对应的缓存策略：</p><ul><li>正常操作：强制缓存有效，协商缓存有效</li><li>手动刷新：强制缓存失效，协商缓存有效</li><li>强制刷新，强制缓存失效，协商缓存失效</li></ul><h2 id="_5-https" tabindex="-1"><a class="header-anchor" href="#_5-https" aria-hidden="true">#</a> 5. HTTPS</h2><p>HTTP 是明文传输，传输的所有内容（如登录的用户名和密码），都会被中间的代理商（无论合法还是非法）获取到</p><p>HTTP + TLS/SSL = HTTPS ，即加密传输信息。只有客户端和服务端可以解密为明文，中间的过程无法解密</p><h3 id="_1-关于信息加密" tabindex="-1"><a class="header-anchor" href="#_1-关于信息加密" aria-hidden="true">#</a> 1. 关于信息加密</h3><h4 id="_1-对称加密" tabindex="-1"><a class="header-anchor" href="#_1-对称加密" aria-hidden="true">#</a> 1. 对称加密</h4><p>一个密钥，既负责加密，又负责解密</p><ul><li>浏览器访问服务端，服务端生成密钥，并传递给浏览器</li><li>浏览器和服务端，通过这个密钥来加密、解密信息</li></ul><p>但这有一个很严重的问题：密钥也会被劫持</p><h4 id="_2-非对称加密" tabindex="-1"><a class="header-anchor" href="#_2-非对称加密" aria-hidden="true">#</a> 2. 非对称加密</h4><p>生成一对密钥，一个公钥，一个私钥</p><ul><li><p>公钥加密的信息，只有私钥能解密</p></li><li><p>私钥加密的信息，只有公钥能解密</p></li><li><p>浏览器访问服务端，服务端生成公钥、私钥，并把公钥传递给浏览器</p></li><li><p>浏览器生成一个 key（随机字符串），并用公钥加密，传递给服务端</p></li><li><p>服务端用私钥解密 key 。这样浏览器和服务端，就都得到了 key ，而且 key 还是加密传输的</p></li><li><p>然后，浏览器和服务端使用 key 为密钥，做对称加密传输</p></li></ul><p>思考：如果公钥和 key 被劫持，黑客能解密 key 吗？—— 不能，因为解密 key 要使用私钥，而私钥一直在服务端，没有传输</p><h4 id="_3-证书" tabindex="-1"><a class="header-anchor" href="#_3-证书" aria-hidden="true">#</a> 3. 证书</h4><p>公钥劫持了不行，那替换行不行呢？</p><p>黑客直接劫持请求，替换为自己的公钥（当然他自己有私钥），你的所有请求他劫持到，就都可以解密了。这叫做“中间人攻击”</p><p>这个问题，不好从技术上规避，那就从标准规范上解决 —— CA 证书</p><ul><li>由正规的第三方结构颁发证书（如去阿里云申请，但要花钱）</li><li>证书包括：公钥，域名，申请人信息，过期时间等 —— 这些都是绑定的</li><li>浏览器识别到正规的证书，才使用。否则会交给用户确认</li></ul><p>这样，当黑客使用中间人攻击时，浏览器就会识别到它的证书不合规范，就会提示用户</p><p>所以，尽量使用正规渠道申请的证书，花点钱，保证安全和稳定性</p><h3 id="_2-过程解析" tabindex="-1"><a class="header-anchor" href="#_2-过程解析" aria-hidden="true">#</a> 2. 过程解析</h3><figure><img src="https://zhf-picture.oss-cn-qingdao.aliyuncs.com/my-img/知识点总结-HTTP01.png" alt="知识点总结-HTTP01.png" tabindex="0" loading="lazy"><figcaption>知识点总结-HTTP01.png</figcaption></figure>',76),r=[t];function h(n,o){return i(),a("div",null,r)}const s=e(d,[["render",h],["__file","05-知识点总结-HTTP.html.vue"]]);export{s as default};
