import{_ as t,o as e,c as a,b as d}from"./app-df2e2230.js";const r={},i=d('<p>JavaScript 语言的一大特点就是单线程，也就是说，同一时间只能做一件事</p><p>这是因为 JavaScript 这门脚本语言诞生的使命所致——JavaScript 是为处理页面中用户的交互，以及操作 DOM 而诞生的。比如我们对某个 DOM 元素进行添加和删除操作，不能同时进行。应该先进行添加，然后再删除</p><p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样导致的问题是：如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉</p><p>为了解决这个问题，利用多核 CPU 的计算能力，HTML 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程。于是，JS 中出现了同步和异步</p><h2 id="_1-同步和异步" tabindex="-1"><a class="header-anchor" href="#_1-同步和异步" aria-hidden="true">#</a> 1. 同步和异步</h2><p>前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做法：我们要烧水做饭，等水开了（十分钟后），再去切菜、炒菜</p><p>在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做饭的异步做法：我们在烧水的同时，利用这十分钟去切菜、炒菜</p><p><mark>它们的本质区别：这条流水线上各个流程的执行顺序不同</mark></p><h3 id="_1-1-同步代码-任务" tabindex="-1"><a class="header-anchor" href="#_1-1-同步代码-任务" aria-hidden="true">#</a> 1.1 同步代码（任务）</h3><p>同步代码：立即放入JS引擎（JS主线程）执行，并原地等待结果，如：<code>console.log()</code></p><h3 id="_1-2-异步代码-任务" tabindex="-1"><a class="header-anchor" href="#_1-2-异步代码-任务" aria-hidden="true">#</a> 1.2 异步代码（任务）</h3><p>异步代码：先放入宿主环境（浏览器/Node），不必原地等待结果，并不阻塞主线程继续往下执行，异步结果在将来执行</p><p>JS 的异步是通过回调函数实现的</p><p>一般而言，异步任务有以下三种类型：</p><ul><li>普通事件，如 <code>click</code>、<code>resize</code> 等</li><li>资源加载，如 <code>load</code>、<code>error</code> 等</li><li>定时器，如 <code>setInterval</code>、<code>setTimeout</code> 等</li></ul><h2 id="_2-执行顺序" tabindex="-1"><a class="header-anchor" href="#_2-执行顺序" aria-hidden="true">#</a> 2. 执行顺序</h2><ol><li><p>先执行执行栈中的同步任务（同步代码给JS引擎执行）</p></li><li><p>异步任务交给宿主环境，等时机成熟将任务以回调函数的形式添加到任务队列中（任务队列也称为消息队列）</p></li><li><p>一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行</p></li></ol><p>演示：</p><figure><img src="https://zhf-picture.oss-cn-qingdao.aliyuncs.com/my-img/JavaScript-执行机制01.gif" alt="JavaScript-执行机制01.gif" tabindex="0" loading="lazy"><figcaption>JavaScript-执行机制01.gif</figcaption></figure><p>由于主线程不断的重复获得任务、执行任务、再获得任务、再执行，这种机制被称为事件循环（event loop）</p><h2 id="_3-宏任务和微任务" tabindex="-1"><a class="header-anchor" href="#_3-宏任务和微任务" aria-hidden="true">#</a> 3. 宏任务和微任务</h2><p>JS把异步任务分为宏任务和微任务</p><p>由于JS引入了Promise，这样，不需要浏览器，JavaScript引擎自身也能够发起异步任务了</p><p>宏任务是由宿主（浏览器、Node）发起</p><table><thead><tr><th>任务</th><th>环境</th></tr></thead><tbody><tr><td>script</td><td>浏览器</td></tr><tr><td>事件</td><td>浏览器</td></tr><tr><td>网络请求</td><td>浏览器</td></tr><tr><td>定时器</td><td>浏览器</td></tr></tbody></table><p>微任务是由JS引擎发起</p><table><thead><tr><th>任务</th><th>环境</th></tr></thead><tbody><tr><td>Promise</td><td>JS引擎</td></tr></tbody></table><p>Promise本身同步，then/catch的回调函数是异步的</p><p>先执行同步任务，同步任务执行完毕后，如果微任务队列中有任务，则执行微任务，然后看宏任务队列中是否有任务，再执行宏任务</p>',29),c=[i];function p(o,h){return e(),a("div",null,c)}const n=t(r,[["render",p],["__file","30-JavaScript-执行机制.html.vue"]]);export{n as default};
