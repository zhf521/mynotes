import{_ as l,o as i,c as e,b as a}from"./app-2e85f6e4.js";const d={},c=a('<h2 id="_1-设计模式" tabindex="-1"><a class="header-anchor" href="#_1-设计模式" aria-hidden="true">#</a> 1. 设计模式</h2><h3 id="_1-什么是设计模式" tabindex="-1"><a class="header-anchor" href="#_1-什么是设计模式" aria-hidden="true">#</a> 1. 什么是设计模式</h3><p>在软件工程中，设计模式是对软件设计中普遍存在的各种问题所提出的解决方案</p><p>设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案</p><h3 id="_2-常见的设计模式" tabindex="-1"><a class="header-anchor" href="#_2-常见的设计模式" aria-hidden="true">#</a> 2. 常见的设计模式</h3><ul><li>单例模式 <ul><li>全局唯一的实例</li><li>保证一个类仅有一个实例，并提供一个访问它的全局访问点</li><li>实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象</li><li>如<code>Vuex</code>中的<code>store</code></li><li>如登录框</li></ul></li><li>工厂模式 <ul><li>工厂模式通常会分成3个角色： <ul><li>工厂角色-负责实现创建所有实例的内部逻辑</li><li>抽象产品角色-是所创建的所有对象的父类，负责描述所有实例所共有的公共接口</li><li>具体产品角色-是创建目标，所有创建的对象都充当这个角色的某个具体类的实例</li></ul></li></ul></li><li>策略模式 <ul><li>策略模式，就是定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换</li></ul></li><li>代理模式 <ul><li>为对象提供一个代用品或占位符，以便控制对它的访问</li><li>例如实现图片懒加载的功能，先通过一张<code>loading</code>图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到<code>img</code>标签里面</li><li>如<code>ES6 Proxy</code>实现<code>Vue3</code>响应式</li></ul></li><li>装饰者模式 <ul><li>在不改变对象自身的基础上，在程序运行期间给对象动态地添加方法</li><li>通常运用在原有方法维持不变，在原有方法上再挂载其他方法来满足现有需求</li></ul></li><li>发布订阅模式 <ul><li>一种对象间一对多的依赖关系，当一个对象的状态发生改变时，所依赖它的对象都将得到状态改变的通知</li><li>广泛应用于异步编程中(替代了传递回调函数)</li></ul></li></ul><h2 id="_2" tabindex="-1"><a class="header-anchor" href="#_2" aria-hidden="true">#</a> 2.</h2>',7),_=[c];function o(r,h){return i(),e("div",null,_)}const u=l(d,[["render",o],["__file","06-面试笔记-前端工程化.html.vue"]]);export{u as default};
