const g=(o,a)=>{const i=o.toLowerCase(),e=a.toLowerCase(),s=[];let n=0,l=0;const c=(t,p=!1)=>{let r="";l===0?r=t.length>20?`… ${t.slice(-20)}`:t:p?r=t.length+l>100?`${t.slice(0,100-l)}… `:t:r=t.length>20?`${t.slice(0,20)} … ${t.slice(-20)}`:t,r&&s.push(r),l+=r.length,p||(s.push(["strong",a]),l+=a.length,l>=100&&s.push(" …"))};let h=i.indexOf(e,n);if(h===-1)return null;for(;h>=0;){const t=h+e.length;if(c(o.slice(n,h)),n=t,l>100)break;h=i.indexOf(e,n)}return l<100&&c(o.slice(n),!0),s},d=Object.entries,y=Object.keys,f=o=>o.reduce((a,{type:i})=>a+(i==="title"?50:i==="heading"?20:i==="custom"?10:1),0),$=(o,a)=>{var i;const e={};for(const[s,n]of d(a)){const l=((i=a[s.replace(/\/[^\\]*$/,"")])==null?void 0:i.title)||"",c=`${l?`${l} > `:""}${n.title}`,h=g(n.title,o);h&&(e[c]=[...e[c]||[],{type:"title",path:s,display:h}]),n.customFields&&d(n.customFields).forEach(([t,p])=>{p.forEach(r=>{const u=g(r,o);u&&(e[c]=[...e[c]||[],{type:"custom",path:s,index:t,display:u}])})});for(const t of n.contents){const p=g(t.header,o);p&&(e[c]=[...e[c]||[],{type:"heading",path:s+(t.slug?`#${t.slug}`:""),display:p}]);for(const r of t.contents){const u=g(r,o);u&&(e[c]=[...e[c]||[],{type:"content",header:t.header,path:s+(t.slug?`#${t.slug}`:""),display:u}])}}}return y(e).sort((s,n)=>f(e[s])-f(e[n])).map(s=>({title:s,contents:e[s]}))},m=JSON.parse("{\"/\":{\"/frontend/\":{\"title\":\"前端\",\"contents\":[]},\"/frontend/cssnotes/\":{\"title\":\"CSS\",\"contents\":[]},\"/frontend/htmlnotes/\":{\"title\":\"HTML\",\"contents\":[]},\"/frontend/javascriptnotes/01-JavaScript%E5%9F%BA%E7%A1%80-%E7%AE%80%E4%BB%8B.html\":{\"title\":\"JavaScript基础-简介\",\"contents\":[{\"header\":\"JavaScript 的组成\",\"slug\":\"javascript-的组成\",\"contents\":[\"ECMASCRIPT: 定义了 JavaScript 的语法规范, 描述了语言的基本语法和数据类型\",\"BOM (Browser Object Model): 浏览器对象模型\",\"有一套成熟的可以操作浏览器的 API，通过 BOM 可以操作浏览器。比如： 弹出框、浏览器跳转、获取分辨率等\",\"DOM (Document Object Model): 文档对象模型\",\"有一套成熟的可以操作页面元素的 API，通过 DOM 可以操作页面中的元素。比如： 增加一个 div，减少个一div，给 div 换个位置等\"]},{\"header\":\"JavaScript 用途\",\"slug\":\"javascript-用途\",\"contents\":[\"常见的网页效果，如表单验证，轮播图等\",\"与 H5配合实现游戏\",\"实现应用级别的程序\",\"实现图表统计效果\",\"可以实现人工智能\",\"后端开发，app开发，桌面端开发等\"]},{\"header\":\"JavaScript 的语言风格和特性\",\"slug\":\"javascript-的语言风格和特性\",\"contents\":[\"类 C 语言风格，容易上手\",\"弱类型（动态类型），简单易学\",\"丰富的功能，无敌的生态，强大的性能\"]}]},\"/frontend/javascriptnotes/02-JavaScript%E5%9F%BA%E7%A1%80-%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F.html\":{\"title\":\"JavaScript基础-引入方式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"JavaScript 程序不能独立运行，它需要被嵌入 HTML 中，然后浏览器才能执行 JavaScript 代码。通过 script 标签将 JavaScript 代码引入到 HTML 中\"]},{\"header\":\"内部方式\",\"slug\":\"内部方式\",\"contents\":[\"通过 script 标签包裹 JavaScript 代码\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 引入方式</title> </head> <body> <!-- 内部形式：通过 script 标签包裹 JavaScript 代码 --> <script> // JavaScript代码 </script> </body> </html> \",\"注意：将 JavaScript 代码放在 HTML 页面的底部附近通常是最好的策略\"]},{\"header\":\"外部方式\",\"slug\":\"外部方式\",\"contents\":[\"一般将 JavaScript 代码写在独立的以 .js 结尾的文件中，然后通过 script 标签的 src 属性引入\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 引入方式</title> </head> <body> <!-- 外部形式：通过 script 的 src 属性引入独立的 .js 文件 --> <script src=\\\"xxx.js\\\"></script> </body> </html> \",\"如果 script 标签使用 src 属性引入了某 .js 文件，那么标签的代码会被忽略！！！\",\"如下代码所示：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 引入方式</title> </head> <body> <!-- 外部形式：通过 script 的 src 属性引入独立的 .js 文件 --> <script src=\\\"xxx.js\\\"> // 此处的代码会被忽略掉！！！！ // JavaScript代码 </script> </body> </html> \"]},{\"header\":\"内联方式\",\"slug\":\"内联方式\",\"contents\":[\"代码写在标签内部\",\"例：\",\"<body> <button onclick=\\\"alert('逗你玩~~~')“>点我</button> </body> \"]}]},\"/frontend/javascriptnotes/03-JavaScript%E5%9F%BA%E7%A1%80-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html\":{\"title\":\"JavaScript基础-输入输出\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"输入和输出也可理解为人和计算机的交互，用户通过键盘、鼠标等向计算机输入信息，计算机处理后再展示结果给用户，这便是一次输入和输出的过程\",\"JavaScript本身没有任何打印或者输出的函数，但是我们可以使用其它方式输出和输入数据\"]},{\"header\":\"输出\",\"slug\":\"输出\",\"contents\":[\"JavaScript 可以接收用户的输入，然后再将输入的结果输出：alert()、document.write()、console.log()\",\"alert() 或 document.write() 会在浏览器中展示（输出）给用户\",\"console.log() 可以在控制台打印\",\"后面章节会深入探讨以上方法，目前学习的内容是为了方便我们在运行程序时看到结果\"]},{\"header\":\"输入\",\"slug\":\"输入\",\"contents\":[\"向 prompt() 输入任意内容会以弹窗形式出现在浏览器中，一般提示用户输入一些内容\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 输入输出</title> </head> <body> <script> // 1. 展示给用户 document.write('要输出的内容') alert('要输出的内容'); // 2. 以弹窗形式提示用户输入姓名，注意这里的文字使用英文的引号 prompt('请输入您的姓名:') </script> </body> </html> \"]}]},\"/frontend/javascriptnotes/04-JavaScript%E5%9F%BA%E7%A1%80-%E6%B3%A8%E9%87%8A%E4%B8%8E%E7%BB%93%E6%9D%9F%E7%AC%A6.html\":{\"title\":\"JavaScript基础-注释与结束符\",\"contents\":[{\"header\":\"注释\",\"slug\":\"注释\",\"contents\":[\"通过注释可以阻止代码被执行或者添加备注信息，JavaScript 支持两种形式注释语法\"]},{\"header\":\"单行注释\",\"slug\":\"单行注释\",\"contents\":[\"使用 // 注释单行代码\",\"VSCode中快捷键：ctrl+/\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 注释</title> </head> <body> <script> // 这种是单行注释的语法 // 一次只能注释一行 // 可以重复注释 </script> </body> </html> \"]},{\"header\":\"多行注释\",\"slug\":\"多行注释\",\"contents\":[\"使用 /* */ 注释多行代码\",\"VSCode中快捷键：shift+alt+A\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 注释</title> </head> <body> <script> /* 这种的是多行注释的语法 */ /* 更常见的多行注释是这种写法 可以任意换行 多少行都可以 */ </script> </body> </html> \"]},{\"header\":\"结束符\",\"slug\":\"结束符\",\"contents\":[\"在 JavaScript 中 ; 代表一段代码的结束，多数情况下可以省略 ; 使用回车（enter）替代\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 结束符</title> </head> <body> <script> alert(1); alert(2); alert(1) alert(2) </script> </body> </html> \",\"实际开发中有许多人主张书写 JavaScript 代码时省略结束符 ;\"]}]},\"/frontend/javascriptnotes/05-JavaScript%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F.html\":{\"title\":\"JavaScript基础-变量\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"变量指的是在程序中保存数据的一个容器，变量是计算机内存中存储数据的标识符，根据变量名称可以获取到内存中存储的数据，也就是说，我们向内存中存储了一个数据，然后要给这个数据起一个名字，为了是我们以后再次找到它\"]},{\"header\":\"定义变量及赋值\",\"slug\":\"定义变量及赋值\",\"contents\":[\"// 定义一个变量 var num // 给一个变量赋值 num = 100 // 定义一个变量的同时给其赋值 var num2 = 200 \",\"注意：\",\"一个变量名只能存储一个值\",\"当再次给一个变量赋值的时候，前面一次的值就没有了\",\"变量名称区分大小写（JS 严格区分大小写）\"]},{\"header\":\"变量的命名规则和命名规范\",\"slug\":\"变量的命名规则和命名规范\",\"contents\":[\"规则： 必须遵守的，不遵守就是错\",\"一个变量名称可以由数字、字母、英文下划线 _、美元符号 $ 组成\",\"严格区分大小写\",\"不能由数字开头\",\"不能是保留字或者关键字\",\"不要出现空格\",\"规范： 建议遵守的（开发者默认），不遵守不会报错\",\"变量名尽量有意义（语义化）\",\"遵循驼峰命名规则，由多个单词组成的时候，从第二个单词开始首字母大写\",\"不要使用中文\"]}]},\"/frontend/javascriptnotes/06-JavaScript%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html\":{\"title\":\"JavaScript基础-数据类型\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"数据类型是指存储在内存中的数据的类型，通常分为两大类 基本数据类型 和 复杂数据类型\"]},{\"header\":\"基本数据类型\",\"slug\":\"基本数据类型\",\"contents\":[\"基本数据类型又叫做简单类型或者值类型，在存储时变量中存储的是值本身，因此叫做值类型，如 string，number，boolean，undefined，null\",\"数值类型（number） \",\"一切数字都是数值类型（包括二进制，十进制，十六进制等）\",\"NaN（not a number），一个非数字，NaN 代表一个计算错误，它是一个不正确的或一个未定义的数学操作所得到的结果，NaN 是粘性的，任何对 NaN 的操作都会返回 NaN\",\"字符串类型（string） \",\"被引号包裹的所有内容（可以是单引号''也可以是双引号\\\"\\\"）,单引号和双引号没有本质上的区别，推荐使用单引号\",\"注意： \",\"无论单引号或是双引号必须成对使用\",\"单引号/双引号可以互相嵌套，但是不可以自已嵌套自已\",\"必要时可以使用转义符 \\\\，输出单引号或双引号\",\"布尔类型（boolean） \",\"只有两个（true 或者 false）\",\"null类型（null） \",\"只有一个，就是 null，表示”空“、”无“或”值未知“的意思\",\"未定义类型（undefined） \",\"未定义是比较特殊的类型，只有一个值 undefined，只声明变量，不赋值的情况下，变量的默认值为 undefined，一般很少直接为某个变量赋值为 undefined\"]},{\"header\":\"复杂数据类型\",\"slug\":\"复杂数据类型\",\"contents\":[\"复杂数据类型，在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型\",\"通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date 等\"]},{\"header\":\"判断数据类型\",\"slug\":\"判断数据类型\",\"contents\":[\"使用 typeof 关键字来检测数据类型\",\"// 第一种使用方式 var n1 = 100 console.log(typeof n1)// number // 第二种使用方式 var s1 = 'abcdefg' console.log(typeof(s1))// string \"]},{\"header\":\"数据类型转换\",\"slug\":\"数据类型转换\",\"contents\":[\"数据类型之间的转换，比如数字转成字符串，字符串转成布尔，布尔转成数字等\",\"JavaScript 是弱类型语言：JavaScript 也不知道变量到底属于哪种数据类型，只有赋值了才清楚\"]},{\"header\":\"其他数据类型转成数值\",\"slug\":\"其他数据类型转成数值\",\"contents\":[\"Number(变量)\",\"可以把一个变量强制转换成数值类型\",\"可以转换小数，会保留小数\",\"可以转换布尔值\",\"遇到不可转换的都会返回 NaN\",\"parseInt(变量)\",\"从第一位开始检查，是数字就转换，直到一个不是数字的内容\",\"开头就不是数字，那么直接返回 NaN\",\"不认识小数点，只能保留整数\",\"parseFloat(变量)\",\"从第一位开始检查，是数字就转换，直到一个不是数字的内容\",\"开头就不是数字，那么直接返回 NaN\",\"认识一次小数点\",\"除了加法以外的数学运算\",\"运算符两边都是可运算数字才行\",\"如果运算符任何一边不是一个可运算数字，那么就会返回 NaN\",\"加法不可以用\"]},{\"header\":\"其他数据类型转成字符串\",\"slug\":\"其他数据类型转成字符串\",\"contents\":[\"变量.toString()\",\"有一些数据类型不能使用 toString() 方法，比如 undefined 和 null\",\"String(变量)\",\"所有数据类型都可以\",\"使用加法运算\",\"在 JS 里面，+ 由两个含义 \",\"字符串拼接： 只要 + 任意一边是字符串，就会进行字符串拼接\",\"加法运算：只有 + 两边都是数字的时候，才会进行数学运算\"]},{\"header\":\"其他数据类型转成布尔\",\"slug\":\"其他数据类型转成布尔\",\"contents\":[\"Boolean(变量)\",\"在 js 中，只有 ''、0、null、undefined、NaN，这些是 false\",\"其余都是 true\"]},{\"header\":\"数据类型之间存储的区别\",\"slug\":\"数据类型之间存储的区别\",\"contents\":[\"既然我们区分了基本数据类型和复杂数据类型，那么他们之间就一定会存在一些区别，他们最大的区别就是在存储上的区别\",\"我们的存储空间分成两种：\",\"栈： 主要存储基本数据类型的内容\",\"堆： 主要存储复杂数据类型的内容\"]},{\"header\":\"基本数据类型在内存中的存储情况\",\"slug\":\"基本数据类型在内存中的存储情况\",\"contents\":[\"var num = 100，在内存中的存储情况，直接在 栈空间 内有存储一个数据\"]},{\"header\":\"复杂数据类型在内存中的存储情况\",\"slug\":\"复杂数据类型在内存中的存储情况\",\"contents\":[\"复杂数据类型的存储\",\"在堆里面开辟一个存储空间\",\"把数据存储到存储空间内\",\"把存储空间的地址赋值给栈里面的变量\"]},{\"header\":\"数据类型之间比较的区别\",\"slug\":\"数据类型之间比较的区别\",\"contents\":[\"基本数据类型是 值 之间的比较\",\"var num = 1 var str = '1' console.log(num == str) // true \",\"复杂数据类型是 地址 之间的比较\",\"var obj = { name: 'Jack' } var obj2 = { name: 'Jack' } console.log(obj == obj2) // false \",\"因为我们创建了两个对象，那么就会在 堆空间 里面开辟两个存储空间存储数据（两个地址），虽然存储的内容是一样的，那么也是两个存储空间，两个地址，复杂数据类型之间就是地址的比较，所以 obj 和 obj2 两个变量的地址不一样，所以我们得到的就是 false\"]}]},\"/frontend/javascriptnotes/07-JavaScript%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E7%AC%A6.html\":{\"title\":\"JavaScript基础-运算符\",\"contents\":[{\"header\":\"算术运算符\",\"slug\":\"算术运算符\",\"contents\":[\"算术运算符：也叫数学运算符，主要包括加、减、乘、除、取余（求模）等\",\"+\",\"只有符号两边都是数字的时候才会进行加法运算\",\"只要符号任意一边是字符串类型，就会进行字符串拼接\",\"-\",\"会执行减法运算\",\"会自动把两边都转换成数字进行运算\",\"*\",\"会执行乘法运算\",\"会自动把两边都转换成数字进行运算\",\"/\",\"会执行除法运算\",\"会自动把两边都转换成数字进行运算\",\"%\",\"会执行取余运算\",\"会自动把两边都转换成数字进行运算\",\"注意：在计算失败时，显示的结果是 NaN（not a number）\"]},{\"header\":\"赋值运算符\",\"slug\":\"赋值运算符\",\"contents\":[\"赋值运算符：对变量进行赋值的运算符\",\"= 将等号右边的值赋予给左边, 要求左边必须是一个容器\",\"运算符\",\"作用\",\"+=\",\"加法赋值\",\"-+\",\"减法赋值\",\"*=\",\"乘法赋值\",\"/=\",\"除法赋值\",\"%=\",\"取余赋值\"]},{\"header\":\"比较运算符\",\"slug\":\"比较运算符\",\"contents\":[\"使用场景：比较两个数据是否相等，根据比较结果返回一个布尔值（true / false）\",\"运算符\",\"作用\",\">\",\"左边是否大于右边\",\"<\",\"左边是否小于右边\",\">=\",\"左边是否大于或等于右边\",\"<=\",\"左边是否小于或等于右边\",\"===\",\"左右两边是否类型和值都相等（重点）\",\"==\",\"左右两边值是否相等\",\"!=\",\"左右值不相等\",\"!==\",\"左右两边是否不全等\",\"例：\",\" console.log(3 > 5) console.log(3 >= 3) console.log(2 == 2) // 比较运算符有隐式转换 把'2' 转换为 2 双等号 只判断值 console.log(2 == '2') // true // console.log(undefined === null) // === 全等 判断 值 和 数据类型都一样才行 // 以后判断是否相等 请用 === console.log(2 === '2') console.log(NaN === NaN) // NaN 不等于任何人，包括他自己 console.log(2 !== '2') // true console.log(2 != '2') // false console.log('-------------------------') console.log('a' < 'b') // true console.log('aa' < 'ab') // true console.log('aa' < 'aac') // true console.log('-------------------------') \"]},{\"header\":\"逻辑运算符\",\"slug\":\"逻辑运算符\",\"contents\":[]},{\"header\":\"基本使用\",\"slug\":\"基本使用\",\"contents\":[\"使用场景：可以把多个布尔值放到一起运算，最终返回一个布尔值\",\"符号\",\"名称\",\"日常读法\",\"特点\",\"口诀\",\"&&\",\"逻辑与\",\"并且\",\"符号两边有一个假的结果为假\",\"一假则假\",\"||\",\"逻辑或\",\"或者\",\"符号两边有一个真的结果为真\",\"一真则真\",\"!\",\"逻辑非\",\"取反\",\"true变false false变true\",\"真变假，假变真\",\"A\",\"B\",\"A && B\",\"A || B\",\"!A\",\"false\",\"false\",\"false\",\"false\",\"true\",\"false\",\"true\",\"false\",\"true\",\"true\",\"true\",\"false\",\"false\",\"true\",\"false\",\"true\",\"true\",\"true\",\"true\",\"false\",\" // 逻辑与 一假则假 console.log(true && true) console.log(false && true) console.log(3 < 5 && 3 > 2) console.log(3 < 5 && 3 < 2) console.log('-----------------') // 逻辑或 一真则真 console.log(true || true) console.log(false || true) console.log(false || false) console.log('-----------------') // 逻辑非 取反 console.log(!true) console.log(!false) console.log('-----------------') let num = 6 console.log(num > 5 && num < 10) console.log('-----------------') \"]},{\"header\":\"逻辑中断\",\"slug\":\"逻辑中断\",\"contents\":[\"断路：只存在于 && 和 || 中，当满足一定条件会让右边代码不执行\",\"符号\",\"短路条件\",\"&&\",\"左边为 false 就断路\",\"||\",\"左边为 true 就断路\",\"原因：通过左边能得到整个式子的结果，因此没必要再判断右边\",\"运算结果：无论 && 还是 ||，运算结果都是最后被执行的表达式值，一般用在变量赋值\",\"例：\",\"console.log(false && 20) //false console.log(5 < 3 && 20) //false console.log(undefined && 20) //undefined console.log(null && 20) //null console.log(0 && 20) //0 console.log(10 && 20) //20 console.log(false || 20) //20 console.log(5 < 3 || 20) //20 console.log(undefined || 20) //20 console.log(null || 20) //20 console.log(0 || 20) //20 console.log(10 || 20) //10 \"]},{\"header\":\"逻辑运算符优先级\",\"slug\":\"逻辑运算符优先级\",\"contents\":[\"！> && > ||\"]},{\"header\":\"自增自减运算符\",\"slug\":\"自增自减运算符\",\"contents\":[\"++\",\"进行自增运算\",\"分成两种，前置++ 和 后置++\",\"前置++，会先把值自动 +1，再返回\",\"var a = 10 console.log(++a) // 会返回 11，并且把 a 的值变成 11 \",\"后置++，会先把值返回，再自动+1\",\"var a = 10 console.log(a++) // 会返回 10，然后把 a 的值变成 11 \",\"--\",\"进行自减运算\",\"分成两种，前置-- 和 后置--\",\"和 ++ 运算符道理一样\"]},{\"header\":\"三元运算符\",\"slug\":\"三元运算符\",\"contents\":[\"三元运算，就是用 两个符号 组成一个语句\",\"语法：\",\"条件 ? 条件为 true 的时候执行 : 条件为 false 的时候执行 \",\"例：\",\"var age = 18 age >= 18 ? alert('已经成年') : alert('没有成年') \"]}]},\"/frontend/javascriptnotes/08-JavaScript%E5%9F%BA%E7%A1%80-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84.html\":{\"title\":\"JavaScript基础-分支结构\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"分支结构可以根据条件判断真假，来选择性的执行想要的代码\",\"分支结构包含：\",\"if分支结构（重点）\",\"三元运算符\",\"switch分支结构\"]},{\"header\":\"if条件分支结构\",\"slug\":\"if条件分支结构\",\"contents\":[]},{\"header\":\"if分支结构\",\"slug\":\"if分支结构\",\"contents\":[\"语法：\",\"if(条件表达式) { // 满足条件要执行的语句 } \",\"小括号内的条件结果是布尔值，为 true 时，进入大括号里执行代码，若为 false ，则不执行大括号里面代码\",\"小括号内的结果若不是布尔类型时，会发生类型转换为布尔值，类似Boolean()\",\"如果大括号只有一个语句，大括号可以省略，但是，不提倡这样做\",\"例：\",\"// 1. 用户输入 var score = +prompt('请输入成绩') // 2. 进行判断输出 if (score >= 700) { alert('恭喜考上清华！') } \"]},{\"header\":\"if双分支结构\",\"slug\":\"if双分支结构\",\"contents\":[\"如果有两个条件的时候，可以使用 if else 双分支语句\",\"语法：\",\"if (条件表达式){ // 满足条件要执行的语句 } else { // 不满足条件要执行的语句 } \",\"例：\",\"// 1. 用户输入 var uname = prompt('请输入用户名:') var pwd = prompt('请输入密码:') // 2. 判断输出 if (uname === 'zhf' && pwd === '123456') { alert('恭喜登录成功') } else { alert('用户名或者密码错误') } \"]},{\"header\":\"if多分支结构\",\"slug\":\"if多分支结构\",\"contents\":[\"使用场景： 适合于有多个条件的时候\",\"例：\",\"// 1. 用户输入 var score = +prompt('请输入成绩：') // 2. 判断输出 if (score >= 90) { alert('成绩优秀，宝贝，你是我的骄傲') } else if (score >= 70) { alert('成绩良好，宝贝，你要加油哦~~') } else if (score >= 60) { alert('成绩及格，宝贝，你很危险~') } else { alert('成绩不及格，宝贝，我不想和你说话，我只想用鞭子和你说话~') } \"]},{\"header\":\"switch条件分支结构\",\"slug\":\"switch条件分支结构\",\"contents\":[\"使用场景： 适用于有多个条件的时候，也属于分支语句，大部分情况下和 if 多分支语句功能相同\",\"语法：\",\"switch (要判断的变量) { case 情况1: 情况1要执行的代码 break case 情况2: 情况2要执行的代码 break case 情况3: 情况3要执行的代码 break default: 上述情况都不满足的时候执行的代码 } \",\"例：根据变量给出的数字显示是星期几\",\"var week = 1 switch (week) { case 1: alert('星期一') break case 2: alert('星期二') break case 3: alert('星期三') break case 4: alert('星期四') break case 5: alert('星期五') break case 6: alert('星期六') break case 7: alert('星期日') break default: alert('请输入一个 1 ～ 7 之间的数字') } \",\"注意：\",\"switch case 语句一般用于等值判断, if 适合于区间判断\",\"switch case 一般需要配合 break 关键字使用，没有 break 会造成 case 穿透\",\"if 多分支语句开发要比 switch 更重要，使用也更多\"]},{\"header\":\"if和switch的区别\",\"slug\":\"if和switch的区别\",\"contents\":[\"共同点 \",\"都能实现多分支选择，多选一\",\"大部分情况下可以互换\",\"区别： \",\"switch…case 语句通常处理 case 为比较确定值的情况，而 if…else…语句更加灵活，通常用于范围判断(大于，等于某个范围)\",\"switch 语句进行判断后直接执行到程序的语句，效率更高，而 if…else 语句有几种判断条件，就得判断多少次\",\"switch 一定要注意必须是 === 全等，一定注意数据类型，同时注意 break 否则会有穿透效果\",\"结论： \",\"当分支比较少时，if…else 语句执行效率高\",\"当分支比较多时，switch 语句执行效率高，而且结构更清晰\"]}]},\"/frontend/javascriptnotes/09-JavaScript%E5%9F%BA%E7%A1%80-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84.html\":{\"title\":\"JavaScript基础-循环结构\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"循环结构，就是根据某些给出的条件，重复的执行同一段代码\",\"循环三要素：\",\"初始值 （经常用变量）\",\"终止条件\",\"变量的变化量\"]},{\"header\":\"while循环\",\"slug\":\"while循环\",\"contents\":[\"while，中文叫当…时，其实就是当条件满足时就执行代码，一旦不满足了就不执行了\",\"语法：\",\"while (条件表达式) { // 循环体 } \",\"因为满足条件就执行，所以我们写的时候一定要注意，就是设定一个边界值，不然就一直循环下去了\",\"例：\",\"// 1. 初始值 var num = 0; // 2. 终止条件 while (num < 10) { // 3. 要执行的代码 console.log('当前的 num 的值是 ' + num) // 4. 变量的变化量 num = num + 1 } \"]},{\"header\":\"do while循环\",\"slug\":\"do-while循环\",\"contents\":[\"是一个和 while 循环类似的循环，while 会先进行条件判断，满足就执行，不满足直接就不执行了，但是 do while 循环是先不管条件，先执行一回，然后再开始进行条件判断\",\"语法：\",\"do { 要执行的代码 } while (条件) \",\"例：\",\"// 下面这个代码，条件一开始就不满足，但是依旧会执行一次 do 后面 {} 内部的代码 var num = 10 do { console.log('我执行了一次') num = num + 1 } while (num < 10) \"]},{\"header\":\"for循环\",\"slug\":\"for循环\",\"contents\":[\"语法：\",\"for(起始值; 终止条件; 变化量) { // 要重复执行的代码 } \",\"例：\",\"// 把初始化，条件判断，自身改变，写在了一起 for (var i = 1; i <= 10; i++) { // 这里写的是要执行的代码 console.log(i) } // 控制台会依次输出 1 ~ 10 \"]},{\"header\":\"for循环嵌套\",\"slug\":\"for循环嵌套\",\"contents\":[\"循环之中又嵌套了另一个循环，外层循环循环一次，里层循环循环全部\",\"例：\",\"// 1. 外面的循环 for (var i = 1; i < 4; i++) { console.log(i) // 2. 里层的循环 for (let j = 1; j < 6; j++) { console.log(j) } } \"]},{\"header\":\"break终止循环\",\"slug\":\"break终止循环\",\"contents\":[\"在循环没有进行完毕的时候，因为我设置的条件满足，提前终止循环\",\"比如：我要吃五个包子，吃到三个的时候，不能再吃了，我就停止吃包子这个事情\",\"要终止循环，就可以直接使用 break 关键字\",\"for (var i = 1; i <= 5; i++) { // 每循环一次，吃一个包子 console.log('我吃了一个包子') // 当 i 的值为 3 的时候，条件为 true，执行 {} 里面的代码终止循环 // 循环就不会继续向下执行了，也就没有 4 和 5 了 if (i === 3) { break } } \"]},{\"header\":\"continue结束本次循环\",\"slug\":\"continue结束本次循环\",\"contents\":[\"在循环中，把循环的本次跳过去，继续执行后续的循环\",\"比如：吃五个包子，到第三个的时候，第三个掉地下了，不吃了，跳过第三个，继续吃第四个和第五个\",\"跳过本次循环，就可以使用 continue 关键字\",\"for (var i = 1; i <= 5; i++) { // 当 i 的值为 3 的时候，执行 {} 里面的代码 // {} 里面有 continue，那么本次循环后面的代码就都不执行了 // 自动算作 i 为 3 的这一次结束了，去继续执行 i = 4 的那次循环了 if (i === 3) { console.log('这个是第三个包子，掉地下了，我不吃了') continue } console.log('我吃了一个包子') } \"]}]},\"/frontend/javascriptnotes/10-JavaScript%E5%9F%BA%E7%A1%80-%E5%87%BD%E6%95%B0.html\":{\"title\":\"JavaScript基础-函数\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"对于 js 来说，函数就是把任意一段代码放在一个 盒子 里面\",\"在我想要让这段代码执行的时候，直接执行这个 盒子 里面的代码就行\",\"// 这个是我们以前写的一段代码 for (var i = 0; i < 10; i++) { console.log(i) } // 函数，这个 {} 就是那个 “盒子” function fn() { // 这个函数我们以前写的代码 for (var i = 0; i < 10; i++) { console.log(i) } } \"]},{\"header\":\"函数定义阶段\",\"slug\":\"函数定义阶段\",\"contents\":[\"定义阶段就是我们把代码 放在盒子里面\",\"我们就要学习怎么 放进去，也就是书写一个函数\",\"我们有两种定义方式 声明式 和 赋值式\"]},{\"header\":\"声明式\",\"slug\":\"声明式\",\"contents\":[\"使用 function 这个关键字来声明一个函数\",\"语法：\",\"function fn() { // 一段代码,即函数体 } // function: 声明函数的关键字，表示接下来是一个函数了 // fn: 函数的名字，我们自己定义的（遵循变量名的命名规则和命名规范） // (): 必须写，是用来放参数的位置（一会我们再聊） // {}: 就是我们用来放一段代码的位置（也就是我们刚才说的 “盒子”） \"]},{\"header\":\"赋值式\",\"slug\":\"赋值式\",\"contents\":[\"其实就是和我们使用 var 关键字是一个道理了\",\"首先使用 var 定义一个变量，把一个函数当作值直接赋值给这个变量就可以了\",\"语法：\",\"var fn = function () { // 一段代码，即函数体 } // 不需要在 function 后面书写函数的名字了，因为在前面已经有了 \"]},{\"header\":\"函数调用阶段\",\"slug\":\"函数调用阶段\",\"contents\":[]},{\"header\":\"函数的调用方式\",\"slug\":\"函数的调用方式\",\"contents\":[\"就是让 盒子里面 的代码执行一下\",\"两种定义函数的方式不同，但是调用函数的方式都以一样的\",\"函数调用就是直接写 函数名() 就可以了\",\"// 声明式函数 function fn() { console.log('我是 fn 函数') } fn() // 调用函数 // 赋值式函数 var fn2 = function () { console.log('我是 fn2 函数') } fn() // 调用函数 \",\"注意：定义完一个函数以后，如果没有函数调用，那么写在 {} 里面的代码没有意义，只有调用以后才会执行\"]},{\"header\":\"调用上的区别\",\"slug\":\"调用上的区别\",\"contents\":[\"虽然两种定义方式的调用都是一样的，但是还是有一些区别的\",\"声明式函数： 调用可以在定义之前或者定义之后\",\"fn() // 可以调用 // 声明式函数 function fn() { console.log('我是 fn 函数') } fn() // 可以调用 \",\"赋值式函数： 调用只能在定义之后\",\"fn() // 会报错 // 赋值式函数 var fn = function () { console.log('我是 fn 函数') } fn() // 可以调用 \"]},{\"header\":\"函数的参数\",\"slug\":\"函数的参数\",\"contents\":[\"我们在定义函数和调用函数的时候都出现过 ()，现在我们就来说一下这个 () 的作用，就是用来放参数的\",\"参数分为两种 形参 和 实参\",\"// 声明式 function fn(形参写在这里) { // 一段代码 } fn(实参写在这里) // 赋值式函数 var fn = function (形参写在这里) { // 一段代码 } fn(实参写在这里) \"]},{\"header\":\"形参和实参的作用\",\"slug\":\"形参和实参的作用\",\"contents\":[]},{\"header\":\"形参\",\"slug\":\"形参\",\"contents\":[\"形参就是在函数内部可以使用的变量，在函数外部不能使用，每写一个单词，就相当于在函数内部定义了一个可以使用的变量（遵循变量名的命名规则和命名规范），多个单词之间以 , 分隔，如果只有形参的话，那么在函数内部使用的这个变量是没有值的，也就是 undefined\",\"注意：形参的值是在函数调用的时候由实参决定的\",\"// 书写一个参数 function fn(num) { // 在函数内部就可以使用 num 这个变量 } var fn1 = function (num) { // 在函数内部就可以使用 num 这个变量 } // 书写两个参数 function fun(num1, num2) { // 在函数内部就可以使用 num1 和 num2 这两个变量 } var fun1 = function (num1, num2) { // 在函数内部就可以使用 num1 和 num2 这两个变量 } \"]},{\"header\":\"实参\",\"slug\":\"实参\",\"contents\":[\"在函数调用的时候给形参赋值的，也就是说，在调用的时候是给一个实际的内容的\",\"function fn(num) { // 函数内部可以使用 num } // 这个函数的本次调用，书写的实参是 100 // 那么本次调用的时候函数内部的 num 就是 100 fn(100) // 这个函数的本次调用，书写的实参是 200 // 那么本次调用的时候函数内部的 num 就是 200 fn(200) \",\"函数内部的形参的值，由函数调用的时候传递的实参决定，多个参数的时候，是按照顺序一一对应的\",\"function fn(num1, num2) { // 函数内部可以使用 num1 和 num2 } // 函数本次调用的时候，书写的参数是 100 和 200 // 那么本次调用的时候，函数内部的 num1 就是 100，num2 就是 200 fn(100, 200) \"]},{\"header\":\"参数个数的关系\",\"slug\":\"参数个数的关系\",\"contents\":[\"形参比实参少\",\"因为是按照顺序一一对应的\",\"形参少就会拿不到实参给的值，所以在函数内部就没有办法用到这个值\",\"function fn(num1, num2) { // 函数内部可以使用 num1 和 num2 } // 本次调用的时候，传递了两个实参，100 200 和 300 // 100 对应了 num1，200 对应了 num2，300 没有对应的变量 // 所以在函数内部就没有办法依靠变量来使用 300 这个值 fn(100, 200, 300) \",\"形参比实参多\",\"因为是按照顺序一一对应的\",\"所以多出来的形参就是没有值的，就是 undefined\",\"function fn(num1, num2, num3) { // 函数内部可以使用 num1 num2 和 num3 } // 本次调用的时候，传递了两个实参，100 和 200 // 就分别对应了 num1 和 num2 // 而 num3 没有实参和其对应，那么 num3 的值就是 undefined fn(100, 200) \"]},{\"header\":\"函数的return\",\"slug\":\"函数的return\",\"contents\":[\"return 返回的意思，其实就是给函数一个 返回值 和 终断函数\"]},{\"header\":\"返回值\",\"slug\":\"返回值\",\"contents\":[\"函数调用本身也是一个表达式，表达式就应该有一个值出现，现在的函数执行完毕之后，是不会有结果出现的\",\"// 比如 1 + 2 是一个表达式，那么 这个表达式的结果就是 3 console.log(1 + 2) // 3 function fn() { // 执行代码 } // fn() 也是一个表达式，这个表达式就没有结果出现 console.log(fn()) // undefined \",\"return 关键字就是可以给函数执行完毕一个结果，我们可以在函数内部使用 return 把任何内容当作这个函数运行后的结果\",\"function fn() { // 执行代码 return 100 } // 此时，fn() 这个表达式执行完毕之后就有结果出现了 console.log(fn()) // 100 \"]},{\"header\":\"终断函数\",\"slug\":\"终断函数\",\"contents\":[\"当我开始执行函数以后，函数内部的代码就会从上到下的依次执行，必须要等到函数内的代码执行完毕，而 return 关键字就是可以在函数中间的位置停掉，让后面的代码不在继续执行\",\"function fn() { console.log(1) console.log(2) console.log(3) // 写了 return 以后，后面的 4 和 5 就不会继续执行了 return console.log(4) console.log(5) } // 函数调用 fn() \"]},{\"header\":\"预解析\",\"slug\":\"预解析\",\"contents\":[\"js 是一个解释型语言，就是在代码执行之前，先对代码进行通读和解释，然后再执行代码，也就是说，我们的 js 代码在运行的时候，会经历两个环节 解释代码 和 执行代码，因为是在所有代码执行之前进行解释，所以叫做 预解析（预解释），也叫做变量、函数提升\",\"声明式函数：会把所有函数声明提升到当前作用域的最前面，只提升函数声明，不提升函数调用\",\"var 关键字：把所有var声明的变量提升到当前作用域的最前面，只提升声明，不提升赋值\",\"例：\",\"以下代码\",\"fn() console.log(num) function fn() { console.log('我是 fn 函数') } var num = 100 \",\"经过预解析之后可以变形为\",\"function fn() { console.log('我是 fn 函数') } var num fn() console.log(num) num = 100 \",\"赋值式函数会按照 var 关键字的规则进行预解析\"]},{\"header\":\"作用域\",\"slug\":\"作用域\",\"contents\":[\"变量不是在所有地方都可以使用的，而这个变量的使用范围就是作用域\"]},{\"header\":\"全局作用域\",\"slug\":\"全局作用域\",\"contents\":[\"全局作用域是最大的作用域\",\"在全局作用域中定义的变量可以在任何地方使用\",\"页面打开的时候，浏览器会自动给我们生成一个全局作用域 window\",\"这个作用域会一直存在，直到页面关闭就销毁了\",\"// 下面两个变量都是存在在全局作用域下面的，都是可以在任意地方使用的 var num = 100 var num2 = 200 \"]},{\"header\":\"局部作用域\",\"slug\":\"局部作用域\",\"contents\":[\"局部作用域就是在全局作用域下面有开辟出来的一个相对小一些的作用域\",\"在局部作用域中定义的变量只能在这个局部作用域内部使用\",\"在 JS 中只有函数能生成一个局部作用域，别的都不行\",\"每一个函数，都是一个局部作用域\",\"// 这个 num 是一个全局作用域下的变量 在任何地方都可以使用 var num = 100 function fn() { // 下面这个变量就是一个 fn 局部作用域内部的变量 // 只能在 fn 函数内部使用 var num2 = 200 } fn() \"]},{\"header\":\"变量使用规则\",\"slug\":\"变量使用规则\",\"contents\":[\"有了作用域以后，变量就有了使用范围，也就有了使用规则，变量使用规则分为两种，访问规则 和 赋值规则\"]},{\"header\":\"访问规则\",\"slug\":\"访问规则\",\"contents\":[\"当我想获取一个变量的值的时候，我们管这个行为叫做访问\",\"获取变量的规则：\",\"首先，在自己的作用域内部查找，如果有，就直接拿来使用\",\"如果没有，就去上一级作用域查找，如果有，就拿来使用\",\"如果没有，就继续去上一级作用域查找，依次类推\",\"如果一直到全局作用域都没有这个变量，那么就会直接报错（该变量 is not defined）\",\"var num = 100 function fn() { var num2 = 200 function fun() { var num3 = 300 console.log(num3) // 自己作用域内有，拿过来用 console.log(num2) // 自己作用域内没有，就去上一级，就是 fn 的作用域里面找，发现有，拿过来用 console.log(num) // 自己这没有，去上一级 fn 那里也没有，再上一级到全局作用域，发现有，直接用 console.log(a) // 自己没有，一级一级找上去到全局都没有，就会报错 } fun() } fn() \",\"变量的访问规则 也叫做作用域的查找机制，作用域的查找机制只能是向上找，不能向下找\",\"function fn() { var num = 100 } fn() console.log(num) // 发现自己作用域没有，自己就是全局作用域，没有再上一级了，直接报错 \"]},{\"header\":\"赋值规则\",\"slug\":\"赋值规则\",\"contents\":[\"当你想给一个变量赋值的时候，那么就先要找到这个变量，再给它赋值\",\"变量赋值规则：\",\"先在自己作用域内部查找，有就直接赋值\",\"没有就去上一级作用域内部查找，有就直接赋值\",\"还没有再去上一级作用域查找，有就直接赋值\",\"如果一直找到全局作用域都没有，那么就把这个变量定义为全局变量，再给他赋值\",\"function fn() { num = 100 } fn() // fn 调用以后，要给 num 赋值 // 查看自己的作用域内部没有 num 变量 // 就会向上一级查找 // 上一级就是全局作用域，发现依旧没有 // 那么就会把 num 定义为全局的变量，并为其赋值 // 所以 fn() 以后，全局就有了一个变量叫做 num 并且值是 100 console.log(num) // 100 \"]}]},\"/frontend/javascriptnotes/11-JavaScript%E5%9F%BA%E7%A1%80-%E5%AF%B9%E8%B1%A1.html\":{\"title\":\"JavaScript基础-对象\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"对象是一个复杂数据类型\",\"事实上没有很复杂，只不过是存储了一些基本数据类型的一个集合\",\"var obj = { num: 100, str: 'hello world', boo: true } \",\"这里的 {} 和函数中的 {} 不一样，函数里面的是写代码的，而对象里面是写一些数据的，对象就是一个键值对的集合，{} 里面的每一个键都是一个成员，也就是说，我们可以把一些数据放在一个对象里面，那么他们就互不干扰了，其实就是我们准备一个房子，把我们想要的数据放进去，然后把房子的地址给到变量名，当我们需要某一个数据的时候，就可以根据变量名里面存储的地址找到对应的房子，然后去房子里面找到对应的数据\"]},{\"header\":\"创建对象\",\"slug\":\"创建对象\",\"contents\":[\"字面量的方式创建一个对象\",\"// 创建一个空对象 var obj = {} // 像对象中添加成员 obj.name = 'Jack' obj.age = 18 \",\"内置构造函数的方式创建对象\",\"// 创建一个空对象 var obj = new Object() // 向对象中添加成员 obj.name = 'Rose' obj.age = 20 \",\"Object 是 js 内置给我们的构造函数，用于创建一个对象使用的\"]}]},\"/frontend/javascriptnotes/12-JavaScript%E5%9F%BA%E7%A1%80-%E6%95%B0%E7%BB%84.html\":{\"title\":\"JavaScript基础-数组\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"数组字面理解就是 数字的组合，准确的来说数组是一个 数据的集合\",\"也就是我们把一些数据放在一个盒子里面，按照顺序排好\",\"[1, 2, 3, 'hello', true, false] \"]},{\"header\":\"创建数组\",\"slug\":\"创建数组\",\"contents\":[]},{\"header\":\"字面量创建数组\",\"slug\":\"字面量创建数组\",\"contents\":[\"直接使用 [] 的方式创建一个数组\",\"// 创建一个空数组 var arr1 = [] // 创建一个有内容的数组 var arr2 = [1, 2, 3] \"]},{\"header\":\"内置构造函数创建数组\",\"slug\":\"内置构造函数创建数组\",\"contents\":[\"使用 JS 的内置构造函数 Array 创建一个数组\",\"// 创建一个空数组 var arr1 = new Array() // 创建一个长度为 10 的数组 var arr2 = new Array(10) // 创建一个有内容的数组 var arr3 = new Array(1, 2, 3) \"]},{\"header\":\"数组的长度\",\"slug\":\"数组的长度\",\"contents\":[\"length 表示数组的长度，数组里面有多少个成员，length 就是多少\",\"// 创建一个数组 var arr = [1, 2, 3] console.log(arr.length) // 3 \"]},{\"header\":\"数组的索引\",\"slug\":\"数组的索引\",\"contents\":[\"索引，也叫做下标，是指一个数据在数组里面排在第几个的位置\",\"注意： 在所有的语言里面，索引都是从 0 开始的，在 JS 里面也一样，数组的索引从 0 开始\",\"// 创建一个数组 var arr = ['hello', 'world'] \",\"上面这个数组中，第 0 个 数据就是字符串 hello，第 1 个 数据就是字符串 world，想获取数组中的第几个就使用 数组[索引] 来获取\",\"var arr = ['hello', 'world'] console.log(arr[0]) // hello console.log(arr[1]) // world \"]},{\"header\":\"数组的常用方法\",\"slug\":\"数组的常用方法\",\"contents\":[]},{\"header\":\"数组常用方法之 push\",\"slug\":\"数组常用方法之-push\",\"contents\":[\"push 是用来在数组的末尾追加一个元素\",\"var arr = [1, 2, 3] // 使用 push 方法追加一个元素在末尾 arr.push(4) console.log(arr) // [1, 2, 3, 4] \"]},{\"header\":\"数组常用方法之 pop\",\"slug\":\"数组常用方法之-pop\",\"contents\":[\"pop 是用来删除数组末尾的一个元素\",\"var arr = [1, 2, 3] // 使用 pop 方法删除末尾的一个元素 arr.pop() console.log(arr) // [1, 2] \"]},{\"header\":\"数组常用方法之 unshift\",\"slug\":\"数组常用方法之-unshift\",\"contents\":[\"unshift 是在数组的最前面添加一个元素\",\"var arr = [1, 2, 3] // 使用 unshift 方法想数组的最前面添加一个元素 arr.unshift(4) console.log(arr) // [4, 1, 2, 3] \"]},{\"header\":\"数组常用方法之 shift\",\"slug\":\"数组常用方法之-shift\",\"contents\":[\"shift 是删除数组最前面的一个元素\",\"var arr = [1, 2, 3] // 使用 shift 方法删除数组最前面的一个元素 arr.shift() console.log(arr) // [2, 3] \"]},{\"header\":\"数组常用方法之 splice\",\"slug\":\"数组常用方法之-splice\",\"contents\":[\"splice 是截取数组中的某些内容，按照数组的索引来截取\",\"语法： splice(从哪一个索引位置开始，截取多少个，替换的新元素) （第三个参数可以不写）\",\"var arr = [1, 2, 3, 4, 5] // 使用 splice 方法截取数组 arr.splice(1, 2) console.log(arr) // [1, 4, 5] \",\"arr.splice(1, 2) 表示从索引 1 开始截取 2 个内容，第三个参数没有写，就是没有新内容替换掉截取位置\",\"var arr = [1, 2, 3, 4, 5] // 使用 splice 方法截取数组 arr.splice(1, 2, '我是新内容') console.log(arr) // [1, '我是新内容', 4, 5] \",\"arr.splice(1, 2, '我是新内容') 表示从索引 1 开始截取 2 个内容，然后用第三个参数把截取完空出来的位置填充\"]},{\"header\":\"数组常用方法之 reverse\",\"slug\":\"数组常用方法之-reverse\",\"contents\":[\"reverse 是用来反转数组使用的\",\"var arr = [1, 2, 3] // 使用 reverse 方法来反转数组 arr.reverse() console.log(arr) // [3, 2, 1] \"]},{\"header\":\"数组常用方法之 sort\",\"slug\":\"数组常用方法之-sort\",\"contents\":[\"sort 是用来给数组排序的\",\"var arr = [2, 3, 1] // 使用 sort 方法给数组排序 arr.sort() console.log(arr) // [1, 2, 3] \"]},{\"header\":\"数组常用方法之 concat\",\"slug\":\"数组常用方法之-concat\",\"contents\":[\"concat 是把多个数组进行拼接\",\"和之前的方法有一些不一样的地方，就是 concat 不会改变原始数组，而是返回一个新的数组\",\"var arr = [1, 2, 3] // 使用 concat 方法拼接数组 var newArr = arr.concat([4, 5, 6]) console.log(arr) // [1, 2, 3] console.log(newArr) // [1, 2, 3, 4, 5, 6] \",\"注意： concat 方法不会改变原始数组\"]},{\"header\":\"数组常用方法之 join\",\"slug\":\"数组常用方法之-join\",\"contents\":[\"join 是把数组里面的每一项内容链接起来，变成一个字符串，可以自己定义每一项之间链接的内容 join(要以什么内容链接)，不会改变原始数组，而是把链接好的字符串返回\",\"var arr = [1, 2, 3] // 使用 join 链接数组 var str = arr.join('-') console.log(arr) // [1, 2, 3] console.log(str) // 1-2-3 \",\"注意： join 方法不会改变原始数组，而是返回链接好的字符串\"]},{\"header\":\"数组常用方法之 indexOf\",\"slug\":\"数组常用方法之-indexof\",\"contents\":[\"indexOf 用来找到数组中某一项的索引\",\"语法： indexOf(你要找的数组中的项)\",\"var arr = [1, 2, 3, 4, 5] // 使用 indexOf 超找数组中的某一项 var index = arr.indexOf(3) console.log(index) // 2 \",\"我们要找的是数组中值为 3 的那一项，返回的就是值为 3 的那一项在该数组中的索引，如果你要找的内容在数组中没有，那么就会返回 -1\",\"var arr = [1, 2, 3, 4, 5] // 使用 indexOf 超找数组中的某一项 var index = arr.indexOf(10) console.log(index) // -1 \",\"你要找的值在数组中不存在，那么就会返回 -1\"]},{\"header\":\"数组常用方法之 forEach\",\"slug\":\"数组常用方法之-foreach\",\"contents\":[\"和 for 循环一个作用，就是用来遍历数组的\",\"语法：arr.forEach(function (item, index, arr) {})\",\"var arr = [1, 2, 3] // 使用 forEach 遍历数组 arr.forEach(function (item, index, arr) { // item 就是数组中的每一项 // index 就是数组的索引 // arr 就是原始数组 console.log('数组的第 ' + index + ' 项的值是 ' + item + '，原始数组是', arr) }) \",\"forEach() 的时候传递的那个函数，会根据数组的长度执行，数组的长度是多少，这个函数就会执行多少回\"]},{\"header\":\"数组常用方法之 map\",\"slug\":\"数组常用方法之-map\",\"contents\":[\"和 forEach 类似，只不过可以对数组中的每一项进行操作，返回一个新的数组，用于处理数据\",\"var arr = [1, 2, 3] // 使用 map 遍历数组 var newArr = arr.map(function (item, index, arr) { // item 就是数组中的每一项 // index 就是数组的索引 // arr 就是原始数组 return item + 10 }) console.log(newArr) // [11, 12, 13] \"]},{\"header\":\"数组常用方法之 filter\",\"slug\":\"数组常用方法之-filter\",\"contents\":[\"和 map 的使用方式类似，按照我们的条件来筛选数组，把原始数组中满足条件的筛选出来，组成一个新的数组返回，如果没有符合条件的元素则返回空数组，它不会影响原数组\",\"var arr = [1, 2, 3] // 使用 filter 过滤数组 var newArr = arr.filter(function (item, index, arr) { // item 就是数组中的每一项 // index 就是数组的索引 // arr 就是原始数组 return item > 1 //筛选条件 }) console.log(newArr) // [2, 3] \",\"我们设置的条件就是 > 1，返回的新数组就会是原始数组中所有 > 1 的项\"]}]},\"/frontend/javascriptnotes/13-JavaScript%E5%9F%BA%E7%A1%80-%E5%AD%97%E7%AC%A6%E4%B8%B2.html\":{\"title\":\"JavaScript基础-字符串\",\"contents\":[{\"header\":\"创建字符串\",\"slug\":\"创建字符串\",\"contents\":[\"我们创建字符串也分为两种方法 字面量 和 构造函数\"]},{\"header\":\"字面量\",\"slug\":\"字面量\",\"contents\":[\"var str = 'hello' \"]},{\"header\":\"构造函数创建\",\"slug\":\"构造函数创建\",\"contents\":[\"var str = new String('hello') \"]},{\"header\":\"字符集\",\"slug\":\"字符集\",\"contents\":[]},{\"header\":\"ASCII 字符集\",\"slug\":\"ascii-字符集\",\"contents\":[\"我们都知道，计算机只能存储 0101010 这样的二进制数字，那么我们的 a ~ z 、A ~ Z 、$ 、@ 之类的内容也有由二进制数字组成的，我们可以简单的理解为， a ~ z 、 A ~ Z、 $ 、 @之类的内容都有一个自己的编号，然后在计算机存储的时候，是存储的这些编号，我们看的时候，也是通过这些编号再解析成我们要看到的内容\"]},{\"header\":\"unicode 编码\",\"slug\":\"unicode-编码\",\"contents\":[\"我们看到了，ASCII 只有这 128 个字符的编码结构，但是因为 ASCII 出现的比较早，而且是美国发明的，早先时候这些内容就够用了，因为存储一些英文的内容，传递一些英文的文章什么的都够用了，那么对于这个世界来说肯定是不够用的，因为我们的汉字没有办法存储，包括一些其他国家的语言也没有办法存储，所以就出现了 unicode 编码，也叫（万国码，统一码），unicode 对照表就是一个和 ASCII 一样的对照表，只不过变得很大很大，因为存储的内容特别的多，而且包含了世界上大部分国家的文字，所以我们的文字和字符现在在存储的时候，都是按照 unicode 编码转换成数字进行存储，我们的 UTF-8 就是一种 8 位的 unicode 字符集\"]},{\"header\":\"字符串的常用方法\",\"slug\":\"字符串的常用方法\",\"contents\":[\"字符串和数组有一个相同的特点，即字符串也是按照索引来排列的\"]},{\"header\":\"charAt\",\"slug\":\"charat\",\"contents\":[\"charAt(索引) 是找到字符串中指定索引位置的内容并返回\",\"var str = 'Jack' // 使用 charAt 找到字符串中的某一个内容 var index = str.charAt(2) console.log(index) // c \",\"因为字符串也是按照索引进行排列的，也是同样从 0 开始，所以索引 2 的位置就是 c\",\"如果没有对应的索引，那么就会返回 空字符串\",\"var str = 'Jack' // 使用 charAt 找到字符串中的某一个内容 var index = str.charAt(10) console.log(index) // '' \",\"这个字符串根本没有索引 10 的位置，所以就会返回一个空字符串 ''\"]},{\"header\":\"charCodeAt\",\"slug\":\"charcodeat\",\"contents\":[\"charCodeAt(索引) 就是返回对应索引位置的 unicode 编码\",\"var str = 'Jack' // 使用 charAt 找到字符串中的某一个内容 var index = str.charCodeAt(0) console.log(index) // 74 \",\"因为 J 在 unicode 对照表里面存储的是 74，所以就会返回 74\"]},{\"header\":\"indexOf\",\"slug\":\"indexof\",\"contents\":[\"indexOf 就是按照字符找到对应的索引\",\"var str = 'Jack' // 使用 indexOf 找到对应的索引 var index = str.indexOf('J') console.log(index) // 0 \",\"因为字符 J 在字符串 Jack 中的索引位置是 0，所以会返回 0\"]},{\"header\":\"substring\",\"slug\":\"substring\",\"contents\":[\"substring 是用来截取字符串使用的\",\"语法： substring(从哪个索引开始，到哪个索引截止)，包含开始索引，不包含结束索引\",\"var str = 'hello' // 01234 // 使用 substring 截取字符串 var newStr = str.substring(1, 3) console.log(newStr) // el \",\"从索引 1 开始，到索引 3 截止，包含前面的索引不包含后面的索引，所以返回的是 el\"]},{\"header\":\"substr\",\"slug\":\"substr\",\"contents\":[\"substr 也是用来截取字符串的\",\"语法：substr(从哪个索引开始，截取多少个)\",\"var str = 'hello' // 01234 // 使用 substr 截取字符串 var newStr = str.substr(1, 3) console.log(newStr) // ell \",\"这个方法和 substring 不一样的是，第二个参数是截取多少个，从索引 1 开始，截取 3 个，所以得到的是 ell\"]},{\"header\":\"toLowerCase 和 toUpperCase\",\"slug\":\"tolowercase-和-touppercase\",\"contents\":[\"这两个方法分别使用用来给字符串转成 小写字母 和 大写字母 的\",\"var str = hello // 使用 toUpperCase 转换成大写 var upper = str.toUpperCase() console.log(upper) // HELLO // 使用 toLowerCase 转换成小写 var lower = upper.toLowerCase() console.log(lower) // hello \"]}]},\"/frontend/javascriptnotes/14-JavaScript%E5%9F%BA%E7%A1%80-Math.html\":{\"title\":\"JavaScript基础-Math\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"Math 是 JS 的一个内置对象，称为数学对象，提供了一堆的属性和方法帮助我们操作 数字\"]},{\"header\":\"常用方法\",\"slug\":\"常用方法\",\"contents\":[]},{\"header\":\"random\",\"slug\":\"random\",\"contents\":[\"Math.random() 这个方法是用来生成一个 0 ~ 1 之间的随机数，每次执行生成的数字都不一样，但是一定是 0 ~ 1 之间的，生成的数字包含 0 ，但是不包含 1\",\"var num = Math.random() console.log(num) // 得到一个随机数 \",\"//生成0~10的随机数 Math.floor(Math.random() * 11) //生成N~M之间的随机数 Math.floor(Math.random() * (M - N + 1)) + N \"]},{\"header\":\"round\",\"slug\":\"round\",\"contents\":[\"Math.round() 是将一个小数 四舍五入 变成一个整数\",\"var num = 10.1 console.log(Math.round(num)) // 10 var num2 = 10.6 console.log(Math.round(num2)) // 11 \"]},{\"header\":\"abs\",\"slug\":\"abs\",\"contents\":[\"Math.abs() 是返回一个数字的 绝对值\",\"var num = -10 console.log(math.abs(num)) // 10 \"]},{\"header\":\"ceil\",\"slug\":\"ceil\",\"contents\":[\"Math.ceil() 是将一个小数 向上取整 得到的整数\",\"var num = 10.1 console.log(Math.ceil(num)) // 11 var num2 = 10.9 console.log(Math.ceil(num2)) // 11 \"]},{\"header\":\"floor\",\"slug\":\"floor\",\"contents\":[\"Math.floor() 是将一个小数 向下取整 的到的整数\",\"var num = 10.1 console.log(Math.floor(num)) // 10 var num2 = 10.9 console.log(Math.floor(num2)) // 10 \"]},{\"header\":\"max\",\"slug\":\"max\",\"contents\":[\"Math.max() 得到的是你传入的几个数字之中 最大 的那个数字\",\"console.log(Math.max(1, 2, 3, 4, 5)) // 5 \"]},{\"header\":\"min\",\"slug\":\"min\",\"contents\":[\"Math.min() 得到的是你传入的几个数字之中 最小 的那个数字\",\"console.log(Math.min(1, 2, 3, 4, 5)) // 1 \"]},{\"header\":\"pow\",\"slug\":\"pow\",\"contents\":[\"Math.pow()求某个数的多少次方\",\"// 求 4 的 2 次方 console.log(Math.pow(4, 2)) // 16 // 求 2 的 3 次方 console.log(Math.pow(2, 3)) // 8 \"]},{\"header\":\"sqrt\",\"slug\":\"sqrt\",\"contents\":[\"Math.sqrt()求某数的平方根\",\"console.log(Math.sqrt(16))// 4 \"]},{\"header\":\"常用属性\",\"slug\":\"常用属性\",\"contents\":[]},{\"header\":\"PI\",\"slug\":\"pi\",\"contents\":[\"Math.PI 得到的是 π 的值，也就是 3.1415936...\",\"console.log(Math.PI) // 3.141592653589793 \",\"因为计算机的计算精度问题，只能得到小数点后 15 位，使用 Math.PI 的时候，是不需要加 () 的\"]}]},\"/frontend/javascriptnotes/15-JavaScript%E5%9F%BA%E7%A1%80-Date.html\":{\"title\":\"JavaScript基础-Date\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"Date对象是JS提供的专门用来获取时间的\"]},{\"header\":\"new Date()\",\"slug\":\"new-date\",\"contents\":[\"new Date() 在不传递参数的情况下是默认返回当前时间\",\"var time = new Date() console.log(time) // 当前时间 Fri Mar 01 2019 13:11:23 GMT+0800 (中国标准时间) \",\"new Date() 在传入参数的时候，可以获取到一个你传递进去的时间\",\"var time = new Date('2019-03-03 13:11:11') console.log(time) // Sun Mar 03 2019 13:11:11 GMT+0800 (中国标准时间) \",\"new Date() 传递的参数有多种情况\",\"传递两个数字，第一个表示年，第二个表示月份\",\"var time = new Date(2019, 00) // 月份从 0 开始计数，0 表示 1月，11 表示 12月 console.log(time) // Tue Jan 01 2019 00:00:00 GMT+0800 (中国标准时间) \",\"传递三个数字，前两个不变，第三个表示该月份的第几天，从 1 到 31\",\"var time = new Date(2019, 00, 05) console.log(time) // Sat Jan 05 2019 00:00:00 GMT+0800 (中国标准时间) \",\"传递四个数字，前三个不变，第四个表示当天的几点，从 0 到 23\",\"var time = new Date(2019, 00, 05, 22) console.log(time) // Sat Jan 05 2019 22:00:00 GMT+0800 (中国标准时间) \",\"传递五个数字，前四个不变，第五个表示的是该小时的多少分钟，从 0 到 59\",\"var time = new Date(2019, 00, 05, 22, 33) console.log(time) // Sat Jan 05 2019 22:33:00 GMT+0800 (中国标准时间) \",\"传递六个数字，前五个不变，第六个表示该分钟的多少秒，从 0 到 59\",\"var time = new Date(2019, 00, 05, 22, 33, 55) console.log(time) // Sat Jan 05 2019 22:33:55 GMT+0800 (中国标准时间) \",\"传入字符串的形式\",\"console.log(new Date('2019')) // Tue Jan 01 2019 08:00:00 GMT+0800 (中国标准时间) console.log(new Date('2019-02')) // Fri Feb 01 2019 08:00:00 GMT+0800 (中国标准时间) console.log(new Date('2019-02-03')) // Sun Feb 03 2019 08:00:00 GMT+0800 (中国标准时间) console.log(new Date('2019-02-03 13:')) // Sun Feb 03 2019 13:00:00 GMT+0800 (中国标准时间) console.log(new Date('2019-02-03 13:13:')) // Sun Feb 03 2019 13:13:00 GMT+0800 (中国标准时间) console.log(new Date('2019-02-03 13:13:13')) // Sun Feb 03 2019 13:13:13 GMT+0800 (中国标准时间) \"]},{\"header\":\"将日期字符串格式化成指定内容\",\"slug\":\"将日期字符串格式化成指定内容\",\"contents\":[\"我们得到的时间字符串是 Sun Feb 03 2019 13:13:13 GMT+0800 (中国标准时间)，我只想得到这个日期中是哪一年，我们就要靠截取字符串的形式得到，但是现在 js 为我们提供了一系列的方法来得到里面的指定内容\"]},{\"header\":\"getFullYear\",\"slug\":\"getfullyear\",\"contents\":[\"getFullYear() 方式是得到指定字符串中的哪一年\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getFullYear()) // 2019 \"]},{\"header\":\"getMonth\",\"slug\":\"getmonth\",\"contents\":[\"getMonth() 方法是得到指定字符串中的哪一个月份\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getMonth()) // 3 \",\"这里要有一个注意的地方，月份是从 0 开始数的，0 表示 1月，1 表示 2月，依此类推\"]},{\"header\":\"getDate\",\"slug\":\"getdate\",\"contents\":[\"getDate() 方法是得到指定字符串中的哪一天\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getDate()) // 3 \"]},{\"header\":\"getHours\",\"slug\":\"gethours\",\"contents\":[\"getHours() 方法是得到指定字符串中的哪小时\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getHours()) // 8 \"]},{\"header\":\"getMinutes\",\"slug\":\"getminutes\",\"contents\":[\"getMinutes() 方法是得到指定字符串中的哪分钟\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getMinutes()) // 0 \"]},{\"header\":\"getSeconds\",\"slug\":\"getseconds\",\"contents\":[\"getSeconds() 方法是得到指定字符串中的哪秒钟\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getSeconds()) // 22 \"]},{\"header\":\"getDay\",\"slug\":\"getday\",\"contents\":[\"getDay() 方法是得到指定字符串当前日期是一周中的第几天（周日是 0，周六是 6）\",\"var time = new Date(2019, 03, 08, 08, 00, 22) console.log(time.getDay()) // 1 \"]},{\"header\":\"getTime\",\"slug\":\"gettime\",\"contents\":[\"getTime() 方法是得到执行时间到 格林威治时间 的毫秒数，即时间戳\",\"var time = new Date(2019, 03, 08, 08, 00, 22) console.log(time.getTime()) // 1554681622000 \",\"其他获取时间戳方法：\",\"+new Date() 方法：\",\"console.log(+new Date()) \",\"now() 方法： 无需实例化，但是只能得到当前的时间戳\",\"console.log(Date.now()) \"]},{\"header\":\"获取时间差\",\"slug\":\"获取时间差\",\"contents\":[\"是指获取两个时间点之间相差的时间，在JS中是不能用时间直接做 减法 的，我们需要一些特殊的操作，在编程的世界里面，有一个特殊的时间，是 1970年01月01日00时00分00秒，这个时间我们叫做 格林威治时间，所有的编程世界里面，这个时间都是一样的，而且 格林威治时间 的数字是 0，从 格林威治时间 开始，每经过1毫秒，数字就会 + 1，所以我们可以获取到任意一个时间节点到 格林威治时间 的毫秒数，然后再用两个毫秒数相减，就能得到两个时间点之间相差的毫秒数，我们再通过这个毫秒数得到准确的时间\"]}]},\"/frontend/javascriptnotes/16-JavaScript%E5%9F%BA%E7%A1%80-%E5%AE%9A%E6%97%B6%E5%99%A8.html\":{\"title\":\"JavaScript基础-定时器\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"在 JS 里面，有两种定时器，倒计时定时器 和 间隔定时器\"]},{\"header\":\"倒计时定时器\",\"slug\":\"倒计时定时器\",\"contents\":[\"倒计时多少时间以后执行函数\",\"语法： setTimeout(要执行的函数，多长时间以后执行)\",\"会在你设定的时间以后，执行函数\",\"var timerId = setTimeout(function () { console.log('我执行了') }, 1000) console.log(timerId) // 1 \",\"时间是按照毫秒进行计算的，1000 毫秒就是 1秒钟，所以会在页面打开 1 秒钟以后执行函数，只执行一次，就不再执行了，返回值是当前这个定时器是页面中的第几个定时器，表示定时器的编号\"]},{\"header\":\"间隔定时器\",\"slug\":\"间隔定时器\",\"contents\":[\"每间隔多少时间就执行一次函数\",\"语法： setInterval(要执行的函数，间隔多少时间)\",\"var timerId = setInterval(function () { console.log('我执行了') }, 1000) \",\"时间和刚才一样，是按照毫秒进行计算的，每间隔 1 秒钟执行一次函数，只要不关闭，会一直执行，返回值是，当前这个定时器是页面中的第几个定时器，表示定时器的编号\"]},{\"header\":\"定时器的返回值\",\"slug\":\"定时器的返回值\",\"contents\":[\"设置定时器的时候，它的返回值是部分 setTimeout 和 setInterval 的\",\"只要有一个定时器，那么就是一个数字\",\"var timerId = setTimeout(function () { console.log('倒计时定时器') }, 1000) var timerId2 = setInterval(function () { console.log('间隔定时器') }, 1000) console.log(timerId) // 1 console.log(timerId2) // 2 \"]},{\"header\":\"关闭定时器\",\"slug\":\"关闭定时器\",\"contents\":[\"我们刚才提到过一个 timerId，是表示这个定时器是页面上的第几个定时器\",\"这个 timerId 就是用来关闭定时器的数字\",\"我们有两个方法来关闭定时器 clearTimeout 和 clearInterval\",\"var timerId = setTimeout(function () { console.log('倒计时定时器') }, 1000) clearTimeout(timerId) \",\"关闭以后，定时器就不会再执行了\",\"var timerId2 = setInterval(function () { console.log('间隔定时器') }, 1000) coearInterval(timerId2) \",\"关闭以后定时器就不会再执行了\",\"原则上是clearTimeout 关闭 setTimeout，clearInterval 关闭 setInterval，但是其实是可以通用的，他们可以混着使用\",\"var timerId = setTimeout(function () { console.log('倒计时定时器') }, 1000) // 关闭倒计时定时器 clearInterval(timerId) var timerId2 = setInterval(function () { console.log('间隔定时器') }, 1000) // 关闭间隔定时器 clearTimeout(timerId2) \"]}]},\"/frontend/javascriptnotes/17-JavaScript%E5%9F%BA%E7%A1%80-this%E5%85%B3%E9%94%AE%E5%AD%97.html\":{\"title\":\"JavaScript基础-this关键字\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"每一个函数内部都有一个关键字是 this ，可以让我们直接使用的\",\"重点： 函数内部的 this 只和函数的调用方式有关系，和函数的定义方式没有关系\"]},{\"header\":\"this指向\",\"slug\":\"this指向\",\"contents\":[\"函数内部的 this 指向谁，取决于函数的调用方式\",\"全局定义的函数直接调用，this => window\",\"function fn() { console.log(this) } fn() // 此时 this 指向 window \",\"对象内部的方法调用，this => 调用者\",\"var obj = { fn: function () { console.log(this) } } obj.fn() // 此时 this 指向 obj \",\"定时器的处理函数，this => window\",\"setTimeout(function () { console.log(this) }, 0) // 此时定时器处理函数里面的 this 指向 window \",\"事件处理函数，this => 事件源\",\"div.onclick = function () { console.log(this) } // 当你点击 div 的时候，this 指向 div \",\"自调用函数，this => window\",\"(function () { console.log(this) })() // 此时 this 指向 window \"]},{\"header\":\"call 和 apply 和 bind\",\"slug\":\"call-和-apply-和-bind\",\"contents\":[\"刚才我们说过的都是函数的基本调用方式里面的 this 指向，我们还有三个可以忽略函数本身的 this 指向转而指向别的地方，这三个方法就是 call 、 apply 、 bind，它们是强行改变 this 指向的方法\"]},{\"header\":\"call\",\"slug\":\"call\",\"contents\":[\"call 方法是附加在函数调用后面使用，可以忽略函数本身的 this 指向\",\"语法： 函数名.call(要改变的 this 指向，要给函数传递的参数1，要给函数传递的参数2， ...)\",\"var obj = { name: 'Jack' } function fn(a, b) { console.log(this) console.log(a) console.log(b) } fn(1, 2) fn.call(obj, 1, 2) \",\"fn() 的时候，函数内部的 this 指向 window，fn.call(obj, 1, 2) 的时候，函数内部的 this 就指向了 obj 这个对象，使用 call 方法的时候会立即执行函数，第一个参数是你要改变的函数内部的 this 指向，第二个参数开始，依次是向函数传递参数\"]},{\"header\":\"apply\",\"slug\":\"apply\",\"contents\":[\"apply 方法是附加在函数调用后面使用，可以忽略函数本身的 this 指向\",\"语法： 函数名.apply(要改变的 this 指向，[要给函数传递的参数1， 要给函数传递的参数2， ...])\",\"var obj = { name: 'Jack' } function fn(a, b) { console.log(this) console.log(a) console.log(b) } fn(1, 2) fn.call(obj, [1, 2]) \",\"fn() 的时候，函数内部的 this 指向 window，fn.apply(obj, [1, 2]) 的时候，函数内部的 this 就指向了 obj 这个对象，使用 apply 方法的时候，会立即执行函数，第一个参数是你要改变的函数内部的 this 指向，第二个参数是一个 数组，数组里面的每一项依次是向函数传递的参数\"]},{\"header\":\"bind\",\"slug\":\"bind\",\"contents\":[\"bind 方法是附加在函数调用后面使用，可以忽略函数本身的 this 指向，和 call、apply 有一些不一样，就是不会立即执行函数，而是返回一个已经改变了 this 指向的函数\",\"语法： var newFn = 函数名.bind(要改变的 this 指向); newFn(传递参数)\",\"var obj = { name: 'Jack' } function fn(a, b) { console.log(this) console.log(a) console.log(b) } fn(1, 2) var newFn = fn.bind(obj) newFn(1, 2) \",\"bind 调用的时候，不会执行 fn 这个函数，而是返回一个新的函数，这个新的函数就是一个改变了 this 指向以后的 fn 函数，fn(1, 2) 的时候 this 指向 window，newFn(1, 2) 的时候执行的是一个和 fn 一摸一样的函数，只不过里面的 this 指向改成了 obj\"]}]},\"/frontend/javascriptnotes/\":{\"title\":\"JavaScript\",\"contents\":[]},\"/frontend/vuenotes/01-Vue%E6%A0%B8%E5%BF%83-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B.html\":{\"title\":\"Vue核心-快速上手\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/01-Vue核心-快速上手\"]},{\"header\":\"Vue 简介\",\"slug\":\"vue-简介\",\"contents\":[]},{\"header\":\"官网\",\"slug\":\"官网\",\"contents\":[\"英文官网\",\"中文官网\"]},{\"header\":\"介绍与描述\",\"slug\":\"介绍与描述\",\"contents\":[\"Vue 是一套用来动态构建用户界面的渐进式 JavaScript 框架 \",\"构建用户界面：把数据通过某种办法变成用户界面\",\"渐进式：Vue 可以自底向上逐层的应用，简单应用只需要一个轻量小巧的核心库，复杂应用可以引入各式各样的 Vue 插件\",\"作者 \",\"尤雨溪\"]},{\"header\":\"Vue 的特点\",\"slug\":\"vue-的特点\",\"contents\":[\"遵循 MVVM 模式\",\"编码简洁，体积小，运行效率高，适合移动/PC 端开发\",\"它本身只关注 UI，可以引入其它第三方库开发项目\",\"采用组件化模式，提高代码复用率、且让代码更好维护\",\"声明式编码，让编码人员无需直接操作 DOM，提高开发效率\",\"使用虚拟 DOM 和 Diff 算法，尽量复用 DOM 节点\"]},{\"header\":\"与其他 JS 框架的关联\",\"slug\":\"与其他-js-框架的关联\",\"contents\":[\"借鉴 angular 的模板和数据绑定技术\",\"借鉴 react 的组件化和虚拟 DOM 技术\"]},{\"header\":\"Vue 周边库\",\"slug\":\"vue-周边库\",\"contents\":[\"vue-cli：vue 脚手架\",\"vue-resource (axios)：ajax 请求\",\"vue-router：路由\",\"vuex：状态管理（它是 vue 的插件，但是没有用 vue-xxx 的命名规则）\",\"vue-lazyload：图片懒加载\",\"vue-scroller：页面滑动相关\",\"mint-ui：基于 vue 的 UI 组件库（移动端）\",\"element-ui：基于 vue 的 UI 组件库（PC 端）\"]},{\"header\":\"初识 Vue\",\"slug\":\"初识-vue\",\"contents\":[]},{\"header\":\"前置工作\",\"slug\":\"前置工作\",\"contents\":[\"给浏览器安装 Vue Devtools 插件\",\"标签引入 Vue 包\",\"（可选）阻止 Vue 在启动时生成生产提示 Vue.config.productionTip = false\"]},{\"header\":\"代码演示\",\"slug\":\"代码演示\",\"contents\":[\"想让 Vue 工作，就必须创建一个 Vue实例，且要传入一个配置对象\",\"容器里的代码依然符合 HTML 规范，只不过混入了一些特殊的 Vue 语法\",\"容器里的代码被称为 Vue 模板\",\"Vue 实例与容器是一一对应的\",\"真实开发中只有一个 Vue 实例，并且会配合着组件一起使用\",\"{{xxx}} 中的 xxx 要写 JS 表达式，且 xxx 可以自动读取到 data 中的所有属性\",\"一旦 data 中的数据发生变化，那么页面中用到该数据的地方也会自动更新\",\"<!DOCTYPE html> <html> <head> <meta charset=\\\"UTF-8\\\" /> <title>初识Vue</title> <!-- 引入Vue --> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器 --> <div id=\\\"demo\\\"> <h1>Hello，{{ name.toUpperCase() }}，{{ address }}</h1> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false //阻止 Vue 在启动时生成生产提示 // 创建Vue实例 new Vue({ el: '#demo', // el用于指定当前Vue实例为哪个容器服务，值通常为CSS选择器字符串 data: { // data中用于存储数据，数据供el所指定的容器去使用，值暂时先写成一个对象 name: 'zhf', address: '山东', }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-快速上手01.png\",\"注意区分：JS 表达式和 JS 代码（语句）\",\"JS 表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方，如：a、a+b、demo(1)、x === y ? 'a' : 'b'\",\"JS 代码（语句），只控制代码的走向，不生成值，如：if (){}、for (){}\"]},{\"header\":\"el 和 data\",\"slug\":\"el-和-data\",\"contents\":[]},{\"header\":\"el\",\"slug\":\"el\",\"contents\":[\"el 用于指定当前 Vue 实例为哪个容器服务，值通常为 CSS 选择器字符串\"]},{\"header\":\"data\",\"slug\":\"data\",\"contents\":[\"data 中用于存储数据，数据供 el 所指定的容器去使用，值暂时先写成一个对象\"]},{\"header\":\"el 和 data 的两种写法\",\"slug\":\"el-和-data-的两种写法\",\"contents\":[\"el 有两种写法：\",\"创建 Vue 实例对象的时候配置 el 属性\",\"const v = new Vue({ el:'#root', //第一种写法 data:{ name:'zhf' } }) \",\"先创建 Vue 实例，随后再通过 vm.$mount('选择器') 指定 el 的值\",\"const v = new Vue({ data:{ name:'zhf' } }) v.$mount('#root') //第二种写法 \",\"data 有两种写法：\",\"对象式：data:{}\",\"data:{ name:'zhf' } \",\"函数式：data(){return{}}\",\"data(){ console.log('@@@',this) //此处的this是Vue实例对象 return{ name:'zhf' } } \",\"如何选择：组件时，data 必须使用函数式，否则会报错\",\"重要原则：由 Vue 管理的函数，一定不要写箭头函数，否则 this 就不再是 Vue 实例了\"]}]},\"/frontend/vuenotes/02-Vue%E6%A0%B8%E5%BF%83-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95.html\":{\"title\":\"Vue核心-模板语法\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/02-Vue核心-模板语法\"]},{\"header\":\"模板的理解\",\"slug\":\"模板的理解\",\"contents\":[\"模板就是动态 HTML 页面，这里面包含了一些 JS 语法代码\"]},{\"header\":\"Vue 模板语法\",\"slug\":\"vue-模板语法\",\"contents\":[\"Vue 模板语法包括两大类，分别是：\",\"插值语法：双大括号表示\",\"指令语法：指令（以 v- 开头的自定义标签属性）\"]},{\"header\":\"插值语法\",\"slug\":\"插值语法\",\"contents\":[\"功能：用于解析标签体内容\",\"写法：{{xxx}}，xxx 是 JS 表达式，可以直接读取到 data 中的所有属性\"]},{\"header\":\"指令语法\",\"slug\":\"指令语法\",\"contents\":[\"功能：用于解析标签（包括：标签属性、标签体内容、绑定事件等）\",\"举例：<a v-bind:href=\\\"xxx\\\"> 或简写为 <a :href='xxx'>，xxx 同样要写 JS 表达式，可以直接读取到 data 中所有属性\",\"备注：Vue 中有很多的指令，且形式都是 v-xxx，此处只是以 v-bind 举例\",\"例：\",\"<!DOCTYPE html> <html> <head> <meta charset=\\\"UTF-8\\\" /> <title>模板语法</title> <!-- 引入Vue --> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>插值语法</h2> <h4>你好，{{ name }}</h4> <hr /> <h2>指令语法</h2> <a v-bind:href=\\\"baidu.url.toUpperCase()\\\">点我去{{ baidu.name }}1</a> <a :href=\\\"baidu.url\\\">点我去{{ baidu.name }}2</a> </div> </body> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 new Vue({ el: '#root', data: { name: 'zhf', baidu: { name: '百度', url: 'https://www.baidu.com/', }, }, }) </script> </html> \",\"效果：\",\"Vue核心-模板语法01.gif\"]}]},\"/frontend/vuenotes/03-Vue%E6%A0%B8%E5%BF%83-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.html\":{\"title\":\"Vue核心-数据绑定\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/03-Vue核心-数据绑定\"]},{\"header\":\"数据绑定\",\"slug\":\"数据绑定\",\"contents\":[\"Vue 中有两种数据绑定的方式：\",\"单向绑定 v-bind 数据只能从 data 流向页面\",\"双向绑定 v-model 数据不仅能从 data 流向页面，还可以从页面流向 data\",\"备注：\",\"双向绑定一般都应用在表单类元素上，如 <input>、<select>、<textarea> 等\",\"v-model:value 可以简写为 v-model，因为 v-model 默认收集的就是 value 值\",\"例：\",\"<!DOCTYPE html> <html> <head> <meta charset=\\\"UTF-8\\\" /> <title>数据绑定</title> <!-- 引入Vue --> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <!-- 普通写法 --> <!-- 单向数据绑定：<input type=\\\"text\\\" v-bind:value=\\\"name\\\" /><br /> --> <!-- 双向数据绑定：<input type=\\\"text\\\" v-model:value=\\\"name\\\" /> --> <!-- 简写 --> 单向数据绑定：<input type=\\\"text\\\" :value=\\\"name\\\" /><br /> 双向数据绑定：<input type=\\\"text\\\" v-model=\\\"name\\\" /> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { name: 'zhf', }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-数据绑定01.gif\"]},{\"header\":\"v-model 指令的修饰符\",\"slug\":\"v-model-指令的修饰符\",\"contents\":[]},{\"header\":\"v-model. number\",\"slug\":\"v-model-number\",\"contents\":[\"使用修饰符 .number 可以将输入的数据转换为 Number 类型，否则虽然你输入的是数字. 但它的类型其实是 String\"]},{\"header\":\"v-model. trim\",\"slug\":\"v-model-trim\",\"contents\":[\"给 v-model 添加修饰符 .trim 可以自动过滤用户输入的首尾空格\"]},{\"header\":\"v-model. lazy\",\"slug\":\"v-model-lazy\",\"contents\":[\"并不是实时改变，而是在失去焦点或者按回车时才会更新\",\"在输入框中，v-model默认是在input事件中同步输入框的数据（除了输入法中文输入的情况），使用修饰符 .lazy 会转变为 change 事件中同步（类似懒加载）\"]}]},\"/frontend/vuenotes/04-Vue%E6%A0%B8%E5%BF%83-MVVM%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86.html\":{\"title\":\"Vue核心-MVVM模型与数据代理\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/04-Vue核心-MVVM模型与数据代理\"]},{\"header\":\"MVVM 模型\",\"slug\":\"mvvm-模型\",\"contents\":[\"Vue核心-MVVM模型与数据代理01.png\",\"MVVM 本质上是 MVC （Model-View- Controller）的改进版。即模型-视图-视图模型\",\"模型 model 指的是后端传递的数据，视图 view 指的是所看到的页面\",\"视图模型 viewModel 是 MVVM 模式的核心，它是连接 view 和 model 的桥梁。它有两个方向：\",\"将模型转化成视图，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定\",\"将视图转化成模型，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听\",\"MVVM：\",\"M：模型 Model，data 中的数据\",\"V：视图 View，模板代码（不是静态页面）（两个语法：指令，大括号表达式）\",\"VM：视图模型 ViewModel，Vue 实例 \",\"Dom Listeners（Dom 监听）\",\"Data Bindings（数据绑定）\",\"观察发现：\",\"data 中所有的属性，最后都出现在了 vm 身上\",\"vm 身上所有的属性及 Vue 原型身上所有的属性，在 Vue 模板中都可以直接使用\",\"Vue核心-MVVM模型与数据代理02.png\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>MVVM</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h1>学校名称：{{name}}</h1> <h1>学校地址：{{address}}</h1> <h1>测试：{{$options}}</h1> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: '曲阜师范大学', address: '曲阜', }, }) console.log(vm) </script> </body> </html> \",\"效果：\",\"Vue核心-MVVM模型与数据代理03.png\"]},{\"header\":\"Vue 中的数据代理\",\"slug\":\"vue-中的数据代理\",\"contents\":[]},{\"header\":\"Object. defineproperty 方法\",\"slug\":\"object-defineproperty-方法\",\"contents\":[\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Object.defineproperty方法</title> </head> <body> <script> let number = 18 let person = { name: '张三', sex: '男', } Object.defineProperty(person, 'age', { // value:18, // enumerable:true, // 控制属性是否可以枚举，默认值是false // writable:true, // 控制属性是否可以被修改，默认值是false // configurable:true // 控制属性是否可以被删除，默认值是false // 当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值 get() { console.log('有人读取age属性了') return number }, // 当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值 set(value) { console.log('有人修改了age属性，且值是', value) number = value }, }) console.log(person) </script> </body> </html> \",\"效果：\",\"Vue核心-MVVM模型与数据代理04.png\"]},{\"header\":\"数据代理\",\"slug\":\"数据代理\",\"contents\":[\"数据代理：通过一个对象代理对另一个对象中属性的操作（读/写）\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>模拟一个数据代理</title> </head> <body> <script> let obj1 = { x: 100 } let obj2 = { y: 200 } Object.defineProperty(obj2, 'x', { get() { return obj1.x }, set(value) { obj1.x = value }, }) console.log(obj1.x) console.log(obj1.y) console.log(obj2.x) console.log(obj2.y) </script> </body> </html> \",\"效果：\",\"Vue核心-MVVM模型与数据代理05.png\",\"Vue 中的数据代理通过 vm 对象来代理 data 对象中属性的操作（读/写）\",\"Vue 中数据代理的好处：更加方便的操作 data 中的数据\",\"基本原理 \",\"通过 Object.defineProperty()把 data 对象中所有属性添加到 vm 上\",\"为每一个添加到 vm 上的属性，都指定一个 gettersetter\",\"在 gettersetter 内部去操作（读/写）data 中对应的属性\",\"Vue核心-MVVM模型与数据代理06.png\",\"Vue 将 data 中的数据拷贝了一份到 _data 属性中，又将 _data 里面的属性提到 Vue 实例中（如 name），通过 defineProperty 实现数据代理，这样通过 geter/setter 操作 name，进而操作 _data 中的 name。而 _data 又对 data 进行数据劫持，实现响应式\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Vue中的数据代理</title> <!-- 引入Vue --> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>学校名称：{{ name }}</h2> <h2>学校地址：{{ address }}</h2> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: '曲阜师范大学', address: '曲阜', }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-MVVM模型与数据代理07.png\"]}]},\"/frontend/vuenotes/05-Vue%E6%A0%B8%E5%BF%83-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86.html\":{\"title\":\"Vue核心-事件处理\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/05-Vue核心-事件处理\"]},{\"header\":\"事件的基本用法\",\"slug\":\"事件的基本用法\",\"contents\":[\"使用 v-on:xxx 或 @xxx 绑定事件，其中 xxx 是事件名\",\"事件的回调需要配置在 methods 对象中，最终会在 vm 上\",\"methods 中配置的函数，不要用箭头函数，否则 this 就不是 vm 了\",\"methods 中配置的函数，都是被 Vue 所管理的函数，this 的指向是 vm 或组件实例对象\",\"@click=\\\"xxx\\\" 和 @click=\\\"xxx()\\\" 效果一致，但后者括号里面可以传参\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>事件的基本使用</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>欢迎阅读{{name}}的笔记</h2> <button v-on:click=\\\"showInfo\\\">点我提示信息</button> <button @click=\\\"showInfo1()\\\">点我提示信息1（不传参）</button> <button @click=\\\"showInfo2($event,66)\\\">点我提示信息2（传参）</button> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', }, methods: { showInfo() { alert('你好呀！这是完整写法绑定事件') }, showInfo1() { alert('你好呀！这是简写方法绑定事件，不传参') }, showInfo2(event, number) { alert(`你好呀！这是简写方法绑定事件，传参，传递到参数是${number}`) console.log(event) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-事件处理01.gif\"]},{\"header\":\"事件修饰符\",\"slug\":\"事件修饰符\",\"contents\":[\"Vue 中的事件修饰符：\",\"prevent 阻止默认事件（常用）\",\"stop 阻止事件冒泡（常用）\",\"once 事件只触发一次（常用）\",\"capture 使用事件的捕获模式\",\"self 只有 event.target 是当前操作的元素时才触发事件\",\"passive 事件的默认行为立即执行，无需等待事件回调执行完毕\",\"注意：修饰符可以连续写，比如可以这么用：@click. prevent.stop=\\\"xxx\\\"\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>事件修饰符</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> <style> * { margin-top: 20px; } .box { height: 50px; background-color: skyblue; } .box1 { padding: 5px; background-color: skyblue; } .box2 { padding: 5px; background-color: white; } .list { width: 200px; height: 200px; background-color: skyblue; overflow: auto; } li { height: 100px; } </style> </head> <body> <div id=\\\"root\\\"> <h2>欢迎来{{name}}学习</h2> <!-- 阻止默认事件（常用） --> <a href=\\\"https://www.qfnu.edu.cn/\\\" @click.prevent=\\\"showInfo\\\">点我提示信息</a> <!-- 阻止事件冒泡（常用） --> <div class=\\\"box\\\" @click=\\\"showInfo\\\"> <button @click1=\\\"showInfo\\\">点我提示信息</button> </div> <!-- 事件只触发一次（常用） --> <button @click.once=\\\"showInfo\\\">点我提示信息</button> <!-- 使用事件的捕获模式 --> <div class=\\\"box1\\\" @click.capture=\\\"showMsg(1)\\\"> div1 <div class=\\\"box2\\\" @click=\\\"showMsg(2)\\\">div2</div> </div> <!-- 只有event.target是当前操作的元素时才触发事件 --> <div class=\\\"box\\\" @click.self=\\\"showInfo\\\"> <button @click=\\\"showInfo\\\">点我提示信息</button> </div> <!-- 事件的默认行为立即执行，无需等待事件回调执行完毕--> <!-- scroll是滚动条滚动，passive没有影响 --> <!-- wheel是鼠标滚轮滚动，passive有影响 --> <ul @wheel.passive=\\\"demo\\\" class=\\\"list\\\"> <li>1</li> <li>2</li> <li>3</li> <li>4</li> </ul> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { name: '曲阜师范大学', }, methods: { showInfo() { alert('同学你好！') }, showMsg(msg) { alert(`${msg}`) }, demo() { for (let i = 0; i < 100000; i++) { console.log('#') } console.log('累坏了') }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-事件处理02.gif\"]},{\"header\":\"键盘事件\",\"slug\":\"键盘事件\",\"contents\":[\"键盘上的每个按键都有自己的名称和编码，例如：Enter（13），而 Vue 还对一些常用按键起了别名方便使用\",\"Vue 中常用的按键别名： 回车 enter 删除 delete 捕获“删除”和“退格”键 退出 esc 空格 space 换行 tab 特殊，必须配合 keydown 去使用 上 up 下 down 左 left 右 right\",\"Vue 未提供别名的按键，可以使用按键原始的 key 值去绑定，但注意要转为 kebab-case（多单词小写短横线写法）\",\"系统修饰键（用法特殊）ctrlaltshiftmeta（meta 就是 win 键） \",\"配合 keyup 使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发，指定 ctr+y 使用 @keyup.ctr.y\",\"配合 keydown 使用：正常触发事件\",\"也可以使用 keyCode 去指定具体的按键（不推荐）\",\"Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>键盘事件</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>欢迎阅读{{name}}的笔记</h2> <input type=\\\"text\\\" placeholder=\\\"按下回车提示输入\\\" @keyup.enter=\\\"showInfo\\\" /> <br /> <input type=\\\"text\\\" placeholder=\\\"按下tab提示输入\\\" @keydown.tab=\\\"showInfo\\\" /> <br /> <input type=\\\"text\\\" placeholder=\\\"按下回车提示输入\\\" @keydown.huiche=\\\"showInfo\\\" /> <br /> </div> <script> Vue.config.productionTip = false Vue.config.keyCodes.huiche = 13 // 定义了一个别名按键 new Vue({ el: '#root', data: { name: 'zhf', }, methods: { showInfo(e) { alert(`${e.target.value}`) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-事件处理03.gif\"]}]},\"/frontend/vuenotes/06-Vue%E6%A0%B8%E5%BF%83-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7.html\":{\"title\":\"Vue核心-计算属性与侦听属性\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/06-Vue核心-计算属性与侦听属性\"]},{\"header\":\"计算属性\",\"slug\":\"计算属性\",\"contents\":[\"姓名案例：\",\"Vue核心-计算属性与侦听属性01.gif\",\"插值语法实现：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>插值语法实现姓名案例</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> 姓：<input type=\\\"text\\\" v-model=\\\"firstName\\\" /> <br /> 名：<input type=\\\"text\\\" v-model=\\\"lastName\\\" /> <br /> 全名：<span>{{ firstName }}-{{ lastName }}</span> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false new Vue({ el: '#root', data: { firstName: '张', lastName: '三', }, }) </script> </body> </html> \",\"methods 实现：\",\"数据发生变化，模板就会被重新解析\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>methods实现姓名案例</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> 姓：<input type=\\\"text\\\" v-model=\\\"firstName\\\" /><br /> 名：<input type=\\\"text\\\" v-model=\\\"lastName\\\" /><br /> 全名：<span>{{fullName()}}</span> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { firstName: '张', lastName: '三', }, methods: { fullName() { return this.firstName + '-' + this.lastName }, }, }) </script> </body> </html> \",\"computed 计算属性实现：\",\"定义：要用的属性不存在，需要通过已有属性计算得来\",\"原理：底层借助了 Objcet.defineproperty() 方法提供的 getter 和 setter\",\"get 函数什么时候执行？ \",\"初次读取时会执行一次\",\"当依赖的数据发生改变时会被再次调用\",\"优势：与 methods 实现相比，内部有缓存机制（复用），效率更高，调试方便\",\"备注 \",\"计算属性最终会出现在 vm 上，直接读取使用即可\",\"如果计算属性要被修改，那必须写 set 函数去响应修改，且 set 中要引起计算时依赖的数据发生改变\",\"如果计算属性确定不考虑修改，可以使用计算属性的简写形式\",\"我们用计算属性实现姓名案例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>计算属性实现姓名案例</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> 姓：<input type=\\\"text\\\" v-model=\\\"firstName\\\" /> <br /> 名：<input type=\\\"text\\\" v-model=\\\"lastName\\\" /> <br /> 全名：<span>{{fullName}}</span> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { firstName: '张', lastName: '三', }, computed: { //完整写法 /*fullName: { get() { return this.firstName + '-' + this.lastName }, set(value) { const arr = value.split('-') this.firstName = arr[0] this.lastName = arr[1] }, },*/ //简写形式 fullName() { return this.firstName + '-' + this.lastName }, }, }) </script> </body> </html> \"]},{\"header\":\"侦听属性\",\"slug\":\"侦听属性\",\"contents\":[]},{\"header\":\"侦听属性基本用法\",\"slug\":\"侦听属性基本用法\",\"contents\":[\"watch 侦听属性\",\"当被侦听的属性变化时，回调函数自动调用，进行相关操作\",\"侦听的属性必须存在，才能进行侦听，既可以侦听 data，也可以侦听计算属性\",\"配置项属性 immediate:false，改为 true，则初始化时调用一次 handler(newValue,oldValue)\",\"侦听有两种写法 \",\"创建 Vue 时传入 watch:{}配置\",\"通过 vm.$watch() 侦听\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>侦听的基本用法</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>今天天气很{{info}}</h2> <button @click=\\\"changeWeather\\\">切换天气</button> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { isHot: true, }, computed: { info() { return this.isHot ? '炎热' : '凉爽' }, }, methods: { changeWeather() { this.isHot = !this.isHot }, }, //方式一 /*watch: { isHot: { immediate: true, handler(newValue, oldValue) { console.log('isHot被修改了', newValue, oldValue) }, }, },*/ }) //方式二 vm.$watch('isHot', { immediate: true, //初始化时让handler调用一下 //handler什么时候调用？当isHot发生改变时 handler(newValue, oldValue) { console.log('isHot被修改了', newValue, oldValue) }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-计算属性与侦听属性02.gif\"]},{\"header\":\"深度侦听\",\"slug\":\"深度侦听\",\"contents\":[\"Vue 中的 watch 默认不侦听对象内部值的改变（一层）\",\"在 watch 中配置 deep:true 可以侦听对象内部值的改变（多层）\",\"注意：\",\"Vue 自身可以侦听对象内部值的改变，但 Vue 提供的 watch 默认不可以\",\"使用 watch 时根据侦听数据的具体结构，决定是否采用深度侦听\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>深度侦听</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h3>a的值是:{{ numbers.a }}</h3> <button @click=\\\"numbers.a++\\\">点我让a+1</button> <h3>b的值是:{{ numbers.b }}</h3> <button @click=\\\"numbers.b++\\\">点我让b+1</button> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { numbers: { a: 1, b: 1, }, }, watch: { // 监视多级结构中某个属性的变化 /*'numbers.a': { handler() { console.log('a被改变了') }, },*/ //监视多级结构中所有属性的变化 numbers: { deep: true, handler() { console.log('numbers改变了') }, }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-计算属性与侦听属性03.gif\"]},{\"header\":\"侦听属性简写\",\"slug\":\"侦听属性简写\",\"contents\":[\"如果侦听属性除了 handler 没有其他配置项的话，可以进行简写\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>侦听属性简写</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h3>今天天气很{{ info }}</h3> <button @click=\\\"changeWeather\\\">切换天气</button> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { isHot: true }, computed: { info() { return this.isHot ? '炎热' : '凉爽' }, }, methods: { changeWeather() { this.isHot = !this.isHot }, }, watch: { // 正常写法 // isHot: { // // immediate:true, //初始化时让handler调用一下 // // deep:true, //深度监视 // handler(newValue, oldValue) { // console.log('isHot被修改了', newValue, oldValue) // } // }, //简写 isHot(newValue, oldValue) { console.log('isHot被修改了', newValue, oldValue, this) }, }, }) //正常写法 // vm.$watch('isHot', { // immediate: true, //初始化时让handler调用一下 // deep: true,//深度监视 // handler(newValue, oldValue) { // console.log('isHot被修改了', newValue, oldValue) // } // })l //简写 // vm.$watch('isHot', (newValue, oldValue) => { // console.log('isHot被修改了', newValue, oldValue, this) // }) </script> </body> </html> \"]},{\"header\":\"计算属性 VS 侦听属性\",\"slug\":\"计算属性-vs-侦听属性\",\"contents\":[\"computed 和 watch 之间的区别：\",\"computed 能完成的功能，watch 都可以完成\",\"watch 能完成的功能，computed 不一定能完成，例如 watch 可以进行异步操作\",\"两个重要的小原则：\",\"所有被 Vue 管理的函数，最好写成普通函数，这样 this 的指向才是 vm 或组件实例对象\",\"所有不被 Vue 所管理的函数（定时器的回调函数、Ajax 的回调函数、Promise 的回调函数等），最好写成箭头函数，这样 this 的指向才是 vm 或组件实例对象\",\"上面的姓名案例：\",\"使用计算属性：\",\"new Vue({ el:'#root', data:{ firstName:'张', lastName:'三' }, computed:{ fullName(){ return this.firstName + '-' + this.lastName } } }) \",\"使用监听属性：\",\"new Vue({ el:'#root', data:{ firstName:'张', lastName:'三', fullName:'张-三' }, watch:{ firstName(val){ setTimeout(()=>{ this.fullName = val + '-' + this.lastName },1000); }, lastName(val){ this.fullName = this.firstName + '-' + val } } }) \"]}]},\"/frontend/vuenotes/07-Vue%E6%A0%B8%E5%BF%83-%E7%BB%91%E5%AE%9A%E6%A0%B7%E5%BC%8F.html\":{\"title\":\"Vue核心-绑定样式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/07-Vue核心-绑定样式\"]},{\"header\":\"绑定 class 样式\",\"slug\":\"绑定-class-样式\",\"contents\":[\":class=\\\"xxx\\\" //xxx 可以是字符串、数组、对象 \"]},{\"header\":\"字符串写法\",\"slug\":\"字符串写法\",\"contents\":[\"字符串写法适用于：类名不确定，要动态获取\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>绑定class样式-字符串写法</title> <style> .basic { width: 400px; height: 100px; border: 1px solid black; } .happy { border: 4px solid red; background-color: rgba(255, 255, 0, 0.644); background: linear-gradient(30deg, yellow, pink, orange, yellow); } .sad { border: 4px dashed rgb(2, 197, 2); background-color: gray; } .normal { background-color: skyblue; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器 --> <div id=\\\"root\\\"> <!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 --> <div class=\\\"basic\\\" :class=\\\"mood\\\" @click=\\\"changeMood\\\">{{name}}</div> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', mood: 'normal', }, methods: { changeMood() { const arr = ['happy', 'sad', 'normal'] const index = Math.floor(Math.random() * 3) this.mood = arr[index] }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-绑定样式01.gif\"]},{\"header\":\"数组写法\",\"slug\":\"数组写法\",\"contents\":[\"数组写法适用于：要绑定多个样式，个数不确定，名字也不确定\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>绑定class样式-数组写法</title> <style> .basic { width: 400px; height: 100px; border: 1px solid black; } .zhf1 { background-color: yellowgreen; } .zhf2 { font-size: 30px; text-shadow: 2px 2px 10px red; } .zhf3 { border-radius: 20px; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器--> <div id=\\\"root\\\"> <!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 --> <div class=\\\"basic\\\" :class=\\\"classArr\\\">{{name}}</div> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', classArr: ['zhf1', 'zhf2', 'zhf3'], }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-绑定样式02.png\"]},{\"header\":\"对象写法\",\"slug\":\"对象写法\",\"contents\":[\"对象写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>绑定class样式-对象写法</title> <style> .basic { width: 400px; height: 100px; border: 1px solid black; } .zhf1 { background-color: yellowgreen; } .zhf2 { font-size: 30px; text-shadow: 2px 2px 10px red; } .zhf3 { border-radius: 20px; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器--> <div id=\\\"root\\\"> <!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 --> <div class=\\\"basic\\\" :class=\\\"classObj\\\">{{name}}</div> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', classObj: { zhf1: true, zhf2: false, zhf3: true, }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-绑定样式03.png\"]},{\"header\":\"绑定 style 样式\",\"slug\":\"绑定-style-样式\",\"contents\":[\":style=\\\"xxx\\\" \",\"样式对象中的 key，必须是存在的 CSS 属性，如 fontSize、backgroundColor（小驼峰命名法）\"]},{\"header\":\"对象写法\",\"slug\":\"对象写法-1\",\"contents\":[\":style=\\\"对象\\\"\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>绑定style样式-对象写法</title> <style> .basic { width: 400px; height: 100px; border: 1px solid black; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器--> <div id=\\\"root\\\"> <!-- 绑定style样式--对象写法 --> <div class=\\\"basic\\\" :style=\\\"styleObj, styleObj2\\\">{{name}}</div> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', styleObj: { fontSize: '40px', color: 'red', }, styleObj2: { backgroundColor: 'orange', }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-绑定样式04.png\"]},{\"header\":\"数组写法\",\"slug\":\"数组写法-1\",\"contents\":[\":style=\\\"数组\\\"\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>绑定style样式-数组写法</title> <style> .basic { width: 400px; height: 100px; border: 1px solid black; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器--> <div id=\\\"root\\\"> <!-- 绑定style样式--数组写法 --> <div class=\\\"basic\\\" :style=\\\"styleArr\\\">{{name}}</div> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', styleArr: [ { fontSize: '40px', color: 'blue', }, { backgroundColor: 'gray', }, ], }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-绑定样式05.png\"]}]},\"/frontend/vuenotes/08-Vue%E6%A0%B8%E5%BF%83-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93.html\":{\"title\":\"Vue核心-条件渲染\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/08-Vue核心-条件渲染\"]},{\"header\":\"条件渲染\",\"slug\":\"条件渲染\",\"contents\":[\"v-if\",\"写法跟 if else 语法类似 \",\"v-if=\\\"表达式\\\"\",\"v-else-if=\\\"表达式\\\"\",\"v-else\",\"适用于：切换频率较低的场景，因为不展示的 DOM 元素直接被移除\",\"注意：v-if 可以和 v-else-ifv-else 一起使用，但要求结构不能被打断\",\"v-show\",\"写法：v-show=\\\"表达式\\\"\",\"适用于：切换频率较高的场景\",\"特点：不展示的 DOM 元素未被移除，仅仅是使用样式隐藏掉 display:none;\",\"备注：\",\"使用 v-if 的时，元素可能无法获取到，而使用 v-show 一定可以获取到\",\"template 标签不影响结构，页面 html 中不会有此标签，但只能配合 v-if，不能配合 v-show\",\"例：\",\"v-if\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>条件渲染v-if</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>当前的n值是：{{n}}</h2> <button @click=\\\"n++\\\">点我n+1</button> <!-- 使用v-if做条件渲染 --> <h2 v-if=\\\"false\\\">欢迎来到{{name}}</h2> <h2 v-if=\\\"1 === 1\\\">欢迎来到{{name}}</h2> <!-- v-else和v-else-if --> <div v-if=\\\"n === 1\\\">A</div> <div v-else-if=\\\"n === 2\\\">B</div> <div v-else-if=\\\"n === 3\\\">C</div> <div v-else>哈哈哈</div> <!-- v-if与template的配合使用 --> <template v-if=\\\"n === 1\\\"> <h3>你好</h3> <h3>QFNU</h3> <h3>曲阜</h3> </template> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'QFNU', n: 0, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-条件渲染01.gif\",\"v-show\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>条件渲染v-show</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>当前的n值是:{{ n }}</h2> <button @click=\\\"n++\\\">点我n+1</button> <!-- 使用v-show做条件渲染 --> <h2 v-show=\\\"false\\\">欢迎来到{{name}}</h2> <h2 v-show=\\\"n===1\\\">欢迎来到{{name}}</h2> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'QFNU', n: 0, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-条件渲染02.gif\"]}]},\"/frontend/vuenotes/09-Vue%E6%A0%B8%E5%BF%83-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%9B%91%E8%A7%86.html\":{\"title\":\"Vue核心-列表渲染与数据监视\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/09-Vue核心-列表渲染与数据监视\"]},{\"header\":\"列表渲染\",\"slug\":\"列表渲染\",\"contents\":[]},{\"header\":\"基本列表\",\"slug\":\"基本列表\",\"contents\":[\"v-for 指令\",\"用于展示列表数据\",\"语法：<li v-for=\\\"(item, index) of items\\\" :key=\\\"index\\\">，这里 key 可以是 index，更好的是遍历对象的唯一标识，这里的 of 也可以用 in\",\"可遍历：数组、对象、字符串（用的少）、指定次数（用的少）\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>基本列表</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <!-- 遍历数组 --> <h3>人员列表（遍历数组）</h3> <ul> <li v-for=\\\"(p,index) of persons\\\" :key=\\\"index\\\">{{p.name}}-{{p.age}}</li> </ul> <!-- 遍历对象 --> <h3>汽车信息（遍历对象）</h3> <ul> <li v-for=\\\"(value,k) of car\\\" :key=\\\"k\\\">{{k}}-{{value}}</li> </ul> <!-- 遍历字符串 --> <h3>演示遍历字符串（用得少）</h3> <ul> <li v-for=\\\"(char,index) of str\\\" :key=\\\"index\\\">{{char}}-{{index}}</li> </ul> <!-- 遍历指定次数 --> <h3>演示遍历指定次数（用得少）</h3> <ul> <li v-for=\\\"(number,index) of 5\\\" :key=\\\"index\\\"> {{ index }}-{{ number }} </li> </ul> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { persons: [ { id: '001', name: '张三', age: 18 }, { id: '002', name: '李四', age: 19 }, { id: '003', name: '王五', age: 20 }, ], car: { name: '奥迪', price: '70万', color: '黑色', }, str: 'hello', }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视01.png\"]},{\"header\":\"key 的作用与原理\",\"slug\":\"key-的作用与原理\",\"contents\":[\"原理：\",\"Vue核心-列表渲染与数据监视02.jpg\",\"Vue核心-列表渲染与数据监视03.jpg\",\"面试题：react、vue 中的 key 有什么作用？（key 的内部原理）\",\"虚拟 DOM 中 key 的作用：key 是虚拟 DOM 中对象的标识，当数据发生变化时，Vue 会根据新数据生成新的虚拟 DOM，随后 Vue 进行新虚拟 DOM 与旧虚拟 DOM 的差异比较，比较规则如下： \",\"旧虚拟 DOM 中找到了与新虚拟 DOM 相同的 key \",\"若虚拟 DOM 中内容没变, 直接使用之前的真实 DOM\",\"若虚拟 DOM 中内容变了, 则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM\",\"旧虚拟 DOM 中未找到与新虚拟 DOM 相同的 key \",\"创建新的真实 DOM，随后渲染到到页面\",\"用 index 作为 key 可能会引发的问题 \",\"若对数据进行逆序添加、逆序删除等破坏顺序操作，会产生没有必要的真实 DOM 更新 ==> 界面效果没问题，但效率低\",\"若结构中还包含输入类的 DOM：会产生错误 DOM 更新 ==> 界面有问题\",\"开发中如何选择 key？ \",\"最好使用每条数据的唯一标识作为 key，比如 id、手机号、身份证号、学号等唯一值\",\"如果不存在对数据的逆序添加、逆序删除等破坏顺序的操作，仅用于渲染列表，使用 index 作为 key 是没有问题的\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>key的原理</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>人员列表（遍历数组）</h2> <button @click.once=\\\"add\\\">添加一个老刘</button> <ul> <li v-for=\\\"(p,index) of persons\\\" :key=\\\"index\\\"> {{p.name}}-{{p.age}} <input type=\\\"text\\\" /> </li> </ul> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false new Vue({ el: '#root', data: { persons: [ { id: '001', name: '张三', age: 18 }, { id: '002', name: '李四', age: 19 }, { id: '003', name: '王五', age: 20 }, ], }, methods: { add() { const p = { id: '004', name: '老刘', age: 40 } this.persons.unshift(p) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视04.gif\"]},{\"header\":\"列表过滤\",\"slug\":\"列表过滤\",\"contents\":[\"可以使用 watch 也可以使用计算属性，使用计算属性更加简单方便一点\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>列表过滤</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>人员列表</h2> <input type=\\\"text\\\" placeholder=\\\"请输入名字\\\" v-model=\\\"keyWord\\\" /> <ul> <li v-for=\\\"(p,index) of filPersons\\\" :key=\\\"p.id\\\"> {{p.name}}-{{p.age}}-{{p.sex}} </li> </ul> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { keyWord: '', persons: [ { id: '001', name: '马冬梅', age: 19, sex: '女' }, { id: '002', name: '周冬雨', age: 20, sex: '女' }, { id: '003', name: '周杰伦', age: 21, sex: '男' }, { id: '004', name: '温兆伦', age: 22, sex: '男' }, ], //用watch实现 //filPersons: [], }, //用watch实现 /*watch: { keyWord: { immediate: true, handler(val) { this.filPersons = this.persons.filter((p) => { return p.name.indexOf(val) !== -1 }) }, }, },*/ //用computed实现 computed: { filPersons() { return this.persons.filter((p) => { return p.name.indexOf(this.keyWord) !== -1 }) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视05.gif\"]},{\"header\":\"列表排序\",\"slug\":\"列表排序\",\"contents\":[\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>列表排序</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>人员列表</h2> <input type=\\\"text\\\" placeholder=\\\"请输入名字\\\" v-model=\\\"keyWord\\\" /> <button @click=\\\"sortType = 2\\\">年龄升序</button> <button @click=\\\"sortType = 1\\\">年龄降序</button> <button @click=\\\"sortType = 0\\\">原顺序</button> <ul> <li v-for=\\\"(p,index) of filPersons\\\" :key=\\\"p.id\\\"> {{p.name}}-{{p.age}}-{{p.sex}} </li> </ul> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { keyWord: '', sortType: 0, //0原顺序，1降序，2升序 persons: [ { id: '001', name: '马冬梅', age: 30, sex: '女' }, { id: '002', name: '周冬雨', age: 31, sex: '女' }, { id: '003', name: '周杰伦', age: 18, sex: '男' }, { id: '004', name: '温兆伦', age: 19, sex: '男' }, ], }, computed: { filPersons() { const arr = this.persons.filter((p) => { return p.name.indexOf(this.keyWord) !== -1 }) //判断是否需要排序 if (this.sortType) { arr.sort((p1, p2) => { return this.sortType === 1 ? p2.age - p1.age : p1.age - p2.age }) } return arr }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视06.gif\"]},{\"header\":\"Vue 数据监视\",\"slug\":\"vue-数据监视\",\"contents\":[\"更新时的一个问题：this.persons[0] = {id:'001',name:'马老师',age:50,sex:'男'} 更改 data 数据，Vue 不监听，模板不改变\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>更新时的一个问题</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>人员列表</h2> <button @click=\\\"updateMei\\\">更新马冬梅的信息</button> <ul> <li v-for=\\\"(p,index) of persons\\\" :key=\\\"p.id\\\"> {{p.name}}-{{p.age}}-{{p.sex}} </li> </ul> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { persons: [ { id: '001', name: '马冬梅', age: 30, sex: '女' }, { id: '002', name: '周冬雨', age: 31, sex: '女' }, { id: '003', name: '周杰伦', age: 18, sex: '男' }, { id: '004', name: '温兆伦', age: 19, sex: '男' }, ], }, methods: { updateMei() { // this.persons[0].name = '马老师' //奏效 // this.persons[0].age = 50 //奏效 // this.persons[0].sex = '男' //奏效 // this.persons[0] = {id:'001',name:'马老师',age:50,sex:'男'} //不奏效 this.persons.splice(0, 1, { id: '001', name: '马老师', age: 50, sex: '男', }) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视07.gif\",\"我们先来研究一下 Vue 是如何监测对象里面属性的改变的\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Vue监测数据改变的原理-对象</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器 --> <div id=\\\"root\\\"> <h2>学校名称：{{name }}</h2> <h2>学校地址：{{address}}</h2> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: '曲阜师范大学', address: '曲阜', }, }) </script> </body> </html> \",\"我们打开控制台，由于数据代理，data 中的数据最终会出现在 vm 身上\",\"Vue核心-列表渲染与数据监视08.png\",\"我们复习一下数据代理：\",\"Vue核心-MVVM模型与数据代理06.png\",\"Vue 将 data 中的数据拷贝了一份到 _data 属性中，其实在这一步之前还有一步，那就是对 data 中的数据进行加工\",\"若没有加工的过程，那么 _data 和 data 中的内容应该就是一模一样的, 而 _data 中内容如下图：\",\"Vue核心-列表渲染与数据监视09.png\",\"所谓加工简单来说就是把 data 中的每一组 key-value 都生成一个 getter 和 setter，那么为什么要加工 data 呢，因为这样可以做响应式：例如当我们修改了 data 中的 name 属性，name 的 setter 就会被调用，在 setter 中调用了一个方法，会重新解析模板，生成新的虚拟 DOM，然后 diff 算法对比，然后更新页面，从而实现对数据的监视\",\"我们来模拟一个数据监视（Vue 中实现的更加完善）\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>模拟数据监视</title> </head> <body> <script> let data = { name: '曲阜师范大学', address: '曲阜', } //创建一个监视的实例对象，用于监视data中属性的变化 const obs = new Observer(data) console.log(obs) // 准备一个vm实例对象 let vm = {} vm._data = data = obs function Observer(obj) { // 汇总对象中所有的属性形成一个数组 const keys = Object.keys(obj) console.log(keys) // 遍历 keys.forEach((k) => { Object.defineProperty(this, k, { get() { return obj[k] }, set(val) { console.log( `${k}被改了，我要去解析模板，生成虚拟DOM.....我要开始忙了` ) obj[k] = val }, }) }) } </script> </body> </html> \",\"Observer 构造函数会将 data 中的每个属性都添加到 Observer 实例对象中（通过 defineProperty()），并生成相应的 getter 和 setter，实现对 data 中属性的代理（data 是创建实例时传入的参数）\",\"效果：\",\"Vue核心-列表渲染与数据监视10.png\",\"存在两个问题：\",\"在 Vue 中还对 _data（data） 中的属性进行了代理，可以直接通过 vm.xxx 操作数据，而这里需要通过 vm._data.xxx 来操作数据\",\"只能监测一层数据，如果 data 中有对象，对象中还有属性，就监测不到\",\"下面我们认识一个 API：Vue.set()\",\"首先我们应该知道：读取一个对象中不存在的属性，是 undefined，不报错，如果一个属性值是 undefined，Vue 不会把他展示到页面上\",\"假设需要给某个对象添加一个新的属性（该属性一开始没有定下来，没有在源代码中写，后来随着用户的交互发现需要添加这么一个性别属性），如果直接在 vm._data.某对象 或者 vm 中添加该属性，是做不到响应式的，没有 getter 和 setter 方法，而通过 Vue.set() 或者 vm.$set() 方法，可以做到“后添加的数据也可以实现响应式“\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Vue.set的使用</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器 --> <div id=\\\"root\\\"> <h2>学校名称：{{name}}</h2> <h2>学校地址：{{address}}</h2> <hr /> <h1>学生信息</h1> <button @click=\\\"addSex\\\">添加一个性别，默认值男</button> <h2>学生姓名：{{student.name}}</h2> <h2 v-if=\\\"student.sex\\\">学生性别：{{student.sex}}</h2> <h2>学生年龄：真实{{student.age.rAge}}，对外{{student.age.sAge}}</h2> <h2>朋友们</h2> <ul> <li v-for=\\\"(f,index) in student.friends\\\" :key=\\\"index\\\"> {{f.name}}--{{f.age}} </li> </ul> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: '曲阜师范大学', address: '曲阜', student: { name: 'tom', age: { rAge: 21, sAge: 18, }, friends: [ { name: 'jerry', age: 23 }, { name: 'tony', age: 24 }, ], }, }, methods: { addSex() { //Vue.set(this.student, 'sex', '男') this.$set(this.student, 'sex', '男') }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视11.gif\",\"接下来我们研究一下 Vue 是如何监测数组里面属性的改变的\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Vue监测数据改变的原理-数组</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>学校名称：{{name}}</h2> <h2>学校地址：{{address}}</h2> <hr /> <h1>学生信息</h1> <button @click=\\\"addSex\\\">添加一个性别，默认值男</button> <h2>学生姓名：{{student.name}}</h2> <h2 v-if=\\\"student.sex\\\">学生性别：{{student.sex}}</h2> <h2>学生年龄：真实{{student.age.rAge}}，对外{{student.age.sAge}}</h2> <h2>朋友们</h2> <ul> <li v-for=\\\"(f,index) in student.friends\\\" :key=\\\"index\\\"> {{f.name}}--{{f.age}} </li> </ul> <h2>爱好</h2> <ul> <li v-for=\\\"(h,index) in student.hobby\\\" :key=\\\"index\\\">{{h}}</li> </ul> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: '曲阜师范大学', address: '曲阜', student: { name: 'tom', age: { rAge: 21, sAge: 18, }, hobby: ['唱', '跳', 'rap'], friends: [ { name: 'jerry', age: 23 }, { name: 'tony', age: 24 }, ], }, }, methods: { addSex() { //Vue.set(this.student, 'sex', '男') this.$set(this.student, 'sex', '男') }, }, }) </script> </body> </html> \",\"我们在控制台中会发现：\",\"Vue 核心-列表渲染与数据监视12.png\",\"数组中的数据并没有 getter 和 setter 方法，这也就解释了上面的更新数组的问题\",\"总结\",\"vue 会监视 data 中所有层次的数据\",\"如何监测对象中的数据？通过 setter 实现监视，且要在 new Vue() 时就传入要监测的数据 \",\"对象创建后追加的属性，Vue 默认不做响应式处理\",\"如需给后添加的属性做响应式，请使用如下 API Vue.set(target,propertyName/index,value) 或 vm.$set(target,propertyName/index,value)\",\"如何监测数组中的数据？ 通过包裹数组更新元素的方法实现，本质就是做了两件事 \",\"调用原生对应的方法对数组进行更新\",\"重新解析模板，进而更新页面\",\"在 Vue 修改数组中的某个元素一定要用如下方法 \",\"push() 、pop() 、unshift()、shift()、splice()、sort()、reverse() ，这几个方法被 Vue 重写了\",\"Vue.set() 或 vm.$set()，特别注意：Vue.set() 和 vm.$set() 不能给 vm 或 vm 的根数据对象（data 等）添加属性\",\"综合案例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>总结数据监视</title> <style> button { margin-top: 10px; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h1>学生信息</h1> <button @click=\\\"student.age++\\\">年龄+1岁</button> <br /> <button @click=\\\"addSex\\\">添加性别属性，默认值：男</button> <br /> <button @click=\\\"student.sex = '未知' \\\">修改性别</button> <br /> <button @click=\\\"addFriend\\\">在列表首位添加一个朋友</button> <br /> <button @click=\\\"updateFirstFriendName\\\"> 修改第一个朋友的名字为：张三 </button> <br /> <button @click=\\\"addHobby\\\">添加一个爱好</button> <br /> <button @click=\\\"updateHobby\\\">修改第一个爱好为：开车</button> <br /> <button @click=\\\"removeSmoke\\\">过滤掉爱好中的rap</button> <br /> <h3>姓名：{{ student.name }}</h3> <h3>年龄：{{ student.age }}</h3> <h3 v-if=\\\"student.sex\\\">性别：{{student.sex}}</h3> <h3>爱好：</h3> <ul> <li v-for=\\\"(h,index) in student.hobby\\\" :key=\\\"index\\\">{{ h }}</li> </ul> <h3>朋友们：</h3> <ul> <li v-for=\\\"(f,index) in student.friends\\\" :key=\\\"index\\\"> {{ f.name }}--{{ f.age }} </li> </ul> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { student: { name: 'tom', age: 18, hobby: ['唱', '跳', 'rap'], friends: [ { name: 'jerry', age: 35 }, { name: 'tony', age: 36 }, ], }, }, methods: { addSex() { // Vue.set(this.student,'sex','男') this.$set(this.student, 'sex', '男') }, addFriend() { this.student.friends.unshift({ name: 'jack', age: 70 }) }, updateFirstFriendName() { this.student.friends[0].name = '张三' }, addHobby() { this.student.hobby.push('学习') }, updateHobby() { // this.student.hobby.splice(0,1,'开车') // Vue.set(this.student.hobby,0,'开车') this.$set(this.student.hobby, 0, '开车') }, removeSmoke() { this.student.hobby = this.student.hobby.filter((h) => { return h !== 'rap' }) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue 核心-列表渲染与数据监视13.gif\"]}]},\"/frontend/vuenotes/10-Vue%E6%A0%B8%E5%BF%83-%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE.html\":{\"title\":\"Vue核心-收集表单数据\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/10-Vue核心-收集表单数据\"]},{\"header\":\"收集表单数据\",\"slug\":\"收集表单数据\",\"contents\":[\"收集表单数据\",\"若 <input type=\\\"text\\\"/>，则 v-model 收集的是 value 值，用户输入的内容就是 value 值\",\"若 <input type=\\\"radio\\\"/>，则 v-model 收集的是 value 值，且要给标签配置 value 属性\",\"若 <input type=\\\"checkbox\\\"/>\",\"没有配置 value 属性，那么收集的是 checked 属性（勾选 or 未勾选，是布尔值）\",\"配置了 value 属性 \",\"v-model 的初始值是非数组，那么收集的就是 checked（勾选 or 未勾选，是布尔值）\",\"v-model 的初始值是数组，那么收集的就是 value 组成的数组\",\"v-model 的三个修饰符：\",\"lazy 失去焦点后再收集数据\",\"number 输入字符串转为有效的数字\",\"trim 输入首尾空格过滤\",\"form 表单中 @submit.prevent 作用方法\",\"<form @submit.prevent=\\\"Demo\\\"></form> \",\"submit：表示通常与 form 联合使用，在表单中有提交或按钮，立马触发后面紧跟的方法\",\".prevent：表示阻止默认事件的修饰符，提交以后不会刷新页面。阻止默认事件就是指有些标签本身会存在事件，如 a 标签的跳转，form 表单中的 submit 按钮的提交事件等，某些时候想执行自己设置的事件，这个时候就需要阻止标签的默认事件的执行。在 Vue 中，只需要使用 .prevent 修饰符就可以\",\"注：.prevent 不一定非要跟 submit 绑定在一起\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>收集表单数据</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <form @submit.prevent=\\\"test\\\"> 账号：<input type=\\\"text\\\" v-model.trim=\\\"userInfo.account\\\" /><br /> 密码：<input type=\\\"password\\\" v-model=\\\"userInfo.passWord\\\" /><br /> 年龄：<input type=\\\"number\\\" v-model.number=\\\"userInfo.age\\\" /><br /> 性别：<br /> 男<input type=\\\"radio\\\" v-model=\\\"userInfo.sex\\\" value=\\\"male\\\" /> 女<input type=\\\"radio\\\" v-model=\\\"userInfo.sex\\\" value=\\\"female\\\" /><br /> 爱好：<br /> 学习<input type=\\\"checkbox\\\" v-model=\\\"userInfo.hobby\\\" value=\\\"study\\\" /> 打游戏<input type=\\\"checkbox\\\" v-model=\\\"userInfo.hobby\\\" value=\\\"game\\\" /> 吃饭<input type=\\\"checkbox\\\" v-model=\\\"userInfo.hobby\\\" value=\\\"eat\\\" /> <br /> 所属校区: <br /> <select v-model=\\\"userInfo.area\\\"> <option value=\\\"\\\">请选择校区</option> <option value=\\\"QuFuL\\\">曲阜老校区</option> <option value=\\\"QuFuX\\\">曲阜新校区</option> <option value=\\\"RiZhao\\\">日照校区</option> </select> <br /> 其他信息：<br /> <textarea v-model.lazy=\\\"userInfo.other\\\"></textarea> <br /> <input type=\\\"checkbox\\\" v-model=\\\"userInfo.agree\\\" />阅读并接受 <a href=\\\"https://www.qfnu.edu.cn\\\">《用户协议》</a> <br /> <button>提交</button> </form> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { userInfo: { account: '', passWord: '', age: 18, sex: 'female', hobby: [], area: '', other: '', agree: '', }, }, methods: { test() { console.log(JSON.stringify(this.userInfo)) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-收集表单数据01.png\"]}]},\"/frontend/vuenotes/11-Vue%E6%A0%B8%E5%BF%83-%E8%BF%87%E6%BB%A4%E5%99%A8.html\":{\"title\":\"Vue核心-过滤器\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/11-Vue核心-过滤器\"]},{\"header\":\"过滤器 (Vue 3 已经移除)\",\"slug\":\"过滤器-vue-3-已经移除\",\"contents\":[\"定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）\",\"注册过滤器：Vue.filter(name, callback) 全局过滤器new Vue {filters: {}} 局部过滤器\",\"使用过滤器：{{ xxx | 过滤器名}} 或 v-bind:属性 = \\\"xxx | 过滤器名\\\"\",\"备注：\",\"过滤器可以接收额外参数，多个过滤器也可以串联\",\"并没有改变原本的数据，而是产生新的对应的数据\",\"处理时间的库：moment 体积较大，dayjs 轻量级\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>过滤器</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> <!-- //引入dayjs库 --> <script src=\\\"https://cdn.bootcdn.net/ajax/libs/dayjs/1.11.7/dayjs.min.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>时间</h2> <h3>当前时间戳：{{time}}</h3> <h3>转换后的时间：{{time|timeFilter()}}</h3> <h3>转换后的时间：{{time|timeFilter('YYYY-MM-DD HH:mm:ss')}}</h3> <h3>截取年月日：{{time|timeFilter() | mySlice}}</h3> </div> <script> Vue.config.productionTip = false //全局过滤器 Vue.filter('mySlice', function (value) { return value.slice(0, 11) }) new Vue({ el: '#root', data: { time: 1683621034195, }, //局部过滤器 filters: { timeFilter(value, str = 'YYYY年MM月DD日HH:mm:ss') { return dayjs(value).format(str) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-过滤器01.png\"]}]},\"/frontend/vuenotes/12-Vue%E6%A0%B8%E5%BF%83-%E5%86%85%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4.html\":{\"title\":\"Vue核心-内置指令与自定义指令\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/12-Vue核心-内置指令与自定义指令\"]},{\"header\":\"内置指令\",\"slug\":\"内置指令\",\"contents\":[\"常用的内置指令： v-bind 单向绑定解析表达式，可简写为 :v-model 双向数据绑定v-for 遍历数组 / 对象 / 字符串v-on 绑定事件监听，可简写为 @v-show 条件渲染 (动态控制节点是否展示)v-if 条件渲染（动态控制节点是否存在）v-else-if 条件渲染（动态控制节点是否存在）v-else 条件渲染（动态控制节点是否存在）\"]},{\"header\":\"v-text 指令\",\"slug\":\"v-text-指令\",\"contents\":[\"v-text 指令\",\"作用：向其所在的节点中渲染文本内容\",\"与插值语法的区别：v-text 会替换掉节点中的内容，{{xxx}} 则不会，更灵活\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>v-text指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <div>你好，{{name}}</div> <div v-text=\\\"name\\\"></div> <div v-text=\\\"str\\\"></div> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { name: 'zhf', str: '<h3>你好呀！</h3>', }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-内置指令与自定义指令01.png\"]},{\"header\":\"v-html 指令\",\"slug\":\"v-html-指令\",\"contents\":[\"作用：向指定节点中渲染包含 html 结构的内容\",\"与插值语法的区别：\",\"v-html 会替换掉节点中所有的内容，{{xxx}} 则不会\",\"v-html 可以识别 html 结构\",\"严重注意 v-html 有安全性问题！！！\",\"在网站上动态渲染任意 html 是非常危险的，容易导致 XSS 攻击\",\"一定要在可信的内容上使用 v-html，永远不要用在用户提交的内容上！！！\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>v-html指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <div>你好，{{name}}</div> <div v-html=\\\"str1\\\"></div> <div v-html=\\\"str2\\\"></div> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { name: 'zhf', str1: '<h3>你好呀！</h3>', str2: '<a href=javascript:location.href=\\\"http://www.baidu.com?\\\"+document.cookie>兄弟我找到你想要的资源了，快来！</a>', }, }) </script> </body> </html> \",\"我们在 cookie 中存放如下数据\",\"Vue核心-内置指令与自定义指令02.png\",\"点击案例中的链接就可以获取\",\"效果：\",\"Vue核心-内置指令与自定义指令03.gif\"]},{\"header\":\"v-cloak 指令\",\"slug\":\"v-cloak-指令\",\"contents\":[\"v-cloak 指令（没有值）\",\"本质是一个特殊属性，Vue 实例创建完毕并接管容器后，会删掉 v-cloak 属性\",\"使用 CSS 配合 v-cloak 可以解决网速慢时页面展示出 {{xxx}} 的问题\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>v-cloak指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> <style> [v-cloak] { display: none; } </style> </head> <body> <div id=\\\"root\\\"> <!-- 如果网速慢则一开始不显示 --> <h2 v-cloak>{{name}}</h2> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { name: 'zhf', }, }) </script> </body> </html> \"]},{\"header\":\"v-once 指令\",\"slug\":\"v-once-指令\",\"contents\":[\"v-once 所在节点在初次动态渲染后，就视为静态内容了\",\"以后数据的改变不会引起 v-once 所在结构的更新，可以用于优化性能\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>v-once指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2 v-once>初始化的n值是：{{n}}</h2> <h2>当前的n值是：{{n}}</h2> <button @click=\\\"n++\\\">点我n+1</button> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { n: 1, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-内置指令与自定义指令04.gif\"]},{\"header\":\"v-pre 指令\",\"slug\":\"v-pre-指令\",\"contents\":[\"跳过 v-pre 所在节点的编译过程\",\"可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>v-pre指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2 v-pre>Vue其实很简单</h2> <h2>当前的n值是:{{n}}</h2> <button @click=\\\"n++\\\">点我n+1</button> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { n: 1, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-内置指令与自定义指令05.gif\"]},{\"header\":\"自定义指令\",\"slug\":\"自定义指令\",\"contents\":[\"directives\"]},{\"header\":\"定义语法\",\"slug\":\"定义语法\",\"contents\":[]},{\"header\":\"局部指令\",\"slug\":\"局部指令\",\"contents\":[\"new Vue({ directives:{ 指令名:配置对象 } }) \",\"或\",\"new Vue({ directives:{ 指令名:回调函数 } }) \",\"例：\",\"directives : { 'my-directive' : { bind (el, binding) { el.innerHTML = binding.value.toupperCase() } } } \"]},{\"header\":\"全局指令\",\"slug\":\"全局指令\",\"contents\":[\"Vue.directive(指令名, 配置对象) \",\"或\",\"Vue.directive(指令名, 回调函数) \",\"例：\",\"Vue.directive('my-directive', function(el, binding){ el.innerHTML = binding.value.toupperCase() }) \"]},{\"header\":\"配置对象中常用的3个回调函数\",\"slug\":\"配置对象中常用的3个回调函数\",\"contents\":[\"bind (element, binding) 指令与元素成功绑定时调用\",\"inserted (element, binding) 指令所在元素被插入页面时调用\",\"update(element, binding) 指令所在模板结构被重新解析时调用\",\"element 就是 DOM 元素，binding 就是要绑定的对象，它包含以下属性：name 、value、oldValue、expression、arg、modifiers\",\"例：\",\"Vue.directive('fbind', { // 指令与元素成功绑定时（一上来） bind(element, binding) { // element就是DOM元素，binding就是要绑定的 element.value = binding.value }, // 指令所在元素被插入页面时 inserted(element, binding) { element.focus() }, // 指令所在的模板被重新解析时 update(element, binding) { element.value = binding.value } }) \"]},{\"header\":\"注意\",\"slug\":\"注意\",\"contents\":[\"指令定义时不加 v-，但使用时要加 v-\",\"指令名如果是多个单词，要使用 kebab-case 命名方式，不要用 camelCase 命名\"]},{\"header\":\"使用指令\",\"slug\":\"使用指令\",\"contents\":[\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>自定义指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>当前n值是：<span v-text=\\\"n\\\"></span></h2> <h2>放大10倍后的n值是：<span v-big=\\\"n\\\"></span></h2> <button @click=\\\"n++\\\">点我n+1</button> <hr /> <input type=\\\"text\\\" v-fbind:value=\\\"n\\\" /> </div> <script> Vue.config.productionTip = false //定义全局指令 /*Vue.directive('fbind', { //指令与元素成功绑定时（一上来） bind(element, binding) { element.value = binding.value }, //指令所在元素被插入页面时 inserted(element, binding) { element.focus() }, //指令所在的模板被重新解析时 update(element, binding) { element.value = binding.value }, })*/ new Vue({ el: '#root', data: { n: 1, }, directives: { //big函数何时会被调用？ //1.指令与元素成功绑定时（一上来） //2.指令所在的模板被重新解析时 big(element, binding) { //console.log('big', this) //注意此处的this是window element.innerText = binding.value * 10 }, fbind: { //指令与元素成功绑定时（一上来） bind(element, binding) { element.value = binding.value }, //指令所在元素被插入页面时 inserted(element, binding) { element.focus() }, //指令所在的模板被重新解析时 update(element, binding) { element.value = binding.value }, }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-内置指令与自定义指令06.gif\"]}]},\"/frontend/vuenotes/\":{\"title\":\"Vue\",\"contents\":[]}}}");self.onmessage=({data:o})=>{self.postMessage($(o.query,m[o.routeLocale]))};
//# sourceMappingURL=original.js.map
