const g=(o,a)=>{const i=o.toLowerCase(),e=a.toLowerCase(),s=[];let n=0,l=0;const c=(t,p=!1)=>{let r="";l===0?r=t.length>20?`… ${t.slice(-20)}`:t:p?r=t.length+l>100?`${t.slice(0,100-l)}… `:t:r=t.length>20?`${t.slice(0,20)} … ${t.slice(-20)}`:t,r&&s.push(r),l+=r.length,p||(s.push(["strong",a]),l+=a.length,l>=100&&s.push(" …"))};let h=i.indexOf(e,n);if(h===-1)return null;for(;h>=0;){const t=h+e.length;if(c(o.slice(n,h)),n=t,l>100)break;h=i.indexOf(e,n)}return l<100&&c(o.slice(n),!0),s},d=Object.entries,y=Object.keys,f=o=>o.reduce((a,{type:i})=>a+(i==="title"?50:i==="heading"?20:i==="custom"?10:1),0),$=(o,a)=>{var i;const e={};for(const[s,n]of d(a)){const l=((i=a[s.replace(/\/[^\\]*$/,"")])==null?void 0:i.title)||"",c=`${l?`${l} > `:""}${n.title}`,h=g(n.title,o);h&&(e[c]=[...e[c]||[],{type:"title",path:s,display:h}]),n.customFields&&d(n.customFields).forEach(([t,p])=>{p.forEach(r=>{const u=g(r,o);u&&(e[c]=[...e[c]||[],{type:"custom",path:s,index:t,display:u}])})});for(const t of n.contents){const p=g(t.header,o);p&&(e[c]=[...e[c]||[],{type:"heading",path:s+(t.slug?`#${t.slug}`:""),display:p}]);for(const r of t.contents){const u=g(r,o);u&&(e[c]=[...e[c]||[],{type:"content",header:t.header,path:s+(t.slug?`#${t.slug}`:""),display:u}])}}}return y(e).sort((s,n)=>f(e[s])-f(e[n])).map(s=>({title:s,contents:e[s]}))},m=JSON.parse("{\"/\":{\"/computer-network/\":{\"title\":\"计算机网络\",\"contents\":[]},\"/computer-usage-skills/\":{\"title\":\"电脑使用技巧\",\"contents\":[]},\"/data-structures-and-algorithms/\":{\"title\":\"数据结构与算法\",\"contents\":[]},\"/front-end/\":{\"title\":\"前端\",\"contents\":[]},\"/software-tool/\":{\"title\":\"软件工具\",\"contents\":[]},\"/computer-network/xiaolin-coding-network/01-%E5%B0%8F%E6%9E%97coding%E8%AE%A1%E7%BD%91-%E5%9F%BA%E7%A1%80%E7%AF%87.html\":{\"title\":\"小林coding计网-基础篇\",\"contents\":[{\"header\":\"1. TCP/IP网络模型\",\"slug\":\"_1-tcp-ip网络模型\",\"contents\":[\"以下并非严格意义的TCP/IP模型，网络接口被分成两层：\",\"层级\",\"功能\",\"主要协议\",\"应用层\",\"专注于为用户提供应用功能，不关心数据如何传输（在用户态工作，往下是内核态）\",\"HTTP、FTP、 DNS、(SMTP -> IMAP)、Telnet、SSH、NFS、DHCP\",\"传输层\",\"负责向两台终端设备进程之间的通信提供通用的数据传输服务\",\"TCP、UDP\",\"网络层\",\"实际的传输功能，为分组交换网上的不同主机提供通信服务；选择合适的路由\",\"IP、ICMP、IGMP、NAT（路由的网络地址转换协议）\",\"数据链路层（网络接口）\",\"数据链路层的作用是将网络层交下来的 IP 数据报封装成帧，在两个相邻节点间的链路上传送帧\",\"ARP、RARP\",\"物理层（网络接口）\",\"实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异\",\"应用层协议：\",\"基于TCP的应用层协议\",\"基于UDP的应用层协议\",\"HTTP、FTP、SMTP、TELNET、SSH\",\"DNS、SFTP（简单）、SNMP（简单）\",\"为什么要分层？\",\"各层之间相互独立\",\"提高整体灵活性\",\"大问题化小\",\"传输单位：网络接口层–>帧（frame），IP 层–>包（packet），TCP 层–>段（segment），HTTP–>报文（message）。但这些没有本质区别，可以统称为数据包\",\"小林coding计网-基础篇01.png\"]},{\"header\":\"2. 键入网址到网页显示，期间发生了什么？\",\"slug\":\"_2-键入网址到网页显示-期间发生了什么\",\"contents\":[\"解析URL：首先浏览器要解析URL，URL包括协议 + web服务器 + 目录名和文件名，继而生成发送给web服务器的、对该资源的请求信息\",\"DNS解析：查询服务器域名对应的 IP 地址。DNS服务器保存了 Web 服务器域名与 IP 的对应关系。客户端发送DNS请求给本地DNS服务器，查询对应的IP地址后返回客户端。PS：需要查询时，浏览器、操作系统、hosts文件依次看有没有缓存，不一定每次都要解析IP\",\"TCP连接：HTTP报文是基于TCP传输的，涉及到三次握手。组装好TCP报文后交给网络层处理\",\"发送HTTP请求：\",\"加入IP头部，生成IP报文\",\"加入MAC头部（发送方MAC地址在网卡里，接收方的MAC地址靠ARP协议在以太网广播寻找，当然也是有缓存的）\",\"再经过网卡、交换机、路由器，抵达服务器\",\"服务器处理请求并返回HTTP报文：服务器依次检查MAC头部、IP头、TCP头检查序列号和端口号，HTTP进程收到后把这个网页封装在HTTP响应报文里并返回（相同步骤）\",\"浏览器解析渲染页面：浏览器是一个边解析边渲染的过程\",\"连接结束\"]}]},\"/computer-network/xiaolin-coding-network/02-%E5%B0%8F%E6%9E%97coding%E8%AE%A1%E7%BD%91-HTTP%E7%AF%87.html\":{\"title\":\"小林coding计网-HTTP篇\",\"contents\":[{\"header\":\"1. 常见面试题\",\"slug\":\"_1-常见面试题\",\"contents\":[]},{\"header\":\"1.1 HTTP是什么\",\"slug\":\"_1-1-http是什么\",\"contents\":[\"HTTP 是超文本传输协议\",\"HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」\"]},{\"header\":\"1.2 HTTP常见状态码\",\"slug\":\"_1-2-http常见状态码\",\"contents\":[\"1xx：提示信息，协议处理的一种中间状态，表示接收的请求正在处理\",\"2xx：成功，服务器正常收到客户端的请求，并处理完毕 \",\"200 OK 是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据\",\"204 No Content与 200 OK 基本相同，但响应头没有 body 数据\",\"206 Partial Content 应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分\",\"3xx：重定向，表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源 \",\"301 Moved Permanently永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问\",\"302 Found临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问\",\"301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL\",\"304 Not Modified不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制\",\"4xx：客户端错误，表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义 \",\"400 Bad Request表示客户端请求的报文有错误，但只是个笼统的错误\",\"403 Forbidden表示服务器禁止访问资源，并不是客户端的请求出错\",\"404 Not Found表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端\",\"5xx：服务器错误，表示客户端请求报文正确，但是服务器处理时内部发生了错误 \",\"500 Internal Server Error与 400 类似，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道\",\"501 Not Implemented表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思\",\"502 Bad Gateway通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误\",\"503 Service Unavailable表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思\"]},{\"header\":\"1.3 HTTP常见字段\",\"slug\":\"_1-3-http常见字段\",\"contents\":[\"Host 客户端发送请求时，用来指定服务器的域名\",\"Content-Length服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度\",\"Connection 最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 Connection 首部字段的值为 Keep-Alive\",\"Content-Type服务器回应时，告诉客户端，本次数据是什么格式。客户端请求的时候，可以使用 Accept字段声明自己可以接受哪些数据格式\",\"Content-Encoding表示服务器返回的数据使用了什么压缩格式。客户端在请求时，用 Accept-Encoding字段说明自己可以接受哪些压缩方法\",\"ETag一种将资源以字符串形式做唯一性标识的方式，服务器为每份资源分配对应的ETag值；资源更新时候，ETag值也更新。例如：Google中英文网页的URI虽然相同但对应的ETag不同\"]},{\"header\":\"1.4 GET和POST区别\",\"slug\":\"_1-4-get和post区别\",\"contents\":[\"安全：是指请求方法不会「破坏」服务器上的资源 幂等：多次执行相同的操作，结果都是「相同」的\",\"方法\",\"GET\",\"POST\",\"语义\",\"请求获取指定的资源（只读）\",\"对指定的资源做出处理（新增或提交数据）\",\"安全性\",\"安全、幂等\",\"不安全、不幂等\",\"缓存\",\"可被缓存\",\"一般不会缓存\",\"请求数据位置\",\"一般写在URL中\",\"一般写在报文 body 中\",\"如果不照RFC规范定义的语义来实现的话， 上述都不一定\",\"它们是 HTTP 请求协议的请求方法，而 HTTP 又是基于TCP/IP的关于数据如何在万维网中如何通信的协议，所以 GET/POST 实际上都是 TCP 链接\"]},{\"header\":\"1.5 强制缓存和协商缓存\",\"slug\":\"_1-5-强制缓存和协商缓存\",\"contents\":[\"缓存技术\",\"强制缓存\",\"协商缓存\",\"特点\",\"浏览器判断没过期，则使用缓存（浏览器主动）\",\"状态码304，告知客户端是否可以使用缓存（与服务端协商）\",\"字段\",\"Cache-control:相对时间（优先级高） Expires：绝对时间\",\"请求If-Modified-Since和响应Last-Modified：如果在这个时间后更新了才接受 & 响应资源最后修改时间请求If-None-Match和响应ETag：和ETag不一致的时候才接受（ETag优先级高）\",\"结果\",\"如果最后修改时间较新，则返回最新资源 200 否则返回304\",\"如果资源变化了返回200，否则返回304\"]},{\"header\":\"1.6 HTTP1.1\",\"slug\":\"_1-6-http1-1\",\"contents\":[\"优点：\",\"简单\",\"灵活易扩展（例如HTTPS和HTTP/3对TCP层的修改）\",\"应用广泛，跨平台\",\"缺点：\",\"无状态——Cookie解决\",\"不安全 \",\"明文传输 - 被窃听\",\"不验证通信方身份 - 被冒充和伪装\",\"不校验报文完整性 - 被篡改\",\"和HTTP1.0相比的优势：\",\"长连接——减少重复操作的开销\",\"管道网络传输——不等回应即可发送第二个请求，减少响应时间\",\"队头阻塞\"]},{\"header\":\"1.7 HTTPS\",\"slug\":\"_1-7-https\",\"contents\":[\"HTTP的通信接口部分用SSL/TLS协议代替 == HTTPS（即HTTP + 加密 + 认证 + 完整性保护）\",\"协议\",\"HTTP\",\"HTTPS\",\"安全性\",\"明文传输\",\"TCP 和 HTTP 之间加入了 SSL/TLS 安全协议，加密传输报文\",\"连接\",\"三次握手\",\"三次握手+SSL/TLS握手\",\"端口号\",\"80\",\"443\",\"另外HTTPS需要向CA申请数字证书来确保服务器的身份\",\"如何解决HTTP的安全问题：\",\"明文传输产生的窃听问题——信息加密 （混合加密）\",\"不验证身份产生的冒充问题——校验机制 （证书）\",\"不校验完整性产生的篡改问题——身份证书 （摘要算法）\",\"常见非对称加密算法：RSA、DSA、ECC、DH\",\"常见对称加密算法：DES、3DES、AES、RC（记：RC或者ES结尾的是对称）\"]},{\"header\":\"1.8 HTTP的演变\",\"slug\":\"_1-8-http的演变\",\"contents\":[\"协议\",\"HTTP/1.1\",\"HTTP/2\",\"HTTP/3(QUIC的特点)\",\"改进\",\"1.长连接2.管道运输：一次发送多个请求 3.废弃了两种请求方法LINK和UNLINK，新增了CONNECT、OPTIONS和TRACE4.新增了大量状态码\",\"1.头部压缩2.二进制格式 3.数据流：可以乱序发送，后stream ID组成HTTP信息 4.多路复用，串行变成并发5.服务器推送\",\"TCP->UDP+ QUIC1.无队头阻塞2.更快的连接建立（QUIC包含TLS，只需1个RTT）3.连接迁移\",\"不足\",\"1.头部冗长，未经压缩，浪费带宽，造成延迟2.没有请求优先级，所以队头阻塞(HTTP层) 3.服务器只能被动接收客户端的请求\",\"TCP层队头阻塞 TCP和TLS握手时延\",\"普及慢，很多网络设备不识别QUIC\",\"小林coeding计网-HTTP篇01.png\"]},{\"header\":\"2. HTTP1.1如何优化\",\"slug\":\"_2-http1-1如何优化\",\"contents\":[\"三个角度\",\"具体优化方法\",\"避免发送HTTP请求\",\"缓存 客户端第一次请求及数据保存在本地磁盘，形成<key,value> 过期？在请求的ETag带上第一次请求中响应头部的摘要，服务器收到后会与本地资源的摘要作比较，如果相同则返回不含包体的304 Not Modified\",\"减少请求次数\",\"1.减少重定向请求次数：利用中间的代理服务器知晓规则2.合并请求：合并资源，如CSS、webpack3.延迟发送请求：按需获取，滑动页面的时候再获取资源\",\"减少服务器响应数据大小\",\"无损压缩：gzip。请求Accepy-Encoding，响应Content-Encoding（文本、程序代码)有损压缩：舍弃一些数据（质量）。请求Accept中的q质量因子（音视频、图片）\"]},{\"header\":\"3. HTTPS如何优化\",\"slug\":\"_3-https如何优化\",\"contents\":[\"硬件优化、软件优化：HTTPS 协议是计算密集型，而不是 I/O 密集型，所以不能把钱花在网卡、硬盘等地方，应该花在 CPU 上\",\"协议优化 \",\"用ECDHE替换RSA，往返1RTT\",\"TLS 1.2->TLS 1.3，往返1RTT；在Hello时就发送椭圆曲线，且废除RSA和DH\",\"证书优化 \",\"证书选择：椭圆曲线证书比RSA密钥长度短\",\"证书验证优化：OCSP(Online Certificate Status Protocal)、OCSP Stapling\",\"密钥缓存（无前向安全，且易被重放攻击） \",\"Session ID：双方缓存密钥，Session ID和密钥相当于key-value。但是也有缺点，首先是每一个客户端都要保存密钥，其次是现在网站一般多服务器，不一定命中上次的服务器\",\"Session Ticket：客户端负责缓存\",\"Pre-shared Key：TLS 1.3重连只需要0 RTT。重连时Ticket和HTTP一起发给服务端\",\"解决重放攻击，应给密钥设定过期时间\"]},{\"header\":\"4. HTTP2提高传输效率、吞吐能力\",\"slug\":\"_4-http2提高传输效率、吞吐能力\",\"contents\":[\"兼容HTTP1.1\",\"没有在URL改变协议名字，只在应用层做了改变，还是基于TCP传输，但是把HTTP分解成了语义和语法，语义没变，还是请求方法、状态码和头字段等，语法有很多改变\",\"头部压缩（解决头部冗长问题）\",\"HPACK取代gzip \",\"静态表：首先两端维护一个字典，用索引号index代替字段名（GET，200，https等），共61种高频字符串\",\"动态表：发送新首部时在静态表里添加索引号\",\"Huffman编码：关于首部字段的内容用哈夫曼编码代替，基于二进制编码，不需要\\\\r\\\\n，改用表示字符串长度的Value Length\",\"二进制帧\",\"二进制+位运算\",\"并发传输（解决队头阻塞问题）\",\"多个Stream复用一条TCP连接，达到并发效果；每个帧头携带Stream ID，同一Stream内部的帧严格有序，方便接收后组装；还可以设置优先级，比方说先传递HTML再传递图片\",\"包含关系：TCP连接 > Stream > Message >Frame\",\"服务器主动推送（解决不支持服务器推送问题）\",\"但是HTTP2是基于TCP传输数据的，TCP是字节流协议，必须保证字节数据是完整连续的，内核才会将缓冲区的数据给HTTP应用，这方面存在阻塞，因此改用UDP，即HTTP3\"]},{\"header\":\"5. HTTP3\",\"slug\":\"_5-http3\",\"contents\":[\"之前存在的问题：\",\"队头阻塞：TCP丢包时，整个TCP都要等待重传\",\"握手延迟：发起HTTP请求时，需要经过TCP+TLS总计3RTT时延\",\"网络迁移需要重新连接：4G切WiFi时要重新握手，因为IP地址和端口变动了\",\"QUIC协议特点：\",\"无队头阻塞，Stream之间没有依赖\",\"更快建立连接：QUIC包含TLS，只需要1RTT即可握手\",\"连接迁移：通过连接ID标记两个端点，而不是IP地址和端口\",\"其他：HPACK升级->QPACK，静态表91项\"]}]},\"/computer-network/xiaolin-coding-network/\":{\"title\":\"小林coding计网\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文借鉴小林coding的图解计算机网络以及该文章https://blog.csdn.net/weixin_53833977/article/details/124421812\"]}]},\"/computer-usage-skills/optimization/01-%E6%96%B0%E6%9C%BA%E5%BC%80%E8%8D%92%E6%8C%87%E5%8D%97.html\":{\"title\":\"新机开荒指南\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"一个刚装完系统的电脑需要做什么？\",\"安装显卡驱动\",\"关掉系统底部任务栏无用的内容\",\"卸载掉不需要的系统应用\",\"进入设置隐私, 墨迹书写和键入个性化、诊断与反馈、日历联系人、后台应用，全部关掉\",\"开始菜单右键，个性化，选择哪些文件夹显示在“开始”菜单上\",\"进入文件资源管理器，点击上方的查看->选项，在常规中将“打开文件资源管理器时打开”选项改为“此电脑”，在此处可以设置隐私\",\"将系统文件夹中的七个文件夹路径改为 C 盘外的盘（注意命名时最好使用英文）\",\"打开控制面板，打开系统和安全->更改用户账户控制设置->拉到最低\",\"进入设置->系统->存储->更改新内容的保存位置，改成除 C 盘外的其他盘\",\"进入系统服务，禁用无用的服务 \",\"打印假脱机程序 Print Spooler如果您的计算机不使用打印机，可以禁用打印后台处理服务。未使用的可以先禁用，然后在使用时打开\",\"下载地图管理器 Downloaded Maps Manager可以直接禁用下载的地图管理器\",\"视窗防御防火墙 Windows Defender Firewall防火墙，视窗杀毒软件，如果你的电脑安装了第三方杀毒工具，你可以关闭它，如果没有，你最好打开它\",\"远程桌面服务/配置 Remote Desktop Services /Configuration这三项服务与远程桌面相关。如果您在使用遥控功能时通常使用 QQ 或电视，您可以禁用此服务\",\"互联用户体验和遥测 Connected User Experiences and Telemetry该服务是操作系统的微软外围辅助服务。主要用于收集数据，但也有责任收集错误和崩溃信息\",\"诊断执行服务/策略/服务主机系统主机 Diagnostic Execution Service/Policy/Service Host/System Host这四种服务是系统诊断服务，用于支持和执行系统诊断。这些服务会有高 CPU 使用率的问题，可以禁用\",\"传真 Fax目前很少使用的传真服务通常是默认禁用的\",\"智能卡 Smart Card普通用户不使用智能卡服务\",\"触摸键盘和手写面板服务 Touch Keyboard and Handwriting Panel Service触摸键盘和手写面板，非触摸屏用户可以直接禁用笔和墨水功能\",\"净 logo Netlogon此服务使用域控制器来验证您的用户帐户和其他服务，这些服务通常不被独立于家庭的计算机使用，可以直接禁用\"]}]},\"/computer-usage-skills/optimization/02-%E5%88%A0%E9%99%A4%E6%AD%A4%E7%94%B5%E8%84%91%E4%B8%AD%E7%9A%84%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F.html\":{\"title\":\"删除此电脑中的快捷方式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"我们在使用电脑时经常会遇到这种情况，在\\\"此电脑\\\"中出现很多快捷方式，那么怎们删除它们呢？\",\"删除此电脑中的快捷方式.png\",\"直接右键删除\",\"右键删除无效的，使用开源软件 MyComputerManager\",\"还是不行的话，打开注册表，修改注册表，路径为：计算机\\\\HKEY_CURRENT_USER\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\MyComputer\\\\NameSpace\\n进入以后删除快捷方式即可\"]}]},\"/computer-usage-skills/optimization/03-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8.html\":{\"title\":\"软件设置开机自启动\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"建议使用任务计划启动\",\"关闭软件的自启动\",\"打开任务计划程序\",\"软件设置开机自启动01.png\",\"选择操作中的创建任务\",\"软件设置开机自启动02.png\",\"输入名称，记得勾上使用最高权限运行\",\"软件设置开机自启动03.png\",\"切换到触发器，新建选择登陆时\",\"软件设置开机自启动04.png\",\"切换到操作，新建启动程序某某某\",\"软件设置开机自启动05.png\",\"设置完成，点击确定即可\"]}]},\"/computer-usage-skills/optimization/04-win11%E4%BF%AE%E6%94%B9%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95.html\":{\"title\":\"Win11修改右键菜单\",\"contents\":[{\"header\":\"还原为Win10右键菜单\",\"slug\":\"还原为win10右键菜单\",\"contents\":[\"win+R输入cmd，打开命令提示符\",\"输入如下命令：\",\"reg add HKCU\\\\Software\\\\Classes\\\\CLSID\\\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\\\\InprocServer32 /f /ve \",\"随后重启电脑即可\"]},{\"header\":\"恢复为Win11右键菜单\",\"slug\":\"恢复为win11右键菜单\",\"contents\":[\"在命令提示符中输入如下命令：\",\"reg.exe delete \\\"HKCU\\\\Software\\\\Classes\\\\CLSID\\\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\\\\InprocServer32\\\" /va /f \",\"随后重启电脑即可\"]}]},\"/computer-usage-skills/optimization/\":{\"title\":\"优化设置\",\"contents\":[]},\"/computer-usage-skills/troubleshoot/01-%E6%B8%B8%E6%88%8F%E9%97%AA%E9%80%80%E6%80%8E%E4%B9%88%E5%8A%9E.html\":{\"title\":\"游戏闪退怎么办？\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"检查游戏文件的完整性 \",\"steam 右击游戏属性，本地文件，验证完整性\",\"Quick Fix 检测驱动和系统时间 \",\"检查系统时间是否正确\",\"更新显卡驱动\",\"使用联想 Quick Fix Lenovo Quick Fix：游戏闪退检测工具\",\"3DM 修复 \",\"使用 3DM 离线包修复：3DM游戏运行库合集离线安装包\",\"尝试使用加速器 \",\"推荐使用 steam++（Watt Toolkit）：Watt Toolkit\",\"重启、重装 \",\"重启解决 90%问题\",\"重装解决 99%问题\"]}]},\"/computer-usage-skills/troubleshoot/\":{\"title\":\"疑难解答\",\"contents\":[]},\"/front-end/css-notes/01-%E5%88%9D%E8%AF%86CSS.html\":{\"title\":\"初识CSS\",\"contents\":[{\"header\":\"1. CSS简介\",\"slug\":\"_1-css简介\",\"contents\":[\"CSS 是层叠样式表 ( Cascading Style Sheets ) 的简称，有时我们也会称之为 CSS样式表 或 级联样式表\",\"CSS 也是一种标记语言\",\"CSS 主要用于设置 HTML 页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局和外观显示样式\",\"CSS 让我们的网页更加丰富多彩，布局更加灵活自如，简单理解：CSS 可以美化 HTML , 让 HTML 更漂亮，让页面布局更简单\",\"CSS 最大价值: 由 HTML 专注去做结构呈现，样式交给 CSS，即结构 ( HTML ) 与样式 ( CSS ) 相分离\"]},{\"header\":\"2. CSS的引入方式\",\"slug\":\"_2-css的引入方式\",\"contents\":[\"按照 CSS 样式书写的位置（或者引入的方式），CSS 样式表可以分为三大类\"]},{\"header\":\"2.1 行内样式表（行内式）\",\"slug\":\"_2-1-行内样式表-行内式\",\"contents\":[\"行内样式表（内联样式表）是在元素标签内部的 style 属性中设定 CSS 样式。适合于修改简单样式\",\"语法：\",\"<div style=\\\"样式\\\"></div> \",\"style 其实就是标签的属性，在双引号中间，写法要符合 CSS 规范，是 名：值 的形式\",\"可以控制当前的标签设置样式\",\"由于书写繁琐，并且没有体现出结构与样式相分离的思想，所以不推荐大量使用，只有对当前元素添加简单样式的时候，可以考虑使用\",\"使用行内样式表设定 CSS，通常也被称为行内式引入\"]},{\"header\":\"2.2 内部样式表（嵌入式）\",\"slug\":\"_2-2-内部样式表-嵌入式\",\"contents\":[\"内部样式表（内嵌样式表）是写到 html 页面内部，是将所有的 CSS 代码抽取出来，单独放到一个 <style> 标签中\",\"语法：\",\"<style> /*样式*/ </style> \",\"<style> 标签理论上可以放在 HTML 文档的任何地方，但一般会放在文档的 <head> 标签中\",\"通过此种方式，可以方便控制当前整个页面中的元素样式设置\",\"代码结构清晰，但是并没有实现结构与样式完全分离\",\"使用内部样式表设定 CSS，通常也被称为嵌入式引入，这种方式是我们练习时常用的方式\"]},{\"header\":\"2.3 外部样式表（链接式）\",\"slug\":\"_2-3-外部样式表-链接式\",\"contents\":[\"实际开发都是外部样式表，适合于样式比较多的情况，核心是: 样式单独写到 .css 文件中，之后把 .css 文件引入到 HTML 页面中使用\",\"引入外部样式表分为两步：\",\"新建一个后缀名为 .css 的样式文件，把所有 CSS 代码都放入此文件中\",\"在 HTML 页面中，使用 <link> 标签引入这个文件\",\"语法：\",\"<link rel=\\\"stylesheet\\\" href=\\\"css文件路径\\\"> \",\"注意：\",\"<link> 标签要写在 <head> 标签中\",\"标签属性说明： \",\"href ：引入的文档来自于哪里\",\"rel ：( relation，关系）说明引入的文档与当前文档之间的关系\",\"外部样式的优势：样式可以复用、结构清晰、可触发浏览器的缓存机制，提高访问速度，实现了结构与样式的完全分离\",\"实际开发中，几乎都使用外部样式，这是最推荐的使用方式\"]},{\"header\":\"2.4 CSS引入方式总结\",\"slug\":\"_2-4-css引入方式总结\",\"contents\":[\"样式表\",\"优点\",\"缺点\",\"使用情况\",\"控制范围\",\"行内样式表\",\"书写方便，权重高\",\"结构样式混写\",\"较少\",\"控制一个标签\",\"内部样式表\",\"部分结构和样式相分离\",\"没有彻底分离\",\"较多\",\"控制一个页面\",\"外部样式表\",\"完全实现结构和样式相分离\",\"需要引入\",\"最多\",\"控制多个页面\"]},{\"header\":\"2.5 样式表的优先级\",\"slug\":\"_2-5-样式表的优先级\",\"contents\":[\"优先级规则：行内样式 > 内部样式 = 外部样式\",\"内部样式、外部样式，这二者的优先级相同，且：后面的会覆盖前面的（简记：“后来者居上”）\",\"同一个样式表中，优先级也和编写顺序有关，且：后面的会覆盖前面的（简记：“后来者居上”）\"]},{\"header\":\"3. CSS语法规范\",\"slug\":\"_3-css语法规范\",\"contents\":[\"CSS 规则由两个主要的部分构成：\",\"选择器：找到要添加样式的元素\",\"声明块：设置具体的样式（声明块是由一个或多个声明组成的），声明的格式为： 属性名: 属性值;\",\"h1{ color:red; font-size:25px; } /*h1是选择器*/ \",\"选择器是用于指定 CSS 样式的 HTML 标签，花括号内是对该对象设置的具体样式\",\"属性和属性值以“键值对”的形式出现\",\"属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等\",\"属性和属性值之间用英文:分开\",\"多个“键值对”之间用英文;进行区分\",\"例如：所有的样式，都包含在 <style> 标签内，表示是样式表。<style> 一般写到 </head> 上方\",\"<head> <style> h4 { color: blue; font-size: 100px; } </style> </head> \",\"注释的写法：\",\"/* 给h1元素添加样式 */ h1{ /* 设置文字颜色为红色 */ color: red; /* 设置文字大小为40px */ font-size: 40px; } \"]},{\"header\":\"4. CSS代码风格\",\"slug\":\"_4-css代码风格\",\"contents\":[\"样式格式书写\",\"紧凑格式（项目上线时推荐，可减小文件体积）\",\"h3 { color: deeppink; font-size: 20px;} \",\"展开格式（开发时推荐，便于维护和调试）\",\"h3 { color: pink; font-size: 20px; } \",\"样式大小写风格\",\"小写格式（强烈推荐样式选择器，属性名，属性值关键字全部使用小写字母，特殊情况除外）\",\"h3 { color: pink; } \",\"大写格式：\",\"H3 { COLOR: PINK; } \",\"样式空格风格\",\"属性值前面，冒号后面，保留一个空格，选择器（标签）和大括号中间保留空格\",\"h3 { color: pink; } \"]}]},\"/front-end/css-notes/02-CSS%E9%80%89%E6%8B%A9%E5%99%A8.html\":{\"title\":\"CSS选择器\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"选择器 (选择符)就是根据不同需求把不同的标签选出来，简单来说，就是选择标签用的\"]},{\"header\":\"1. CSS基本选择器\",\"slug\":\"_1-css基本选择器\",\"contents\":[\"基础选择器包括：\",\"通配符选择器\",\"标签（元素）选择器\",\"类选择器\",\"id 选择器\"]},{\"header\":\"1.1 通配符选择器\",\"slug\":\"_1-1-通配符选择器\",\"contents\":[\"作用：可以选中所有的 HTML 元素\",\"语法：\",\"* { 属性名: 属性值; } \",\"例：\",\"* { margin: 0; padding: 0; } \"]},{\"header\":\"1.2 标签选择器\",\"slug\":\"_1-2-标签选择器\",\"contents\":[\"标签选择器（元素选择器）是指用 HTML 标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的 CSS 样式\",\"作用：为页面中某种元素统一设置样式\",\"语法：\",\"标签名{ 属性名：属性值 } \",\"例：\",\"/* 选中所有h1元素 */ h1 { color: orange; font-size: 40px; } /* 选中所有p元素 */ p { color: blue; font-size: 60px; } \"]},{\"header\":\"1.3 类选择器\",\"slug\":\"_1-3-类选择器\",\"contents\":[\"如果想要差异化选择不同的标签，单独选一个或者某几个标签，可以使用类选择器\",\"作用：根据元素的 class 值，来选中某些元素\",\"语法：\",\".类名 { 属性名: 属性值; } \",\"例：\",\"/* 选中所有class值为speak的元素 */ .speak { color: red; } /* 选中所有class值为answer的元素 */ .answer { color: blue; } \",\"如果想要差异化选择不同的标签，单独选一个或者某几个标签，可以使用类选择器\",\"类选择器在 HTML 中以 class 属性表示，在 CSS 中，类选择器以一个点号 . 显示\",\"类选择器使用.（英文点号）进行标识，后面紧跟类名（自定义，我们自己命名的）\",\"可以理解为给这个标签起了一个名字，来表示\",\"长名称或词组可以使用中横线来为选择器命名\",\"不要使用纯数字、中文等命名，尽量使用英文字母来表示\",\"命名要有意义，尽量使别人一眼就知道这个类名的目的\",\"注意：在标签 class 属性中可以写多个类名，多个类名中间必须用空格分开，这个标签就可以分别具有这些类名的样式\"]},{\"header\":\"1.4 id选择器\",\"slug\":\"_1-4-id选择器\",\"contents\":[\"id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式\",\"作用：根据元素的 id 属性值，来精准的选中某个元素\",\"语法：\",\"#id值 { 属性名: 属性值; } \",\"例：\",\"/* 选中id值为earthy的那个元素 */ #earthy { color: red; font-size: 60px; } \",\"注意：\",\"id 属性值：尽量由字母、数字、下划线 _ 、短杠 - 组成，最好以字母开头、不要包含空格、区分大小写\",\"一个元素只能拥有一个 id 属性，多个元素的 id 属性值不能相同\",\"一个元素可以同时拥有 id 和 class 属性\"]},{\"header\":\"1.5 选择器总结\",\"slug\":\"_1-5-选择器总结\",\"contents\":[\"基础选择器\",\"作用\",\"特点\",\"使用情况\",\"用法\",\"标签选择器\",\"可以选出所有相同的标签\",\"不能差异化选择\",\"较多\",\"p{color: red};\",\"类选择器\",\"可以选出 1 个或多个标签\",\"可以根据需求选择\",\"非常多\",\". nav{color: red;}\",\"id 选择器\",\"一次只能选择 1 个标签\",\"ID 属性只能在每个 HTML 文档中出现一次\",\"一般和 js 搭配\",\"# nav{color: red;}\",\"通配符选择器\",\"选择所有的标签\",\"选择的太多，有部分不需要\",\"特殊情况使用\",\"* {color: red;}\"]},{\"header\":\"2. CSS复合选择器\",\"slug\":\"_2-css复合选择器\",\"contents\":[\"在 CSS 中，可以根据选择器的类型把选择器分为基础选择器和复合选择器，复合选择器是建立在基础选择器之上，对基本选择器进行组合形成的\",\"复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的，可以更准确、更高效的选择目标元素（标签）\",\"常用的复合选择器包括：\",\"交集选择器\",\"并集选择器\",\"后代选择器\",\"子元素选择器\",\"兄弟选择器\",\"属性选择器\",\"伪类选择器\",\"伪元素选择器\",\"……\"]},{\"header\":\"2.1 交集选择器\",\"slug\":\"_2-1-交集选择器\",\"contents\":[\"作用：选中同时符合多个条件的元素\",\"语法：\",\"选择器1选择器2选择器3...选择器n { 样式声明 } \",\"例：\",\"/* 选中类名为beauty的p元素，此种写法用的非常多 */ p.beauty { color: blue; } /* 选中：类名包含rich和beauty的元素 */ .rich.beauty { color: green; } \",\"注意：\",\"有标签名，标签名必须写在前面\",\"id 选择器、通配选择器，理论上可以作为交集的条件，但实际应用中几乎不用 —— 因为没有意义\",\"交集选择器中不可能出现两个元素选择器，因为一个元素，不可能即是 p 元素又是 span 元 素\",\"用的最多的交集选择器是：元素选择器配合类名选择器，例如： p.beauty\"]},{\"header\":\"2.2 并集选择器\",\"slug\":\"_2-2-并集选择器\",\"contents\":[\"作用：选中多个选择器对应的元素，又称：分组选择器\",\"语法：\",\"选择器1, 选择器2, 选择器3, ... 选择器n { 样式声明 } \",\"例：\",\"/* 选中id为peiqi，或类名为rich，或类名为beauty的元素 */ #peiqi, .rich, .beauty { font-size: 40px; background-color: skyblue; width: 200px; } \",\"注意：\",\"并集选择器，我们一般竖着写\",\"任何形式的选择器，都可以作为并集选择器的一部分\",\"并集选择器，通常用于集体声明，可以缩小样式表体积\"]},{\"header\":\"2.3 基于HTML元素间的关系的选择器\",\"slug\":\"_2-3-基于html元素间的关系的选择器\",\"contents\":[\"分为：父元素、子元素、祖先元素、后代元素、兄弟元素\",\"父元素：直接包裹某个元素的元素，就是该元素的父元素\",\"CSS选择器01.png\",\"子元素：被父元素直接包含的元素（简记：儿子元素）\",\"CSS选择器02.png\",\"祖先元素：父亲的父亲......，一直往外找，都是祖先（父元素也算是祖先元素的一种）\",\"CSS选择器03.png\",\"后代元素：儿子的儿子......，一直往里找，都是后代（子元素，也算是后代元素的一种）\",\"CSS选择器04.png\",\"兄弟元素：具有相同父元素的元素，互为兄弟元素\",\"CSS选择器05.png\"]},{\"header\":\"2.3.1 后代选择器\",\"slug\":\"_2-3-1-后代选择器\",\"contents\":[\"作用：选中指定元素中，符合要求的后代元素\",\"语法：\",\"选择器1 选择器2 选择器3 ...... 选择器n { 样式声明 } /*（先写祖先，再写后代）*/ \",\"语法说明：中间用空格隔开\",\"例：\",\"/* 选中ul中的所有li */ ul li { color: red; } /* 选中ul中所有li中的a */ ul li a { color: orange; } /* 选中类名为subject元素中的所有li */ .subject li { color: blue; } /* 选中类名为subject元素中的所有类名为front-end的li */ .subject li.front-end { color: blue; } \",\"注意：\",\"后代选择器，最终选择的是后代，不选中祖先\",\"儿子、孙子、重孙子，都算是后代\",\"结构一定要符合之前讲的 HTML 嵌套要求，例如：不能 p 中写 h1 ~ h6\"]},{\"header\":\"2.3.2 子代选择器\",\"slug\":\"_2-3-2-子代选择器\",\"contents\":[\"作用：选中指定元素中，符合要求的子元素（儿子元素）。（先写父，再写子）\",\"语法：\",\"选择器1 > 选择器2 > 选择器3 > ...... 选择器n { 样式声明 } \",\"例：\",\"/* div中的子代a元素 */ div>a { color: red; } /* 类名为persons的元素中的子代a元素 */ .persons>a{ color: red; } \",\"注意：\",\"子代选择器，最终选择的是子代，不是父级\",\"子、孙子、重孙子、重重孙子 ...... 统称后代！，子就是指儿子\"]},{\"header\":\"2.3.3 兄弟选择器\",\"slug\":\"_2-3-3-兄弟选择器\",\"contents\":[]},{\"header\":\"2.3.3.1 相邻兄弟选择器\",\"slug\":\"_2-3-3-1-相邻兄弟选择器\",\"contents\":[\"作用：选中指定元素后，符合条件的相邻兄弟元素（所谓相邻，就是紧挨着他的下一个）\",\"语法：\",\"选择器1+选择器2 { 样式声明 } \",\"例：\",\"/* 选中div后相邻的兄弟p元素 */ div+p { color:red; } \"]},{\"header\":\"2.3.3.2 通用兄弟选择器\",\"slug\":\"_2-3-3-2-通用兄弟选择器\",\"contents\":[\"作用：选中指定元素后，符合条件的所有兄弟元素\",\"语法：\",\"选择器1~选择器2 { 样式声明 } \",\"例：\",\"/* 选中div后的所有的兄弟p元素 */ div~p { color:red; } \"]},{\"header\":\"2.4 属性选择器\",\"slug\":\"_2-4-属性选择器\",\"contents\":[\"作用：选中属性值符合一定要求的元素\",\"选择符\",\"简介\",\"E[att]\",\"选择具有 att 属性的 E 元素\",\"E[att=\\\"val\\\"]\",\"选择具有 att 属性且属性值等于 val 的 E 元素\",\"E[att^=\\\"val\\\"]\",\"匹配具有 att 属性且值以 val 开头的 E 元素\",\"E[att$=\\\"val\\\"]\",\"匹配具有 att 属性且值以 val 结尾的 E 元素\",\"E[att*=\\\"val\\\"]\",\"匹配具有 att 属性且值中含有 val 的 E 元素\",\"示例代码：\",\" /* 只选择 type=text 文本框的 input 选取出来 */ input[type=text] { color: pink; } /* 选择首先是 div 然后 具有 class 属性 并且属性值 必须是 icon 开头的这些元素 */ div[class^=icon] { color: red; } /* 选择首先是 section 然后 具有 class 属性 并且属性值 必须是 data 结尾的这些元素 */ section[class$=data] { color: blue; } \",\"属性选择器，按照字面意思，都是根据标签中的属性来选择元素，属性选择器可以根据元素特定属性的来选择元素。这样就可以不用借助于类或者 id 选择器，属性选择器也可以选择出来自定义的属性\"]},{\"header\":\"2.5 伪类选择器\",\"slug\":\"_2-5-伪类选择器\",\"contents\":[\"作用：选中特殊状态的元素\"]},{\"header\":\"2.5.1 动态伪类\",\"slug\":\"_2-5-1-动态伪类\",\"contents\":[\":link 超链接未被访问的状态 :visited 超链接访问过的状态 :hover 鼠标悬停在元素上的状态 :active 元素激活的状态 :focus 获取焦点的元素\",\"注意：\",\"激活表示按下鼠标不松开\",\"为了确保生效，请按照 LVHA 的顺序声明 :link － :visited － :hover － :active\",\"表单类元素才能使用 :focus 伪类，当用户点击元素、触摸元素、通过键盘的 tab 键等方法选择元素时，就是获得焦点\"]},{\"header\":\"2.5.2 结构伪类\",\"slug\":\"_2-5-2-结构伪类\",\"contents\":[\"结构伪类选择器主要根据文档结构来选择器元素，常用于根据父级选择器里面的子元素\",\"选择符\",\"简介\",\":first-child\",\"所有兄弟元素中的第一个\",\":last-child\",\"所有兄弟元素中的最后一个\",\":nth-child (n)\",\"所有兄弟元素中的第 n 个\",\":first-of-type\",\"所有同类型兄弟元素中的第一个\",\":last-of-type\",\"所有同类型兄弟元素中的最后一个\",\":nth-of-type (n)\",\"所有同类型兄弟元素中的第n个\",\"关于 n 的值：\",\"0 或不写 ：什么都选不中 —— 几乎不用\",\"n ：选中所有子元素 —— 几乎不用\",\"1~正无穷的整数 ：选中对应序号的子元素\",\"2n 或 even ：选中序号为偶数的子元素\",\"2n+1 或 odd ：选中序号为奇数的子元素\",\"-n+3 ：选中的是前 3 个\",\"n 可以是公式\",\"了解即可：\",\":nth-last-child(n) 所有兄弟元素中的倒数第 n 个\",\":nth-last-of-type(n) 所有同类型兄弟元素中的倒数第 n 个\",\":only-child 选择没有兄弟的元素（独生子女）\",\":only-of-type 选择没有同类型兄弟的元素\",\":root 根元素\",\":empty 内容为空元素（空格也算内容）\"]},{\"header\":\"2.5.3 否定伪类\",\"slug\":\"_2-5-3-否定伪类\",\"contents\":[\":not(选择器) 排除满足括号中条件的元素\"]},{\"header\":\"2.5.4 UI伪类\",\"slug\":\"_2-5-4-ui伪类\",\"contents\":[\":checked 被选中的复选框或单选按钮\",\":enable 可用的表单元素（没有 disabled 属性）\",\":disabled 不可用的表单元素（有 disabled 属性）\"]},{\"header\":\"2.5.5 目标伪类\",\"slug\":\"_2-5-5-目标伪类\",\"contents\":[\":target 选中锚点指向的元素\"]},{\"header\":\"2.5.6 语言伪类\",\"slug\":\"_2-5-6-语言伪类\",\"contents\":[\":lang() 根据指定的语言选择元素（本质是看 lang 属性的值）\"]},{\"header\":\"2.6 伪元素选择器\",\"slug\":\"_2-6-伪元素选择器\",\"contents\":[\"作用：选中元素中的有一些特殊位置\",\"::first-letter 选中元素中的第一个文字\",\"::first-line 选中元素中的第一行文字\",\"::selection 选中被鼠标选中的内容\",\"::placeholder 选中输入框的提示文字\",\"::before 在元素最开始的位置，创建一个子元素（必须用 content 属性指定内容）\",\"::after 在元素最后的位置，创建一个子元素（必须用 content 属性指定内容）\",\"注意：\",\"before 和 after 创建一个元素，但是属于行内元素\",\"新创建的这个元素在文档树中是找不到的，所以我们称为伪元素\",\"语法：element::before {}\",\"before 和 after 必须有 content 属性\",\"before 在父元素内容的前面创建元素，after 在父元素内容的后面插入元素\"]},{\"header\":\"3. 选择器的优先级\",\"slug\":\"_3-选择器的优先级\",\"contents\":[\"通过不同的选择器，选中相同的元素，并且为相同的样式名设置不同的值时，就发生了样式的冲突。到底应用哪个样式，此时就需要看优先级了\"]},{\"header\":\"3.1 简单描述\",\"slug\":\"_3-1-简单描述\",\"contents\":[\"行内样式 > ID 选择器 > 类选择器 > 元素选择器 > 通配选择器\"]},{\"header\":\"3.2 详细描述\",\"slug\":\"_3-2-详细描述\",\"contents\":[\"计算方式：每个选择器，都可计算出一组权重，格式为： (a,b,c)\",\"a : ID 选择器的个数\",\"b : 类、伪类、属性选择器的个数\",\"c : 元素、伪元素选择器的个数\",\"例：\",\"选择器\",\"权重\",\"ul>li\",\"(0,0,2)\",\"div ul>li p a span\",\"(0,0,6)\",\"#a .slogan\",\"(1,1,0)\",\"#a .slogan a\",\"(1,1,1)\",\"#a .slogan a:hover\",\"(1,2,1)\",\"比较规则：按照从左到右的顺序，依次比较大小，当前位胜出后，后面的不再对比\",\"例：\",\"(1,0,0) > (0,2,2)\",\"(1,1,0) > (1,0,3)\",\"(1,1,3) > (1,1,2)\",\"特殊规则：\",\"行内样式权重大于所有选择器\",\"!important 的权重，大于行内样式，大于所有选择器，权重最高！\",\"图示：\",\"CSS选择器06.png\"]}]},\"/front-end/css-notes/03-CSS%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7.html\":{\"title\":\"CSS三大特性\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"CSS 有三个非常重要的三个特性：层叠性、继承性、优先级\"]},{\"header\":\"1. 层叠性\",\"slug\":\"_1-层叠性\",\"contents\":[\"相同选择器给设置相同的样式，此时一个样式就会覆盖（层叠）另一个冲突的样式，层叠性主要解决样式冲突的问题\",\"层叠性原则:\",\"样式冲突，遵循的原则是就近原则，哪个样式离结构近，就执行哪个样式，即后面的样式会覆盖掉前面的样式\",\"样式不冲突，不会层叠\"]},{\"header\":\"2. 继承性\",\"slug\":\"_2-继承性\",\"contents\":[\"CSS 中的继承: 子标签会继承父标签的某些样式\",\"规则：优先继承离得近的\",\"恰当地使用继承可以简化代码，降低 CSS 样式的复杂性\",\"常见的可继承属性：text-??，font-??，line-??，color\"]},{\"header\":\"3. 优先级\",\"slug\":\"_3-优先级\",\"contents\":[\"!important > 行内样式 > ID 选择器 > 类选择器 > 元素选择器 > * > 继承的样式\"]}]},\"/front-end/css-notes/04-CSS%E9%95%BF%E5%BA%A6%E5%92%8C%E9%A2%9C%E8%89%B2.html\":{\"title\":\"CSS长度和颜色\",\"contents\":[{\"header\":\"1. 长度\",\"slug\":\"_1-长度\",\"contents\":[]},{\"header\":\"1.1 像素\",\"slug\":\"_1-1-像素\",\"contents\":[\"像素（px）是指由图像的小方格组成的，这些小格都有一个明确的位置和被分配的色彩数值，小方格颜色和位置就决定该图像所呈现出来的样子\",\"可以将像素视为整个图像中不可分割的单位或者是元素。不可分割的意思是它不能够再切割成更小单位抑或是元素，它是以一个单一颜色的小格存在。每一个点阵图像包含了一定量的像素，这些像素决定图像在屏幕上所呈现的大小，也就是说，显示器屏幕实际上是由一个一个的小点（单位色块，即像素）构成的\"]},{\"header\":\"1.2 屏幕分辨率\",\"slug\":\"_1-2-屏幕分辨率\",\"contents\":[\"例如，屏幕分辨率是1920×1080，则该屏幕水平方向有1920个像素，垂直方向有1080个像素\",\"不同屏幕的像素大小是不同的，也就是说像素大小不像我们现行的长度单位（如米/m）那样有着固定的国际标准\",\"所以同样的像素大小在不同的设备上显示效果是不一样的，像素越小的屏幕显示的效果越清晰\"]},{\"header\":\"1.3 图像分辨率\",\"slug\":\"_1-3-图像分辨率\",\"contents\":[\"例如，一张图片分辨率是300x200，则该图片在屏幕上按1:1缩放时，水平方向有300个像素，垂直方向有200个像素点\",\"图片分辨率越高，1:1缩放时面积越大\",\"图片分辨率越低，1:1缩放时面积越小\",\"同一台设备像素大小是不变的，那把图片放大超过100%时占的像素点就多了，但是图像也会变得模糊\"]},{\"header\":\"1.4 百分比\",\"slug\":\"_1-4-百分比\",\"contents\":[\"将属性值设置为相对于其父元素属性的百分比，可以使子元素跟随父元素的改变而改变\"]},{\"header\":\"1.5 em\",\"slug\":\"_1-5-em\",\"contents\":[\"em是相对于元素的字体大小来计算的，1em = <self>.font-size，也就说em值会根据元素本身的字体大小的改变而改变\"]},{\"header\":\"1.6 rem\",\"slug\":\"_1-6-rem\",\"contents\":[\"rem是相对于根元素的字体大小来计算，1em = <root>.font-size，也就说em值会根据根元素的字体大小的改变而改变\"]},{\"header\":\"2. 颜色\",\"slug\":\"_2-颜色\",\"contents\":[]},{\"header\":\"2.1 颜色名\",\"slug\":\"_2-1-颜色名\",\"contents\":[\"编写方式：直接使用颜色对应的英文单词，编写比较简单\",\"如：\",\"红色：red\",\"绿色：green\",\"蓝色：blue\",\"紫色：purple\",\"橙色：orange\",\"灰色：gray\"]},{\"header\":\"2.2 rgb或rgba\",\"slug\":\"_2-2-rgb或rgba\",\"contents\":[\"编写方式：使用红、黄、蓝这三种光的三原色进行组合\",\"r 表示红色， g 表示绿色， b 表示蓝色， a 表示透明度\",\"例：\",\"/* 使用 0~255 之间的数字表示一种颜色 */ color: rgb(255, 0, 0);/* 红色 */ color: rgb(0, 255, 0);/* 绿色 */ color: rgb(0, 0, 255);/* 蓝色 */ color: rgb(0, 0, 0);/* 黑色 */ color: rgb(255, 255, 255);/* 白色 */ /* 混合出任意一种颜色 */ color:rgb(138, 43, 226) /* 紫罗兰色 */ color:rgba(255, 0, 0, 0.5);/* 半透明的红色 */ /* 也可以使用百分比表示一种颜色（用的少） */ color: rgb(100%, 0%, 0%);/* 红色 */ color: rgba(100%, 0%, 0%,50%);/* 半透明的红色 */ \",\"小规律：\",\"若三种颜色值相同，呈现的是灰色，值越大，灰色越浅\",\"rgb (0, 0, 0) 是黑色， rgb (255, 255,255) 是白色\",\"对于 rbga 来说，前三位的 rgb 形式要保持一致，要么都是 0~255 的数字，要么都是百分比\"]},{\"header\":\"2.3 HEX或HEXA\",\"slug\":\"_2-3-hex或hexa\",\"contents\":[\"HEX 的原理同与 rgb 一样，依然是通过：红、绿、蓝色进行组合，只不过要用 6位（分成3组） 来表达，格式为：#rrggbb\",\"每一位数字的取值范围是： 0 ~ f ，即：（ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f ），所以每一种光的最小值是： 00 ，最大值是： ff\",\"color: #ff0000;/* 红色 */ color: #00ff00;/* 绿色 */ color: #0000ff;/* 蓝色 */ color: #000000;/* 黑色 */ color: #ffffff;/* 白色 */ /* 如果每种颜色的两位都是相同的，就可以简写*/ color: #ff9988;/* 可简为：#f98 */ /* 但要注意前三位简写了，那么透明度就也要简写 */ color: #ff998866;/* 可简为：#f986 */ \"]},{\"header\":\"2.4 HSL或HSLA\",\"slug\":\"_2-4-hsl或hsla\",\"contents\":[\"HSL 是通过：色相、饱和度、亮度，来表示一个颜色的，格式为：hsl(色相,饱和度,亮度)\",\"色相：取值范围是 0~360 度，具体度数对应的颜色如下图\",\"CSS长度和颜色01.png\",\"饱和度：取值范围是 0%~100% 。（向色相中对应颜色中添加灰色， 0% 全灰， 100% 没有灰）\",\"亮度：取值范围是 0%~100% 。（ 0% 亮度没了，所以就是黑色。 100% 亮度太强，所以就是白色了）\",\"HSLA 其实就是在 HSL 的基础上，添加了透明度\"]}]},\"/front-end/css-notes/05-CSS%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7.html\":{\"title\":\"CSS常用属性\",\"contents\":[{\"header\":\"1. CSS字体属性\",\"slug\":\"_1-css字体属性\",\"contents\":[]},{\"header\":\"1.1 字体大小\",\"slug\":\"_1-1-字体大小\",\"contents\":[\"属性名：font-size\",\"作用：控制字体的大小\",\"语法：\",\"p { font-size: 20px; } \",\"谷歌浏览器支持的最小文字为 12px，默认的文字大小为 16px，并且 0px 会自动消失\",\"不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小\",\"可以给 body 指定整个页面文字的大小\",\"由于字体设计原因，文字最终呈现的大小，并不一定与 font-size 的值一致，可能大，也可能小\",\"通常情况下，文字相对字体设计框，并不是垂直居中的，通常都靠下一些\"]},{\"header\":\"1.2 字体族\",\"slug\":\"_1-2-字体族\",\"contents\":[\"属性名：font-family\",\"作用：控制字体类型\",\"语法：\",\"p{ font-family：\\\"微软雅黑\\\"； } \",\"各种字体之间必须使用英文状态下的逗号隔开\",\"一般情况下，如果有空格隔开的多个单词组成的字体，加引号\",\"尽量使用系统默认自带字体，保证在任何用户的浏览器中都能正确显示\",\"使用字体的英文名字兼容性会更好\",\"可以设置多个字体，按照从左到右的顺序逐个查找，找到就用，没有找到就使用后面的，且通常在最后写上 serif （衬线字体）或 sans-serif （非衬线字体）\"]},{\"header\":\"1.3 字体风格\",\"slug\":\"_1-3-字体风格\",\"contents\":[\"属性名：font-style\",\"作用：控制字体是否为斜体\",\"语法：\",\"p { font-style: normal; } \",\"属性值\",\"作用\",\"normal\",\"默认值，浏览器会显示标准的字体样式\",\"italic\",\"浏览器会显示斜体的字体样式（推荐使用）\",\"oblique\",\"斜体（强制倾斜产生的斜体效果）\"]},{\"header\":\"1.4 字体粗细\",\"slug\":\"_1-4-字体粗细\",\"contents\":[\"属性名：font-weight\",\"作用：控制字体的粗细\",\"语法：\",\"p { font-weight: bold; } p { font-weight: 600; } \",\"属性值\",\"描述\",\"normal\",\"默认值（不加粗的）\",\"bold\",\"定义粗体（加粗的）\",\"lighter\",\"细\",\"bolder\",\"很粗\",\"100~1000\",\"100~300 等同于 lighter，400~500 等同于 normal，而 600 及以上 等同于 bold，注意这个数字后面不跟单位\"]},{\"header\":\"1.5 字体的复合写法\",\"slug\":\"_1-5-字体的复合写法\",\"contents\":[\"属性名：font，可以把上述字体样式合并成一个属性\",\"作用：将上述所有字体相关的属性复合在一起编写\",\"编写规则：\",\"字体大小、字体族必须都写上\",\"字体族必须是最后一位、字体大小必须是倒数第二位\",\"各个属性间用空格隔开\",\"body { font: font-style font-weight font-size/line-height font-family; } \"]},{\"header\":\"2. CSS文本属性\",\"slug\":\"_2-css文本属性\",\"contents\":[]},{\"header\":\"2.1 文本颜色\",\"slug\":\"_2-1-文本颜色\",\"contents\":[\"属性名：color\",\"作用：控制文字的颜色\",\"可选值：\",\"颜色名\",\"rgb 或 rgba\",\"HEX 或 HEXA （十六进制）（开发中最常用）\",\"HSL 或 HSLA\",\"语法：\",\"div { color: red; } \"]},{\"header\":\"2.2 文本间距\",\"slug\":\"_2-2-文本间距\",\"contents\":[\"字母间距： letter-spacing\",\"单词间距： word-spacing （通过空格识别词）\",\"属性值为像素（ px ），正值让间距增大，负值让间距缩小\"]},{\"header\":\"2.3 文本修饰\",\"slug\":\"_2-3-文本修饰\",\"contents\":[\"属性名：text-decoration\",\"作用：控制文本的各种装饰线\",\"语法：\",\"div { text-decoration：underline; } \",\"属性值\",\"描述\",\"none\",\"默认，没有装饰线\",\"underline\",\"下划线，链接自带下划线\",\"overline\",\"上划线\",\"line-through\",\"删除线\",\"可搭配如下值使用：\",\"dotted ：虚线\",\"wavy ：波浪线\",\"也可以指定颜色\"]},{\"header\":\"2.4 文本缩进\",\"slug\":\"_2-4-文本缩进\",\"contents\":[\"属性名： text-indent\",\"作用：控制文本首字母的缩进\",\"语法：\",\"div { text-indent：20px； } div { text-indent：2em； } \",\"em 是一个相对单位，就是当前元素（font-size) 1 个文字的大小, 如果当前元素没有设置大小，则会按照父元素的 1 个文字大小\"]},{\"header\":\"2.5 文本对齐_水平\",\"slug\":\"_2-5-文本对齐-水平\",\"contents\":[\"属性名：text-align\",\"作用：控制文本的水平对齐方式\",\"语法：\",\"div { text-align: center; } \",\"属性值\",\"解释\",\"left\",\"左对齐（默认值）\",\"right\",\"右对齐\",\"center\",\"居中对齐\"]},{\"header\":\"2.6 行高\",\"slug\":\"_2-6-行高\",\"contents\":[\"属性名：line-height\",\"作用：控制一行文字的高度\",\"可选值：\",\"normal ：由浏览器根据文字大小决定的一个默认值\",\"像素 ( px )\",\"数字：参考自身 font-size 的倍数（很常用）\",\"百分比：参考自身 font-size 的百分比\",\"语法：\",\"p { line-height: 26px; line-height: 1.5; line-height: 150%; } \",\"行高注意事项：\",\"line-height 过小会怎样？—— 文字产生重叠，且最小值是 0 ，不能为负数\",\"line-height 是可以继承的，且为了能更好的呈现文字，最好写数值\",\"line-height 和 height 是什么关系？ \",\"设置了 height ，那么高度就是 height 的值\",\"不设置 height 的时候，会根据 line-height 计算高度\",\"应用场景：\",\"对于多行文字：控制行与行之间的距离\",\"对于单行文字：让 height 等于 line-height ，可以实现文字垂直居中（由于字体设计原因，靠上述办法实现的居中，并不是绝对的垂直居中，但如果一行中都是文字，不会太影响观感）\"]},{\"header\":\"2.7 文本对齐_垂直\",\"slug\":\"_2-7-文本对齐-垂直\",\"contents\":[\"顶部：无需任何属性，在垂直方向上，默认就是顶部对齐\",\"居中：对于单行文字，让 height = line-height 即可\",\"底部：对于单行文字，目前一个临时的方式： 让 line-height = ( height × 2 ) - font-size - x ，备注： x 是根据字体族，动态决定的一个值\"]},{\"header\":\"2.8 vertical-align\",\"slug\":\"_2-8-vertical-align\",\"contents\":[\"属性名： vertical-align\",\"作用：用于指定同一行元素之间，或表格单元格内文字的垂直对齐方式\",\"常用值：\",\"baseline （默认值）：使元素的基线与父元素的基线对齐\",\"top ：使元素的顶部与其所在行的顶部对齐\",\"middle ：使元素的中部与父元素的基线加上父元素字母 x 的一半对齐\",\"bottom ：使元素的底部与其所在行的底部对齐\",\"特别注意： vertical-align 不能控制块元素\"]},{\"header\":\"3. CSS列表属性\",\"slug\":\"_3-css列表属性\",\"contents\":[\"列表相关的属性，可以作用在 ul 、 ol 、 li 元素上\"]},{\"header\":\"3.1 list-style-type\",\"slug\":\"_3-1-list-style-type\",\"contents\":[\"功能：设置列表符号\",\"属性值：\",\"none：不显示前面的标识\",\"square：实心方块\",\"disc：圆形\",\"decimal：数字\",\"lower-roman：小写罗马字\",\"upper-roman：大写罗马字\",\"lower-alpha：小写字母\",\"upper-alpha：大写字母\"]},{\"header\":\"3.2 list-style-position\",\"slug\":\"_3-2-list-style-position\",\"contents\":[\"功能：设置列表符号的位置\",\"属性值：\",\"inside ：在 li 的里面\",\"outside ：在 li 的外边\"]},{\"header\":\"3.3 list-style-image\",\"slug\":\"_3-3-list-style-image\",\"contents\":[\"功能：自定义列表符号\",\"属性值：url(图片地址)\"]},{\"header\":\"3.4 list-style\",\"slug\":\"_3-4-list-style\",\"contents\":[\"功能：复合属性\",\"属性值：没有数量、顺序的要求\"]},{\"header\":\"4. CSS表格属性\",\"slug\":\"_4-css表格属性\",\"contents\":[]},{\"header\":\"4.1 边框相关属性\",\"slug\":\"_4-1-边框相关属性\",\"contents\":[\"CSS 属性名\",\"功能\",\"属性值\",\"border-width\",\"边框宽度\",\"CSS 中可用的长度值\",\"border-color\",\"边框颜色\",\"CSS 中可用的颜色值\",\"border-style\",\"边框风格\",\"none 默认值solid 实线dashed 虚线dotted 点线double 双实线\",\"border\",\"边框复合属性\",\"没有数量、顺序的要求\",\"注意：以上 4 个边框相关的属性，其他元素也可以用\"]},{\"header\":\"4.2 表格独有属性\",\"slug\":\"_4-2-表格独有属性\",\"contents\":[\"CSS 属性名\",\"功能\",\"属性值\",\"table-layout\",\"设置列宽度\",\"auto 自动，列宽度根据内容计算（默认值）fixed 固定列宽，平均分\",\"border-spacing\",\"单元格间距\",\"CSS 中可用的长度值 （生效的前提是单元格边框不能合并）\",\"border-collapse\",\"合并单元格边框\",\"collapse 合并separate 不合并\",\"empty-cells\",\"隐藏没有内容的单元格\",\"show 显示，默认值hide 隐藏 （生效的前提是单元格不能合并）\",\"caption-side\",\"设置表格标题位置\",\"top 上面，默认值bottom 在表格下面\",\"注意：以上 5 个属性，只有表格才能使用，即 <table> 标签\"]},{\"header\":\"5. CSS的背景\",\"slug\":\"_5-css的背景\",\"contents\":[\"通过 CSS 背景属性，可以给页面元素添加背景样式\",\"背景属性可以设置背景颜色、背景图片、背景平铺、背景图片位置、背景图像固定等\"]},{\"header\":\"5.1 背景颜色\",\"slug\":\"_5-1-背景颜色\",\"contents\":[\"样式名称：background-color 定义元素的背景颜色\",\"使用方式：\",\"background-color：颜色值； \",\"其他说明：元素背景颜色默认值是 transparent（透明）\",\"background-color:transparent； \"]},{\"header\":\"5.2 背景图片\",\"slug\":\"_5-2-背景图片\",\"contents\":[\"样式名称：background-image 定义元素的背景图片\",\"使用方式：\",\"background-image:none | url(url); \",\"参数值\",\"作用\",\"none\",\"无背景图（默认的）\",\"url\",\"使用绝对或相对地址指定背景图像\",\"其他说明：实际开发常见于 logo 或者一些装饰性的小图片或者是超大的背景图片, 优点是非常便于控制位置 (精灵图也是一种运用场景)\",\"注意：背景图片后面的地址，千万不要忘记加 url，同时里面的路径不要加引号\"]},{\"header\":\"5.3 背景平铺\",\"slug\":\"_5-3-背景平铺\",\"contents\":[\"样式名称：background-repeat 设置元素背景图像的平铺\",\"使用方式：\",\"background-repeat:repeat | no-repeat | repeat-x | repeat-y; \",\"参数值\",\"作用\",\"repeat\",\"背景图像在纵向和横向上平铺（默认的）\",\"no-repeat\",\"背景图像不平铺\",\"repeat-x\",\"背景图像在横向上平铺\",\"repeat-y\",\"背景图像在纵向上平铺\",\"注意：背景图片会压住背景颜色\"]},{\"header\":\"5.4 背景图片位置\",\"slug\":\"_5-4-背景图片位置\",\"contents\":[\"样式名称：background-position 属性可以改变图片在背景中的位置\",\"使用方式：\",\"background-position:x y; \",\"参数含义：x 坐标和 y 坐标。可以使用方位名词或者精确单位\",\"参数值\",\"说明\",\"length\",\"百分数、由浮点数或单位标识符组成的长度值\",\"position\",\"top、center、bottom、left、center、right 等方位名词\",\"其他说明：\",\"参数是方位名词, 如果指定的两个值都是方位名词，则两个值前后顺序无关，比如 left top 和 top left 效果一致, 如果只指定了一个方位名词，另一个值省略，则第二个值默认居中对齐\",\"参数是精确单位, 如果参数值是精确坐标，那么第一个肯定是 x 坐标，第二个一定是 y 坐标, 如果只指定一个数值，那该数值一定是 x 坐标，另一个默认垂直居中\",\"参数是混合单位, 如果指定的两个值是精确单位和方位名词混合使用，则第一个值是 x 坐标，第二个值是 y 坐标\"]},{\"header\":\"5.5 背景图片固定\",\"slug\":\"_5-5-背景图片固定\",\"contents\":[\"样式名称：background-attachment 属性设置背景图像是否固定或者随着页面的其余部分滚动\",\"使用方式：\",\"background-attachment:scroll | fixed; \",\"参数\",\"作用\",\"scroll\",\"背景图像是随对象内容滚动\",\"fixed\",\"背景图像固定\",\"其他说明：background-attachment 可以制作视差滚动的效果\"]},{\"header\":\"5.6 背景样式复合写法\",\"slug\":\"_5-6-背景样式复合写法\",\"contents\":[\"背景合写样式：background: 背景颜色、背景图片地址、背景平铺、背景图像滚动、背景图片位置;\",\"使用方式：\",\"background: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置； \"]},{\"header\":\"5.7 背景色半透明\",\"slug\":\"_5-7-背景色半透明\",\"contents\":[\"CSS3 提供了背景颜色半透明的效果\",\"使用方式：\",\"background：rgba(0,0,0,0.3); \",\"最后一个参数是 alpha 透明度，取值范围在 0~1 之间\",\"我们习惯把 0.3 的 0 省略掉，写为 background:rgba(0,0,0,.3);\",\"注意：\",\"背景半透明是指盒子背景半透明，盒子里面的内容不受影响\"]},{\"header\":\"5.8 背景总结\",\"slug\":\"_5-8-背景总结\",\"contents\":[\"属性\",\"作用\",\"值\",\"background-color\",\"背景颜色\",\"预定义的颜色值/十六进制/RGB 代码\",\"background-image\",\"背景图片\",\"url (图片路径)\",\"background-repeat\",\"是否平铺\",\"repeat/no-repeat/repeat-x/repeat-y\",\"background-position\",\"背景位置\",\"length/position 分别是 x 和 y 坐标\",\"background-attachment\",\"背景附着\",\"scroll（背景滚动）/fixed（背景固定）\",\"背景简写\",\"书写更简单\",\"背景颜色、背景图片地址、背景平铺、背景图像滚动、背景图片位置\",\"背景色半透明\",\"背景颜色半透明\",\"background: rgba ()\"]},{\"header\":\"6. CSS鼠标属性\",\"slug\":\"_6-css鼠标属性\",\"contents\":[\"CSS 属性名\",\"功能\",\"属性值\",\"cursor\",\"设置鼠标光标的样式\",\"pointer 小手move 移动图标 text 文字选择器 crosshair 十字架wait 等待help 帮助\",\"扩展：自定义鼠标图标\",\"/* 自定义鼠标光标 */ cursor: url(\\\"./arrow.png\\\"),pointer; \"]}]},\"/front-end/css-notes/06-CSS%E5%85%83%E7%B4%A0%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F.html\":{\"title\":\"CSS元素显示模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"定义：元素显示模式就是元素（标签）以什么方式进行显示，比如 <div> 自己占一行，比如一行可以放多个 <span>\",\"作用：网页的标签非常多，在不同地方会用到不同类型的标签，了解他们的特点可以更好的布局我们的网页\"]},{\"header\":\"1. 元素显示模式的分类\",\"slug\":\"_1-元素显示模式的分类\",\"contents\":[]},{\"header\":\"1.1 块元素\",\"slug\":\"_1-1-块元素\",\"contents\":[\"<!-- 主体结构标签 --> <html>、<body> <!-- 排版标签 --> <h1>~<h6>、<hr>、<p>、<pre>、<div> <!-- 列表标签 --> <ul>、<ol>、<li>、<dl>、<dt>、<dd> <!-- 表格相关标签 --> <table>、<tbody>、<thead>、<tfoot>、<tr>、<caption> <!-- 表单相关标签 --> <form>与<option> \",\"块级元素的特点：\",\"在页面中独占一行，不会与任何元素共用一行，是从上到下排列的\",\"默认宽度：撑满父元素\",\"默认高度：由内容撑开\",\"可以通过 CSS 设置宽高\",\"注意：\",\"文字类的元素内不能放块级元素\",\"<p> 标签主要用于存放文字，因此 <p> 里面不能放块级元素，特别是不能放 <div>\",\"<h1>~<h6> 等都是文字类块级标签，里面也不能放其他块级元素\"]},{\"header\":\"1.2 行内元素\",\"slug\":\"_1-2-行内元素\",\"contents\":[\"<!-- 文本标签 --> <br>、<em>、<strong>、<sup>、<sub>、<del>、<ins> <!-- 其它标签 --> <a>与<label> \",\"<span> 标签是最典型的行内元素。有的地方也将行内元素称为内联元素\",\"行内元素的特点：\",\"在页面中不独占一行，一行中不能容纳下的行内元素，会在下一行继续从左到右排列\",\"默认宽度：由内容撑开\",\"默认高度：由内容撑开\",\"无法通过 CSS 设置宽高\",\"注意：\",\"链接里面不能再放链接\",\"特殊情况链接 <a> 里面可以放块级元素，但是给 <a> 转换成块级模式最安全\"]},{\"header\":\"1.3 行内块元素\",\"slug\":\"_1-3-行内块元素\",\"contents\":[\"<!-- 图片 --> <img> <!-- 单元格 --> <td>、<th> <!-- 表单控件 --> <input>、<textarea>、<select>、<button> <!-- 框架标签 --> <iframe> \",\"它们同时具有块元素和行内元素的特点\",\"行内块元素的特点：\",\"在页面中不独占一行，一行中不能容纳下的行内元素，会在下一行继续从左到右排 列\",\"默认宽度：由内容撑开\",\"默认高度：由内容撑开\",\"可以通过 CSS 设置宽高\"]},{\"header\":\"1.4 总结\",\"slug\":\"_1-4-总结\",\"contents\":[\"元素模式\",\"元素排列\",\"设置样式\",\"默认宽度\",\"包含\",\"块级元素\",\"一行只能放一个块级元素\",\"可以设置宽度高度\",\"容器的 100%\",\"容器可以包含任何标签\",\"行内元素\",\"一行可以放多个行内元素\",\"不可以直接设置宽度高度\",\"它本身内容的宽度\",\"容纳文本或其他行内元素\",\"行内块元素\",\"一行放多个行内块元素\",\"可以设置宽度和高度\",\"它本身内容的宽度\"]},{\"header\":\"2. 元素显示模式的转换\",\"slug\":\"_2-元素显示模式的转换\",\"contents\":[\"通过 CSS 中的 display 属性可以修改元素的默认显示模式\",\"转换方式：\",\"转换为块元素：display: block;\",\"转换为行内元素：display: inline;\",\"转换为行内块：display: inline-block;\",\"隐藏：display: none;\"]}]},\"/front-end/css-notes/07-CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.html\":{\"title\":\"CSS盒子模型\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"CSS 会把所有的 HTML 元素都看成一个盒子，所有的样式也都是基于这个盒子\",\"margin（外边距）： 盒子与外界的距离\",\"border（边框）： 盒子的边框\",\"padding（内边距）： 紧贴内容的补白区域\",\"content（内容）：元素中的文本或后代元素都是它的内容\",\"CSS盒子模型01.png\",\"盒子的大小=content+左右padding+左右border\",\"注意：外边距 margin 不会影响盒子的大小，但会影响盒子的位置\"]},{\"header\":\"1. 盒子内容区（content）\",\"slug\":\"_1-盒子内容区-content\",\"contents\":[\"CSS 属性名\",\"功能\",\"属性值\",\"width\",\"设置内容区域宽度\",\"长度\",\"max-width\",\"设置内容区域的最大宽度\",\"长度\",\"min-width\",\"设置内容区域的最小宽度\",\"长度\",\"height\",\"设置内容区域高度\",\"长度\",\"max-height\",\"设置内容区域的最大高度\",\"长度\",\"min-height\",\"设置内容区域的最小高度\",\"长度\",\"注意：\",\"max-width 、 min-width 一般不与 width 一起使用\",\"max-height 、 min-height 一般不与 height 一起使用\"]},{\"header\":\"2. 盒子内边距（padding）\",\"slug\":\"_2-盒子内边距-padding\",\"contents\":[\"CSS 属性名\",\"功能\",\"属性值\",\"padding-top\",\"上内边距\",\"长度\",\"padding-right\",\"右内边距\",\"长度\",\"padding-bottom\",\"下内边距\",\"长度\",\"padding-left\",\"左内边距\",\"长度\",\"padding\",\"复合属性\",\"长度，可以设置 1~4 个值\",\"padding 复合属性的使用规则：\",\"padding: 10px; 四个方向内边距都是 10px\",\"padding: 10px 20px; 上下 10px ，左右 20px 。（上下、左右）\",\"padding: 10px 20px 30px; 上 10px ，左右 20px ，下 30px 。（上、左右、下）\",\"padding: 10px 20px 30px 40px; 上 10px ，右 20px ，下 30px ，左 40px 。（上、右、下、左）\",\"注意点：\",\"padding 的值不能为负数\",\"行内元素的左右内边距是没问题的，上下内边距不能完美的设置\",\"块级元素、行内块元素，四个方向内边距都可以完美设置\"]},{\"header\":\"3. 盒子边框（border）\",\"slug\":\"_3-盒子边框-border\",\"contents\":[\"border 可以设置元素的边框\",\"边框由三部分组成：边框宽度 (粗细)、边框样式、边框颜色\",\"语法：\",\"border : border-width || border-style || border-color; \",\"属性\",\"作用\",\"border-width\",\"定义边框粗细，单位是 px\",\"border-style\",\"边框的样式\",\"border-color\",\"边框颜色\",\"边框样式 border-style 可以设置如下值：\",\"none：没有边框即忽略所有边框的宽度（默认值）\",\"solid：边框为单实线 (最为常用的)\",\"dashed：边框为虚线\",\"dotted：边框为点线\",\"边框简写：\",\"border: 1px solid red; /* 没有顺序 */ \",\"边框分开写法：\",\"border-top: 1px solid red; /* 只设定上边框， 其余同理 */ \"]},{\"header\":\"4. 盒子外边距（margin）\",\"slug\":\"_4-盒子外边距-margin\",\"contents\":[\"margin 属性用于设置外边距，即控制盒子和盒子之间的距离\",\"属性\",\"作用\",\"margin-left\",\"左外边距\",\"margin-right\",\"右外边距\",\"margin-top\",\"上外边距\",\"margin-bottom\",\"下外边距\"]},{\"header\":\"4.1 margin注意事项\",\"slug\":\"_4-1-margin注意事项\",\"contents\":[\"子元素的 margin ，是参考父元素的 content 计算的。（因为是父亲的 content 中承装着子元素）\",\"上 margin 、左 margin ：影响自己的位置；下 margin 、右 margin ：影响后面兄弟元素的位置\",\"块级元素、行内块元素，均可以完美地设置四个方向的 margin ；但行内元素，左右 margin 可以完美设置，上下 margin 设置无效\",\"margin 的值也可以是 auto ，如果给一个块级元素设置左右 margin 都为 auto ，该块级元素会在父元素中水平居中\",\"margin 的值可以是负值\"]},{\"header\":\"4.2 margin合并问题\",\"slug\":\"_4-2-margin合并问题\",\"contents\":[\"上面兄弟元素的下外边距和下面兄弟元素的上外边距会合并，取一个最大的值，而不是相加\",\"相邻块元素垂直外边距的合并\",\"当上下相邻的两个块元素（兄弟关系）相遇时，如果上面的元素有下外边距 margin-bottom，下面的元素有上外边距 margin-top ，则他们之间的垂直间距不是 margin-bottom 与 margin-top 之和。取两个值中的较大者这种现象被称为相邻块元素垂直外边距的合并\",\"解决方案：尽量只给一个盒子添加 margin 值\",\"CSS盒子模型02.png\"]},{\"header\":\"4.3 margin塌陷问题\",\"slug\":\"_4-3-margin塌陷问题\",\"contents\":[\"第一个子元素的上margin会作用在父元素上，最后一个子元素的下margin会作用在父元素上\",\"嵌套块元素垂直外边距的塌陷\",\"对于两个嵌套关系（父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值\",\"解决方案： \",\"可以为父元素定义上边框（border）\",\"可以为父元素定义上内边距（padding）\",\"可以为父元素添加 overflow:hidden\",\"CSS盒子模型03.png\"]}]},\"/front-end/css-notes/08-CSS%E5%85%83%E7%B4%A0%E6%98%BE%E7%A4%BA%E4%B8%8E%E9%9A%90%E8%97%8F.html\":{\"title\":\"CSS元素显示与隐藏\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"目的：让一个元素在页面中消失或者显示出来\",\"场景：类似网站广告，当我们点击关闭就不见了，但是我们重新刷新页面，会重新出现\"]},{\"header\":\"1. display显示\",\"slug\":\"_1-display显示\",\"contents\":[\"display 属性用于设置一个元素应如何显示\",\"display: none； /* 隐藏对象 */ display：block；/* 除了转换为块级元素之外，同时还有显示元素的意思 */ \",\"特点： display 隐藏元素后，不再占有原来的位置\"]},{\"header\":\"2. visibility可见性\",\"slug\":\"_2-visibility可见性\",\"contents\":[\"visibility 属性用于指定一个元素应可见还是隐藏\",\"visibility：visible; /* 元素可视 */ visibility：hidden; /* 元素隐藏 */ \",\"特点：visibility 隐藏元素后，继续占有原来的位置\",\"如果隐藏元素想要原来位置，就用 visibility:hidden;\",\"如果隐藏元素不想要原来位置，就用 display:none;\"]},{\"header\":\"3. overflow溢出\",\"slug\":\"_3-overflow溢出\",\"contents\":[\"overflow 属性指定了如果内容溢出一个元素的框（超过其指定高度及宽度） 时，会发生什么\",\"属性值\",\"描述\",\"visible\",\"不剪切内容也不添加滚动条\",\"hidden\",\"不显示超过对象尺寸的内容，超出的部分隐藏掉\",\"scroll\",\"不管超出内容否，总是显示滚动条\",\"auto\",\"超出自动显示滚动条，不超出不显示滚动条\",\"一般情况下，我们都不想让溢出的内容显示出来，因为溢出的部分会影响布局\",\"但是如果有定位的盒子，请慎用 overflow:hidden 因为它会隐藏多余的部分\",\"用途\",\"清除浮动\",\"保证盒子里面的内容不会超出该盒子范围\"]},{\"header\":\"4. 显示与隐藏总结\",\"slug\":\"_4-显示与隐藏总结\",\"contents\":[\"属性\",\"区别\",\"用途\",\"display 显示\",\"隐藏对象，不保留位置\",\"配合后面 js 做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单，应用极为广泛\",\"visibility 可见性\",\"隐藏对象，保留位置\",\"使用较少\",\"overflow 溢出\",\"只是隐藏超出大小的部分\",\"1. 可以清除浮动2. 保证盒子里面的内容不会超出该盒子范围\"]}]},\"/front-end/css-notes/09-CSS%E4%BC%A0%E7%BB%9F%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F.html\":{\"title\":\"CSS传统网页布局方式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"CSS 提供了三种传统布局方式 (简单说, 就是盒子如何进行排列)：\",\"普通流（标准流）\",\"浮动\",\"定位\",\"这三种布局方式都是用来摆放盒子的，盒子摆放到合适位置，布局自然就完成了\",\"注意：实际开发中，一个页面基本都包含了这三种布局方式\"]},{\"header\":\"1. 标准流（普通流/文档流）\",\"slug\":\"_1-标准流-普通流-文档流\",\"contents\":[\"所谓的标准流: 就是标签按照规定好默认方式排列\",\"块级元素会独占一行，从上向下顺序排列 \",\"常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table\",\"行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行 \",\"常用元素：span、a、i、em 等\",\"标准流是最基本的布局方式\"]},{\"header\":\"2. 浮动\",\"slug\":\"_2-浮动\",\"contents\":[]},{\"header\":\"2.1 为什么需要浮动\",\"slug\":\"_2-1-为什么需要浮动\",\"contents\":[\"有很多的布局效果，标准流没有办法完成，此时就可以利用浮动完成布局。因为浮动可以改变元素标签默认的排列方式\",\"浮动最典型的应用：可以让多个块级元素一行内排列显示\",\"网页布局第一准则：多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动\"]},{\"header\":\"2.2 什么是浮动\",\"slug\":\"_2-2-什么是浮动\",\"contents\":[\"float 属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及块或另一个浮动框的边缘\",\"语法：\",\" 选择器 { float: 属性值; } \",\"属性值\",\"描述\",\"none\",\"元素不浮动（默认值）\",\"left\",\"元素向左浮动\",\"right\",\"元素向右浮动\"]},{\"header\":\"2.3 浮动特性\",\"slug\":\"_2-3-浮动特性\",\"contents\":[\"加了浮动之后的元素, 会具有很多特性：\",\"浮动元素会脱离标准流 (脱标：浮动的盒子不再保留原先的位置)\",\"CSS传统网页布局方式01.png\",\"浮动的元素会一行内显示并且元素顶部对齐\",\"注意：浮动的元素是互相贴靠在一起的（不会有缝隙），如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐\",\"浮动的元素会具有行内块元素的特性\",\"任何元素都可以浮动，如果块级盒子没有设置宽度，默认宽度和父级一样宽，但是添加浮动后，它的大小根据内容来决定\",\"浮动的盒子中间是没有缝隙的\"]},{\"header\":\"2.4 浮动布局注意点\",\"slug\":\"_2-4-浮动布局注意点\",\"contents\":[\"浮动和标准流的父盒子搭配\",\"为了约束浮动元素位置, 我们网页布局一般采取的策略是：先用标准流父元素排列上下位置, 之后内部子元素采取浮动排列左右位置，符合网页布局第一准侧\",\"CSS传统网页布局方式02.png\",\"先用标准流的父元素排列上下位置, 之后内部子元素采取浮动排列左右位置\",\"一个元素浮动了，理论上其余的兄弟元素也要浮动\",\"一个盒子里面有多个子盒子，如果其中一个盒子浮动了，其他兄弟也应该浮动，以防止引起问题\",\"浮动的盒子只会影响浮动盒子后面的标准流, 不会影响前面的标准流\"]},{\"header\":\"2.5 清除浮动\",\"slug\":\"_2-5-清除浮动\",\"contents\":[]},{\"header\":\"2.5.1 为什么需要清除浮动\",\"slug\":\"_2-5-1-为什么需要清除浮动\",\"contents\":[\"由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为 0 时，就会影响下面的标准流盒子\"]},{\"header\":\"2.5.2 清除浮动本质\",\"slug\":\"_2-5-2-清除浮动本质\",\"contents\":[\"清除浮动的本质是清除浮动元素造成的影响：浮动的子标签无法撑开父盒子的高度\",\"注意：\",\"如果父盒子本身有高度，则不需要清除浮动\",\"清除浮动之后，父级就会根据浮动的子盒子自动检测高度，父级有了高度，就不会影响下面的标准流了\"]},{\"header\":\"2.5.3 清除浮动样式\",\"slug\":\"_2-5-3-清除浮动样式\",\"contents\":[\"语法：\",\" 选择器{clear:属性值;} \",\"属性值\",\"描述\",\"left\",\"不允许左侧有浮动元素（清除左侧浮动的影响）\",\"right\",\"不允许右侧有浮动元素（清除右侧浮动的影响）\",\"both\",\"同时清除左右两侧浮动的影响\",\"清除浮动的策略是: 闭合浮动\"]},{\"header\":\"2.5.4 清除浮动的多种方式\",\"slug\":\"_2-5-4-清除浮动的多种方式\",\"contents\":[]},{\"header\":\"2.5.4.1 额外标签法\",\"slug\":\"_2-5-4-1-额外标签法\",\"contents\":[\"额外标签法也称为隔墙法，是 W3C 推荐的做法\",\"使用方式：额外标签法会在浮动元素末尾添加一个空的标签\",\"例如 <div style=\\\"clear:both\\\"></div>，或者其他标签（如<br/>等） \",\"优点： 通俗易懂，书写方便\",\"缺点： 添加许多无意义的标签，结构化较差\",\"注意： 要求这个新的空标签必须是块级元素\"]},{\"header\":\"2.5.4.2 父级添加overflow属性\",\"slug\":\"_2-5-4-2-父级添加overflow属性\",\"contents\":[\"可以给父级添加 overflow 属性，将其属性值设置为 hidden、 auto 或 scroll\",\"例如：\",\"overflow:hidden | auto | scroll; \",\"优点：代码简洁\",\"缺点：无法显示溢出的部分\",\"注意：是给父元素添加代码\"]},{\"header\":\"2.5.4.3 父级添加after伪元素\",\"slug\":\"_2-5-4-3-父级添加after伪元素\",\"contents\":[\":after 方式是额外标签法的升级版，给父元素添加：\",\" .clearfix:after { content: \\\"\\\"; display: block; height: 0; clear: both; visibility: hidden; } .clearfix { /* IE6、7 专有 */ *zoom: 1; } \",\"优点：没有增加标签，结构更简单\",\"缺点：兼容性问题\"]},{\"header\":\"2.5.4.4 父级添加双伪元素\",\"slug\":\"_2-5-4-4-父级添加双伪元素\",\"contents\":[\"给父元素添加：\",\" .clearfix:before,.clearfix:after { content:\\\"\\\"; display:table; } .clearfix:after { clear:both; } .clearfix { *zoom:1; } \",\"优点：代码更简洁\",\"缺点：兼容性问题\"]},{\"header\":\"2.6 总结\",\"slug\":\"_2-6-总结\",\"contents\":[\"为什么需要清除浮动？\",\"父级没高度\",\"子盒子浮动了\",\"影响下面布局了，我们就应该清除浮动了\",\"清除浮动的方式\",\"优点\",\"缺点\",\"额外标签法\",\"通俗易懂，书写方便\",\"添加许多无意义的标签，结构化较差\",\"父级 overflow:hidden;\",\"书写简单\",\"溢出隐藏\",\"父级 after 伪元素\",\"结构语义化，代码简洁\",\"兼容性问题\",\"父级双伪元素\",\"结构语义化，代码简洁\",\"兼容性问题\"]},{\"header\":\"3. 定位\",\"slug\":\"_3-定位\",\"contents\":[]},{\"header\":\"3.1 为什么使用定位\",\"slug\":\"_3-1-为什么使用定位\",\"contents\":[\"浮动可以让多个块级盒子一行没有缝隙排列显示，经常用于横向排列盒子\",\"定位则是可以让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子\"]},{\"header\":\"3.2 定位组成\",\"slug\":\"_3-2-定位组成\",\"contents\":[\"定位：将盒子定在某一个位置，所以定位也是在摆放盒子，按照定位的方式移动盒子\",\"定位也是用来布局的，它有两部分组成：定位 = 定位模式 + 边偏移\",\"定位模式 用于指定一个元素在文档中的定位方式\",\"边偏移则决定了该元素的最终位置\"]},{\"header\":\"3.2.1 边偏移（方位名词）\",\"slug\":\"_3-2-1-边偏移-方位名词\",\"contents\":[\"边偏移 就是定位的盒子移动到最终位置。有 top、bottom、left 和 right 4 个属性\",\"边偏移属性\",\"示例\",\"描述\",\"top\",\"top: 80px\",\"顶端偏移量，定义元素相对于其父元素上边线的距离\",\"bottom\",\"bottom: 80px\",\"底部偏移量，定义元素相对于其父元素下边线的距离\",\"left\",\"left: 80px\",\"左侧偏移量，定义元素相对于其父元素左边线的距离\",\"right\",\"right: 80px\",\"右侧偏移量，定义元素相对于其父元素右边线的距离\",\"定位的盒子有了边偏移才有价值。一般情况下，凡是有定位的地方必有边偏移\"]},{\"header\":\"3.2.2 定位模式（position）\",\"slug\":\"_3-2-2-定位模式-position\",\"contents\":[\"在 CSS 中，通过 position 属性定义元素的定位模式，语法如下：\",\"选择器 { position: 属性值; } \",\"定位模式是有不同分类的，在不同情况下，我们用到不同的定位模式\",\"定位模式决定元素的定位方式，它通过 CSS 的 position 属性来设置，其值可以分为四个：\",\"值\",\"语义\",\"static\",\"静态定位\",\"relative\",\"相对定位\",\"absolute\",\"绝对定位\",\"fixed\",\"固定定位\"]},{\"header\":\"3.2.2.1 静态定位 (static)\",\"slug\":\"_3-2-2-1-静态定位-static\",\"contents\":[\"静态定位是元素的默认定位方式，无定位的意思，在不需要定位的时候用\",\"语法：\",\"选择器 { position: static; } \",\"静态定位按照标准流特性摆放位置，它没有边偏移，静态定位在布局时几乎不用\"]},{\"header\":\"3.2.2.2 相对定位 (relative)\",\"slug\":\"_3-2-2-2-相对定位-relative\",\"contents\":[\"相对定位是元素在移动位置的时候，是相对于它自己原来的位置来说的\",\"语法：\",\"选择器 { position: relative; } \",\"相对定位的特点：（务必记住）\",\"它是相对于自己原来的位置来移动的（移动位置的时候参照点是自己原来的位置）\",\"原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待它，因此，相对定位并没有脱标\"]},{\"header\":\"3.2.2.3 绝对定位 (absolute)\",\"slug\":\"_3-2-2-3-绝对定位-absolute\",\"contents\":[]},{\"header\":\"3.2.2.3.1 绝对定位的介绍\",\"slug\":\"_3-2-2-3-1-绝对定位的介绍\",\"contents\":[\"绝对定位是元素在移动位置的时候，是相对于它祖先元素来说的\",\"语法：\",\" 选择器 { position: absolute; } \",\"绝对定位的特点：\",\"完全脱标 —— 完全不占位置\",\"如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位（Document 文档）\",\"如果祖先元素有定位 (相对、绝对、固定定位)，则以最近一级的有定位祖先元素为参考点移动位置\"]},{\"header\":\"3.2.2.3.2 定位口诀——子绝父相\",\"slug\":\"_3-2-2-3-2-定位口诀——子绝父相\",\"contents\":[\"子级是绝对定位的话，父级要用相对定位\",\"子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子\",\"父盒子需要加定位限制子盒子在父盒子内显示\",\"父盒子布局时，需要占有位置，因此父亲只能是相对定位\",\"父级要占有位置，子级要任意摆放这就是子绝父相的由来，所以相对定位经常用来作为绝对定位的父级\",\"总结： 因为父级需要占有位置，因此是相对定位， 子盒子不需要占有位置，则是绝对定位\",\"当然，子绝父相不是永远不变的，如果父元素不需要占有位置，子绝父绝也会遇到\"]},{\"header\":\"3.2.2.4 固定定位 (fixed)\",\"slug\":\"_3-2-2-4-固定定位-fixed\",\"contents\":[\"固定定位是元素固定于浏览器可视区的位置\",\"主要使用场景：可以在浏览器页面滚动时元素的位置不会改变\",\"语法：\",\" 选择器 { position: fixed; } \",\"固定定位的特点：\",\"以浏览器的可视窗口为参照点移动元素\",\"跟父元素没有任何关系\",\"不随滚动条滚动\",\"固定定位不再占有原先的位置\",\"固定定位也是脱标的，其实固定定位也可以看做是一种特殊的绝对定位\"]},{\"header\":\"3.2.2.5 粘性定位 (sticky)\",\"slug\":\"_3-2-2-5-粘性定位-sticky\",\"contents\":[\"粘性定位可以被认为是相对定位和固定定位的混合\",\"语法：\",\" 选择器 { position: sticky; top: 10px; } \",\"粘性定位的特点：\",\"以浏览器的可视窗口为参照点移动元素（固定定位特点）\",\"粘性定位占有原先的位置（相对定位特点）\",\"必须添加 top 、left、right、bottom 其中一个才有效\"]},{\"header\":\"3.2.2.6 总结\",\"slug\":\"_3-2-2-6-总结\",\"contents\":[\"定位模式\",\"是否脱标\",\"移动位置\",\"是否常用\",\"static 静态定位\",\"否\",\"不能使用边偏移\",\"很少\",\"relative 相对定位\",\"否 (占有位置)\",\"相对于自身位置移动\",\"基本单独使用\",\"absolute绝对定位\",\"是（不占有位置）\",\"带有定位的父级\",\"要和定位父级元素搭配使用\",\"fixed 固定定位\",\"是（不占有位置）\",\"浏览器可视区\",\"单独使用，不需要父级\",\"sticky 粘性定位\",\"否 (占有位置)\",\"浏览器可视区\",\"当前阶段少\",\"注意：\",\"边偏移需要和定位模式联合使用，单独使用无效\",\"top 和 bottom 不要同时使用\",\"left 和 right 不要同时使用\"]},{\"header\":\"3.3 定位的应用\",\"slug\":\"_3-3-定位的应用\",\"contents\":[\"固定定位小技巧： 固定在版心右侧位置\",\"小算法：\",\"让固定定位的盒子 left: 50%;，走到浏览器可视区（也可以看做版心）的一半位置\",\"让固定定位的盒子 margin-left: 版心宽度的一半距离; 多走版心宽度的一半位置\",\"就可以让固定定位的盒子贴着版心右侧对齐了\"]},{\"header\":\"3.4 定位堆叠顺序 (z-index)\",\"slug\":\"_3-4-定位堆叠顺序-z-index\",\"contents\":[\"在使用定位布局时，可能会出现盒子重叠的情况，此时，可以使用 z-index 来控制盒子的前后次序 (z轴)\",\"语法：\",\"选择器 { z-index: 1; } \",\"z-index 的特性如下：\",\"属性值：正整数、负整数或0，默认值是0，数值越大，盒子越靠上\",\"如果属性值相同，则按照书写顺序，后来者居上\",\"数字后面不能加单位\",\"注意：z-index 只能应用于相对定位、绝对定位和固定定位的元素，其他标准流、浮动和静态定位无效\"]},{\"header\":\"3.5 定位的拓展\",\"slug\":\"_3-5-定位的拓展\",\"contents\":[]},{\"header\":\"3.5.1 绝对定位的盒子居中\",\"slug\":\"_3-5-1-绝对定位的盒子居中\",\"contents\":[\"注意：加了绝对定位/固定定位的盒子不能通过设置 margin: auto 设置水平居中，但是可以通过以下计算方法实现水平和垂直居中，可以按照下图的方法：\",\"left: 50%; 让盒子的左侧移动到父级元素的水平中心位置\",\"margin-left: -x px; 让盒子向左移动自身宽度的一半\"]},{\"header\":\"3.5.2 定位特殊特性\",\"slug\":\"_3-5-2-定位特殊特性\",\"contents\":[\"绝对定位和固定定位也和浮动类似：\",\"行内元素添加绝对或者固定定位，可以直接设置高度和宽度\",\"块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小\",\"display 是显示模式，可以改变显示模式有以下方式:\",\"可以用 inline-block 转换为行内块\",\"可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的）\",\"绝对定位和固定定位也和浮动类似，默认转换的特性转换为行内块\",\"所以说，一个行内的盒子，如果加了浮动、固定定位和绝对定位，不用转换，就可以给这个盒子直接设置宽度和高度等\"]},{\"header\":\"3.5.3 脱标的盒子不会触发外边距塌陷\",\"slug\":\"_3-5-3-脱标的盒子不会触发外边距塌陷\",\"contents\":[\"浮动元素、绝对定位 (固定定位）元素的都不会触发外边距合并的问题\",\"也就是说，我们给盒子改为了浮动或者定位，就不会有垂直外边距合并的问题\"]},{\"header\":\"3.5.4 绝对定位(固定定位)会完全压住盒子\",\"slug\":\"_3-5-4-绝对定位-固定定位-会完全压住盒子\",\"contents\":[\"浮动元素不同，只会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字，但是绝对定位（固定定位）会压住下面标准流所有的内容\",\"浮动之所以不会压住文字，因为浮动产生的目的最初是为了做文字环绕效果的，文字会围绕浮动元素\"]}]},\"/front-end/css-notes/10-CSS%E7%B2%BE%E7%81%B5%E5%9B%BE.html\":{\"title\":\"CSS精灵图\",\"contents\":[{\"header\":\"1. 为什么需要精灵图\",\"slug\":\"_1-为什么需要精灵图\",\"contents\":[\"一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接收和发送请求图片，造成服务器请求压力过大，这将大大降低页面的加载速度\",\"为了有效地减少服务器接收和发送请求的次数，提高页面的加载速度，出现了 CSS 精灵技术（也称 CSS Sprites、CSS 雪碧图）\",\"核心原理：将网页中的一些小背景图像整合到一张大图中，这样服务器只需要一次请求就可以了\"]},{\"header\":\"2. 精灵图（sprites）的使用\",\"slug\":\"_2-精灵图-sprites-的使用\",\"contents\":[\"使用精灵图核心：\",\"精灵技术主要针对于背景图片使用。就是把多个小背景图片整合到一张大图片中\",\"这个大图片也称为 sprites 精灵图或者雪碧图\",\"移动背景图片位置，此时可以使用 background-position\",\"移动的距离就是这个目标图片的 x 和 y 坐标。注意网页中的坐标有所不同\",\"因为一般情况下都是往上往左移动，所以数值是负值\",\"使用精灵图的时候需要精确测量，每个小背景图片的大小和位置\",\"例：\",\"效果：\",\"CSS精灵图01.png\",\"精灵图：\",\"CSS精灵图02.jpg\",\"结构：\",\"<span class=\\\"p\\\">p</span> <span class=\\\"i\\\">i</span> <span class=\\\"n\\\">n</span> <span class=\\\"k\\\">k</span> \",\"样式：\",\"span { display: inline-block; background: url(images/abcd.jpg) no-repeat; } .p { width: 100px; height: 112px; /* background-color: pink; */ background-position: -493px -276px; } .i { width: 60px; height: 108px; /* background-color: pink; */ background-position: -327px -142px; } .n { width: 108px; height: 109px; /* background-color: pink; */ background-position: -215px -141px; } .k { width: 105px; height: 114px; /* background-color: pink; */ background-position: -495px -142px; } \"]}]},\"/front-end/css-notes/11-CSS%E5%B8%83%E5%B1%80%E6%8A%80%E5%B7%A7.html\":{\"title\":\"CSS布局技巧\",\"contents\":[{\"header\":\"1. margin负值运用\",\"slug\":\"_1-margin负值运用\",\"contents\":[\"让每个盒子 margin 往左侧移动-1px 正好压住相邻盒子边框\",\"鼠标经过某个盒子的时候，提高当前盒子的层级即可（如果没有有定位，则加相对定位（保留位置），如果有定位，则加（z-index）\"]},{\"header\":\"2. 文字围绕浮动元素\",\"slug\":\"_2-文字围绕浮动元素\",\"contents\":[\"利用浮动元素不会压住文字的特性实现\"]},{\"header\":\"3. 行内块巧妙运用\",\"slug\":\"_3-行内块巧妙运用\",\"contents\":[\"页面底部页码栏\",\"页码在页面中间显示:\",\"把这些链接盒子转换为行内块，之后给父级指定 text-align: center;\",\"利用行内块元素中间有缝隙，并且给父级添加 text-align: center; 行内块元素会水平会居中\"]},{\"header\":\"4. CSS三角形\",\"slug\":\"_4-css三角形\",\"contents\":[\"网页中常见一些三角形，使用 CSS 直接画出来就可以，不必做成图片或者字体图标\",\"我们用 CSS 边框可以模拟三角效果\",\"宽度高度为 0\",\"我们 4 个边框都要写，只保留需要的边框颜色，其余的不能省略，都改为 transparent 透明就好了\",\"为了照顾兼容性低版本的浏览器，加上 font-size: 0;line-height: 0;\"]},{\"header\":\"5. 关于默认宽度\",\"slug\":\"_5-关于默认宽度\",\"contents\":[\"所谓的默认宽度，就是不设置 width 属性时，元素所呈现出来的宽度\",\"总宽度 = 父的content - 自身的左右margin\",\"内容区的宽度 = 父的content - 自身的左右margin - 自身的左右border - 自身的左右padding\"]},{\"header\":\"6. 行内元素、行内块元素\",\"slug\":\"_6-行内元素、行内块元素\",\"contents\":[\"行内元素、行内块元素，可以被父元素当做文本处理\"]},{\"header\":\"7. 如何让子元素在父亲中水平居中\",\"slug\":\"_7-如何让子元素在父亲中水平居中\",\"contents\":[\"若子元素为块元素，给父元素加上： margin:0 auto; 若子元素为行内元素、行内块元素，给父元素加上： text-align:center;\"]},{\"header\":\"8. 如何让子元素在父亲中垂直居中\",\"slug\":\"_8-如何让子元素在父亲中垂直居中\",\"contents\":[\"（若想绝对垂直居中，父元素 font-size 设置为 0）\",\"若子元素为块元素，给子元素加上： margin-top ，值为：(父元素content －子元素盒子总高) / 2\",\"若子元素为行内元素、行内块元素：让父元素的 height = line-height ，每个子元素都加上： vertical-align: middle;\"]},{\"header\":\"9. 元素之间的空白问题\",\"slug\":\"_9-元素之间的空白问题\",\"contents\":[\"产生原因：行内元素、行内块元素，彼此之间的换行会被浏览器解析为一个空白字符\",\"解决方案：\",\"方案一： 去掉换行和空格（不推荐）\",\"方案二： 给父元素设置 font-size: 0 ，再给需要显示文字的元素，单独设置字体大小（推荐）\"]},{\"header\":\"10. 行内块的幽灵空白问题\",\"slug\":\"_10-行内块的幽灵空白问题\",\"contents\":[\"产生原因：行内块元素与文本的基线对齐，而文本的基线与文本最底端之间是有一定距离的\",\"解决方案：\",\"方案一： 给行内块设置 vertical-align ，值不为 baseline 即可，设置为 middel 、 bottom 、 top 均可\",\"方案二： 若父元素中只有一张图片，设置图片为 display: block;\",\"方案三： 给父元素设置 font-size: 0;。如果该行内块内部还有文本，则需单独设置 font-size\"]},{\"header\":\"11. 常用布局名词\",\"slug\":\"_11-常用布局名词\",\"contents\":[\"位置\",\"名词\",\"顶部导航条\",\"topbar\",\"页头\",\"header、page-header\",\"导航\",\"nav、navigator、navbar\",\"搜索框\",\"search、search-box\",\"横幅、广告、宣传图\",\"banner\",\"主要内容\",\"content、main\",\"侧边栏\",\"aside、sidebar\",\"页脚\",\"footer、page-footer\"]},{\"header\":\"12. 重置默认样式（CSS初始化）\",\"slug\":\"_12-重置默认样式-css初始化\",\"contents\":[\"很多元素都有默认样式，比如：\",\"p 元素有默认的上下 margin\",\"h1~h6 标题也有上下 margin ，且字体加粗\",\"body 元素有默认的 8px 外边距\",\"超链接有默认的文字颜色和下划线\",\"ul 元素有默认的左 padding\",\"……\"]},{\"header\":\"12.1 使用全局选择器\",\"slug\":\"_12-1-使用全局选择器\",\"contents\":[\"* { margin: 0; padding: 0; ...... } \"]},{\"header\":\"12.2 reset.css\",\"slug\":\"_12-2-reset-css\",\"contents\":[\"选择到具有默认样式的元素，清空其默认的样式\"]},{\"header\":\"12.3 Normalize.css\",\"slug\":\"_12-3-normalize-css\",\"contents\":[\"Normalize.css 是一种最新方案，它在清除默认样式的基础上，保留了一些有价值的默认样式\",\"官网地址：Normalize.css\",\"相对于 reset.css ， Normalize.css 有如下优点：\",\"保护了有价值的默认样式，而不是完全去掉它们\",\"为大部分 HTML 元素提供一般化的样式\",\"新增对 HTML5 元素的设置\",\"对并集选择器的使用比较谨慎，有效避免调试工具杂乱\"]}]},\"/front-end/css-notes/12-CSS3%E7%AE%80%E4%BB%8B.html\":{\"title\":\"CSS3简介\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"CSS3 是 CSS2 的升级版本，它在 CSS2 的基础上，新增了很多强大的新功能，从而解决一些实际面临的问题\",\"CSS3 在未来会按照模块化的方式去发展，一些最重要CSS3模块：\",\"选择器\",\"盒模型\",\"背景和边框\",\"文字特效\",\"2D/3D转换\",\"动画\",\"多列布局\",\"用户界面\",\"CSS3 的新特性如下：\",\"新增了更加实用的选择器，例如：动态伪类选择器、目标伪类选择器、伪元素选择器等等\",\"新增了更好的视觉效果，例如：圆角、阴影、渐变等\",\"新增了丰富的背景效果，例如：支持多个背景图片，同时新增了若干个背景相关的属性\",\"新增了全新的布局方案 —— 弹性盒子\",\"新增了 Web 字体，可以显示用户电脑上没有安装的字体\",\"增强了颜色，例如： HSL 、 HSLA 、 RGBA 几种新的颜色模式，新增 opacity 属性来控制透明度\",\"增加了 2D 和 3D 变换，例如：旋转、扭曲、缩放、位移等\",\"增加动画与过渡效果，让效果的变换更具流线性、平滑性\",\"……\"]}]},\"/front-end/css-notes/13-CSS3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A7%81%E6%9C%89%E5%89%8D%E7%BC%80.html\":{\"title\":\"CSS3浏览器私有前缀\",\"contents\":[{\"header\":\"1. 什么是私有前缀？\",\"slug\":\"_1-什么是私有前缀\",\"contents\":[\"如下代码中的 -webkit- 就是私有前缀\",\"div { width:400px; height:400px; -webkit-border-radius: 20px; } \"]},{\"header\":\"2. 为什么要有私有前缀\",\"slug\":\"_2-为什么要有私有前缀\",\"contents\":[\"W3C 标准所提出的某个 CSS 特性，在被浏览器正式支持之前，浏览器厂商会根据浏览器的内核，使用私有前缀来测试该 CSS 特性，在浏览器正式支持该 CSS 特性后，就不需要私有前缀了\",\"查询 CSS3 兼容性的网站：Can I use... Support tables for HTML5, CSS3\",\"常见浏览器私有前缀:\",\"Chrome 浏览器： -webkit-\",\"Safari 浏览器： -webkit-\",\"Firefox 浏览器： -moz-\",\"Edge 浏览器：-webkit-\",\"旧 Opera 浏览器： -o-\",\"旧 IE 浏览器： -ms-\"]}]},\"/front-end/css-notes/14-CSS3%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7.html\":{\"title\":\"CSS3自定义属性\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"CSS3自定义属性是一种定义在 :root 参照根元素上的属性，可以被所有后代元素所继承和使用\",\"自定义属性可以用 -- 作为前缀来定义，如：--primary-color: #ff0000\",\"定义自定义属性后，可以在任何CSS规则内使用var()函数来引用自定义属性的值\",\"示例：\",\"定义一个自定义属性：\",\":root { --primary-color: #ff0000; } \",\"使用自定义属性：\",\"body { background-color: var(--primary-color); } \",\"在上述代码中，我们定义了一个名为 --primary-color 的自定义属性，并将其值设置为红色。在 body 元素的CSS规则中，我们使用 var() 函数来引用这个自定义属性，并将其值设置为 background-color 的值，这样 body 的背景色会使用 --primary-color 自定义属性的值，即红色\",\"使用自定义属性的好处是代码的可重用性和构建更易于维护的样式库，可以使开发者在整个网站中更容易地应用相同的样式属性\"]}]},\"/front-end/css-notes/15-CSS3%E9%80%89%E6%8B%A9%E5%99%A8.html\":{\"title\":\"CSS3选择器\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"CSS3新增的选择器有：动态伪类、目标伪类、语言伪类、 UI 伪类、结构伪类、否定伪类、伪元素\",\"具体内容看前面CSS选择器部分\"]}]},\"/front-end/css-notes/16-CSS3%E8%BE%B9%E6%A1%86.html\":{\"title\":\"CSS3边框\",\"contents\":[{\"header\":\"1. 盒子阴影\",\"slug\":\"_1-盒子阴影\",\"contents\":[\"使用 box-shadow 属性为盒子添加阴影\",\"语法：\",\" box-shadow: h-shadow v-shadow blur spread color inset; \",\"值\",\"描述\",\"h-shadow\",\"必需。水平阴影的位置，允许负值\",\"v-shadow\",\"必需。垂直阴影的位置，允许负值\",\"blur\",\"可选。模糊距离\",\"spread\",\"可选。阴影的尺寸\",\"color\",\"可选。阴影的颜色\",\"inset\",\"可选。将外部阴影 (outset)改为内部阴影\",\"注意：\",\"box-shadow-none，表示没有阴影\",\"默认的是外阴影（outset），但是不可以写，否则会造成阴影无效\",\"盒子阴影不占用空间，不会影响其它盒子排列\",\"例：\",\"/* 写两个值，含义：水平位置、垂直位置 */ box-shadow: 10px 10px; /* 写三个值，含义：水平位置、垂直位置、颜色 */ box-shadow: 10px 10px red; /* 写三个值，含义：水平位置、垂直位置、模糊值 */ box-shadow: 10px 10px 10px; /* 写四个值，含义：水平位置、垂直位置、模糊值、颜色 */ box-shadow: 10px 10px 10px red; /* 写五个值，含义：水平位置、垂直位置、模糊值、外延值、颜色 */ box-shadow: 10px 10px 10px 10px blue; /* 写六个值，含义：水平位置、垂直位置、模糊值、外延值、颜色、内阴影 */ box-shadow: 10px 10px 20px 3px blue inset; \"]},{\"header\":\"2. 圆角边框\",\"slug\":\"_2-圆角边框\",\"contents\":[\"使用 border-radius 属性用于设置元素的外边框圆角\",\"语法：\",\" border-radius:length; \",\"参数值可以为数值或百分比的形式\",\"如果是正方形，想要设置为一个圆，把数值修改为高度或者宽度的一半即可，或者直接写为 50%\",\"该属性是一个简写属性，可以跟四个值，分别代表左上角、右上角、右下角、左下角\",\"分开写：border-top-left-radius、border-top-right-radius、border-bottom-right-radius 和 border-bottom-left-radius\"]},{\"header\":\"3. 边框外轮廓\",\"slug\":\"_3-边框外轮廓\",\"contents\":[\"outline-width ：外轮廓的宽度\",\"outline-color ：外轮廓的颜色\",\"outline-style ：外轮廓的风格\",\"none ： 无轮廓\",\"dotted ： 点状轮廓\",\"dashed ： 虚线轮廓\",\"solid ： 实线轮廓\",\"double ： 双线轮廓\",\"outline-offset 设置外轮廓与边框的距离，正负值都可以设置（注意，outline-offset 不是 outline 的子属性，是一个独立的属性）\",\"outline 复合属性 outline:50px solid blue;\",\"注意，轮廓与边框有两点不同：\",\"轮廓不占用空间\",\"轮廓可能是非矩形\"]}]},\"/front-end/css-notes/17-CSS3%E8%83%8C%E6%99%AF.html\":{\"title\":\"CSS3背景\",\"contents\":[{\"header\":\"1. background-origin\",\"slug\":\"_1-background-origin\",\"contents\":[\"作用：设置背景图的原点\",\"属性值：\",\"padding-box ：从 padding 区域开始显示背景图像—— 默认值\",\"border-box ： 从 border 区域开始显示背景图像\",\"content-box ： 从 content 区域开始显示背景图像\"]},{\"header\":\"2. background-clip\",\"slug\":\"_2-background-clip\",\"contents\":[\"作用：设置背景图的向外裁剪的区域\",\"属性值：\",\"border-box ： 从 border 区域开始向外裁剪背景。 —— 默认值\",\"padding-box ： 从 padding 区域开始向外裁剪背景\",\"content-box ： 从 content 区域开始向外裁剪背景\",\"text ：背景图只呈现在文字上（backgroun-clip 要加上 -webkit- 前缀）\"]},{\"header\":\"3. background-size\",\"slug\":\"_3-background-size\",\"contents\":[\"作用：设置背景图的尺寸\",\"属性值：\",\"用长度值指定背景图片大小，不允许负值 background-size: 300px 200px;\",\"用百分比指定背景图片大小，不允许负值 background-size: 100% 100%;\",\"auto：背景图片的真实大小。 —— 默认值\",\"contain：将背景图片等比缩放，使背景图片的宽或高，与容器的宽或高相等，再将完整背景图片包含在容器内，但要注意：可能会造成容器里部分区域没有背景图片 background-size: contain;\",\"cover：将背景图片等比缩放，直到完全覆盖容器，图片会尽可能全的显示在元素上，但要注意：背景图片有可能显示不完整。—— 相对比较好的选择 background-size: cover;\"]},{\"header\":\"4. background复合属性\",\"slug\":\"_4-background复合属性\",\"contents\":[\"语法：\",\"background: color url repeat position / size origin clip \",\"注意：\",\"origin 和 clip 的值如果一样，如果只写一个值，则 origin 和 clip 都设置；如果设置了两个值，前面的是 origin ，后面的 clip\",\"size 的值必须写在 position 值的后面，并且用 / 分开\"]},{\"header\":\"5. 多背景图\",\"slug\":\"_5-多背景图\",\"contents\":[\"CSS3 允许元素设置多个背景图片\",\"/* 添加多个背景图 */ background: url(../images/bg-lt.png) no-repeat, url(../images/bg-rt.png) no-repeat right top, url(../images/bg-lb.png) no-repeat left bottom, url(../images/bg-rb.png) no-repeat right bottom; \"]}]},\"/front-end/css-notes/18-CSS3%E6%96%87%E6%9C%AC%E6%95%88%E6%9E%9C.html\":{\"title\":\"CSS3文本效果\",\"contents\":[{\"header\":\"1. 文本阴影\",\"slug\":\"_1-文本阴影\",\"contents\":[\"在 CSS3 中，我们可以使用 text-shadow 属性将阴影应用于文本\",\"语法：\",\" text-shadow: h-shadow v-shadow blur color; \",\"值\",\"描述\",\"h-shadow\",\"必需。水平阴影的位置，允许负值\",\"v-shadow\",\"必需。垂直阴影的位置，允许负值\",\"blur\",\"可选。模糊的距离\",\"color\",\"可选。阴影的颜色\",\"默认值：text-shadow: none; 表示没有阴影\"]},{\"header\":\"2. 文本换行\",\"slug\":\"_2-文本换行\",\"contents\":[\"在 CSS3 中，我们可以使用 white-space 属性设置文本换行方式\",\"常用值如下：\",\"值\",\"含义\",\"normal\",\"文本超出边界自动换行，文本中的换行被浏览器识别为一个空格（默认值）\",\"pre\",\"原样输出，与 pre 标签的效果相同\",\"pre-wrap\",\"在 pre 效果的基础上，超出元素边界自动换行\",\"pre-line\",\"在 pre 效果的基础上，超出元素边界自动换行，且识别文本中的换行，空格会忽略\",\"nowrap\",\"强制不换行\"]},{\"header\":\"3. 文本溢出\",\"slug\":\"_3-文本溢出\",\"contents\":[\"在 CSS3 中，我们可以使用 text-overflow 属性设置文本内容溢出时的呈现模式\",\"常用值如下：\",\"值\",\"含义\",\"clip\",\"当内联内容溢出时，将溢出部分裁切掉（默认值）\",\"ellipsis\",\"当内联内容溢出块容器时，将溢出部分替换为 …\",\"注意：要使得 text-overflow 属性生效，块容器必须显式定义 overflow 为非 visible 值， white-space 为 nowrap 值\"]},{\"header\":\"4. 文本修饰\",\"slug\":\"_4-文本修饰\",\"contents\":[\"CSS3 升级了 text-decoration 属性，让其变成了复合属性\",\"text-decoration: text-decoration-line || text-decoration-style || text-decoration-color \",\"子属性及其含义：\",\"text-decoration-line 设置文本装饰线的位置 \",\"none ： 指定文字无装饰 （默认值）\",\"underline ： 指定文字的装饰是下划线\",\"overline ： 指定文字的装饰是上划线\",\"line-through ： 指定文字的装饰是贯穿线\",\"text-decoration-style 文本装饰线条的形状 \",\"solid ： 实线 （默认）\",\"double ： 双线\",\"dotted ： 点状线条\",\"dashed ： 虚线\",\"wavy ： 波浪线\",\"text-decoration-color 文本装饰线条的颜色\"]},{\"header\":\"5. 文本描边\",\"slug\":\"_5-文本描边\",\"contents\":[\"注意：文字描边功能仅 webkit 内核浏览器支持\",\"-webkit-text-stroke-width ：设置文字描边的宽度，写长度值\",\"-webkit-text-stroke-color ：设置文字描边的颜色，写颜色值\",\"-webkit-text-stroke ：复合属性，设置文字描边宽度和颜色\"]}]},\"/front-end/css-notes/19-CSS3%E6%B8%90%E5%8F%98.html\":{\"title\":\"CSS3渐变\",\"contents\":[{\"header\":\"1. 线性渐变\",\"slug\":\"_1-线性渐变\",\"contents\":[\"多个颜色之间的渐变，默认从上到下渐变\",\"background-image:linear-gradient(red,yellow,green); \",\"使用关键词设置线性渐变的方向\",\"background-image: linear-gradient(to right top,red,yellow,green); \",\"使用角度设置线性渐变的方向\",\"background-image: linear-gradient(30deg,red,yellow,green); \",\"调整开始渐变的位置\",\"background-image: linear-gradient(red 50px,yellow 100px ,green 150px); \"]},{\"header\":\"2. 径向渐变\",\"slug\":\"_2-径向渐变\",\"contents\":[\"多个颜色之间的渐变，默认从圆心四散。（注意：不一定是正圆，要看容器本身宽高比）\",\"background-image: radial-gradient(red,yellow,green); \",\"使用关键词调整渐变圆的圆心位置\",\"background-image: radial-gradient(at right top,red,yellow,green); \",\"使用像素值调整渐变圆的圆心位置\",\"background-image: radial-gradient(at 100px 50px,red,yellow,green); \",\"调整渐变形状为正圆\",\"background-image: radial-gradient(circle,red,yellow,green); \",\"调整形状的半径\",\"background-image: radial-gradient(100px,red,yellow,green); \",\"background-image: radial-gradient(50px 100px,red,yellow,green); \",\"调整开始渐变的位置\",\"background-image: radial-gradient(red 50px,yellow 100px,green 150px); \"]},{\"header\":\"3. 重复渐变\",\"slug\":\"_3-重复渐变\",\"contents\":[\"无论线性渐变，还是径向渐变，在没有发生渐变的位置，继续进行渐变，就为重复渐变\",\"使用 repeating-linear-gradient 进行重复线性渐变，具体参数同 linear-gradient\",\"使用 repeating-radial-gradient 进行重复径向渐变，具体参数同 radial-gradient\"]}]},\"/front-end/css-notes/20-CSS3%E5%AD%97%E4%BD%93.html\":{\"title\":\"CSS3字体\",\"contents\":[{\"header\":\"1. 基本用法\",\"slug\":\"_1-基本用法\",\"contents\":[\"可以通过 @font-face 指定字体的具体地址，浏览器会自动下载该字体，这样就不依赖用户电脑上的字体了\",\"语法（简写方式）：\",\"@font-face { font-family: \\\"情书字体\\\"; src: url('./方正手迹.ttf'); } \",\"语法（高兼容性写法）：\",\"@font-face { font-family: \\\"atguigu\\\"; font-display: swap; src: url('webfont.eot'); /* IE9 */ src: url('webfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('webfont.woff2') format('woff2'), url('webfont.woff') format('woff'), /* chrome、firefox */ url('webfont.ttf') format('truetype'), /* chrome、firefox、opera、Safari, Android*/ url('webfont.svg#webfont') format('svg'); /* iOS 4.1- */ } \"]},{\"header\":\"2. 定制字体\",\"slug\":\"_2-定制字体\",\"contents\":[\"中文的字体文件很大，使用完整的字体文件不现实，通常针对某几个文字进行单独定制\",\"可使用阿里 Web 字体定制工具：iconfont-webfont平台\"]},{\"header\":\"3. 字体图标\",\"slug\":\"_3-字体图标\",\"contents\":[\"字体图标可以为前端工程师提供一种方便高效的图标使用方式，展示的是图标，本质属于字体\",\"字体图标使用场景：主要用于显示网页中通用的、常用的一些小图标\",\"字体图标的优点：\",\"轻量级：一个图标字体要比一系列的图像要小。一旦字体加载了，图标就会马上渲染出来，减少了服务器请求\",\"灵活性：本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果、旋转等\",\"兼容性：几乎支持所有的浏览器，请放心使用\",\"注意： 字体图标不能替代精灵技术，只是对工作中图标部分技术的提升和优化\"]}]},\"/front-end/css-notes/21-CSS3%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2.html\":{\"title\":\"CSS3用户界面\",\"contents\":[{\"header\":\"1. box-sizing怪异盒模型\",\"slug\":\"_1-box-sizing怪异盒模型\",\"contents\":[\"使用 box-sizing 属性可以设置盒模型的两种类型\",\"可选值\",\"含义\",\"content-box\",\"width 和 height 设置的是盒子内容区的大小（默认值）\",\"border-box\",\"width 和 height 设置的是盒子总大小（怪异盒模型）\"]},{\"header\":\"2. resize调整尺寸\",\"slug\":\"_2-resize调整尺寸\",\"contents\":[\"使用 resize 属性可以控制是否允许用户调节元素尺寸\",\"值\",\"含义\",\"none\",\"不允许用户调整元素大小（默认）\",\"both\",\"用户可以调节元素的宽度和高度\",\"horizontal\",\"用户可以调节元素的宽度\",\"vertical\",\"用户可以调节元素的高度\",\"例如：实际开发中，我们文本域右下角是不可以拖拽的：\",\" textarea{ resize: none; } \"]}]},\"/front-end/css-notes/22-CSS3%E9%95%BF%E5%BA%A6%E5%92%8C%E9%A2%9C%E8%89%B2.html\":{\"title\":\"CSS3长度和颜色\",\"contents\":[{\"header\":\"1. CSS3新增长度单位\",\"slug\":\"_1-css3新增长度单位\",\"contents\":[\"rem 根元素字体大小的倍数，只与根元素字体大小有关\",\"vw 视口宽度的百分之多少 10vw 就是视口宽度的 10%\",\"vh 视口高度的百分之多少 10vh 就是视口高度的 10%\",\"vmax 视口宽高中大的那个的百分之多少\",\"vmin 视口宽高中小的那个的百分之多少\"]},{\"header\":\"2. CSS3新增颜色设置方式\",\"slug\":\"_2-css3新增颜色设置方式\",\"contents\":[\"CSS3 新增了三种颜色设置方式，分别是： rgba 、 hsl 、 hsla，前面颜色部分有详细介绍\"]},{\"header\":\"3. opacity不透明度\",\"slug\":\"_3-opacity不透明度\",\"contents\":[\"opacity 属性能为整个元素添加透明效果，值是 0 到 1 之间的小数， 0 是完全透明， 1 表示完全不透明\",\"opacity 与 rgba 的区别：\",\"opacity 是一个属性，设置的是整个元素（包括元素里的内容）的不透明度\",\"rgba 是颜色的设置方式，用于设置颜色，它的透明度，仅仅是调整颜色的透明度\"]}]},\"/front-end/css-notes/23-CSS3%E6%BB%A4%E9%95%9C.html\":{\"title\":\"CSS3滤镜\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"filter CSS 属性将模糊或颜色偏移等图形效果应用于元素\",\"语法：\",\"filter:函数(); \",\"例如：\",\"filter: blur(5px);/* blur模糊处理,数值越大越模糊 */ \"]}]},\"/front-end/css-notes/24-CSS3calc%E5%87%BD%E6%95%B0.html\":{\"title\":\"CSS3calc函数\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"calc() 此 CSS 函数让你在声明 CSS 属性值时执行一些计算\",\"语法：\",\"width: calc(100% - 80px); \",\"括号里面可以使用 + - *  / 来进行计算\"]}]},\"/front-end/css-notes/25-CSS3%E5%A4%9A%E5%88%97%E5%B8%83%E5%B1%80.html\":{\"title\":\"CSS3多列布局\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"作用：专门用于实现类似于报纸的布局\",\"常用属性如下：\",\"column-count ：指定列数，值是数字\",\"column-width ：指定列宽，值是长度\",\"columns ：同时指定列宽和列数，复合属性；值没有数量和顺序要求\",\"column-gap ：设置列边距，值是长度\",\"column-rule-style ：设置列与列之间边框的风格，值与 border-style 一致\",\"column-rule-width ：设置列与列之间边框的宽度，值是长度\",\"column-rule-color ：设置列与列之间边框的颜色\",\"coumn-rule ：设置列边框，复合属性\",\"column-span 指定是否跨列；值: none 、 all\"]}]},\"/front-end/css-notes/26-CSS3%E5%9B%BE%E5%BD%A2%E5%8F%98%E6%8D%A2.html\":{\"title\":\"CSS3图形变换\",\"contents\":[{\"header\":\"1. 2D变换\",\"slug\":\"_1-2d变换\",\"contents\":[\"二维坐标系如图：\",\"CSS3图形变换01.png\"]},{\"header\":\"1.1 2D位移\",\"slug\":\"_1-1-2d位移\",\"contents\":[\"2D 位移可以改变元素的位置，具体使用方式如下：\",\"先给元素添加转换属性 transform\",\"编写 transform 的具体值，相关可选值如下：\",\"translateX：设置水平方向位移，需指定长度值；若指定的是百分比，是参考自身宽度的百分比\",\"translateY：设置垂直方向位移，需指定长度值；若指定的是百分比，是参考自身高度的百分比\",\"translate：一个值代表水平方向，两个值代表水平和垂直方向\",\"注意点：\",\"位移与相对定位很相似，都不脱离文档流，不会影响到其它元素\",\"与相对定位的区别：相对定位的百分比值，参考的是其父元素；定位的百分比值，参考的是其自身\",\"浏览器针对位移有优化，与定位相比，浏览器处理位移的效率更高\",\"transform 可以链式编写，例如：transform: translateX(30px) translateY(40px);\",\"位移对行内元素无效\",\"位移配合定位，可实现元素水平垂直居中\"]},{\"header\":\"1.2 2D缩放\",\"slug\":\"_1-2-2d缩放\",\"contents\":[\"2D 缩放是指：让元素放大或缩小，具体使用方式如下：\",\"先给元素添加转换属性 transform\",\"编写 transform 的具体值，相关可选值如下： \",\"scaleX：设置水平方向的缩放比例，值为一个数字， 1 表示不缩放，大于 1 放大，小于 1 缩小\",\"scaleY：设置垂直方向的缩放比例，值为一个数字， 1 表示不缩放，大于 1 放大，小于 1 缩小\",\"scale：同时设置水平方向、垂直方向的缩放比例，一个值代表同时设置水平和垂直缩放；两个值分别代表：水平缩放、垂直缩放\",\"注意点： \",\"scale 的值，是支持写负数的，但几乎不用，因为容易让人产生误解\",\"借助缩放，可实现小于 12px 的文字\"]},{\"header\":\"1.3 2D旋转\",\"slug\":\"_1-3-2d旋转\",\"contents\":[\"2D 旋转是指：让元素在二维平面内，顺时针旋转或逆时针旋转，具体使用方式如下：\",\"先给元素添加转换属性 transform\",\"编写 transform 的具体值，相关可选值如下： \",\"rotate：设置旋转角度，需指定一个角度值 ( deg )，正值顺时针，负值逆时针\",\"注意： rotateZ(20deg) 相当于 rotate(20deg) ，当然到了 3D 变换的时候，还能写： rotate(x,x,x)\"]},{\"header\":\"1.4 2D扭曲\",\"slug\":\"_1-4-2d扭曲\",\"contents\":[\"2D 扭曲是指：让元素在二维平面内被“拉扯”，进而“走形”，实际开发几乎不用，了解即可，具体使用方式如下：\",\"先给元素添加转换属性 transform\",\"编写 transform 的具体值，相关可选值如下： \",\"skewX：设置元素在水平方向扭曲，值为角度值，会将元素的左上角、右下角拉扯\",\"skewY：设置元素在垂直方向扭曲，值为角度值，会将元素的左上角、右下角拉扯\",\"skew：一个值代表 skewX ，两个值分别代表： skewX 、 skewY\"]},{\"header\":\"1.5 多重变换\",\"slug\":\"_1-5-多重变换\",\"contents\":[\"多个变换，可以同时使用一个 transform 来编写\",\"transform: translate(-50%, -50%) rotate(45deg); \"]},{\"header\":\"1.6 变换原点\",\"slug\":\"_1-6-变换原点\",\"contents\":[\"元素变换时，默认的原点是元素的中心，使用 transform-origin 可以设置变换的原点\",\"修改变换原点对位移没有影响，对旋转和缩放会产生影响\",\"如果提供两个值，第一个用于横坐标，第二个用于纵坐标\",\"如果只提供一个，若是像素值，表示横坐标，纵坐标取 50% ；若是关键词，则另一个坐标取 50%\",\"/* 变换原点在元素的中心位置，百分比是相对于自身。—— 默认值 */ transform-origin: 50% 50%; /* 变换原点在元素的左上角 */ transform-origin: left top; /* 变换原点距离元素左上角 50px 50px 的位置 */ transform-origin: 50px 50px; /* 只写一个值的时候，第二个值默认为 50% */ transform-origin: 0; \"]},{\"header\":\"2. 3D变换\",\"slug\":\"_2-3d变换\",\"contents\":[]},{\"header\":\"2.1 开启3D空间\",\"slug\":\"_2-1-开启3d空间\",\"contents\":[\"重要原则：元素进行 3D 变换的首要操作：父元素必须开启 3D 空间！\",\"使用 transform-style 开启 3D 空间，可选值如下：\",\"flat ： 让子元素位于此元素的二维平面内（ 2D 空间）—— 默认值\",\"preserve-3d ： 让子元素位于此元素的三维空间内（ 3D 空间）\"]},{\"header\":\"2.2 设置景深\",\"slug\":\"_2-2-设置景深\",\"contents\":[\"何为景深？—— 指定观察者与 z=0 平面的距离，能让发生 3D 变换的元素，产生透视效果，看来更加立体\",\"使用 perspective 设置景深，可选值如下：\",\"none ： 不指定透视 ——（默认值）\",\"长度值 ： 指定观察者距离 z=0 平面的距离，不允许负值\",\"注意： perspective 设置给发生 3D 变换元素的父元素！\"]},{\"header\":\"2.3 透视点位置\",\"slug\":\"_2-3-透视点位置\",\"contents\":[\"所谓透视点位置，就是观察者位置；默认的透视点在元素的中心\",\"使用 perspective-origin 设置观察者位置（透视点的位置）\",\"/* 相对坐标轴往右偏移400px，往下偏移300px（相当于人蹲下300像素，然后向右移动400像素看元素） */ perspective-origin: 400px 300px; \",\"注意：通常情况下，我们不需要调整透视点位置\"]},{\"header\":\"2.4 3D位移\",\"slug\":\"_2-4-3d位移\",\"contents\":[\"3D 位移是在 2D 位移的基础上，可以让元素沿 z 轴位移，具体使用方式如下：\",\"先给元素添加转换属性 transform\",\"编写 transform 的具体值， 3D 相关可选值如下： \",\"translateZ：设置 z 轴位移，需指定长度值，正值向屏幕外，负值向屏幕里，且不能写百分比\",\"translate3d：第1个参数对应 x 轴，第2个参数对应 y 轴，第3个参数对应 z 轴，且均不能省略\"]},{\"header\":\"2.5 3D旋转\",\"slug\":\"_2-5-3d旋转\",\"contents\":[\"3D 旋转是在 2D 旋转的基础上，可以让元素沿 x 轴和 y 轴旋转，具体使用方式如下：\",\"先给元素添加转换属性 transform\",\"编写 transform 的具体值， 3D 相关可选值如下： \",\"rotateX：设置 x 轴旋转角度，需指定一个角度值 ( deg )，面对 x 轴正方向：正值顺时针，负值逆时针\",\"rotateY：设置 y 轴旋转角度，需指定一个角度值 ( deg )，面对 y 轴正方向：正值顺时针，负值逆时针\",\"rotate3d：前 3 个参数分别表示坐标轴： x , y , z ，第 4 个参数表示旋转的角度，参数不允许省略。例如：transform: rotate3d (1,1,1,30deg) ，意思是： x 、 y 、 z 分别旋转 30 度\"]},{\"header\":\"2.6 3D缩放\",\"slug\":\"_2-6-3d缩放\",\"contents\":[\"3D 缩放是在 2D 缩放的基础上，可以让元素沿 z 轴缩放，具体使用方式如下：\",\"先给元素添加转换属性 transform\",\"编写 transform 的具体值， 3D 相关可选值如下： \",\"scaleZ：设置 z 轴方向的缩放比例，值为一个数字， 1 表示不缩放，大于 1 放大，小于 1 缩小\",\"scale3d：第1个参数对应 x 轴，第2个参数对应 y 轴，第3个参数对应 z 轴，参数不允许省略\"]},{\"header\":\"2.7 多重变换\",\"slug\":\"_2-7-多重变换\",\"contents\":[\"多个变换，可以同时使用一个 transform 来编写\",\"transform: translateZ(100px) scaleZ(3) rotateY(40deg); \",\"注意点：多重变换时，建议最后旋转\"]},{\"header\":\"2.8 背部可见性\",\"slug\":\"_2-8-背部可见性\",\"contents\":[\"使用 backface-visibility 指定元素背面，在面向用户时是否可见，常用值如下：\",\"visible：指定元素背面可见，允许显示正面的镜像。—— 默认值\",\"hidden：指定元素背面不可见\",\"注意： backface-visibility 需要加在发生 3D 变换元素的自身上\"]}]},\"/front-end/css-notes/27-CSS3%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB.html\":{\"title\":\"CSS3过渡与动画\",\"contents\":[{\"header\":\"1. 过渡\",\"slug\":\"_1-过渡\",\"contents\":[\"过渡可以在不使用 Flash 动画，不使用 JavaScript 的情况下，让元素从一种样式平滑过渡为另一种样式\"]},{\"header\":\"1.1 transition-property\",\"slug\":\"_1-1-transition-property\",\"contents\":[\"作用：定义哪个属性需要过渡，只有在该属性中定义的属性（比如宽、高、颜色等）才会以有过渡效果\",\"常用值：\",\"none ：不过渡任何属性\",\"all ：过渡所有能过渡的属性\",\"具体某个属性名，例如： width 、 heigth ，若有多个以逗号分隔\",\"不是所有的属性都能过渡，值为数字，或者值能转为数字的属性，都支持过渡，否则不支持过渡。常见的支持过渡的属性有：颜色、长度值、百分比、 z-index 、 opacity 、 2D 变换属性、 3D 变换属性、阴影\"]},{\"header\":\"1.2 transition-duration\",\"slug\":\"_1-2-transition-duration\",\"contents\":[\"作用：设置过渡的持续时间，即：一个状态过渡到另外一个状态耗时多久\",\"常用值：\",\"0 ：没有任何过渡时间 —— 默认值\",\"s 或 ms ：秒或毫秒\",\"列表 ： \",\"如果想让所有属性都持续一个时间，那就写一个值\",\"如果想让每个属性持续不同的时间那就写一个时间的列表\"]},{\"header\":\"1.3 transition-delay\",\"slug\":\"_1-3-transition-delay\",\"contents\":[\"作用：指定开始过渡的延迟时间，单位： s 或 ms\"]},{\"header\":\"1.4 transition-timing-function\",\"slug\":\"_1-4-transition-timing-function\",\"contents\":[\"作用：设置过渡的类型\",\"常用值：\",\"ease ： 平滑过渡 —— 默认值\",\"linear ： 线性过渡\",\"ease-in ： 慢 → 快\",\"ease-out ： 快 → 慢\",\"ease-in-out ： 慢 → 快 → 慢\",\"step-start ： 等同于 steps (1, start)\",\"step-end ： 等同于 steps (1, end)\",\"steps( integer,?) ： 接受两个参数的步进函数。第一个参数必须为正整数，指定函数的步数。第二个参数取值可以是 start 或 end ，指定每一步的值发生变化的时间点。第二个参数默认值为 end\",\"cubic-bezie ( number, number, number, number)： 特定的贝塞尔曲线类型\",\"在线制作贝塞尔曲线： cubic-bezier✿\"]},{\"header\":\"1.5 transition 复合属性\",\"slug\":\"_1-5-transition-复合属性\",\"contents\":[\"如果设置了一个时间，表示 duration ；如果设置了两个时间，第一是 duration ，第二个是 delay ；其他值没有顺序要求\",\"transition:1s 1s linear all; \"]},{\"header\":\"2. 动画\",\"slug\":\"_2-动画\",\"contents\":[]},{\"header\":\"2.1 什么是帧\",\"slug\":\"_2-1-什么是帧\",\"contents\":[\"一段动画，就是一段时间内连续播放 n 个画面。每一张画面，我们管它叫做“帧”。一定时间内连续快速播放若干个帧，就成了人眼中所看到的动画。同样时间内，播放的帧数越多，画面看起来越流畅\"]},{\"header\":\"2.2 什么是关键帧\",\"slug\":\"_2-2-什么是关键帧\",\"contents\":[\"关键帧指的是，在构成一段动画的若干帧中，起到决定性作用的 2-3 帧\"]},{\"header\":\"2.3 动画的基本使用\",\"slug\":\"_2-3-动画的基本使用\",\"contents\":[\"第一步：定义关键帧（定义动画）\",\"简单定义方式：\",\"/*写法一*/ @keyframes 动画名 { from { /*property1:value1*/ /*property2:value2*/ } to { /*property1:value1*/ } } \",\"完整定义方式：\",\"@keyframes 动画名 { 0% { /*property1:value1*/ } 20% { /*property1:value1*/ } 40% { /*property1:value1*/ } 60% { /*property1:value1*/ } 80% { /*property1:value1*/ } 100% { /*property1:value1*/ } } \",\"第二步：给元素应用动画，用到的属性如下：\",\"animation-name ：给元素指定具体的动画（具体的关键帧）\",\"animation-duration ：设置动画所需时间\",\"animation-delay ：设置动画延迟\",\".box { /* 指定动画 */ animation-name: testKey; /* 设置动画所需时间 */ animation-duration: 5s; /* 设置动画延迟 */ animation-delay: 0.5s; } \"]},{\"header\":\"2.4 动画的其他属性\",\"slug\":\"_2-4-动画的其他属性\",\"contents\":[\"animation-timing-function ，设置动画的类型，常用值如下：\",\"ease ： 平滑动画 —— 默认值\",\"linear ： 线性过渡\",\"ease-in ： 慢 → 快\",\"ease-out ： 快 → 慢\",\"ease-in-out ： 慢 → 快 → 慢\",\"step-start ： 等同于 steps (1, start)\",\"step-end ： 等同于 steps(1, end)\",\"steps( integer,?) ： 接受两个参数的步进函数。第一个参数必须为正整数，指定函数的步数。第二个参数取值可以是 start 或 end ，指定每一步的值发生变化的时间点。第二个参数默认值为 end\",\"cubic-bezie ( number, number, number, number)： 特定的贝塞尔曲线类型\",\"animation-iteration-count ，指定动画的播放次数，常用值如下：\",\"number ：动画循环次数\",\"infinite ： 无限循环\",\"animation-direction ，指定动画方向，常用值如下：\",\"normal ： 正常方向 (默认)\",\"reverse ： 反方向运行\",\"alternate ： 动画先正常运行再反方向运行，并持续交替运行\",\"alternate-reverse ： 动画先反运行再正方向运行，并持续交替运行\",\"animation-fill-mode ，设置动画之外的状态，常用值如下：\",\"forwards ： 设置对象状态为动画结束时的状态\",\"backwards ： 设置对象状态为动画开始时的状态\",\"animation-play-state ，设置动画的播放状态，常用值如下：\",\"running ： 运动 (默认)\",\"paused ： 暂停\"]},{\"header\":\"2.5 动画复合属性\",\"slug\":\"_2-5-动画复合属性\",\"contents\":[\"只设置一个时间表示 duration ，设置两个时间分别是： duration 和 delay ，其他属性没有数量和顺序要求\",\".inner { animation: atguigu 3s 0.5s linear 2 alternate-reverse forwards; } \",\"备注： animation-play-state 一般单独使用\"]}]},\"/front-end/css-notes/28-CSS3%E4%BC%B8%E7%BC%A9%E7%9B%92%E6%A8%A1%E5%9E%8B.html\":{\"title\":\"CSS3伸缩盒模型\",\"contents\":[{\"header\":\"1. 伸缩盒模型\",\"slug\":\"_1-伸缩盒模型\",\"contents\":[\"2009 年， W3C 提出了一种新的盒子模型 —— Flexible Box （伸缩盒模型，又称：弹性盒子）\",\"它可以轻松的控制：元素分布方式、元素对齐方式、元素视觉顺序 .......\",\"截止目前，除了在部分 IE 浏览器不支持，其他浏览器均已全部支持\",\"伸缩盒模型的出现，逐渐演变出了一套新的布局方案 —— flex 布局\",\"小贴士：\",\"传统布局是指：基于传统盒状模型，主要靠： display 属性 + position 属性 + float 属性\",\"flex 布局目前在移动端应用比较广泛，因为传统布局不能很好的呈现在移动设备上\"]},{\"header\":\"2. 伸缩容器、伸缩项目\",\"slug\":\"_2-伸缩容器、伸缩项目\",\"contents\":[\"伸缩容器：开启了 flex 的元素，就是伸缩容器 \",\"给元素设置： display: flex 或 display: inline-flex ，该元素就变为了伸缩容器\",\"display: inline-flex 很少使用，因为可以给多个伸缩容器的父容器，也设置为伸缩容器\",\"一个元素可以同时是：伸缩容器、伸缩项目\",\"伸缩项目：伸缩容器所有子元素自动成为了伸缩项目 \",\"仅伸缩容器的子元素成为了伸缩项目，孙子元素、重孙子元素等后代，不是伸缩项目\",\"无论原来是哪种元素（块、行内块、行内），一旦成为了伸缩项目，全都会“块状化”\"]},{\"header\":\"3. 主轴与侧轴\",\"slug\":\"_3-主轴与侧轴\",\"contents\":[\"主轴： 伸缩项目沿着主轴排列，主轴默认是水平的，默认方向是：从左到右（左边是起点，右边是终点）\",\"侧轴： 与主轴垂直的就是侧轴，侧轴默认是垂直的，默认方向是：从上到下（上边是起点，下边是终点）\"]},{\"header\":\"4. 主轴方向\",\"slug\":\"_4-主轴方向\",\"contents\":[\"属性名：flex-direction\",\"常用值如下：\",\"row ：主轴方向水平从左到右 —— 默认值\",\"row-reverse ：主轴方向水平从右到左\",\"column ：主轴方向垂直从上到下\",\"column-reverse ：主轴方向垂直从下到上\",\"CSS3伸缩盒模型01.png\",\"注意：改变了主轴的方向，侧轴方向也随之改变\"]},{\"header\":\"5. 主轴换行方式\",\"slug\":\"_5-主轴换行方式\",\"contents\":[\"属性名：flex-wrap\",\"常用值如下：\",\"nowrap ：默认值，不换行\",\"CSS3伸缩盒模型02.png\",\"wrap ：自动换行，伸缩容器不够自动换行\",\"CSS3伸缩盒模型03.png\",\"wrap-reverse ：反向换行\",\"CSS3伸缩盒模型04.png\"]},{\"header\":\"6. flex-flow\",\"slug\":\"_6-flex-flow\",\"contents\":[\"flex-flow 是一个复合属性，复合了 flex-direction 和 flex-wrap 两个属性。值没有顺序要求\",\"flex-flow: row wrap; \"]},{\"header\":\"7. 主轴对齐方式\",\"slug\":\"_7-主轴对齐方式\",\"contents\":[\"属性名：justify-content\",\"常用值如下：\",\"flex-start ：主轴起点对齐。—— 默认值\",\"flex-end ：主轴终点对齐\",\"center ：居中对齐\",\"space-between ：均匀分布，两端对齐（最常用）\",\"space-around ：均匀分布，两端距离是中间距离的一半\",\"space-evenly ：均匀分布，两端距离与中间距离一致\",\"CSS3伸缩盒模型05.png\"]},{\"header\":\"8. 侧轴对齐方式\",\"slug\":\"_8-侧轴对齐方式\",\"contents\":[]},{\"header\":\"8.1 一行的情况\",\"slug\":\"_8-1-一行的情况\",\"contents\":[\"所需属性： align-items\",\"常用值如下：\",\"flex-start ：侧轴的起点对齐\",\"flex-end ：侧轴的终点对齐\",\"center ：侧轴的中点对齐\",\"baseline : 伸缩项目的第一行文字的基线对齐\",\"stretch ：如果伸缩项目未设置高度，将占满整个容器的高度。—— （默认值）\",\"CSS3伸缩盒模型06.png\"]},{\"header\":\"8.2 多行的情况\",\"slug\":\"_8-2-多行的情况\",\"contents\":[\"所需属性： align-content\",\"常用值如下：\",\"flex-start ：与侧轴的起点对齐\",\"flex-end ：与侧轴的终点对齐\",\"center ：与侧轴的中点对齐\",\"space-between ：与侧轴两端对齐，中间平均分布\",\"space-around ：伸缩项目间的距离相等，比距边缘大一倍\",\"space-evenly : 在侧轴上完全平分\",\"stretch ：占满整个侧轴。—— 默认值\",\"CSS3伸缩盒模型07.png\"]},{\"header\":\"9. flex实现水平垂直居中\",\"slug\":\"_9-flex实现水平垂直居中\",\"contents\":[\"方法一：父容器开启 flex 布局，随后使用 justify-content 和 align-items 实现水平垂直居中\",\"方法二：父容器开启 flex 布局，随后子元素 margin: auto\"]},{\"header\":\"10. 伸缩性\",\"slug\":\"_10-伸缩性\",\"contents\":[]},{\"header\":\"10.1 flex-basis\",\"slug\":\"_10-1-flex-basis\",\"contents\":[\"概念： flex-basis 设置的是主轴方向的基准长度，会让宽度或高度失效\",\"备注：主轴横向：宽度失效；主轴纵向：高度失效\",\"作用：浏览器根据这个属性设置的值，计算主轴上是否有多余空间，默认值 auto ，即：伸缩项目的宽或高\"]},{\"header\":\"10.2 flex-grow（伸）\",\"slug\":\"_10-2-flex-grow-伸\",\"contents\":[\"概念： flex-grow 定义伸缩项目的放大比例，默认为 0 ，即：纵使主轴存在剩余空间，也不拉伸 （放大）\",\"规则：\",\"若所有伸缩项目的 flex-grow 值都为 1 ，则：它们将等分剩余空间（如果有空间的话）\",\"若三个伸缩项目的 flex-grow 值分别为： 1 、 2 、 3 ，则：分别瓜分到： 1/6 、 2/6 、 3/6 的空间\"]},{\"header\":\"10.3 flex-shrink（缩）\",\"slug\":\"_10-3-flex-shrink-缩\",\"contents\":[\"概念： flex-shrink 定义了项目的压缩比例，默认为 1 ，即：如果空间不足，该项目将会缩小\",\"收缩项目的计算，略微复杂一点，我们拿一个场景举例：\",\"例如： 三个收缩项目，宽度分别为： 200px 、 300px 、 200px ，它们的 flex-shrink 值分别为： 1 、 2 、 3\",\"若想刚好容纳下三个项目，需要总宽度为 700px ，但目前容器只有 400px ，还差 300px 所以每个人都要收缩一下才可以放下，具体收缩的值，这样计算：\",\"计算分母： (200×1) + (300×2) + (200×3) = 1400\",\"计算比例： \",\"项目一： (200×1) / 1400 = 比例值1\",\"项目二： (300×2) / 1400 = 比例值2\",\"项目三： (200×3) / 1400 = 比例值3\",\"计算最终收缩大小： \",\"项目一需要收缩： 比例值1 × 300\",\"项目二需要收缩： 比例值2 × 300\",\"项目三需要收缩： 比例值3 × 300\"]},{\"header\":\"11. flex复合属性\",\"slug\":\"_11-flex复合属性\",\"contents\":[\"flex 是复合属性，复合了： flex-grow 、 flex-shrink 、 flex-basis 三个属性，默认值为 0 1 auto\",\"如果写 flex:1 1 auto ，则可简写为： flex:auto\",\"如果写 flex: 1 1 0 ，则可简写为： flex: 1\",\"如果写 flex: 0 0 auto ，则可简写为： flex: none\",\"如果写 flex: 0 1 auto ，则可简写为： flex: 0 auto —— 即 flex 初始值\"]},{\"header\":\"12. 项目排序\",\"slug\":\"_12-项目排序\",\"contents\":[\"order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0\"]},{\"header\":\"13. 单独对齐\",\"slug\":\"_13-单独对齐\",\"contents\":[\"通过 align-self 属性，可以单独调整某个伸缩项目的对齐方式\",\"默认值为 auto ，表示继承父元素的 align-items 属性\"]}]},\"/front-end/css-notes/29-CSS3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80.html\":{\"title\":\"CSS3响应式布局\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"响应式布局指的是同一页面在不同屏幕尺寸下有不同的布局\"]},{\"header\":\"1. 媒体查询\",\"slug\":\"_1-媒体查询\",\"contents\":[]},{\"header\":\"1.1 媒体类型\",\"slug\":\"_1-1-媒体类型\",\"contents\":[\"值\",\"含义\",\"all\",\"检测所有设备\",\"screen\",\"检测电子屏幕，包括：电脑屏幕、平板屏幕、手机屏幕等\",\"print\",\"检测打印机\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Document</title> <style> h1 { width: 600px; height: 400px; line-height: 400px; background-image: linear-gradient(30deg, red, yellow, green); margin: 0 auto; text-align: center; font-size: 100px; color: white; text-shadow: 0 0 10px black; } /* 只有在打印机或打印预览才应用的样式 */ @media print { h1 { background: transparent; } } </style> </head> <body> <h1>新年快乐</h1> </body> </html> \"]},{\"header\":\"1.2 媒体特性\",\"slug\":\"_1-2-媒体特性\",\"contents\":[\"值\",\"含义\",\"width\",\"检测视口宽度\",\"max-width\",\"检测视口最大宽度\",\"min-width\",\"检测视口最小宽度\",\"height\",\"检测视口高度\",\"max-height\",\"检测视口最大高度\",\"min-height\",\"检测视口最小高度\",\"device-width\",\"检测设备屏幕的宽度\",\"max-device-width\",\"检测设备屏幕的最大宽度\",\"min-device-width\",\"检测设备屏幕的最小宽度\",\"orientation\",\"检测视口的旋转方向（是否横屏） 1. portrait ：视口处于纵向，即高度大于等于宽度2. landscape ：视口处于横向，即宽度大于高度\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Document</title> <style> * { margin: 0; padding: 0; } h1 { height: 200px; background-color: gray; text-align: center; line-height: 200px; font-size: 100px; } /* 检测到视口的宽度为800px时*/ @media (width: 800px) { h1 { background-color: green; } } /* 检测到视口的宽度小于等于700px时*/ @media (max-width: 700px) { h1 { background-color: orange; } } /* 检测到视口的宽度大于等于900px时*/ @media (min-width: 900px) { h1 { background-color: deepskyblue; } } </style> </head> <body> <h1>你好啊</h1> </body> </html> \"]},{\"header\":\"1.3 运算符\",\"slug\":\"_1-3-运算符\",\"contents\":[\"值\",\"含义\",\"and\",\"并且\",\", 或 or\",\"或\",\"not\",\"否定\",\"only\",\"肯定\"]},{\"header\":\"1.4 常用阈值\",\"slug\":\"_1-4-常用阈值\",\"contents\":[\"在实际开发中，会将屏幕划分成几个区间，例如：\",\"CSS3响应式布局01.png\"]}]},\"/front-end/css-notes/30-CSS3BFC.html\":{\"title\":\"CSS3BFC\",\"contents\":[{\"header\":\"1. 什么是BFC\",\"slug\":\"_1-什么是bfc\",\"contents\":[\"W3C 上对 BFC 的定义：\",\"原文：Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with 'overflow' other than 'visible' (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.\",\"译文：浮动、绝对定位元素、不是块盒子的块容器（如 inline-blocks 、 table-cells 和 table-captions ），以及 overflow 属性的值除 visible 以外的块盒，将为其内容建立新的块格式化上下文\",\"MDN 上对 BFC 的描述：\",\"块格式化上下文（Block Formatting Context，BFC） 是 Web 页面的可视 CSS 渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域\",\"更加通俗的描述：\",\"BFC 是 Block Formatting Context （块级格式上下文），可以理解成元素的一个 “特异功能”\",\"该 “特异功能”，在默认的情况下处于关闭状态；当元素满足了某些条件后，该“特异功能”被激活\",\"所谓激活“特异功能”，专业点说就是：该元素创建了 BFC （又称：开启了 BFC ）\"]},{\"header\":\"2. 开启了BFC能解决什么问题\",\"slug\":\"_2-开启了bfc能解决什么问题\",\"contents\":[\"元素开启 BFC 后，其子元素不会再产生 margin 塌陷问题\",\"元素开启 BFC 后，自己不会被其他浮动元素所覆盖\",\"元素开启 BFC 后，就算其子元素浮动，元素自身高度也不会塌陷\"]},{\"header\":\"3. 如何开启BFC\",\"slug\":\"_3-如何开启bfc\",\"contents\":[\"根元素\",\"浮动元素绝对定位、固定定位的元素\",\"行内块元素\",\"表格单元格： table 、 thead 、 tbody 、 tfoot 、 th 、 td 、 tr 、 caption\",\"overflow 的值不为 visible 的块元素\",\"伸缩项目\",\"多列容器\",\"column-span 为 all 的元素（即使该元素没有包裹在多列容器中）\",\"display 的值，设置为 flow-root\"]}]},\"/front-end/css-notes/\":{\"title\":\"CSS笔记\",\"contents\":[]},\"/front-end/html-notes/01-HTML%E7%AE%80%E4%BB%8B.html\":{\"title\":\"HTML简介\",\"contents\":[{\"header\":\"1. 什么是 HTML\",\"slug\":\"_1-什么是-html\",\"contents\":[\"HTML 指的是超文本标记语言 (Hyper Text Markup Language) ，它是用来描述网页的一种语言\",\"HTML 不是一种编程语言，而是一种标记语言 (markup language)，标记语言是一套标记标签 (markup tag)\"]},{\"header\":\"2. Web 标准\",\"slug\":\"_2-web-标准\",\"contents\":[\"Web 标准是由 W3C组织 和其他标准化组织制定的一系列标准的集合。W3C（万维网联盟）是国际最著名的标准化组织\"]},{\"header\":\"2.1 为什么需要 Web 标准\",\"slug\":\"_2-1-为什么需要-web-标准\",\"contents\":[\"浏览器不同，它们显示页面或者排版就有些许差异，遵循 Web 标准除了可以让不同的开发人员写出的页面更标准、更统一外，还有以下优点：\",\"让 Web 的发展前景更广阔\",\"内容能被更广泛的设备访问\",\"更容易被搜索引擎搜索\",\"降低网站流量费用\",\"使网站更易于维护\",\"提高页面浏览速度\"]},{\"header\":\"2.2 Web 标准的构成\",\"slug\":\"_2-2-web-标准的构成\",\"contents\":[\"主要包括：结构（Structure）、表现（Presentation）和行为（Behavior）三个方面\",\"Web 标准提出的最佳体验方案：结构、样式、行为相分离\",\"简单理解：结构写到 HTML 文件中，表现写到 CSS 文件中，行为写到 JavaScript 文件中\",\"结构类似身体\",\"表现类似外观装饰\",\"行为类似行为动作\",\"相比较而言, 三者中结构最重要\"]}]},\"/front-end/html-notes/02-HTML%E6%A0%87%E7%AD%BE.html\":{\"title\":\"HTML标签\",\"contents\":[{\"header\":\"1. HTML标签\",\"slug\":\"_1-html标签\",\"contents\":[\"标签又称元素，是 HTML 的基本组成单位\",\"HTML 标签是由尖括号包围的关键词，例如 <html>\",\"标签分为单标签和双标签\",\"HTML 标签通常是成对出现的，例如 <html> 和 </html> ，我们称为双标签\",\"标签对中的第一个标签是开始标签，第二个标签是结束标签\",\"有些特殊的标签必须是单个标签（极少情况），例如 <br/>，我们称为单标签\",\"双标签关系可以分为两类：包含关系和并列关系\",\"包含关系：\",\"<head> <title> </title> </head> \",\"并列关系：\",\"<head> </head> <body> </body> \"]},{\"header\":\"2. HTML标签属性\",\"slug\":\"_2-html标签属性\",\"contents\":[\"用于给标签提供附加信息，可以写在起始标签或单标签中，即 <标签名 属性名=\\\"属性值\\\" 属性名=\\\"属性值\\\">\",\"有些特殊的属性，没有属性名，只有属性值\",\"注意：\",\"不同的标签，有不同的属性；也有一些通用属性（在任何标签内都能写）\",\"属性名、属性值不能乱写，都是 W3C 规定好的\",\"属性名、属性值，都不区分大小写，但推荐小写\",\"双引号，也可以写成单引号，甚至不写都行，但还是推荐写双引号\",\"标签中不要出现同名属性，否则后写的会失效\"]}]},\"/front-end/html-notes/03-HTML%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.html\":{\"title\":\"HTML基本结构\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"每个网页都会有一个基本的结构标签（也称为骨架标签），页面内容也是在这些基本标签上书写\",\"标签名\",\"定义\",\"说明\",\"<html></html>\",\"HTML 标签\",\"页面中最大的标签，我们称为根标签\",\"<head></head>\",\"文档的头部\",\"注意在 head 标签中我们必须要设置的标签是 title\",\"<title></title>\",\"文档的标题\",\"让页面拥有一个属于自己的网页标题\",\"<body></body>\",\"文档的主体\",\"元素包含文档的所有内容，页面内容基本都是放到 body 里面的\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>Document</title> </head> <body> </body> </html> \",\"想要呈现在网页中的内容写在 body 标签中\",\"head 标签中的内容不会出现在网页中\",\"head 标签中的 title 标签可以指定网页的标题\"]},{\"header\":\"1. HTML文档声明\",\"slug\":\"_1-html文档声明\",\"contents\":[\"<!DOCTYPE html> 文档类型声明标签, 告诉浏览器这个页面采取 HTML 5 版本来显示页面\",\"注意：\",\"声明位于文档中的最前面的位置，处于 <html> 标签之前\",\"不是一个 HTML 标签，它就是文档类型声明标签\"]},{\"header\":\"2. HTML设置语言\",\"slug\":\"_2-html设置语言\",\"contents\":[\"用来定义当前文档显示的语言：\",\"en 定义语言为英语\",\"zh-CN 定义语言为中文\",\"主要作用：让浏览器显示对应的翻译提示；有利于搜索引擎优化\",\"简单来说, 定义为 en 就是英文网页, 定义为 zh-CN 就是中文网页\",\"其实对于文档显示来说，定义成 en 的文档也可以显示中文，定义成 zh-CN 的文档也可以显示英文\"]},{\"header\":\"3. HTML 字符编码\",\"slug\":\"_3-html-字符编码\",\"contents\":[\"字符集 (Character set)是多个字符的集合。以便计算机能够识别和存储各种文字\",\"在 <head> 标签内，可以通过 <meta> 标签的 charset 属性来规定 HTML 文档应该使用哪种字符编码\",\"<meta charset=\\\"UTF-8\\\" />\",\"charset 常用的值有：GB 2312 、BIG 5 、GBK 和 UTF-8，其中 UTF-8 也被称为万国码，基本包含了全世界所有国家需要用到的字符\",\"注意：上面语法是必须要写的代码，否则可能引起乱码的情况。一般情况下，统一使用“UTF-8”编码，尽量统一写成标准的 \\\"UTF-8\\\"，不要写成  \\\"utf 8\\\" 或 \\\"UTF 8\\\"\"]}]},\"/front-end/html-notes/04-HTML%E6%B3%A8%E9%87%8A.html\":{\"title\":\"HTML注释\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"如果需要在 HTML 文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签\",\"HTML 中的注释以 <!-- 开头，以 --> 结束\",\"具体实现：\",\" <!-- 注释语句 --> \",\"VSCode中快捷键: ctrl + / \",\"添加注释是为了更好地解释代码的功能，便于相关开发人员理解和阅读代码，程序是不会执行注释内容的\"]}]},\"/front-end/html-notes/05-HTML%E5%9F%BA%E7%A1%80.html\":{\"title\":\"HTML基础\",\"contents\":[{\"header\":\"1. 排版标签\",\"slug\":\"_1-排版标签\",\"contents\":[\"标签名\",\"标签含义\",\"单/双标签\",\"h1~h6\",\"标题\",\"双\",\"p\",\"段落\",\"双\",\"div、span\",\"没有任何含义，用于整体布局\",\"双\"]},{\"header\":\"1.1 标题标签\",\"slug\":\"_1-1-标题标签\",\"contents\":[\"标题标签 <h1> - <h6>\",\"为了使网页更具有语义化，我们经常会在页面中用到标题标签。HTML 提供了 6 个等级的网页标题，即 <h1> - <h6> ，有重要的意味\",\"特点：\",\"加了标题的文字会变的加粗，字号也会依次变大\",\"一个标题独占一行\"]},{\"header\":\"1.2 段落标签\",\"slug\":\"_1-2-段落标签\",\"contents\":[\"在网页中，要把文字有条理地显示出来，就需要将这些文字分段显示。在 HTML 标签中，<p> 标签用于定义段落，它可以将整个网页分为若干个段落\",\"特点：\",\"文本在一个段落中会根据浏览器窗口的大小自动换行\",\"段落和段落之间保有空隙\"]},{\"header\":\"1.3 div 和 span 标签\",\"slug\":\"_1-3-div-和-span-标签\",\"contents\":[\"<div> 和 <span> 是没有语义的，它们就是一个盒子，用来装内容的\",\"特点：\",\"<div> 标签用来布局，但是一行只能放一个 <div>，大盒子\",\"<span> 标签用来布局，一行上可以多个 <span>，小盒子\"]},{\"header\":\"2. 语义化标签\",\"slug\":\"_2-语义化标签\",\"contents\":[\"概念：用特定的标签去表达特定的含义\",\"原则：标签的默认效果不重要（后期可以通过 CSS 随便控制效果），语义最重要！\",\"优势：\",\"代码结构清晰可读性强\",\"有利于 SEO（搜索引擎优化）\",\"方便设备解析（如屏幕阅读器、盲人阅读器等）\"]},{\"header\":\"3. 块级元素与行内元素\",\"slug\":\"_3-块级元素与行内元素\",\"contents\":[\"块级元素：独占一行（排版标签都是块级元素）\",\"行内元素：不独占一行\",\"使用原则：\",\"块级元素中能写行内元素和块级元素（简单记：块级元素中几乎什么都能写）\",\"行内元素中能写行内元素，但不能写块级元素\",\"一些特殊的规则： h1~h6 不能互相嵌套、p 中不要写块级元素\"]},{\"header\":\"4. 文本标签\",\"slug\":\"_4-文本标签\",\"contents\":[\"语义\",\"标签\",\"说明\",\"加粗\",\"<strong></strong>或<b></b>\",\"更推荐使用 <strong> 标签加粗，语义更强烈\",\"倾斜\",\"<em></em>或<i></i>\",\"更推荐使用 <em> 标签倾斜，语义更强烈\",\"删除线\",\"<del></del>或<s></s>\",\"更推荐使用 <del> 标签添加删除线，语义更强烈\",\"下划线\",\"<ins></ins>或<u></u>\",\"更推荐使用 <ins> 标签添加下划线，语义更强烈\"]},{\"header\":\"5. 图片标签\",\"slug\":\"_5-图片标签\",\"contents\":[]},{\"header\":\"5.1 图片标签\",\"slug\":\"_5-1-图片标签\",\"contents\":[\"在 HTML 标签中，<img> 标签用于定义 HTML 页面中的图像\",\"具体实现：\",\"<img src=\\\"图像URL\\\" /> \",\"解释：src 是 <img> 标签的必须属性，它用于指定图像文件的路径和文件名，所谓属性，简单理解就是属于这个图像标签的特性\",\"图像标签的其他属性：\",\"属性\",\"属性值\",\"说明\",\"src\",\"图片路径\",\"必须属性\",\"alt\",\"文本\",\"替换文本，图像不能显示时显示的文字\",\"title\",\"文本\",\"提示文本，鼠标放到图像上，显示的文字\",\"width\",\"像素\",\"设置图像的宽度\",\"height\",\"像素\",\"设置图像的高度\",\"border\",\"像素\",\"设置图像的边框粗细\",\"图像标签注意点：\",\"图像标签可以拥有多个属性，必须写在标签名的后面\",\"属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开\",\"属性采取键值对的格式，即 key=\\\"value\\\" 的格式，属性 =\\\"属性值\\\"\"]},{\"header\":\"5.2 路径\",\"slug\":\"_5-2-路径\",\"contents\":[\"分为相对路径和绝对路径\"]},{\"header\":\"5.2.1 相对路径\",\"slug\":\"_5-2-1-相对路径\",\"contents\":[\"相对路径：以引用文件所在位置为参考基础而建立出的目录路径\",\"这里简单来说，就是图片相对于 HTML 页面的位置\",\"相对路径分类\",\"符号\",\"说明\",\"同级路径\",\"图像文件位于 HTML 文件同一级，如 <img src=\\\"baidu.gif\\\"/>\",\"下级路径\",\"/\",\"图像文件位于 HTML 文件下一级，如 <img src=\\\"images/baidu.gif\\\"/>\",\"上级路径\",\"../\",\"图像文件位于 HTML 文件上一级，如 <img src=\\\"../baidu.gif\\\"/>\",\"特点：相对路径是从代码所在的这个文件出发，去寻找目标文件的，而我们这里所说的上一级、下一级和同一级就是图片相对于 HTML 页面的位置\"]},{\"header\":\"5.2.2 绝对路径\",\"slug\":\"_5-2-2-绝对路径\",\"contents\":[\"绝对路径：是指目录下的绝对位置，直接到达目标位置，通常是从盘符开始的路径，例如，\\\"D:\\\\web\\\\img\\\\logo. gif\\\" 或完整的网络地址 \\\"http://www.itcast.cn/images/logo.gif\\\"\"]},{\"header\":\"5.3 常见的图片格式\",\"slug\":\"_5-3-常见的图片格式\",\"contents\":[\"jpg 格式： \",\"概述：扩展名为 .jpg 或 .jpeg ，是一种有损的压缩格式（把肉眼不容易观察出来的细节丢弃了）\",\"主要特点：支持的颜色丰富、占用空间较小、不支持透明背景、不支持动态图\",\"使用场景：对图片细节没有极高要求的场景，例如：网站的产品宣传图等。—— 该格式网页中很常见\",\"png 格式： \",\"概述：扩展名为 .png ，是一种无损的压缩格式，能够更高质量的保存图片\",\"主要特点：支持的颜色丰富、占用空间略大、支持透明背景、不支持动态图\",\"使用场景：想让图片有透明背景；想更高质量的呈现图片；例如 ：公司 logo 图、重要配图等\",\"bmp 格式： \",\"概述：扩展名为 .bmp ，不进行压缩的一种格式，在最大程度上保留图片更多的细节\",\"主要特点：支持的颜色丰富、保留的细节更多、占用空间极大、不支持透明背景、不支持动态图\",\"使用场景：对图片细节要求极高的场景，例如：一些大型游戏中的图片。（网页中很少使用）\",\"gif 格式： \",\"概述：扩展名为 .gif ，仅支持 256 种颜色，色彩呈现不是很完整\",\"主要特点：支持的颜色较少、支持简单透明背景、支持动态图\",\"使用场景：网页中的动态图片\",\"webp 格式： \",\"概述：扩展名为 .webp ，谷歌推出的一种格式，专门用来在网页中呈现图片\",\"主要特点：具备上述几种格式的优点，但兼容性不太好，一旦使用务必要解决兼容性问题\",\"使用场景：网页中的各种图片\",\"base 64 格式 \",\"本质：一串特殊的文本，要通过浏览器打开，传统看图应用通常无法打开\",\"原理：把图片进行 base 64 编码，形成一串文本\",\"如何生成：靠一些工具或网站\",\"如何使用：直接作为 img 标签的 src 属性的值即可，并且不受文件位置的影响\",\"使用场景：一些较小的图片，或者需要和网页一起加载的图片\"]},{\"header\":\"6. 链接\",\"slug\":\"_6-链接\",\"contents\":[\"链接的语法格式: <a href=\\\"跳转目标\\\" target=\\\"目标窗口的弹出方式\\\"> 文本或图像 </a>\",\"属性：\",\"href：用于指定链接目标的 url 地址\",\"target: 用于指定链接页面的打开方式，_self 默认值，_blank 新窗口打开\",\"#: 空链接\",\"链接分类：\",\"外部链接: 例如 <a href=\\\"http://www.baidu.com\\\">百度</a>\",\"内部链接: 网站内部页面之间的相互链接。直接链接内部页面名称即可，例如 <a href=\\\"index.html\\\">首页</a>\",\"空链接: 如果当时没有确定链接目标时，<a href=\\\"#\\\">首页</a>\",\"下载链接: 如果 href 里面地址是一个文件或者压缩包，会下载这个文件\",\"网页元素链接: 在网页中的各种网页元素，如文本、图像、表格、音频、视频等都可以添加超链接\",\"锚点链接: 点我们点击链接, 可以快速定位到页面中的某个位置，在链接文本的 href 属性中，设置属性值为 #名字 的形式，如 <a href=\\\"#two\\\">第2集</a>，找到目标位置标签，里面添加一个 id属性 = 刚才的名字，如：<h3 id=\\\"two\\\">第2集介绍</h3>\"]},{\"header\":\"7. 列表\",\"slug\":\"_7-列表\",\"contents\":[\"表格是用来显示数据的，那么列表就是用来布局的\",\"列表最大的特点就是整齐、整洁、有序，它作为布局会更加自由和方便\",\"根据使用情景不同，列表可以分为三大类：无序列表、有序列表和自定义列表\"]},{\"header\":\"7.1 无序列表\",\"slug\":\"_7-1-无序列表\",\"contents\":[\"<ul> 标签表示 HTML 页面中项目的无序列表，一般会以项目符号呈现列表项，而列表项使用 <li> 标签定义\",\"无序列表的基本语法格式如下：\",\"<ul> <li>列表项1</li> <li>列表项2</li> <li>列表项3</li> ... </ul> \",\"无序列表的各个列表项之间没有顺序级别之分，是并列的\",\"<ul></ul> 中只能嵌套 <li></li>，直接在 <ul></ul> 标签中输入其他标签或者文字的做法是不被允许的\",\"<li> 与 </li> 之间相当于一个容器，可以容纳所有元素\",\"无序列表会带有自己的样式属性，但在实际使用时，我们会使用 CSS 来设置\"]},{\"header\":\"7.2 有序列表\",\"slug\":\"_7-2-有序列表\",\"contents\":[\"有序列表即为有排列顺序的列表，其各个列表项会按照一定的顺序排列定义。在 HTML 标签中，<ol> 标签用于定义有序列表，列表排序以数字来显示，并且使用 <li> 标签来定义列表项\",\"有序列表的基本语法格式如下：\",\"<ol> <li>列表项1</li> <li>列表项2</li> <li>列表项3</li> ... </ol> \",\"<ol></ol> 中只能嵌套 <li></li>，直接在 <ol></ol> 标签中输入其他标签或者文字的做法是不被允许的\",\"<li> 与 </li> 之间相当于一个容器，可以容纳所有元素\",\"有序列表会带有自己样式属性，但在实际使用时，我们会使用 CSS 来设置\"]},{\"header\":\"7.3 自定义列表\",\"slug\":\"_7-3-自定义列表\",\"contents\":[\"自定义列表的使用场景: 自定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。在 HTML 标签中，<dl> 标签用于定义描述列表（或定义列表），该标签会与 <dt>（定义项目/名字）和 < dd>（描述每一个项目/名字）一起使用\",\"语法如下：\",\"<dl> <dt>名词1</dt> <dd>名词1解释1</dd> <dd>名词1解释2</dd> </dl> \"]},{\"header\":\"8. 表格\",\"slug\":\"_8-表格\",\"contents\":[]},{\"header\":\"8.1 基本结构\",\"slug\":\"_8-1-基本结构\",\"contents\":[\"一个完整的表格由：表格标题、表格头部、表格主体、表格脚注，四部分组成\",\"HTML基础01.png\",\"表格涉及到的标签：\",\"标签\",\"含义\",\"table\",\"表格\",\"caption\",\"表格标题\",\"thead\",\"表格头部\",\"tbody\",\"表格主体\",\"tfoot\",\"表格注脚\",\"tr\",\"每一行\",\"th、td\",\"每一个单元格（备注：表格头部中用 th，表格主体、表格脚注中用 td）\",\"HTML基础02.png\",\"HTML基础03.png\",\"HTML基础04.png\"]},{\"header\":\"8.2 常用属性\",\"slug\":\"_8-2-常用属性\",\"contents\":[\"table 标签（表格）\",\"属性\",\"含义\",\"width\",\"设置表格宽度\",\"height\",\"设置表格最小高度，表格最终高度可能比设置的值大\",\"border\",\"设置表格边框宽度\",\"cellspacing\",\"设置单元格之间的间距\",\"thead 标签（表格头部）\",\"属性\",\"含义\",\"height\",\"设置表格头部高度\",\"align\",\"设置单元格的水平对齐方式，可选 left、center、right\",\"valign\",\"设置单元格的垂直对齐方式，可选 top、middle、bottom\",\"tbody 标签（表格主体）、tr 标签（行）、tfoot 标签（表格脚注）常用属性与 thead 相同\",\"td 标签（普通单元格）\",\"属性\",\"含义\",\"width\",\"设置单元格的宽度，同列所有单元格全都受影响\",\"height\",\"设置单元格的高度，同行所有单元格全都受影响\",\"align\",\"设置单元格的水平对齐方式\",\"valign\",\"设置单元格的垂直对齐方式\",\"rowspan\",\"指定要跨的行数\",\"colspan\",\"指定要跨的列数\",\"注意：\",\"<table> 元素的 border 属性可以控制表格边框，但 border 值的大小，并不控制单元格边框的宽度，只能控制表格最外侧边框的宽度\",\"默认情况下，每列的宽度，得看这一列单元格最长的那个文字\",\"给某个 th 或 td 设置了宽度之后，他们所在的那一列的宽度就确定了\",\"给某个 th 或 td 设置了高度之后，他们所在的那一行的高度就确定了\"]},{\"header\":\"8.3 跨行跨列\",\"slug\":\"_8-3-跨行跨列\",\"contents\":[\"rowspan ：指定要跨的行数\",\"colspan ：指定要跨的列数\"]},{\"header\":\"9. 换行标签\",\"slug\":\"_9-换行标签\",\"contents\":[\"在 HTML 中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后才自动换行。如果希望某段文本强制换行显示，就需要使用换行标签 <br/>\",\"特点：\",\"<br/> 是个单标签\",\"<br/> 标签只是简单地开始新的一行，跟段落不一样，段落之间会插入一些垂直的间距\"]},{\"header\":\"10. 分隔线\",\"slug\":\"_10-分隔线\",\"contents\":[\"<hr> 分隔线，单标签\",\"<hr> 的语义是分隔，如果不想要语义，只是想画一条水平线，那么应当使用 CSS 完成\"]},{\"header\":\"11. 表单\",\"slug\":\"_11-表单\",\"contents\":[\"概念：一个包含交互的区域，用于收集用户提供的数据\"]},{\"header\":\"11.1 基本结构\",\"slug\":\"_11-1-基本结构\",\"contents\":[\"<form action=\\\"https://www.baidu.com/s\\\" target=\\\"_blank\\\" method=\\\"get\\\"> <input type=\\\"text\\\" name=\\\"wd\\\" /> <button>去百度搜索</button> </form> \",\"form 标签（表单），双标签\",\"属性\",\"含义\",\"action\",\"用于指定表单的提交地址\",\"target\",\"用于控制表单提交后，如何打开页面，常用值如下：_self 在本窗口打开，_blank 在新窗口打开\",\"method\",\"用于控制表单的提交方式\",\"input 标签（输入框），单标签\",\"属性\",\"含义\",\"type\",\"设置输入框的类型，目前用到的值是 text ，表示普通文本\",\"name\",\"用于指定提交数据的名字\"]},{\"header\":\"11.2 常用表单控件\",\"slug\":\"_11-2-常用表单控件\",\"contents\":[]},{\"header\":\"11.2.1 文本输入框\",\"slug\":\"_11-2-1-文本输入框\",\"contents\":[\"<input type=\\\"text\\\"> \",\"常用属性如下：\",\"name 属性：数据的名称\",\"value 属性：输入框的默认输入值\",\"maxlength 属性：输入框最大可输入长度\"]},{\"header\":\"11.2.2 密码输入框\",\"slug\":\"_11-2-2-密码输入框\",\"contents\":[\"<input type=\\\"password\\\"> \",\"常用属性如下：\",\"name 属性：数据的名称\",\"value 属性：输入框的默认输入值（一般不用，无意义）\",\"maxlength 属性：输入框最大可输入长度\"]},{\"header\":\"11.2.3 单选框\",\"slug\":\"_11-2-3-单选框\",\"contents\":[\"<input type=\\\"radio\\\" name=\\\"sex\\\" value=\\\"female\\\">女 <input type=\\\"radio\\\" name=\\\"sex\\\" value=\\\"male\\\">男 \",\"常用属性如下：\",\"name 属性：数据的名称，注意：想要单选效果，多个 radio 的 name 属性值要保持一致\",\"value 属性：提交的数据值\",\"checked 属性：让该单选按钮默认选中\"]},{\"header\":\"11.2.4 复选框\",\"slug\":\"_11-2-4-复选框\",\"contents\":[\"<input type=\\\"checkbox\\\" name=\\\"hobby\\\" value=\\\"sing\\\">唱 <input type=\\\"checkbox\\\" name=\\\"hobby\\\" value=\\\"dance\\\">跳 <input type=\\\"checkbox\\\" name=\\\"hobby\\\" value=\\\"rap\\\">rap \",\"常用属性如下：\",\"name 属性：数据的名称\",\"value 属性：提交的数据值\",\"checked 属性：让该复选框默认选中\"]},{\"header\":\"11.2.5 隐藏域\",\"slug\":\"_11-2-5-隐藏域\",\"contents\":[\"<input type=\\\"hidden\\\" name=\\\"tag\\\" value=\\\"100\\\"> \",\"用户不可见的一个输入区域，作用是： 提交表单的时候，携带一些固定的数据\",\"常用属性如下：\",\"name 属性：指定数据的名称\",\"value 属性：指定的是真正提交的数据\"]},{\"header\":\"11.2.6 提交按钮\",\"slug\":\"_11-2-6-提交按钮\",\"contents\":[\"<input type=\\\"submit\\\" value=\\\"点我提交表单\\\"> <button>点我提交表单</button> \",\"注意：\",\"button 标签 type 属性的默认值是 submit\",\"button 不要指定 name 属性\",\"input 标签编写的按钮，使用 value 属性指定按钮文字\"]},{\"header\":\"11.2.7 重置按钮\",\"slug\":\"_11-2-7-重置按钮\",\"contents\":[\"<input type=\\\"reset\\\" value=\\\"点我重置\\\"> <button type=\\\"reset\\\">点我重置</button> \",\"注意：\",\"button 不要指定 name 属性\",\"input 标签编写的按钮，使用 value 属性指定按钮文字\"]},{\"header\":\"11.2.8 普通按钮\",\"slug\":\"_11-2-8-普通按钮\",\"contents\":[\"<input type=\\\"button\\\" value=\\\"普通按钮\\\"> <button type=\\\"button\\\">普通按钮</button> \",\"注意：普通按钮的 type 值为 button ，若不写 type 值是 submit 会引起表单的提交\"]},{\"header\":\"11.2.9 文本域\",\"slug\":\"_11-2-9-文本域\",\"contents\":[\"<textarea name=\\\"msg\\\" rows=\\\"22\\\" cols=\\\"3\\\">我是文本域</textarea> \",\"常用属性如下：\",\"rows 属性：指定默认显示的行数，会影响文本域的高度\",\"cols 属性：指定默认显示的列数，会影响文本域的宽度\",\"不能编写 type 属性，其他属性，与普通文本输入框一致\"]},{\"header\":\"11.2.10 下拉框\",\"slug\":\"_11-2-10-下拉框\",\"contents\":[\"<select name=\\\"from\\\"> <option value=\\\"黑\\\">黑龙江</option> <option value=\\\"吉\\\">吉林</option> <option value=\\\"辽\\\">辽宁</option> </select> \",\"常用属性及注意事项：\",\"name 属性：指定数据的名称\",\"option 标签设置 value 属性，如果没有 value 属性，提交的数据是 option 中间的文字；如果设置了 value 属性，提交的数据就是 value 的值（建议设置 value 属性）\",\"option 标签设置了 selected 属性，表示默认选中\"]},{\"header\":\"11.2.11 禁用表单控件\",\"slug\":\"_11-2-11-禁用表单控件\",\"contents\":[\"给表单控件的标签设置 disabled 既可禁用表单控件\",\"input 、 textarea 、 button 、 select 、 option 都可以设置 disabled 属性\"]},{\"header\":\"11.3 label 标签\",\"slug\":\"_11-3-label-标签\",\"contents\":[\"label 标签可与表单控件相关联，关联之后点击文字，与之对应的表单控件就会获取焦点\",\"两种与 label 关联方式如下：\",\"让 label 标签的 for 属性的值等于表单控件的 id\",\"把表单控件套在 label 标签的里面\"]},{\"header\":\"11.4 fieldset 与 legend 的使用\",\"slug\":\"_11-4-fieldset-与-legend-的使用\",\"contents\":[\"fieldset 可以为表单控件分组、 legend 标签是分组的标题\"]},{\"header\":\"12. 框架标签\",\"slug\":\"_12-框架标签\",\"contents\":[\"标签名\",\"功能和语义\",\"属性\",\"单/双标签\",\"iframe\",\"框架（在网页中嵌入其他文件）\",\"name: 框架名字，可以与 target 属性配合width：框架的宽度height：框架的高度frameborder：是否显示边框，值为 0 或 1\",\"双\",\"iframe 标签的实际应用：\",\"在网页中嵌入广告\",\"与超链接或表单的 target 配合，展示不同的内容\"]},{\"header\":\"13. HTML 实体\",\"slug\":\"_13-html-实体\",\"contents\":[\"在 HTML 中我们可以用一种 特殊的形式 的内容，来表示某个符号，这种特殊形式的内容，就是 HTML 实体。比如小于号 < 用于定义 HTML 标签的开始。如果我们希望浏览器正确地显示这些字符，我们必须在 HTML 源码中插入字符实体\",\"字符实体由三部分组成：一个 & 和一个实体名称（或者一个 # 和一个实体编号），最后加上一个分号 ;\",\"常见的字符实体：\",\"描述\",\"实体名称\",\"实体编号\",\"空格\",\"&nbsp;\",\"&#160;\",\"<\",\"小于号\",\"&lt;\",\"&#60;\",\">\",\"大于号\",\"&gt;\",\"&#62;\",\"&\",\"和号\",\"&amp;\",\"&#38;\",\"\\\"\",\"引号\",\"&quot;\",\"&#34;\",\"￥\",\"元（yen）\",\"&yen;\",\"&#165;\",\"©\",\"版权（copyright）\",\"&copy;\",\"&#169;\",\"×\",\"乘号\",\"&times;\",\"&#215;\",\"÷\",\"除号\",\"&divide;\",\"&#247;\"]},{\"header\":\"14. HTML 全局属性\",\"slug\":\"_14-html-全局属性\",\"contents\":[\"常用的全局属性：\",\"属性名\",\"含义\",\"id\",\"给标签指定唯一标识，注意：id 是不能重复的。作用：可以让 label 标签与表单控件相关联；也可以与 CSS、JavaScript 配合使用\",\"class\",\"给标签指定类名，随后通过 CSS 就可以给标签设置样式\",\"style\",\"给标签设置 CSS 样式\",\"dir\",\"内容的方向，值: ltr、rtl\",\"title\",\"给标签设置一个文字提示，一般超链接和图片用得比较多\",\"lang\",\"给标签指定语\"]},{\"header\":\"15. meta 元信息\",\"slug\":\"_15-meta-元信息\",\"contents\":[\"配置字符编码\",\"<meta charset=\\\"UTF-8\\\"> \",\"针对 IE 浏览器的兼容性配置\",\"<meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> \",\"针对移动端的配置\",\"<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> \",\"配置网页关键字\",\"<meta name=\\\"keywords\\\" content=\\\"8-12个以英文逗号隔开的单词/词语\\\"> \",\"配置网页描述信息\",\"<meta name=\\\"description\\\" content=\\\"80字以内的一段话，与网站内容相关\\\"> \",\"针对搜索引擎爬虫配置\",\"<meta name=\\\"robots\\\" content=\\\"此处可选值见下表\\\"> \",\"值\",\"描述\",\"index\",\"允许搜索爬虫索引此页面\",\"noindex\",\"要求搜索爬虫不索引此页面\",\"follow\",\"允许搜索爬虫跟随此页面上的链接\",\"nofollow\",\"要求搜索爬虫不跟随此页面上的链接\",\"all\",\"与 index，follow 等价\",\"none\",\"与 noindex，nofollow 等价\",\"noarchive\",\"要求搜索引擎不缓存页面内容\",\"nocache\",\"noarchive 的替代名称\",\"配置网页作者\",\"<meta name=\\\"author\\\" content=\\\"tony\\\"> \",\"配置网页生成工具\",\"<meta name=\\\"generator\\\" content=\\\"Visual Studio Code\\\"> \",\"配置定义网页版权信息\",\"<meta name=\\\"copyright\\\" content=\\\"2023-2027©版权所有\\\"> \",\"配置网页自动刷新\",\"<meta http-equiv=\\\"refresh\\\" content=\\\"10;url=http://www.baidu.com\\\"> \"]}]},\"/front-end/html-notes/06-HTML5%E7%AE%80%E4%BB%8B.html\":{\"title\":\"HTML5简介\",\"contents\":[{\"header\":\"1. 什么是HTML5\",\"slug\":\"_1-什么是html5\",\"contents\":[\"HTML5 是新一代的 HTML 标准，2014年10月由万维网联盟（ W3C ）完成标准制定\",\"HTML5 在狭义上是指新一代的 HTML 标准，在广义上是指：整个前端\"]},{\"header\":\"2. HTML5优势\",\"slug\":\"_2-html5优势\",\"contents\":[\"针对 JavaScript ，新增了很多可操作的接口\",\"新增了一些语义化标签、全局属性\",\"新增了多媒体标签，可以很好的替代 flash\",\"更加侧重语义化，对于 SEO 更友好\",\"可移植性好，可以大量应用在移动设备上\"]}]},\"/front-end/html-notes/07-HTML5%E6%96%B0%E5%A2%9E%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE.html\":{\"title\":\"HTML5新增语义化标签\",\"contents\":[{\"header\":\"1. 新增布局标签\",\"slug\":\"_1-新增布局标签\",\"contents\":[\"<header> 头部标签\",\"<nav> 导航标签\",\"<article> 内容标签\",\"<section> 定义文档某个区域\",\"<aside> 侧边栏标签\",\"<footer> 尾部标签\",\"HTML5新增语义化标签01.png\",\"关于 article 和 section：\",\"artical 里面可以有多个 section\",\"section 强调的是分段或分块，如果你想将一块内容分成几段的时候，可使用 section 元素\",\"article 比 section 更强调独立性，一块内容如果比较独立、比较完整，应该使用 article 元素\"]},{\"header\":\"2. 新增状态标签\",\"slug\":\"_2-新增状态标签\",\"contents\":[]},{\"header\":\"2.1 meter 标签\",\"slug\":\"_2-1-meter-标签\",\"contents\":[\"语义：定义已知范围内的标量测量。也被称为 gauge （尺度），双标签，例如：电量、磁盘用量等\",\"常用属性如下：\",\"属性\",\"值\",\"描述\",\"high\",\"数值\",\"规定高值\",\"low\",\"数值\",\"规定低值\",\"max\",\"数值\",\"规定最大值\",\"min\",\"数值\",\"规定最小值\",\"optimum\",\"数值\",\"规定最优值\",\"value\",\"数值\",\"规定当前值\"]},{\"header\":\"2.2 progress 标签\",\"slug\":\"_2-2-progress-标签\",\"contents\":[\"语义：显示某个任务完成的进度的指示器，一般用于表示进度条，双标签，例如：工作完成进度等\",\"常用属性如下：\",\"属性\",\"值\",\"描述\",\"max\",\"数值\",\"规定目标值\",\"value\",\"数值\",\"规定当前值\"]},{\"header\":\"3. 新增列表标签\",\"slug\":\"_3-新增列表标签\",\"contents\":[\"标签名\",\"语义\",\"单/双标签\",\"datalist\",\"用于搜索框的关键字提示\",\"双\",\"details\",\"用于展示问题和答案，或对专有名词进行解释\",\"双\",\"summary\",\"写在 details 的里面，用于指定问题或专有名词\",\"双\"]},{\"header\":\"4. 新增文本标签\",\"slug\":\"_4-新增文本标签\",\"contents\":[]},{\"header\":\"4.1 文本注音\",\"slug\":\"_4-1-文本注音\",\"contents\":[\"标签名\",\"语义\",\"单/双标签\",\"ruby\",\"包裹需要注音的文字\",\"双\",\"rt\",\"写注音，rt 标签写在 ruby 的里面\",\"双\"]},{\"header\":\"4.2 文本标记\",\"slug\":\"_4-2-文本标记\",\"contents\":[\"标签名\",\"语义\",\"单/双标签\",\"mark\",\"标记\",\"双\",\"注意： W3C 建议 mark 用于标记搜索结果中的关键字\"]}]},\"/front-end/html-notes/08-HTML5%E6%96%B0%E5%A2%9E%E8%A1%A8%E5%8D%95%E7%9B%B8%E5%85%B3%E5%8A%9F%E8%83%BD.html\":{\"title\":\"HTML5新增表单相关功能\",\"contents\":[{\"header\":\"1. 表单控件新增属性\",\"slug\":\"_1-表单控件新增属性\",\"contents\":[\"属性\",\"值\",\"说明\",\"required\",\"required\",\"表单拥有该属性表示其内容不能为空，必填\",\"placeholder\",\"提示文本\",\"表单的提示信息，存在默认值将不显示\",\"autofocus\",\"autofocus\",\"自动聚焦属性，页面加载完成自动聚焦到指定表单\",\"autocomplete\",\"off/on\",\"当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。默认已经打开，需放在表单内，同时加上 name 属性，同时成功提交\",\"multiple\",\"multiple\",\"可以多选文件提交\",\"pattern\",\"regexp\",\"填写正则表达式，适用于文本输入类表单控件\",\"补充：通过如下方法可以设置 placeholder 里面的字体颜色\",\"input::placeholder{ color:pink; } \"]},{\"header\":\"2. input新增type属性值\",\"slug\":\"_2-input新增type属性值\",\"contents\":[\"在 HTML5 中，帮我们新增加了很多类型的表单\",\"案例代码：\",\"<!-- 我们验证的时候必须添加 form 表单域 --> <form action=\\\"\\\"> <ul> <li>邮箱: <input type=\\\"email\\\" /></li> <li>网址: <input type=\\\"url\\\" /></li> <li>日期: <input type=\\\"date\\\" /></li> <li>时间: <input type=\\\"time\\\" /></li> <li>数量: <input type=\\\"number\\\" /></li> <li>手机号码: <input type=\\\"tel\\\" /></li> <li>搜索: <input type=\\\"search\\\" /></li> <li>颜色: <input type=\\\"color\\\" /></li> <li>范围: <input type=\\\"range\\\" /></li> <!-- 当我们点击提交按钮就可以验证表单了 --> <li> <input type=\\\"submit\\\" value=\\\"提交\\\"></li> </ul> </form> \",\"常见输入类型：\",\"text password radio checkbox button file hidden submit reset image \",\"新的输入类型：\",\"属性值\",\"说明\",\"type=\\\"email\\\"\",\"限制用户输入必须为 email 类型\",\"type=\\\"url\\\"\",\"限制用户输入必须为 url 类型\",\"type=\\\"data\\\"\",\"限制用户输入必须为日期类型\",\"type=\\\"time\\\"\",\"限制用户输入必须为时间类型\",\"type=\\\"month\\\"\",\"限制用户输入必须为月份类型\",\"type=\\\"week\\\"\",\"限制用户输入必须为周类型\",\"type=\\\"number\\\"\",\"限制用户输入必须为数字类型\",\"type=\\\"tel\\\"\",\"手机号码\",\"type=\\\"search\\\"\",\"搜索框\",\"type=\\\"color\\\"\",\"生成一个颜色选择表单\",\"type=\\\"range\\\"\",\"范围选择框，默认值为 50 ，表单提交时不会验证格式\",\"type=\\\"datetime-local\\\"\",\"日期+时间选择框，默认值为空，表单提交时不会验证格式\"]},{\"header\":\"3. form 标签新增属性\",\"slug\":\"_3-form-标签新增属性\",\"contents\":[\"属性名\",\"功能\",\"novalidate\",\"如果给 form 标签设置了该属性，表单提交的时候不再进行验证\"]}]},\"/front-end/html-notes/09-HTML5%E6%96%B0%E5%A2%9E%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A0%87%E7%AD%BE.html\":{\"title\":\"HTML5新增多媒体标签\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"多媒体标签分为音频 audio 和视频 video 两个标签，使用它们，我们可以很方便的在页面中嵌入音频和视频，而不再去使用落后的 flash 和其他浏览器插件了\"]},{\"header\":\"1. 视频标签-video\",\"slug\":\"_1-视频标签-video\",\"contents\":[]},{\"header\":\"1.1 基本使用\",\"slug\":\"_1-1-基本使用\",\"contents\":[\"当前 <video> 元素支持三种视频格式：尽量使用 mp4 格式的视频\",\"使用语法：\",\"<video src=\\\"文件地址\\\"></video> \",\"浏览器\",\"MP 4\",\"WebM\",\"Ogg\",\"Internet Explorer\",\"yes\",\"no\",\"no\",\"Chrome\",\"yes\",\"yes\",\"yes\",\"Firefox\",\"yes\",\"yes\",\"yes\",\"Safari\",\"yes\",\"no\",\"no\",\"Opera\",\"yes\",\"yes\",\"yes\"]},{\"header\":\"1.2 兼容写法\",\"slug\":\"_1-2-兼容写法\",\"contents\":[\"由于各个浏览器的支持情况不同，所以我们会有一种兼容性的写法，这种写法了解一下即可\",\"<video controls=\\\"controls\\\" width=\\\"300\\\"> <source src=\\\"move.ogg\\\" type=\\\"video/ogg\\\" > <source src=\\\"move.mp4\\\" type=\\\"video/mp4\\\" > 您的浏览器暂不支持 <video> 标签播放视频 </ video > \",\"上面这种写法，浏览器会匹配 video 标签中的 source，如果支持就播放，如果不支持往下匹配，直到没有匹配的格式，就提示文本\"]},{\"header\":\"1.3 video 常用属性\",\"slug\":\"_1-3-video-常用属性\",\"contents\":[\"属性\",\"值\",\"描述\",\"autoplay\",\"autoplay\",\"视频就绪自动播放（谷歌浏览器需要添加 muted 来解决自动播放的问题）\",\"controls\",\"controls\",\"向用户显示播放控件\",\"width\",\"px（像素）\",\"设置播放器宽度\",\"height\",\"px（像素）\",\"设置播放器高度\",\"loop\",\"loop\",\"播放完是否继续播放该视频，循环播放\",\"preload\",\"auto（预先加载视频）、none（不预先加载视频）\",\"规定是否预加载视频（如果有了 autoplay 就忽略该属性）\",\"src\",\"url\",\"视频 URL 地址\",\"poster\",\"imgurl\",\"加载等待的画面图片\",\"muted\",\"muted\",\"静音播放\",\"属性很多，需重点掌握：\",\"autoplay 自动播放 \",\"注意： 在 google 浏览器上面，默认禁止了自动播放，如果想要自动播放的效果，需要设置 muted 属性\",\"width 宽度\",\"height 高度\",\"loop 循环播放\",\"src 播放源\",\"muted 静音播放\",\"示例代码：\",\"<video src=\\\"media/mi.mp4\\\" autoplay=\\\"autoplay\\\" muted=\\\"muted\\\" loop=\\\"loop\\\" poster=\\\"media/mi.jpg\\\"></video> \"]},{\"header\":\"2. 音频标签-audio\",\"slug\":\"_2-音频标签-audio\",\"contents\":[]},{\"header\":\"2.1 基本使用\",\"slug\":\"_2-1-基本使用\",\"contents\":[\"当前 <audio> 元素支持三种视频格式：尽量使用 mp3 格式\",\"使用语法：\",\"<audio src=\\\"文件地址\\\"></audio> \",\"浏览器\",\"MP 3\",\"Wav\",\"Ogg\",\"Internet Explorer\",\"yes\",\"no\",\"no\",\"Chrome\",\"yes\",\"yes\",\"yes\",\"Firefox\",\"yes\",\"yes\",\"yes\",\"Safari\",\"yes\",\"yes\",\"no\",\"Opera\",\"yes\",\"yes\",\"yes\"]},{\"header\":\"2.2 兼容写法\",\"slug\":\"_2-2-兼容写法\",\"contents\":[\"由于各个浏览器的支持情况不同，所以我们会有一种兼容性的写法，这种写法了解一下即可\",\"< audio controls=\\\"controls\\\" > <source src=\\\"happy.mp3\\\" type=\\\"audio/mpeg\\\" > <source src=\\\"happy.ogg\\\" type=\\\"audio/ogg\\\" > 您的浏览器暂不支持 <audio> 标签。 </ audio> \",\"上面这种写法，浏览器会匹配 audio 标签中的 source，如果支持就播放，如果不支持往下匹配，直到没有匹配的格式，就提示文本\"]},{\"header\":\"2.3 audio 常用属性\",\"slug\":\"_2-3-audio-常用属性\",\"contents\":[\"属性\",\"值\",\"描述\",\"autoplay\",\"autoplay\",\"如果出现该属性，则音频在就绪后马上播放\",\"controls\",\"controls\",\"如果出现该属性，则向用户显示控件，比如播放按钮\",\"loop\",\"loop\",\"如果出现该属性，则每当音频结束时重新开始播放\",\"src\",\"url\",\"要播放的音频的 url\",\"示例代码：\",\"<audio src=\\\"media/music.mp3\\\" autoplay=\\\"autoplay\\\" controls=\\\"controls\\\"></audio> \"]},{\"header\":\"3. 小结\",\"slug\":\"_3-小结\",\"contents\":[\"音频标签和视频标签使用方式基本一致\",\"浏览器支持情况不同\",\"谷歌浏览器把音频和视频自动播放禁止了\",\"我们可以给视频标签添加 muted 属性来静音播放视频，音频不可以（可以通过 JavaScript 解决）\",\"视频标签是重点，我们经常设置自动播放，不使用 controls 控件，循环和设置大小属性\"]}]},\"/front-end/html-notes/10-HTML5%E6%96%B0%E5%A2%9E%E5%85%A8%E5%B1%80%E5%B1%9E%E6%80%A7.html\":{\"title\":\"HTML5新增全局属性\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"属性名\",\"功能\",\"contenteditable\",\"表示元素是否可被用户编辑，可选值：true：可编辑false：不可编辑\",\"draggable\",\"表示元素可以被拖动，可选值：true：可拖动false：不可拖动\",\"hidden\",\"隐藏元素\",\"spellcheck\",\"规定是否对元素进行拼写和语法检查，可选值：true：检查false：不检查\",\"contextmenu\",\"规定元素的上下文菜单，在用户鼠标右击元素时显示\",\"data-*\",\"用于存储页面的私有定制数据\"]}]},\"/front-end/html-notes/11-HTML5%E5%85%BC%E5%AE%B9%E6%80%A7%E5%A4%84%E7%90%86.html\":{\"title\":\"HTML5兼容性处理\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"添加元信息，让浏览器处于最优渲染模式\",\"<!--设置IE总是使用最新的文档模式进行渲染--> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=Edge\\\"> <!--优先使用 webkit ( Chromium ) 内核进行渲染, 针对360等浏览器--> <meta name=\\\"renderer\\\" content=\\\"webkit\\\"> \",\"使用 html5shiv 让低版本浏览器认识 H5 的语义化标签\",\"<!--[if lt ie 9]> <script src=\\\"html5shiv.js\\\"></script> <![endif]--> \",\"扩展：\",\"lt 小于\",\"lte 小于等于\",\"gt 大于\",\"gte 大于等于\",\"! 逻辑非\",\"示例：\",\"<!--[if IE 8]>仅IE8可见<![endif]--> <!--[if gt IE 8]>仅IE8以上可见<![endif]--> <!--[if lt IE 8]>仅IE8以下可见<![endif]--> <!--[if gte IE 8]>IE8及以上可见<![endif]--> <!--[if lte IE 8]>IE8及以下可见<![endif]--> \"]}]},\"/front-end/html-notes/\":{\"title\":\"HTML笔记\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"HTML学习过程中的笔记\"]}]},\"/front-end/javascript-notes/01-JavaScript-%E7%AE%80%E4%BB%8B.html\":{\"title\":\"JavaScript-简介\",\"contents\":[{\"header\":\"1. JavaScript的组成\",\"slug\":\"_1-javascript的组成\",\"contents\":[\"ECMASCRIPT: 定义了 JavaScript 的语法规范, 描述了语言的基本语法和数据类型\",\"BOM (Browser Object Model): 浏览器对象模型\",\"有一套成熟的可以操作浏览器的 API，通过 BOM 可以操作浏览器。比如： 弹出框、浏览器跳转、获取分辨率等\",\"DOM (Document Object Model): 文档对象模型\",\"有一套成熟的可以操作页面元素的 API，通过 DOM 可以操作页面中的元素。比如： 增加一个 div，减少个一div，给 div 换个位置等\"]},{\"header\":\"2. JavaScript用途\",\"slug\":\"_2-javascript用途\",\"contents\":[\"常见的网页效果，如表单验证，轮播图等\",\"与 H5配合实现游戏\",\"实现应用级别的程序\",\"实现图表统计效果\",\"可以实现人工智能\",\"后端开发，app开发，桌面端开发等\"]},{\"header\":\"3. JavaScript的语言风格和特性\",\"slug\":\"_3-javascript的语言风格和特性\",\"contents\":[\"类 C 语言风格，容易上手\",\"弱类型（动态类型），简单易学\",\"丰富的功能，无敌的生态，强大的性能\"]}]},\"/front-end/javascript-notes/02-JavaScript-%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F.html\":{\"title\":\"JavaScript-引入方式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"JavaScript 程序不能独立运行，它需要被嵌入 HTML 中，然后浏览器才能执行 JavaScript 代码。通过 script 标签将 JavaScript 代码引入到 HTML 中\"]},{\"header\":\"1. 内部方式\",\"slug\":\"_1-内部方式\",\"contents\":[\"通过 script 标签包裹 JavaScript 代码\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 引入方式</title> </head> <body> <!-- 内部形式：通过 script 标签包裹 JavaScript 代码 --> <script> // JavaScript代码 </script> </body> </html> \",\"注意：将 JavaScript 代码放在 HTML 页面的底部附近通常是最好的策略\"]},{\"header\":\"2. 外部方式\",\"slug\":\"_2-外部方式\",\"contents\":[\"一般将 JavaScript 代码写在独立的以 .js 结尾的文件中，然后通过 script 标签的 src 属性引入\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 引入方式</title> </head> <body> <!-- 外部形式：通过 script 的 src 属性引入独立的 .js 文件 --> <script src=\\\"xxx.js\\\"></script> </body> </html> \",\"如果 script 标签使用 src 属性引入了某 .js 文件，那么标签的代码会被忽略！！！\",\"如下代码所示：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 引入方式</title> </head> <body> <!-- 外部形式：通过 script 的 src 属性引入独立的 .js 文件 --> <script src=\\\"xxx.js\\\"> // 此处的代码会被忽略掉！！！！ // JavaScript代码 </script> </body> </html> \"]},{\"header\":\"3. 内联方式\",\"slug\":\"_3-内联方式\",\"contents\":[\"代码写在标签内部\",\"例：\",\"<body> <button onclick=\\\"alert('逗你玩~~~')“>点我</button> </body> \"]}]},\"/front-end/javascript-notes/03-JavaScript-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html\":{\"title\":\"JavaScript-输入输出\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"输入和输出也可理解为人和计算机的交互，用户通过键盘、鼠标等向计算机输入信息，计算机处理后再展示结果给用户，这便是一次输入和输出的过程\",\"JavaScript本身没有任何打印或者输出的函数，但是我们可以使用其它方式输出和输入数据\"]},{\"header\":\"1. 输出\",\"slug\":\"_1-输出\",\"contents\":[\"JavaScript 可以接收用户的输入，然后再将输入的结果输出：alert()、document.write()、console.log()\",\"alert() 或 document.write() 会在浏览器中展示（输出）给用户\",\"console.log() 可以在控制台打印\",\"后面章节会深入探讨以上方法，目前学习的内容是为了方便我们在运行程序时看到结果\"]},{\"header\":\"2. 输入\",\"slug\":\"_2-输入\",\"contents\":[\"向 prompt() 输入任意内容会以弹窗形式出现在浏览器中，一般提示用户输入一些内容\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 输入输出</title> </head> <body> <script> // 1. 展示给用户 document.write('要输出的内容') alert('要输出的内容') console.log('要输出的内容') // 2. 以弹窗形式提示用户输入姓名，注意这里的文字使用英文的引号 prompt('请输入您的姓名:') </script> </body> </html> \",\"后面章节会深入探讨以上方法，目前学习的内容是为了方便我们在运行程序时看到结果\"]}]},\"/front-end/javascript-notes/04-JavaScript-%E6%B3%A8%E9%87%8A%E4%B8%8E%E7%BB%93%E6%9D%9F%E7%AC%A6.html\":{\"title\":\"JavaScript-注释与结束符\",\"contents\":[{\"header\":\"1. 注释\",\"slug\":\"_1-注释\",\"contents\":[\"通过注释可以阻止代码被执行或者添加备注信息，JavaScript 支持两种形式注释语法\"]},{\"header\":\"1.1 单行注释\",\"slug\":\"_1-1-单行注释\",\"contents\":[\"使用 // 注释单行代码\",\"VSCode中快捷键：ctrl+/\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 注释</title> </head> <body> <script> // 这种是单行注释的语法 // 一次只能注释一行 // 可以重复注释 </script> </body> </html> \"]},{\"header\":\"1.2 多行注释\",\"slug\":\"_1-2-多行注释\",\"contents\":[\"使用 /* */ 注释多行代码\",\"VSCode中快捷键：shift+alt+A\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 注释</title> </head> <body> <script> /* 这种的是多行注释的语法 */ /* 更常见的多行注释是这种写法 可以任意换行 多少行都可以 */ </script> </body> </html> \"]},{\"header\":\"2. 结束符\",\"slug\":\"_2-结束符\",\"contents\":[\"在 JavaScript 中 ; 代表一段代码的结束，多数情况下可以省略 ; 使用回车（enter）替代\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 结束符</title> </head> <body> <script> alert(1); alert(2); alert(1) alert(2) </script> </body> </html> \",\"实际开发中有许多人主张书写 JavaScript 代码时省略结束符 ;\"]}]},\"/front-end/javascript-notes/05-JavaScript-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F.html\":{\"title\":\"JavaScript-严格模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"严格模式：\",\"<script> 'use strict'//在代码开头添加该语句，即表示在严格模式下 <script> \"]}]},\"/front-end/javascript-notes/06-JavaScript-%E5%8F%98%E9%87%8F.html\":{\"title\":\"JavaScript-变量\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"变量指的是在程序中保存数据的一个容器，变量是计算机内存中存储数据的标识符，根据变量名称可以获取到内存中存储的数据，也就是说，我们向内存中存储了一个数据，然后要给这个数据起一个名字，为了是我们以后再次找到它\"]},{\"header\":\"1. 定义变量及赋值\",\"slug\":\"_1-定义变量及赋值\",\"contents\":[\"// 定义一个变量 var num // 给一个变量赋值 num = 100 // 定义一个变量的同时给其赋值 var num2 = 200 \",\"注意：\",\"一个变量名只能存储一个值\",\"当再次给一个变量赋值的时候，前面一次的值就没有了\",\"变量名称区分大小写（JS 严格区分大小写）\"]},{\"header\":\"2. 变量的命名规则和命名规范\",\"slug\":\"_2-变量的命名规则和命名规范\",\"contents\":[\"规则： 必须遵守的，不遵守就是错\",\"一个变量名称可以由数字、字母、英文下划线 _、美元符号 $ 组成\",\"严格区分大小写\",\"不能由数字开头\",\"不能是保留字或者关键字\",\"不要出现空格\",\"规范： 建议遵守的（开发者默认），不遵守不会报错\",\"变量名尽量有意义（语义化）\",\"遵循驼峰命名规则，由多个单词组成的时候，从第二个单词开始首字母大写\",\"不要使用中文\"]},{\"header\":\"3. 变量提示\",\"slug\":\"_3-变量提示\",\"contents\":[\"变量声明的提升：可以提前使用一个稍后才声明的变量，而不会引发异常\",\"在执行所有代码前，JS 有预解析阶段，会预读所有变量的声明（不会提升赋值，只会提升定义）\",\"// 变量声明提升的只是定义，不提升赋值！！！ // 先使用变量 console.log(a) // undefined var a = 10 // 后定义变量 console.log(a) // 10 \",\"实际的情况相当于：\",\"var a console.log(a) // undefined a = 10 console.log(a) // 10 \"]}]},\"/front-end/javascript-notes/07-JavaScript-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html\":{\"title\":\"JavaScript-数据类型\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"数据类型是指存储在内存中的数据的类型，通常分为两大类 基本数据类型 和 复杂数据类型\"]},{\"header\":\"1. 基本数据类型\",\"slug\":\"_1-基本数据类型\",\"contents\":[\"基本数据类型又叫做简单类型或者值类型，在存储时变量中存储的是值本身，因此叫做值类型，如 string，number，boolean，undefined，null\",\"数值类型（number） \",\"一切数字都是数值类型（包括二进制，十进制，十六进制等）\",\"NaN（not a number），一个非数字，NaN 代表一个计算错误，它是一个不正确的或一个未定义的数学操作所得到的结果，NaN 是粘性的，任何对 NaN 的操作都会返回 NaN\",\"字符串类型（string） \",\"被引号包裹的所有内容（可以是单引号''也可以是双引号\\\"\\\"）,单引号和双引号没有本质上的区别，推荐使用单引号\",\"注意： \",\"无论单引号或是双引号必须成对使用\",\"单引号/双引号可以互相嵌套，但是不可以自已嵌套自已\",\"必要时可以使用转义符 \\\\，输出单引号或双引号\",\"布尔类型（boolean） \",\"只有两个（true 或者 false）\",\"null类型（null） \",\"只有一个，就是 null，表示”空“、”无“或”值未知“的意思\",\"未定义类型（undefined） \",\"未定义是比较特殊的类型，只有一个值 undefined，只声明变量，不赋值的情况下，变量的默认值为 undefined，一般很少直接为某个变量赋值为 undefined\"]},{\"header\":\"2. 复杂数据类型\",\"slug\":\"_2-复杂数据类型\",\"contents\":[\"复杂数据类型，在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型\",\"通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date 等\"]},{\"header\":\"3. 判断数据类型\",\"slug\":\"_3-判断数据类型\",\"contents\":[\"使用 typeof 关键字来检测数据类型\",\"// 第一种使用方式 var n1 = 100 console.log(typeof n1)// number // 第二种使用方式 var s1 = 'abcdefg' console.log(typeof(s1))// string \"]},{\"header\":\"4. 数据类型转换\",\"slug\":\"_4-数据类型转换\",\"contents\":[\"数据类型之间的转换，比如数字转成字符串，字符串转成布尔，布尔转成数字等\",\"JavaScript 是弱类型语言：JavaScript 也不知道变量到底属于哪种数据类型，只有赋值了才清楚\"]},{\"header\":\"4.1 其他数据类型转成数值\",\"slug\":\"_4-1-其他数据类型转成数值\",\"contents\":[\"Number(变量)\",\"可以把一个变量强制转换成数值类型\",\"可以转换小数，会保留小数\",\"可以转换布尔值\",\"遇到不可转换的都会返回 NaN\",\"parseInt(变量)\",\"从第一位开始检查，是数字就转换，直到一个不是数字的内容\",\"开头就不是数字，那么直接返回 NaN\",\"不认识小数点，只能保留整数\",\"parseFloat(变量)\",\"从第一位开始检查，是数字就转换，直到一个不是数字的内容\",\"开头就不是数字，那么直接返回 NaN\",\"认识一次小数点\",\"除了加法以外的数学运算\",\"运算符两边都是可运算数字才行\",\"如果运算符任何一边不是一个可运算数字，那么就会返回 NaN\",\"加法不可以用\"]},{\"header\":\"4.2 其他数据类型转成字符串\",\"slug\":\"_4-2-其他数据类型转成字符串\",\"contents\":[\"变量.toString()\",\"有一些数据类型不能使用 toString() 方法，比如 undefined 和 null\",\"String(变量)\",\"所有数据类型都可以\",\"使用加法运算\",\"在 JS 里面，+ 由两个含义 \",\"字符串拼接： 只要 + 任意一边是字符串，就会进行字符串拼接\",\"加法运算：只有 + 两边都是数字的时候，才会进行数学运算\"]},{\"header\":\"4.3 其他数据类型转成布尔\",\"slug\":\"_4-3-其他数据类型转成布尔\",\"contents\":[\"Boolean(变量)\",\"在 js 中，只有 ''、0、null、undefined、NaN，这些是 false\",\"其余都是 true\"]},{\"header\":\"5. 数据类型之间存储的区别\",\"slug\":\"_5-数据类型之间存储的区别\",\"contents\":[\"既然我们区分了基本数据类型和复杂数据类型，那么他们之间就一定会存在一些区别，他们最大的区别就是在存储上的区别\",\"我们的存储空间分成两种：\",\"栈： 主要存储基本数据类型的内容\",\"堆： 主要存储复杂数据类型的内容\"]},{\"header\":\"5.1 基本数据类型在内存中的存储情况\",\"slug\":\"_5-1-基本数据类型在内存中的存储情况\",\"contents\":[\"var num = 100，在内存中的存储情况，直接在 栈空间 内有存储一个数据\"]},{\"header\":\"5.2 复杂数据类型在内存中的存储情况\",\"slug\":\"_5-2-复杂数据类型在内存中的存储情况\",\"contents\":[\"复杂数据类型的存储\",\"在堆里面开辟一个存储空间\",\"把数据存储到存储空间内\",\"把存储空间的地址赋值给栈里面的变量\"]},{\"header\":\"6. 数据类型之间比较的区别\",\"slug\":\"_6-数据类型之间比较的区别\",\"contents\":[\"基本数据类型是 值 之间的比较\",\"var num = 1 var str = '1' console.log(num == str) // true \",\"复杂数据类型是 地址 之间的比较\",\"var obj = { name: 'Jack' } var obj2 = { name: 'Jack' } console.log(obj == obj2) // false \",\"因为我们创建了两个对象，那么就会在 堆空间 里面开辟两个存储空间存储数据（两个地址），虽然存储的内容是一样的，那么也是两个存储空间，两个地址，复杂数据类型之间就是地址的比较，所以 obj 和 obj2 两个变量的地址不一样，所以我们得到的就是 false\"]}]},\"/front-end/javascript-notes/08-JavaScript-%E8%BF%90%E7%AE%97%E7%AC%A6.html\":{\"title\":\"JavaScript-运算符\",\"contents\":[{\"header\":\"1. 算术运算符\",\"slug\":\"_1-算术运算符\",\"contents\":[\"算术运算符：也叫数学运算符，主要包括加、减、乘、除、取余（求模）等\",\"+\",\"只有符号两边都是数字的时候才会进行加法运算\",\"只要符号任意一边是字符串类型，就会进行字符串拼接\",\"-\",\"会执行减法运算\",\"会自动把两边都转换成数字进行运算\",\"*\",\"会执行乘法运算\",\"会自动把两边都转换成数字进行运算\",\"/\",\"会执行除法运算\",\"会自动把两边都转换成数字进行运算\",\"%\",\"会执行取余运算\",\"会自动把两边都转换成数字进行运算\",\"注意：在计算失败时，显示的结果是 NaN（not a number）\"]},{\"header\":\"2. 赋值运算符\",\"slug\":\"_2-赋值运算符\",\"contents\":[\"赋值运算符：对变量进行赋值的运算符\",\"= 将等号右边的值赋予给左边, 要求左边必须是一个容器\",\"运算符\",\"作用\",\"+=\",\"加法赋值\",\"-+\",\"减法赋值\",\"*=\",\"乘法赋值\",\"/=\",\"除法赋值\",\"%=\",\"取余赋值\"]},{\"header\":\"3. 比较运算符\",\"slug\":\"_3-比较运算符\",\"contents\":[\"使用场景：比较两个数据是否相等，根据比较结果返回一个布尔值（true / false）\",\"运算符\",\"作用\",\">\",\"左边是否大于右边\",\"<\",\"左边是否小于右边\",\">=\",\"左边是否大于或等于右边\",\"<=\",\"左边是否小于或等于右边\",\"===\",\"左右两边是否类型和值都相等（重点）\",\"==\",\"左右两边值是否相等\",\"!=\",\"左右值不相等\",\"!==\",\"左右两边是否不全等\",\"例：\",\" console.log(3 > 5) console.log(3 >= 3) console.log(2 == 2) // 比较运算符有隐式转换 把'2' 转换为 2 双等号 只判断值 console.log(2 == '2') // true // console.log(undefined === null) // === 全等 判断 值 和 数据类型都一样才行 // 以后判断是否相等 请用 === console.log(2 === '2') console.log(NaN === NaN) // NaN 不等于任何人，包括他自己 console.log(2 !== '2') // true console.log(2 != '2') // false console.log('-------------------------') console.log('a' < 'b') // true console.log('aa' < 'ab') // true console.log('aa' < 'aac') // true console.log('-------------------------') \"]},{\"header\":\"4. 逻辑运算符\",\"slug\":\"_4-逻辑运算符\",\"contents\":[]},{\"header\":\"4.1 基本使用\",\"slug\":\"_4-1-基本使用\",\"contents\":[\"使用场景：可以把多个布尔值放到一起运算，最终返回一个布尔值\",\"符号\",\"名称\",\"日常读法\",\"特点\",\"口诀\",\"&&\",\"逻辑与\",\"并且\",\"符号两边有一个假的结果为假\",\"一假则假\",\"||\",\"逻辑或\",\"或者\",\"符号两边有一个真的结果为真\",\"一真则真\",\"!\",\"逻辑非\",\"取反\",\"true变false false变true\",\"真变假，假变真\",\"A\",\"B\",\"A && B\",\"A || B\",\"!A\",\"false\",\"false\",\"false\",\"false\",\"true\",\"false\",\"true\",\"false\",\"true\",\"true\",\"true\",\"false\",\"false\",\"true\",\"false\",\"true\",\"true\",\"true\",\"true\",\"false\",\" // 逻辑与 一假则假 console.log(true && true) console.log(false && true) console.log(3 < 5 && 3 > 2) console.log(3 < 5 && 3 < 2) console.log('-----------------') // 逻辑或 一真则真 console.log(true || true) console.log(false || true) console.log(false || false) console.log('-----------------') // 逻辑非 取反 console.log(!true) console.log(!false) console.log('-----------------') let num = 6 console.log(num > 5 && num < 10) console.log('-----------------') \"]},{\"header\":\"4.2 逻辑中断\",\"slug\":\"_4-2-逻辑中断\",\"contents\":[\"断路：只存在于 && 和 || 中，当满足一定条件会让右边代码不执行\",\"符号\",\"短路条件\",\"&&\",\"左边为 false 就断路\",\"||\",\"左边为 true 就断路\",\"原因：通过左边能得到整个式子的结果，因此没必要再判断右边\",\"运算结果：无论 && 还是 ||，运算结果都是最后被执行的表达式值，一般用在变量赋值\",\"例：\",\"console.log(false && 20) //false console.log(5 < 3 && 20) //false console.log(undefined && 20) //undefined console.log(null && 20) //null console.log(0 && 20) //0 console.log(10 && 20) //20 console.log(false || 20) //20 console.log(5 < 3 || 20) //20 console.log(undefined || 20) //20 console.log(null || 20) //20 console.log(0 || 20) //20 console.log(10 || 20) //10 \"]},{\"header\":\"4.3 逻辑运算符优先级\",\"slug\":\"_4-3-逻辑运算符优先级\",\"contents\":[\"！> && > ||\"]},{\"header\":\"5. 自增自减运算符\",\"slug\":\"_5-自增自减运算符\",\"contents\":[\"++\",\"进行自增运算\",\"分成两种，前置++ 和 后置++\",\"前置++，会先把值自动 +1，再返回\",\"var a = 10 console.log(++a) // 会返回 11，并且把 a 的值变成 11 \",\"后置++，会先把值返回，再自动+1\",\"var a = 10 console.log(a++) // 会返回 10，然后把 a 的值变成 11 \",\"--\",\"进行自减运算\",\"分成两种，前置-- 和 后置--\",\"和 ++ 运算符道理一样\"]},{\"header\":\"6. 三元运算符\",\"slug\":\"_6-三元运算符\",\"contents\":[\"三元运算，就是用 两个符号 组成一个语句\",\"语法：\",\"条件 ? 条件为 true 的时候执行 : 条件为 false 的时候执行 \",\"例：\",\"var age = 18 age >= 18 ? alert('已经成年') : alert('没有成年') \"]}]},\"/front-end/javascript-notes/09-JavaScript-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84.html\":{\"title\":\"JavaScript-分支结构\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"分支结构可以根据条件判断真假，来选择性的执行想要的代码\",\"分支结构包含：\",\"if分支结构（重点）\",\"三元运算符\",\"switch分支结构\"]},{\"header\":\"1. if条件分支结构\",\"slug\":\"_1-if条件分支结构\",\"contents\":[]},{\"header\":\"1.1 if分支结构\",\"slug\":\"_1-1-if分支结构\",\"contents\":[\"语法：\",\"if(条件表达式) { // 满足条件要执行的语句 } \",\"小括号内的条件结果是布尔值，为 true 时，进入大括号里执行代码，若为 false ，则不执行大括号里面代码\",\"小括号内的结果若不是布尔类型时，会发生类型转换为布尔值，类似Boolean()\",\"如果大括号只有一个语句，大括号可以省略，但是，不提倡这样做\",\"例：\",\"// 1. 用户输入 var score = +prompt('请输入成绩') // 2. 进行判断输出 if (score >= 700) { alert('恭喜考上清华！') } \"]},{\"header\":\"1.2 if双分支结构\",\"slug\":\"_1-2-if双分支结构\",\"contents\":[\"如果有两个条件的时候，可以使用 if else 双分支语句\",\"语法：\",\"if (条件表达式){ // 满足条件要执行的语句 } else { // 不满足条件要执行的语句 } \",\"例：\",\"// 1. 用户输入 var uname = prompt('请输入用户名:') var pwd = prompt('请输入密码:') // 2. 判断输出 if (uname === 'zhf' && pwd === '123456') { alert('恭喜登录成功') } else { alert('用户名或者密码错误') } \"]},{\"header\":\"1.3 if多分支结构\",\"slug\":\"_1-3-if多分支结构\",\"contents\":[\"使用场景： 适合于有多个条件的时候\",\"例：\",\"// 1. 用户输入 var score = +prompt('请输入成绩：') // 2. 判断输出 if (score >= 90) { alert('成绩优秀，宝贝，你是我的骄傲') } else if (score >= 70) { alert('成绩良好，宝贝，你要加油哦~~') } else if (score >= 60) { alert('成绩及格，宝贝，你很危险~') } else { alert('成绩不及格，宝贝，我不想和你说话，我只想用鞭子和你说话~') } \"]},{\"header\":\"2. switch条件分支结构\",\"slug\":\"_2-switch条件分支结构\",\"contents\":[\"使用场景： 适用于有多个条件的时候，也属于分支语句，大部分情况下和 if 多分支语句功能相同\",\"语法：\",\"switch (要判断的变量) { case 情况1: 情况1要执行的代码 break case 情况2: 情况2要执行的代码 break case 情况3: 情况3要执行的代码 break default: 上述情况都不满足的时候执行的代码 } \",\"例：根据变量给出的数字显示是星期几\",\"var week = 1 switch (week) { case 1: alert('星期一') break case 2: alert('星期二') break case 3: alert('星期三') break case 4: alert('星期四') break case 5: alert('星期五') break case 6: alert('星期六') break case 7: alert('星期日') break default: alert('请输入一个 1 ～ 7 之间的数字') } \",\"注意：\",\"switch case 语句一般用于等值判断, if 适合于区间判断\",\"switch case 一般需要配合 break 关键字使用，没有 break 会造成 case 穿透\",\"if 多分支语句开发要比 switch 更重要，使用也更多\"]},{\"header\":\"3. if和switch的区别\",\"slug\":\"_3-if和switch的区别\",\"contents\":[\"共同点 \",\"都能实现多分支选择，多选一\",\"大部分情况下可以互换\",\"区别： \",\"switch…case 语句通常处理 case 为比较确定值的情况，而 if…else…语句更加灵活，通常用于范围判断(大于，等于某个范围)\",\"switch 语句进行判断后直接执行到程序的语句，效率更高，而 if…else 语句有几种判断条件，就得判断多少次\",\"switch 一定要注意必须是 === 全等，一定注意数据类型，同时注意 break 否则会有穿透效果\",\"结论： \",\"当分支比较少时，if…else 语句执行效率高\",\"当分支比较多时，switch 语句执行效率高，而且结构更清晰\"]}]},\"/front-end/javascript-notes/10-JavaScript-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84.html\":{\"title\":\"JavaScript-循环结构\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"循环结构，就是根据某些给出的条件，重复的执行同一段代码\",\"循环三要素：\",\"初始值 （经常用变量）\",\"终止条件\",\"变量的变化量\"]},{\"header\":\"1. while循环\",\"slug\":\"_1-while循环\",\"contents\":[\"while，中文叫当…时，其实就是当条件满足时就执行代码，一旦不满足了就不执行了\",\"语法：\",\"while (条件表达式) { // 循环体 } \",\"因为满足条件就执行，所以我们写的时候一定要注意，就是设定一个边界值，不然就一直循环下去了\",\"例：\",\"// 1. 初始值 var num = 0; // 2. 终止条件 while (num < 10) { // 3. 要执行的代码 console.log('当前的 num 的值是 ' + num) // 4. 变量的变化量 num = num + 1 } \"]},{\"header\":\"2. do while循环\",\"slug\":\"_2-do-while循环\",\"contents\":[\"是一个和 while 循环类似的循环，while 会先进行条件判断，满足就执行，不满足直接就不执行了，但是 do while 循环是先不管条件，先执行一回，然后再开始进行条件判断\",\"语法：\",\"do { 要执行的代码 } while (条件) \",\"例：\",\"// 下面这个代码，条件一开始就不满足，但是依旧会执行一次 do 后面 {} 内部的代码 var num = 10 do { console.log('我执行了一次') num = num + 1 } while (num < 10) \"]},{\"header\":\"3. for循环\",\"slug\":\"_3-for循环\",\"contents\":[\"语法：\",\"for(起始值; 终止条件; 变化量) { // 要重复执行的代码 } \",\"例：\",\"// 把初始化，条件判断，自身改变，写在了一起 for (var i = 1; i <= 10; i++) { // 这里写的是要执行的代码 console.log(i) } // 控制台会依次输出 1 ~ 10 \"]},{\"header\":\"4. for循环嵌套\",\"slug\":\"_4-for循环嵌套\",\"contents\":[\"循环之中又嵌套了另一个循环，外层循环循环一次，里层循环循环全部\",\"例：\",\"// 1. 外面的循环 for (var i = 1; i < 4; i++) { console.log(i) // 2. 里层的循环 for (var j = 1; j < 6; j++) { console.log(j) } } \"]},{\"header\":\"5. break终止循环\",\"slug\":\"_5-break终止循环\",\"contents\":[\"在循环没有进行完毕的时候，因为我设置的条件满足，提前终止循环\",\"比如：我要吃五个包子，吃到三个的时候，不能再吃了，我就停止吃包子这个事情\",\"要终止循环，就可以直接使用 break 关键字\",\"for (var i = 1; i <= 5; i++) { // 每循环一次，吃一个包子 console.log('我吃了一个包子') // 当 i 的值为 3 的时候，条件为 true，执行 {} 里面的代码终止循环 // 循环就不会继续向下执行了，也就没有 4 和 5 了 if (i === 3) { break } } \"]},{\"header\":\"6. continue结束本次循环\",\"slug\":\"_6-continue结束本次循环\",\"contents\":[\"在循环中，把循环的本次跳过去，继续执行后续的循环\",\"比如：吃五个包子，到第三个的时候，第三个掉地下了，不吃了，跳过第三个，继续吃第四个和第五个\",\"跳过本次循环，就可以使用 continue 关键字\",\"for (var i = 1; i <= 5; i++) { // 当 i 的值为 3 的时候，执行 {} 里面的代码 // {} 里面有 continue，那么本次循环后面的代码就都不执行了 // 自动算作 i 为 3 的这一次结束了，去继续执行 i = 4 的那次循环了 if (i === 3) { console.log('这个是第三个包子，掉地下了，我不吃了') continue } console.log('我吃了一个包子') } \"]}]},\"/front-end/javascript-notes/11-JavaScript-%E5%87%BD%E6%95%B0.html\":{\"title\":\"JavaScript-函数\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"对于 JS 来说，函数就是把任意一段代码放在一个 盒子 里面\",\"在我想要让这段代码执行的时候，直接执行这个 盒子 里面的代码就行\",\"// 这个是我们以前写的一段代码 for (var i = 0; i < 10; i++) { console.log(i) } // 函数，这个 {} 就是那个 “盒子” function fn() { // 这个函数我们以前写的代码 for (var i = 0; i < 10; i++) { console.log(i) } } \"]},{\"header\":\"1. 函数定义阶段\",\"slug\":\"_1-函数定义阶段\",\"contents\":[\"定义阶段就是我们把代码 放在盒子里面\",\"我们就要学习怎么 放进去，也就是书写一个函数\",\"我们有两种定义方式 声明式 和 赋值式\"]},{\"header\":\"1.1 声明式\",\"slug\":\"_1-1-声明式\",\"contents\":[\"使用 function 这个关键字来声明一个函数\",\"语法：\",\"function fn() { // 一段代码,即函数体 } // function: 声明函数的关键字，表示接下来是一个函数了 // fn: 函数的名字，我们自己定义的（遵循变量名的命名规则和命名规范） // (): 必须写，是用来放参数的位置（一会我们再聊） // {}: 就是我们用来放一段代码的位置（也就是我们刚才说的 “盒子”） \"]},{\"header\":\"1.2 赋值式\",\"slug\":\"_1-2-赋值式\",\"contents\":[\"其实就是和我们使用 var 关键字是一个道理了\",\"首先使用 var 定义一个变量，把一个函数当作值直接赋值给这个变量就可以了\",\"语法：\",\"var fn = function () { // 一段代码，即函数体 } // 不需要在 function 后面书写函数的名字了，因为在前面已经有了 \"]},{\"header\":\"2. 函数调用阶段\",\"slug\":\"_2-函数调用阶段\",\"contents\":[]},{\"header\":\"2.1 函数的调用方式\",\"slug\":\"_2-1-函数的调用方式\",\"contents\":[\"就是让 盒子里面 的代码执行一下\",\"两种定义函数的方式不同，但是调用函数的方式都以一样的\",\"函数调用就是直接写 函数名() 就可以了\",\"// 声明式函数 function fn() { console.log('我是 fn 函数') } fn() // 调用函数 // 赋值式函数 var fn2 = function () { console.log('我是 fn2 函数') } fn() // 调用函数 \",\"注意：定义完一个函数以后，如果没有函数调用，那么写在 {} 里面的代码没有意义，只有调用以后才会执行\"]},{\"header\":\"2.2 调用上的区别\",\"slug\":\"_2-2-调用上的区别\",\"contents\":[\"虽然两种定义方式的调用都是一样的，但是还是有一些区别的\",\"声明式函数： 调用可以在定义之前或者定义之后\",\"fn() // 可以调用 // 声明式函数 function fn() { console.log('我是 fn 函数') } fn() // 可以调用 \",\"赋值式函数： 调用只能在定义之后\",\"fn() // 会报错 // 赋值式函数 var fn = function () { console.log('我是 fn 函数') } fn() // 可以调用 \"]},{\"header\":\"3. 函数的参数\",\"slug\":\"_3-函数的参数\",\"contents\":[\"我们在定义函数和调用函数的时候都出现过 ()，现在我们就来说一下这个 () 的作用，就是用来放参数的\",\"参数分为两种 形参 和 实参\",\"// 声明式 function fn(形参写在这里) { // 一段代码 } fn(实参写在这里) // 赋值式函数 var fn = function (形参写在这里) { // 一段代码 } fn(实参写在这里) \"]},{\"header\":\"3.1 形参和实参的作用\",\"slug\":\"_3-1-形参和实参的作用\",\"contents\":[]},{\"header\":\"3.1.1 形参\",\"slug\":\"_3-1-1-形参\",\"contents\":[\"形参就是在函数内部可以使用的变量，在函数外部不能使用，每写一个单词，就相当于在函数内部定义了一个可以使用的变量（遵循变量名的命名规则和命名规范），多个单词之间以 , 分隔，如果只有形参的话，那么在函数内部使用的这个变量是没有值的，也就是 undefined\",\"注意：形参的值是在函数调用的时候由实参决定的\",\"// 书写一个参数 function fn(num) { // 在函数内部就可以使用 num 这个变量 } var fn1 = function (num) { // 在函数内部就可以使用 num 这个变量 } // 书写两个参数 function fun(num1, num2) { // 在函数内部就可以使用 num1 和 num2 这两个变量 } var fun1 = function (num1, num2) { // 在函数内部就可以使用 num1 和 num2 这两个变量 } \"]},{\"header\":\"3.1.2 实参\",\"slug\":\"_3-1-2-实参\",\"contents\":[\"在函数调用的时候给形参赋值的，也就是说，在调用的时候是给一个实际的内容的\",\"function fn(num) { // 函数内部可以使用 num } // 这个函数的本次调用，书写的实参是 100 // 那么本次调用的时候函数内部的 num 就是 100 fn(100) // 这个函数的本次调用，书写的实参是 200 // 那么本次调用的时候函数内部的 num 就是 200 fn(200) \",\"函数内部的形参的值，由函数调用的时候传递的实参决定，多个参数的时候，是按照顺序一一对应的\",\"function fn(num1, num2) { // 函数内部可以使用 num1 和 num2 } // 函数本次调用的时候，书写的参数是 100 和 200 // 那么本次调用的时候，函数内部的 num1 就是 100，num2 就是 200 fn(100, 200) \"]},{\"header\":\"3.2 参数个数的关系\",\"slug\":\"_3-2-参数个数的关系\",\"contents\":[\"形参比实参少\",\"因为是按照顺序一一对应的\",\"形参少就会拿不到实参给的值，所以在函数内部就没有办法用到这个值\",\"function fn(num1, num2) { // 函数内部可以使用 num1 和 num2 } // 本次调用的时候，传递了两个实参，100 200 和 300 // 100 对应了 num1，200 对应了 num2，300 没有对应的变量 // 所以在函数内部就没有办法依靠变量来使用 300 这个值 fn(100, 200, 300) \",\"形参比实参多\",\"因为是按照顺序一一对应的\",\"所以多出来的形参就是没有值的，就是 undefined\",\"function fn(num1, num2, num3) { // 函数内部可以使用 num1 num2 和 num3 } // 本次调用的时候，传递了两个实参，100 和 200 // 就分别对应了 num1 和 num2 // 而 num3 没有实参和其对应，那么 num3 的值就是 undefined fn(100, 200) \"]},{\"header\":\"3.3 arguments对象\",\"slug\":\"_3-3-arguments对象\",\"contents\":[\"函数内 arguments 表示它接收到的实参列表，它是一个类数组对象\",\"类数组对象：所有属性均为从 0 开始的自然数序列，并且有 length 属性，和数组类似可以用方括号书写下标访问对象的某个属性值，但是不能调用数组的方法\",\"数组的方法详见数组篇\",\"function fun() { console.log(arguments) // 11 22 33 44 console.log(arguments[0]) // 11 console.log(arguments[1]) // 22 console.log(arguments[9]) // undefined } fun(11, 22, 33, 44) \"]},{\"header\":\"4. 函数的return\",\"slug\":\"_4-函数的return\",\"contents\":[\"return 返回的意思，其实就是给函数一个 返回值 和 终断函数\"]},{\"header\":\"4.1 返回值\",\"slug\":\"_4-1-返回值\",\"contents\":[\"函数调用本身也是一个表达式，表达式就应该有一个值出现，现在的函数执行完毕之后，是不会有结果出现的\",\"// 比如 1 + 2 是一个表达式，那么 这个表达式的结果就是 3 console.log(1 + 2) // 3 function fn() { // 执行代码 } // fn() 也是一个表达式，这个表达式就没有结果出现 console.log(fn()) // undefined \",\"return 关键字就是可以给函数执行完毕一个结果，我们可以在函数内部使用 return 把任何内容当作这个函数运行后的结果\",\"function fn() { // 执行代码 return 100 } // 此时，fn() 这个表达式执行完毕之后就有结果出现了 console.log(fn()) // 100 \"]},{\"header\":\"4.2 终断函数\",\"slug\":\"_4-2-终断函数\",\"contents\":[\"当我开始执行函数以后，函数内部的代码就会从上到下的依次执行，必须要等到函数内的代码执行完毕，而 return 关键字就是可以在函数中间的位置停掉，让后面的代码不在继续执行\",\"function fn() { console.log(1) console.log(2) console.log(3) // 写了 return 以后，后面的 4 和 5 就不会继续执行了 return console.log(4) console.log(5) } // 函数调用 fn() \"]},{\"header\":\"5. 作用域\",\"slug\":\"_5-作用域\",\"contents\":[\"变量不是在所有地方都可以使用的，而这个变量的使用范围就是作用域\"]},{\"header\":\"5.1 全局作用域\",\"slug\":\"_5-1-全局作用域\",\"contents\":[\"全局作用域是最大的作用域\",\"在全局作用域中定义的变量可以在任何地方使用\",\"页面打开的时候，浏览器会自动给我们生成一个全局作用域 window\",\"这个作用域会一直存在，直到页面关闭就销毁了\",\"// 下面两个变量都是存在在全局作用域下面的，都是可以在任意地方使用的 var num = 100 var num2 = 200 \"]},{\"header\":\"5.2 局部作用域\",\"slug\":\"_5-2-局部作用域\",\"contents\":[\"局部作用域就是在全局作用域下面有开辟出来的一个相对小一些的作用域\",\"在局部作用域中定义的变量只能在这个局部作用域内部使用\",\"在 JS 中只有函数能生成一个局部作用域，别的都不行\",\"每一个函数，都是一个局部作用域\",\"// 这个 num 是一个全局作用域下的变量 在任何地方都可以使用 var num = 100 function fn() { // 下面这个变量就是一个 fn 局部作用域内部的变量 // 只能在 fn 函数内部使用 var num2 = 200 } fn() \"]},{\"header\":\"6. 变量使用规则\",\"slug\":\"_6-变量使用规则\",\"contents\":[\"有了作用域以后，变量就有了使用范围，也就有了使用规则，变量使用规则分为两种，访问规则 和 赋值规则\"]},{\"header\":\"6.1 访问规则\",\"slug\":\"_6-1-访问规则\",\"contents\":[\"当我想获取一个变量的值的时候，我们管这个行为叫做访问\",\"获取变量的规则：\",\"首先，在自己的作用域内部查找，如果有，就直接拿来使用\",\"如果没有，就去上一级作用域查找，如果有，就拿来使用\",\"如果没有，就继续去上一级作用域查找，依次类推\",\"如果一直到全局作用域都没有这个变量，那么就会直接报错（该变量 is not defined）\",\"var num = 100 function fn() { var num2 = 200 function fun() { var num3 = 300 console.log(num3) // 自己作用域内有，拿过来用 console.log(num2) // 自己作用域内没有，就去上一级，就是 fn 的作用域里面找，发现有，拿过来用 console.log(num) // 自己这没有，去上一级 fn 那里也没有，再上一级到全局作用域，发现有，直接用 console.log(a) // 自己没有，一级一级找上去到全局都没有，就会报错 } fun() } fn() \",\"变量的访问规则 也叫做作用域的查找机制，作用域的查找机制只能是向上找，不能向下找\",\"function fn() { var num = 100 } fn() console.log(num) // 发现自己作用域没有，自己就是全局作用域，没有再上一级了，直接报错 \"]},{\"header\":\"6.2 赋值规则\",\"slug\":\"_6-2-赋值规则\",\"contents\":[\"当你想给一个变量赋值的时候，那么就先要找到这个变量，再给它赋值\",\"变量赋值规则：\",\"先在自己作用域内部查找，有就直接赋值\",\"没有就去上一级作用域内部查找，有就直接赋值\",\"还没有再去上一级作用域查找，有就直接赋值\",\"如果一直找到全局作用域都没有，那么就把这个变量定义为全局变量，再给他赋值\",\"function fn() { num = 100 } fn() // fn 调用以后，要给 num 赋值 // 查看自己的作用域内部没有 num 变量 // 就会向上一级查找 // 上一级就是全局作用域，发现依旧没有 // 那么就会把 num 定义为全局的变量，并为其赋值 // 所以 fn() 以后，全局就有了一个变量叫做 num 并且值是 100 console.log(num) // 100 \"]},{\"header\":\"7. 函数提升\",\"slug\":\"_7-函数提升\",\"contents\":[\"声明式函数：会把所有函数声明提升到当前作用域的最前面，只提升函数声明，不提升函数调用\",\"例：\",\"以下代码\",\"fn() console.log(num) function fn() { console.log('我是 fn 函数') } var num = 100 \",\"经过预解析之后可以变形为\",\"function fn() { console.log('我是 fn 函数') } var num fn() console.log(num) num = 100 \",\"赋值式函数会按照 var 关键字的规则进行预解析\"]},{\"header\":\"8. 立即执行函数\",\"slug\":\"_8-立即执行函数\",\"contents\":[\"避免全局变量之间的污染\",\"(function(){ xxx })(); ;(function(){ xxx })() ！function(){ xxx }() (function(){xxxx}()); \",\"无需调用，立即执行，其实本质已经调用了\",\"多个立即执行函数之间用分号隔开\"]},{\"header\":\"9.this\",\"slug\":\"_9-this\",\"contents\":[\"每一个函数内部都有一个关键字是 this ，可以让我们直接使用的\",\"后面会详述\"]}]},\"/front-end/javascript-notes/12-JavaScript-%E5%AF%B9%E8%B1%A1.html\":{\"title\":\"JavaScript-对象\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"对象是一个复杂数据类型\",\"事实上没有很复杂，只不过是存储了一些基本数据类型的一个集合\",\"var obj = { num: 100, str: 'hello world', boo: true } \",\"这里的 {} 和函数中的 {} 不一样，函数里面的是写代码的，而对象里面是写一些数据的，对象就是一个键值对的集合，{} 里面的每一个键都是一个成员，也就是说，我们可以把一些数据放在一个对象里面，那么他们就互不干扰了，其实就是我们准备一个房子，把我们想要的数据放进去，然后把房子的地址给到变量名，当我们需要某一个数据的时候，就可以根据变量名里面存储的地址找到对应的房子，然后去房子里面找到对应的数据\"]},{\"header\":\"1. 创建对象\",\"slug\":\"_1-创建对象\",\"contents\":[\"字面量的方式创建一个对象\",\"// 创建一个空对象 var obj = {} // 像对象中添加成员 obj.name = 'Jack' obj.age = 18 \",\"内置构造函数的方式创建对象\",\"// 创建一个空对象 var obj = new Object() // 向对象中添加成员 obj.name = 'Rose' obj.age = 20 \",\"Object 是 js 内置给我们的构造函数，用于创建一个对象使用的\"]},{\"header\":\"2. 属性和访问\",\"slug\":\"_2-属性和访问\",\"contents\":[\"数据描述性的信息称为属性，如人的姓名、身高、年龄、性别等，一般是名词性的\",\"属性都是成对出现的，包括属性名和值，它们之间使用英文 : 分隔\",\"多个属性之间使用英文 , 分隔\",\"属性就是依附在对象上的变量\",\"属性名可以使用 \\\"\\\" 或 ''，一般情况下省略，除非名称遇到特殊符号如空格、中横线等\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 对象语法</title> </head> <body> <script> // 通过对象描述一个人的数据信息 // person 是一个对象，它包含了一个属性 name // 属性都是成对出现的，属性名 和 值，它们之间使用英文 : 分隔 var person = { name: '小明', // 描述人的姓名 age: 18, // 描述人的年龄 stature: 185, // 描述人的身高 gender: '男', // 描述人的性别 } </script> </body> </html> \",\"声明对象，并添加了若干属性后，可以使用 . 或 对象名['属性'] 方式也可以访问 获得对象中属性对应的值，称之为属性访问\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 对象语法</title> </head> <body> <script> // 通过对象描述一个人的数据信息 // person 是一个对象，它包含了一个属性 name // 属性都是成对出现的，属性名 和 值，它们之间使用英文 : 分隔 var person = { name: '小明', // 描述人的姓名 age: 18, // 描述人的年龄 stature: 185, // 描述人的身高 gender: '男', // 描述人的性别 }; // 访问人的名字 console.log(person.name) // 结果为 小明 // 访问人性别 console.log(person.gender) // 结果为 男 // 访问人的身高 console.log(person['stature']) // 结果为 185 // 或者 console.log(person.stature) // 结果同为 185 </script> </body> </html> \",\"var person = { 'user-name': 'pink', age: 18, gender: '女', } console.log(person['user-name'])//pink console.log(person['age'])//18 \",\"扩展：也可以动态为对象添加属性，动态添加与直接定义是一样的，只是语法上更灵活\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 对象语法</title> </head> <body> <script> // 声明一个空的对象（没有任何属性） var user = {} // 动态追加属性 user.name = '小明' user['age'] = 18 // 动态添加与直接定义是一样的，只是语法上更灵活 </script> </body> </html> \",\"删除属性：devare 对象名.属性\",\"var person = { uname: 'pink', age: 18, gender: '女', } devare person.gender \"]},{\"header\":\"3. 方法和调用\",\"slug\":\"_3-方法和调用\",\"contents\":[\"数据行为性的信息称为方法，如跑步、唱歌等，一般是动词性的，其本质是函数\",\"方法是由方法名和函数两部分构成，它们之间使用 : 分隔\",\"多个属性之间使用英文 , 分隔\",\"方法是依附在对象中的函数\",\"方法名可以使用 \\\"\\\" 或 ''，一般情况下省略，除非名称遇到特殊符号如空格、中横线等\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 对象方法</title> </head> <body> <script> // 方法是依附在对象上的函数 var person = { name: '小红', age: 18, // 方法是由方法名和函数两部分构成，它们之间使用 : 分隔 singing: function () { console.log('两只老虎，两只老虎，跑的快，跑的快...') }, run: function () { console.log('我跑的非常快...') } } </script> </body> </html> \",\"声明对象，并添加了若干方法后，可以使用 . 或 对象名['方法'()] 方式也可以访问调用对象中函数，称为方法调用\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 对象方法</title> </head> <body> <script> // 方法是依附在对象上的函数 var person = { name: '小红', age: 18, // 方法是由方法名和函数两部分构成，它们之间使用 : 分隔 singing: function () { console.log('两只老虎，两只老虎，跑的快，跑的快...') }, run: function () { console.log('我跑的非常快...') } } // 调用对象中 singing 方法 person.singing() // 调用对象中的 run 方法 person.['run']() </script> </body> </html> \",\"扩展：也可以动态为对象添加方法，动态添加与直接定义是一样的，只是语法上更灵活\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 对象方法</title> </head> <body> <script> // 声明一个空的对象（没有任何属性，也没有任何方法） var user = {} // 动态追加属性 user.name = '小明' user.['age'] = 18 // 动态添加方法 user.move = function () { console.log('移动一点距离...') } </script> </body> </html> \",\"注：无论是属性或是方法，同一个对象中出现名称一样的，后面的会覆盖前面的\"]},{\"header\":\"4. null\",\"slug\":\"_4-null\",\"contents\":[\"null 也是 JavaScript 中数据类型的一种，通常只用它来表示不存在的对象。使用 typeof 检测类型它的类型时，结果为 object\"]},{\"header\":\"5. 遍历对象\",\"slug\":\"_5-遍历对象\",\"contents\":[\"var obj = { uname: 'pink', age: 18, address: '北京', } for(var k in obj) { // k 是属性名，是一个字符串，带引号 obj.uname才可以取到数据，但是这里，k==='uname'，所以obj.k取不到数据，obj[k]才可以取到属性值，即obj['uname'] console.log(obj[k]) } // 结果是 pink 18 北京 \",\"for in 不提倡遍历数组因为 k 是字符串\",\"var obj = { uname: 'andy', age: 18, sex: '男', } for(var k in obj){ console.log(k) //打印属性名 console.log(boj[k]) //打印属性值 } \",\"注意：k 是获得对象的 属性名，对象名[k] 是获得 属性值\"]}]},\"/front-end/javascript-notes/13-JavaScript-%E6%95%B0%E7%BB%84.html\":{\"title\":\"JavaScript-数组\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"数组字面理解就是数字的组合，准确的来说数组是一个数据的集合\",\"也就是我们把一些数据放在一个盒子里面，按照顺序排好\",\"[1, 2, 3, 'hello', true, false] \"]},{\"header\":\"1. 创建数组\",\"slug\":\"_1-创建数组\",\"contents\":[]},{\"header\":\"1.1 字面量创建数组\",\"slug\":\"_1-1-字面量创建数组\",\"contents\":[\"直接使用 [] 的方式创建一个数组\",\"// 创建一个空数组 var arr1 = [] // 创建一个有内容的数组 var arr2 = [1, 2, 3] \"]},{\"header\":\"1.2 内置构造函数创建数组\",\"slug\":\"_1-2-内置构造函数创建数组\",\"contents\":[\"使用 JS 的内置构造函数 Array 创建一个数组\",\"// 创建一个空数组 var arr1 = new Array() // 创建一个长度为 10 的数组 var arr2 = new Array(10) // 创建一个有内容的数组 var arr3 = new Array(1, 2, 3) \"]},{\"header\":\"2. 数组的长度\",\"slug\":\"_2-数组的长度\",\"contents\":[\"length 表示数组的长度，数组里面有多少个成员，length 就是多少\",\"// 创建一个数组 var arr = [1, 2, 3] console.log(arr.length) // 3 \"]},{\"header\":\"3. 数组的索引\",\"slug\":\"_3-数组的索引\",\"contents\":[\"索引，也叫做下标，是指一个数据在数组里面排在第几个的位置\",\"注意： 在所有的语言里面，索引都是从 0 开始的，在 JS 里面也一样，数组的索引从 0 开始\",\"// 创建一个数组 var arr = ['hello', 'world'] \",\"上面这个数组中，第 0 个 数据就是字符串 hello，第 1 个 数据就是字符串 world，想获取数组中的第几个就使用 数组[索引] 来获取\",\"var arr = ['hello', 'world'] console.log(arr[0]) // hello console.log(arr[1]) // world \"]},{\"header\":\"4. 数组的常用方法\",\"slug\":\"_4-数组的常用方法\",\"contents\":[]},{\"header\":\"4.1 push\",\"slug\":\"_4-1-push\",\"contents\":[\"push 是用来在数组的末尾追加一个元素\",\"var arr = [1, 2, 3] // 使用 push 方法追加一个元素在末尾 arr.push(4) console.log(arr) // [1, 2, 3, 4] \"]},{\"header\":\"4.2 pop\",\"slug\":\"_4-2-pop\",\"contents\":[\"pop 是用来删除数组末尾的一个元素\",\"var arr = [1, 2, 3] // 使用 pop 方法删除末尾的一个元素 arr.pop() console.log(arr) // [1, 2] \"]},{\"header\":\"4.3 unshift\",\"slug\":\"_4-3-unshift\",\"contents\":[\"unshift 是在数组的最前面添加一个元素\",\"var arr = [1, 2, 3] // 使用 unshift 方法想数组的最前面添加一个元素 arr.unshift(4) console.log(arr) // [4, 1, 2, 3] \"]},{\"header\":\"4.4 shift\",\"slug\":\"_4-4-shift\",\"contents\":[\"shift 是删除数组最前面的一个元素\",\"var arr = [1, 2, 3] // 使用 shift 方法删除数组最前面的一个元素 arr.shift() console.log(arr) // [2, 3] \"]},{\"header\":\"4.5 splice\",\"slug\":\"_4-5-splice\",\"contents\":[\"splice 是截取数组中的某些内容，按照数组的索引来截取\",\"语法： splice(从哪一个索引位置开始，截取多少个，替换的新元素) （第三个参数可以不写）\",\"var arr = [1, 2, 3, 4, 5] // 使用 splice 方法截取数组 arr.splice(1, 2) console.log(arr) // [1, 4, 5] \",\"arr.splice(1, 2) 表示从索引 1 开始截取 2 个内容，第三个参数没有写，就是没有新内容替换掉截取位置\",\"var arr = [1, 2, 3, 4, 5] // 使用 splice 方法截取数组 arr.splice(1, 2, '我是新内容') console.log(arr) // [1, '我是新内容', 4, 5] \",\"arr.splice(1, 2, '我是新内容') 表示从索引 1 开始截取 2 个内容，然后用第三个参数把截取完空出来的位置填充\"]},{\"header\":\"4.6 reverse\",\"slug\":\"_4-6-reverse\",\"contents\":[\"reverse 是用来反转数组使用的\",\"var arr = [1, 2, 3] // 使用 reverse 方法来反转数组 arr.reverse() console.log(arr) // [3, 2, 1] \"]},{\"header\":\"4.7 sort\",\"slug\":\"_4-7-sort\",\"contents\":[\"sort 是用来给数组排序的\",\"var arr = [2, 3, 1] // 使用 sort 方法给数组排序 arr.sort() console.log(arr) // [1, 2, 3] \"]},{\"header\":\"4.8 concat\",\"slug\":\"_4-8-concat\",\"contents\":[\"concat 是把多个数组进行拼接\",\"和之前的方法有一些不一样的地方，就是 concat 不会改变原始数组，而是返回一个新的数组\",\"var arr = [1, 2, 3] // 使用 concat 方法拼接数组 var newArr = arr.concat([4, 5, 6]) console.log(arr) // [1, 2, 3] console.log(newArr) // [1, 2, 3, 4, 5, 6] \",\"注意： concat 方法不会改变原始数组\"]},{\"header\":\"4.9 join\",\"slug\":\"_4-9-join\",\"contents\":[\"join 是把数组里面的每一项内容链接起来，变成一个字符串，可以自己定义每一项之间链接的内容 join(要以什么内容链接)，不会改变原始数组，而是把链接好的字符串返回\",\"var arr = [1, 2, 3] // 使用 join 链接数组 var str = arr.join('-') console.log(arr) // [1, 2, 3] console.log(str) // 1-2-3 \",\"注意： join 方法不会改变原始数组，而是返回链接好的字符串\"]},{\"header\":\"4.10 indexOf\",\"slug\":\"_4-10-indexof\",\"contents\":[\"indexOf 用来找到数组中某一项的索引\",\"语法： indexOf(你要找的数组中的项)\",\"var arr = [1, 2, 3, 4, 5] // 使用 indexOf 超找数组中的某一项 var index = arr.indexOf(3) console.log(index) // 2 \",\"我们要找的是数组中值为 3 的那一项，返回的就是值为 3 的那一项在该数组中的索引，如果你要找的内容在数组中没有，那么就会返回 -1\",\"var arr = [1, 2, 3, 4, 5] // 使用 indexOf 超找数组中的某一项 var index = arr.indexOf(10) console.log(index) // -1 \",\"你要找的值在数组中不存在，那么就会返回 -1\"]},{\"header\":\"4.11 forEach\",\"slug\":\"_4-11-foreach\",\"contents\":[\"和 for 循环一个作用，就是用来遍历数组的\",\"语法：arr.forEach(function (item, index, arr) {})\",\"var arr = [1, 2, 3] // 使用 forEach 遍历数组 arr.forEach(function (item, index, arr) { // item 就是数组中的每一项 // index 就是数组的索引 // arr 就是原始数组 console.log('数组的第 ' + index + ' 项的值是 ' + item + '，原始数组是', arr) }) \",\"forEach() 的时候传递的那个函数，会根据数组的长度执行，数组的长度是多少，这个函数就会执行多少回\"]},{\"header\":\"4.12 map\",\"slug\":\"_4-12-map\",\"contents\":[\"和 forEach 类似，只不过可以对数组中的每一项进行操作，返回一个新的数组，用于处理数据\",\"var arr = [1, 2, 3] // 使用 map 遍历数组 var newArr = arr.map(function (item, index, arr) { // item 就是数组中的每一项 // index 就是数组的索引 // arr 就是原始数组 return item + 10 }) console.log(newArr) // [11, 12, 13] \"]},{\"header\":\"4.13 filter\",\"slug\":\"_4-13-filter\",\"contents\":[\"和 map 的使用方式类似，按照我们的条件来筛选数组，把原始数组中满足条件的筛选出来，组成一个新的数组返回，如果没有符合条件的元素则返回空数组，它不会影响原数组\",\"var arr = [1, 2, 3] // 使用 filter 过滤数组 var newArr = arr.filter(function (item, index, arr) { // item 就是数组中的每一项 // index 就是数组的索引 // arr 就是原始数组 return item > 1 //筛选条件 }) console.log(newArr) // [2, 3] \",\"我们设置的条件就是 > 1，返回的新数组就会是原始数组中所有 > 1 的项\"]}]},\"/front-end/javascript-notes/14-JavaScript-%E5%AD%97%E7%AC%A6%E4%B8%B2.html\":{\"title\":\"JavaScript-字符串\",\"contents\":[{\"header\":\"1. 创建字符串\",\"slug\":\"_1-创建字符串\",\"contents\":[\"我们创建字符串也分为两种方法 字面量 和 构造函数\"]},{\"header\":\"1.1 字面量\",\"slug\":\"_1-1-字面量\",\"contents\":[\"var str = 'hello' \"]},{\"header\":\"1.2 构造函数创建\",\"slug\":\"_1-2-构造函数创建\",\"contents\":[\"var str = new String('hello') \"]},{\"header\":\"2. 字符集\",\"slug\":\"_2-字符集\",\"contents\":[]},{\"header\":\"2.1 ASCII 字符集\",\"slug\":\"_2-1-ascii-字符集\",\"contents\":[\"我们都知道，计算机只能存储 0101010 这样的二进制数字，那么我们的 a ~ z 、A ~ Z 、$ 、@ 之类的内容也有由二进制数字组成的，我们可以简单的理解为， a ~ z 、 A ~ Z、 $ 、 @之类的内容都有一个自己的编号，然后在计算机存储的时候，是存储的这些编号，我们看的时候，也是通过这些编号再解析成我们要看到的内容\"]},{\"header\":\"2.1 unicode 编码\",\"slug\":\"_2-1-unicode-编码\",\"contents\":[\"我们看到了，ASCII 只有这 128 个字符的编码结构，但是因为 ASCII 出现的比较早，而且是美国发明的，早先时候这些内容就够用了，因为存储一些英文的内容，传递一些英文的文章什么的都够用了，那么对于这个世界来说肯定是不够用的，因为我们的汉字没有办法存储，包括一些其他国家的语言也没有办法存储，所以就出现了 unicode 编码，也叫（万国码，统一码），unicode 对照表就是一个和 ASCII 一样的对照表，只不过变得很大很大，因为存储的内容特别的多，而且包含了世界上大部分国家的文字，所以我们的文字和字符现在在存储的时候，都是按照 unicode 编码转换成数字进行存储，我们的 UTF-8 就是一种 8 位的 unicode 字符集\"]},{\"header\":\"3. 字符串的常用方法\",\"slug\":\"_3-字符串的常用方法\",\"contents\":[\"字符串和数组有一个相同的特点，即字符串也是按照索引来排列的\"]},{\"header\":\"3.1 charAt\",\"slug\":\"_3-1-charat\",\"contents\":[\"charAt(索引) 是找到字符串中指定索引位置的内容并返回\",\"var str = 'Jack' // 使用 charAt 找到字符串中的某一个内容 var index = str.charAt(2) console.log(index) // c \",\"因为字符串也是按照索引进行排列的，也是同样从 0 开始，所以索引 2 的位置就是 c\",\"如果没有对应的索引，那么就会返回 空字符串\",\"var str = 'Jack' // 使用 charAt 找到字符串中的某一个内容 var index = str.charAt(10) console.log(index) // '' \",\"这个字符串根本没有索引 10 的位置，所以就会返回一个空字符串 ''\"]},{\"header\":\"3.2 charCodeAt\",\"slug\":\"_3-2-charcodeat\",\"contents\":[\"charCodeAt(索引) 就是返回对应索引位置的 unicode 编码\",\"var str = 'Jack' // 使用 charAt 找到字符串中的某一个内容 var index = str.charCodeAt(0) console.log(index) // 74 \",\"因为 J 在 unicode 对照表里面存储的是 74，所以就会返回 74\"]},{\"header\":\"3.3 indexOf\",\"slug\":\"_3-3-indexof\",\"contents\":[\"indexOf 就是按照字符找到对应的索引\",\"var str = 'Jack' // 使用 indexOf 找到对应的索引 var index = str.indexOf('J') console.log(index) // 0 \",\"因为字符 J 在字符串 Jack 中的索引位置是 0，所以会返回 0\"]},{\"header\":\"3.4 substring\",\"slug\":\"_3-4-substring\",\"contents\":[\"substring 是用来截取字符串使用的\",\"语法： substring(从哪个索引开始，到哪个索引截止)，包含开始索引，不包含结束索引\",\"var str = 'hello' // 01234 // 使用 substring 截取字符串 var newStr = str.substring(1, 3) console.log(newStr) // el \",\"从索引 1 开始，到索引 3 截止，包含前面的索引不包含后面的索引，所以返回的是 el\"]},{\"header\":\"3.5 substr\",\"slug\":\"_3-5-substr\",\"contents\":[\"substr 也是用来截取字符串的\",\"语法：substr(从哪个索引开始，截取多少个)\",\"var str = 'hello' // 01234 // 使用 substr 截取字符串 var newStr = str.substr(1, 3) console.log(newStr) // ell \",\"这个方法和 substring 不一样的是，第二个参数是截取多少个，从索引 1 开始，截取 3 个，所以得到的是 ell\"]},{\"header\":\"3.6 toLowerCase和toUpperCase\",\"slug\":\"_3-6-tolowercase和touppercase\",\"contents\":[\"这两个方法分别使用用来给字符串转成 小写字母 和 大写字母 的\",\"var str = hello // 使用 toUpperCase 转换成大写 var upper = str.toUpperCase() console.log(upper) // HELLO // 使用 toLowerCase 转换成小写 var lower = upper.toLowerCase() console.log(lower) // hello \"]}]},\"/front-end/javascript-notes/16-JavaScript-Math.html\":{\"title\":\"JavaScript-Math\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"Math 是 JS 的一个内置对象，称为数学对象，提供了一堆的属性和方法帮助我们操作 数字\"]},{\"header\":\"1. 常用方法\",\"slug\":\"_1-常用方法\",\"contents\":[]},{\"header\":\"1.1 random\",\"slug\":\"_1-1-random\",\"contents\":[\"Math.random() 这个方法是用来生成一个 0 ~ 1 之间的随机数，每次执行生成的数字都不一样，但是一定是 0 ~ 1 之间的，生成的数字包含 0 ，但是不包含 1\",\"var num = Math.random() console.log(num) // 得到一个随机数 \",\"//生成0~10的随机数 Math.floor(Math.random() * 11) //生成N~M之间的随机数 Math.floor(Math.random() * (M - N + 1)) + N \"]},{\"header\":\"1.2 round\",\"slug\":\"_1-2-round\",\"contents\":[\"Math.round() 是将一个小数 四舍五入 变成一个整数\",\"var num = 10.1 console.log(Math.round(num)) // 10 var num2 = 10.6 console.log(Math.round(num2)) // 11 \"]},{\"header\":\"1.3 abs\",\"slug\":\"_1-3-abs\",\"contents\":[\"Math.abs() 是返回一个数字的 绝对值\",\"var num = -10 console.log(math.abs(num)) // 10 \"]},{\"header\":\"1.4 ceil\",\"slug\":\"_1-4-ceil\",\"contents\":[\"Math.ceil() 是将一个小数 向上取整 得到的整数\",\"var num = 10.1 console.log(Math.ceil(num)) // 11 var num2 = 10.9 console.log(Math.ceil(num2)) // 11 \"]},{\"header\":\"1.5 floor\",\"slug\":\"_1-5-floor\",\"contents\":[\"Math.floor() 是将一个小数 向下取整 的到的整数\",\"var num = 10.1 console.log(Math.floor(num)) // 10 var num2 = 10.9 console.log(Math.floor(num2)) // 10 \"]},{\"header\":\"1.6 max\",\"slug\":\"_1-6-max\",\"contents\":[\"Math.max() 得到的是你传入的几个数字之中 最大 的那个数字\",\"console.log(Math.max(1, 2, 3, 4, 5)) // 5 \"]},{\"header\":\"1.7 min\",\"slug\":\"_1-7-min\",\"contents\":[\"Math.min() 得到的是你传入的几个数字之中 最小 的那个数字\",\"console.log(Math.min(1, 2, 3, 4, 5)) // 1 \"]},{\"header\":\"1.8 pow\",\"slug\":\"_1-8-pow\",\"contents\":[\"Math.pow()求某个数的多少次方\",\"// 求 4 的 2 次方 console.log(Math.pow(4, 2)) // 16 // 求 2 的 3 次方 console.log(Math.pow(2, 3)) // 8 \"]},{\"header\":\"1.9 sqrt\",\"slug\":\"_1-9-sqrt\",\"contents\":[\"Math.sqrt()求某数的平方根\",\"console.log(Math.sqrt(16))// 4 \"]},{\"header\":\"2. 常用属性\",\"slug\":\"_2-常用属性\",\"contents\":[]},{\"header\":\"2.1 PI\",\"slug\":\"_2-1-pi\",\"contents\":[\"Math.PI 得到的是 π 的值，也就是 3.1415936...\",\"console.log(Math.PI) // 3.141592653589793 \",\"因为计算机的计算精度问题，只能得到小数点后 15 位，使用 Math.PI 的时候，是不需要加 () 的\"]}]},\"/front-end/javascript-notes/17-JavaScript-Date.html\":{\"title\":\"JavaScript-Date\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"Date对象是JS提供的专门用来获取时间的\"]},{\"header\":\"1. new Date()\",\"slug\":\"_1-new-date\",\"contents\":[\"new Date() 在不传递参数的情况下是默认返回当前时间\",\"var time = new Date() console.log(time) // 当前时间 Fri Mar 01 2019 13:11:23 GMT+0800 (中国标准时间) \",\"new Date() 在传入参数的时候，可以获取到一个你传递进去的时间\",\"var time = new Date('2019-03-03 13:11:11') console.log(time) // Sun Mar 03 2019 13:11:11 GMT+0800 (中国标准时间) \",\"new Date() 传递的参数有多种情况\",\"传递两个数字，第一个表示年，第二个表示月份\",\"var time = new Date(2019, 00) // 月份从 0 开始计数，0 表示 1月，11 表示 12月 console.log(time) // Tue Jan 01 2019 00:00:00 GMT+0800 (中国标准时间) \",\"传递三个数字，前两个不变，第三个表示该月份的第几天，从 1 到 31\",\"var time = new Date(2019, 00, 05) console.log(time) // Sat Jan 05 2019 00:00:00 GMT+0800 (中国标准时间) \",\"传递四个数字，前三个不变，第四个表示当天的几点，从 0 到 23\",\"var time = new Date(2019, 00, 05, 22) console.log(time) // Sat Jan 05 2019 22:00:00 GMT+0800 (中国标准时间) \",\"传递五个数字，前四个不变，第五个表示的是该小时的多少分钟，从 0 到 59\",\"var time = new Date(2019, 00, 05, 22, 33) console.log(time) // Sat Jan 05 2019 22:33:00 GMT+0800 (中国标准时间) \",\"传递六个数字，前五个不变，第六个表示该分钟的多少秒，从 0 到 59\",\"var time = new Date(2019, 00, 05, 22, 33, 55) console.log(time) // Sat Jan 05 2019 22:33:55 GMT+0800 (中国标准时间) \",\"传入字符串的形式\",\"console.log(new Date('2019')) // Tue Jan 01 2019 08:00:00 GMT+0800 (中国标准时间) console.log(new Date('2019-02')) // Fri Feb 01 2019 08:00:00 GMT+0800 (中国标准时间) console.log(new Date('2019-02-03')) // Sun Feb 03 2019 08:00:00 GMT+0800 (中国标准时间) console.log(new Date('2019-02-03 13:')) // Sun Feb 03 2019 13:00:00 GMT+0800 (中国标准时间) console.log(new Date('2019-02-03 13:13:')) // Sun Feb 03 2019 13:13:00 GMT+0800 (中国标准时间) console.log(new Date('2019-02-03 13:13:13')) // Sun Feb 03 2019 13:13:13 GMT+0800 (中国标准时间) \"]},{\"header\":\"2. 将日期字符串格式化成指定内容\",\"slug\":\"_2-将日期字符串格式化成指定内容\",\"contents\":[\"我们得到的时间字符串是 Sun Feb 03 2019 13:13:13 GMT+0800 (中国标准时间)，我只想得到这个日期中是哪一年，我们就要靠截取字符串的形式得到，但是现在 js 为我们提供了一系列的方法来得到里面的指定内容\"]},{\"header\":\"2.1 getFullYear\",\"slug\":\"_2-1-getfullyear\",\"contents\":[\"getFullYear() 方式是得到指定字符串中的哪一年\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getFullYear()) // 2019 \"]},{\"header\":\"2.2 getMonth\",\"slug\":\"_2-2-getmonth\",\"contents\":[\"getMonth() 方法是得到指定字符串中的哪一个月份\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getMonth()) // 3 \",\"这里要有一个注意的地方，月份是从 0 开始数的，0 表示 1月，1 表示 2月，依此类推\"]},{\"header\":\"2.3 getDate\",\"slug\":\"_2-3-getdate\",\"contents\":[\"getDate() 方法是得到指定字符串中的哪一天\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getDate()) // 3 \"]},{\"header\":\"2.4 getHours\",\"slug\":\"_2-4-gethours\",\"contents\":[\"getHours() 方法是得到指定字符串中的哪小时\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getHours()) // 8 \"]},{\"header\":\"2.5 getMinutes\",\"slug\":\"_2-5-getminutes\",\"contents\":[\"getMinutes() 方法是得到指定字符串中的哪分钟\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getMinutes()) // 0 \"]},{\"header\":\"2.6 getSeconds\",\"slug\":\"_2-6-getseconds\",\"contents\":[\"getSeconds() 方法是得到指定字符串中的哪秒钟\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getSeconds()) // 22 \"]},{\"header\":\"2.7 getDay\",\"slug\":\"_2-7-getday\",\"contents\":[\"getDay() 方法是得到指定字符串当前日期是一周中的第几天（周日是 0，周六是 6）\",\"var time = new Date(2019, 03, 08, 08, 00, 22) console.log(time.getDay()) // 1 \"]},{\"header\":\"2.8 getTime\",\"slug\":\"_2-8-gettime\",\"contents\":[\"getTime() 方法是得到执行时间到 格林威治时间 的毫秒数，即时间戳\",\"var time = new Date(2019, 03, 08, 08, 00, 22) console.log(time.getTime()) // 1554681622000 \",\"其他获取时间戳方法：\",\"+new Date() 方法：\",\"console.log(+new Date()) \",\"now() 方法： 无需实例化，但是只能得到当前的时间戳\",\"console.log(Date.now()) \"]},{\"header\":\"3. 获取时间差\",\"slug\":\"_3-获取时间差\",\"contents\":[\"是指获取两个时间点之间相差的时间，在JS中是不能用时间直接做 减法 的，我们需要一些特殊的操作，在编程的世界里面，有一个特殊的时间，是 1970年01月01日00时00分00秒，这个时间我们叫做 格林威治时间，所有的编程世界里面，这个时间都是一样的，而且 格林威治时间 的数字是 0，从 格林威治时间 开始，每经过1毫秒，数字就会 + 1，所以我们可以获取到任意一个时间节点到 `格林威s\"]}]},\"/front-end/javascript-notes/18-JavaScript-%E5%AE%9A%E6%97%B6%E5%99%A8.html\":{\"title\":\"JavaScript-定时器\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"在 JS 里面，有两种定时器，倒计时定时器 和 间隔定时器\"]},{\"header\":\"1. 倒计时定时器\",\"slug\":\"_1-倒计时定时器\",\"contents\":[\"倒计时多少时间以后执行函数\",\"语法： setTimeout(要执行的函数，多长时间以后执行)\",\"会在你设定的时间以后，执行函数\",\"var timerId = setTimeout(function () { console.log('我执行了') }, 1000) console.log(timerId) // 1 \",\"时间是按照毫秒进行计算的，1000 毫秒就是 1秒钟，所以会在页面打开 1 秒钟以后执行函数，只执行一次，就不再执行了，返回值是当前这个定时器是页面中的第几个定时器，表示定时器的编号\"]},{\"header\":\"2. 间隔定时器\",\"slug\":\"_2-间隔定时器\",\"contents\":[\"每间隔多少时间就执行一次函数\",\"语法： setInterval(要执行的函数，间隔多少时间)\",\"var timerId = setInterval(function () { console.log('我执行了') }, 1000) \",\"时间和刚才一样，是按照毫秒进行计算的，每间隔 1 秒钟执行一次函数，只要不关闭，会一直执行，返回值是，当前这个定时器是页面中的第几个定时器，表示定时器的编号\"]},{\"header\":\"3. 定时器的返回值\",\"slug\":\"_3-定时器的返回值\",\"contents\":[\"设置定时器的时候，它的返回值是部分 setTimeout 和 setInterval 的\",\"只要有一个定时器，那么就是一个数字\",\"var timerId = setTimeout(function () { console.log('倒计时定时器') }, 1000) var timerId2 = setInterval(function () { console.log('间隔定时器') }, 1000) console.log(timerId) // 1 console.log(timerId2) // 2 \"]},{\"header\":\"4. 关闭定时器\",\"slug\":\"_4-关闭定时器\",\"contents\":[\"我们刚才提到过一个 timerId，是表示这个定时器是页面上的第几个定时器\",\"这个 timerId 就是用来关闭定时器的数字\",\"我们有两个方法来关闭定时器 clearTimeout 和 clearInterval\",\"var timerId = setTimeout(function () { console.log('倒计时定时器') }, 1000) clearTimeout(timerId) \",\"关闭以后，定时器就不会再执行了\",\"var timerId2 = setInterval(function () { console.log('间隔定时器') }, 1000) coearInterval(timerId2) \",\"关闭以后定时器就不会再执行了\",\"原则上是clearTimeout 关闭 setTimeout，clearInterval 关闭 setInterval，但是其实是可以通用的，他们可以混着使用\",\"var timerId = setTimeout(function () { console.log('倒计时定时器') }, 1000) // 关闭倒计时定时器 clearInterval(timerId) var timerId2 = setInterval(function () { console.log('间隔定时器') }, 1000) // 关闭间隔定时器 clearTimeout(timerId2) \"]}]},\"/front-end/javascript-notes/19-JavaScript-BOM.html\":{\"title\":\"JavaScript-BOM\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"BOM（Browser Object Model）： 浏览器对象模型\",\"其实就是操作浏览器的一些能力\",\"我们可以操作哪些内容？\",\"获取一些浏览器的相关信息（窗口的大小）\",\"操作浏览器进行页面跳转\",\"获取当前浏览器地址栏的信息\",\"操作浏览器的滚动条\",\"浏览器的信息（浏览器的版本）\",\"让浏览器出现一个弹出框（alert / confirm / prompt）\",\"……\"]},{\"header\":\"1. window对象\",\"slug\":\"_1-window对象\",\"contents\":[\"window 对象是一个全局对象，也可以说是 JavaScript 中的顶级对象，基本 BOM 的属性和方法都是 window 对象\",\"所有通过 var 定义在全局作用域中的变量、函数都会变成 window 对象的属性和方法\",\"window对象下的属性和方法调用的时候可以省略 window\"]},{\"header\":\"1.1 获取浏览器窗口的尺寸\",\"slug\":\"_1-1-获取浏览器窗口的尺寸\",\"contents\":[\" innerHeight 和 innerWidth\",\"这两个方法分别是用来获取浏览器窗口的宽度和高度（包含滚动条的）\",\"var windowHeight = window.innerHeight console.log(windowHeight) var windowWidth = window.innerWidth console.log(windowWidth) \",\"不包含滚动条的尺寸获取方式\",\"document.documentElement.clientWidth ： 可视窗口的宽度\",\"document.documentElement.clientHeight ： 可视窗口的高度\"]},{\"header\":\"1.2 获取元素尺寸\",\"slug\":\"_1-2-获取元素尺寸\",\"contents\":[\"就是获取元素的 \\\"占地面积\\\"，使用document对象\",\"注意:\",\"获取到的尺寸是没有单位的数字\",\"当元素在页面中不占位置的时候， 获取到的是 0 \",\"display: none; 元素在页面不占位\",\"visibility: hidden; 元素在页面占位\"]},{\"header\":\"1.2.1 offsetWith 和 offsetHeight\",\"slug\":\"_1-2-1-offsetwith-和-offsetheight\",\"contents\":[\"offsetWidth ： 获取的是元素 内容 + padding + border 的宽度\",\"offsetHeight ： 获取的是元素 内容 + padding + border 的高度\"]},{\"header\":\"1.2.2 clientWidth 和 clientHeight\",\"slug\":\"_1-2-2-clientwidth-和-clientheight\",\"contents\":[\"clientWidth ： 获取的是元素 内容 + padding 的宽度\",\"clientHeight ： 获取的是元素 内容 + padding 的高度\"]},{\"header\":\"1.3 获取元素的偏移量\",\"slug\":\"_1-3-获取元素的偏移量\",\"contents\":[\"就是元素在页面上相对于参考父级的左边和上边的距离，使用document对象\"]},{\"header\":\"1.3.1 offsetParent\",\"slug\":\"_1-3-1-offsetparent\",\"contents\":[\"获取元素的偏移量参考父级\",\"其实就是假设你要给一个元素 绝对定位 的时候，它是根据谁来进行定位的，那么这个元素的偏移量参考父级就是谁\"]},{\"header\":\"1.3.2 offsetLeft 和 offsetTop\",\"slug\":\"_1-3-2-offsetleft-和-offsettop\",\"contents\":[\"获取的是元素左边的偏移量和上边的偏移量\",\"offsetLeft ： 该元素相对于参考父级的左侧偏移量\",\"offsetTop ： 该元素相对于参考父级的上侧偏移量\"]},{\"header\":\"1.4 浏览器的弹出层\",\"slug\":\"_1-4-浏览器的弹出层\",\"contents\":[\"alert 是在浏览器弹出一个提示框\",\"window.alert('我是一个提示框') \",\"这个弹出层只是一个提示内容，只有一个确定按钮\",\"点击确定按钮以后，这个提示框就消失了\",\"confirm 是在浏览器弹出一个询问框\",\"var boo = window.confirm('我是一个询问框') console.log(boo) \",\"这个弹出层有一个询问信息和两个按钮\",\"当你点击确定的时候，就会得到 true\",\"当你点击取消的时候，就会得到 false\",\"prompt 是在浏览器弹出一个输入框\",\"var str = window.prompt('请输入内容') console.log(str) \",\"这个弹出层有一个输入框和两个按钮\",\"当你点击取消的时候，得到的是 null\",\"当你点击确定的时候得到的就是你输入的内容\"]},{\"header\":\"1.5 控制台对象\",\"slug\":\"_1-5-控制台对象\",\"contents\":[\"可以输出各种信息到控制台，并且还提供了很多有用的辅助方法\",\"console对象的浏览器实现，包含在浏览器自带的开发工具之中。以 Chrome 浏览器的“开发者工具”（Developer Tools）为例，可以按 F12 打开\",\"打开开发者工具以后，顶端有多个面板：\",\"Elements：查看网页的 HTML 源码和 CSS 代码\",\"Resources：查看网页加载的各种资源文件（比如代码文件、字体文件 CSS 文件等），以及在硬盘上创建的各种内容（比如本地缓存、Cookie、Local Storage等）\",\"Network：查看网页的 HTTP 通信情况\",\"Sources：查看网页加载的脚本源码\",\"Timeline：查看各种网页行为随时间变化的情况\",\"Performance：查看网页的性能情况，比如 CPU 和内存消耗\",\"Console：用来运行 JavaScript 命令\",\"console.log方法用于在控制台输出信息\"]},{\"header\":\"1.6 浏览器的地址信息\",\"slug\":\"_1-6-浏览器的地址信息\",\"contents\":[\"在 window 中有一个对象叫做 location，就是专门用来存储浏览器的地址栏内的信息的\"]},{\"header\":\"1.6.1 location.href\",\"slug\":\"_1-6-1-location-href\",\"contents\":[\"location.href 这个属性存储的是浏览器地址栏内 url 地址的信息\",\"console.log(window.location.href) \",\"会把中文变成 url 编码的格式\",\"location.href 这个属性也可以给它赋值，赋值时用于地址的跳转\",\"window.location.href = './index.html' // 这个就会跳转页面到后面你给的那个地址 \"]},{\"header\":\"1.6.2 location.search\",\"slug\":\"_1-6-2-location-search\",\"contents\":[\"location.search这个属性用于获取地址中携带的参数，符号 ？后面部分\"]},{\"header\":\"1.6.3 location.hash\",\"slug\":\"_1-6-3-location-hash\",\"contents\":[\"location.hash这个属性用于获取地址中的哈希值，符号 # 后面部分\"]},{\"header\":\"1.6.4 location.reload\",\"slug\":\"_1-6-4-location-reload\",\"contents\":[\"location.reload() 这个方法会重新加载一遍页面，就相当于刷新，传入参数 true 时表示强制刷新\",\"window.location.reload() \",\"注意： 不要写在全局，不然浏览器就会一直处在刷新状态\"]},{\"header\":\"1.7 浏览器的历史记录\",\"slug\":\"_1-7-浏览器的历史记录\",\"contents\":[\"window 中有一个对象叫做 history，是专门用来存储历史记录信息的\"]},{\"header\":\"1.7.1 history.back\",\"slug\":\"_1-7-1-history-back\",\"contents\":[\"history.back 是用来回退历史记录的，就是回到前一个页面，就相当于浏览器上的 ⬅️ 按钮\",\"window.history.back() \",\"前提是你要有上一条记录，不然就是一直在这个页面，也不会回退\"]},{\"header\":\"1.7.2 history.forword\",\"slug\":\"_1-7-2-history-forword\",\"contents\":[\"history.forword 是去到下一个历史记录里面，也就是去到下一个页面，就相当于浏览器上的 ➡️ 按钮\",\"window.history.forward() \",\"前提是你要之前有过回退操作，不然的话你现在就是最后一个页面，没有下一个\"]},{\"header\":\"1.7.3 history.go\",\"slug\":\"_1-7-3-history-go\",\"contents\":[\"history.go(参数)用来前进和后退，参数如果是 1 前进一个页面，如果是 -1 后退一个页面\"]},{\"header\":\"1.8 浏览器的onload事件\",\"slug\":\"_1-8-浏览器的onload事件\",\"contents\":[\"这个不再是对象了，而是一个事件，是在页面所有资源加载完毕后执行的\",\"window.onload = function () { console.log('页面已经加载完毕') } \"]},{\"header\":\"1.8.1 在html页面中把JS写在head里面\",\"slug\":\"_1-8-1-在html页面中把js写在head里面\",\"contents\":[\"<html> <head> <meta charset=\\\"UTF-8\\\" /> <script> // 这个代码执行的时候，body 还没有加载 // 这个时候我们就获取不到 body 中的那个 div // 就需要使用 window.onload 事件 window.onload = function () { // 这个函数会在页面加载完毕以后在执行 // 那么这个时候页面的 DOM 元素都已经加载了，我们就可以获取 div 了 } </script> </head> <body> <div></div> </body> </html> \"]},{\"header\":\"1.8.2 在html页面中把JS写在body最后面\",\"slug\":\"_1-8-2-在html页面中把js写在body最后面\",\"contents\":[\"<html> <head> <meta charset=\\\"UTF-8\\\" /> </head> <body> <div></div> <script> // 这个代码执行的时候，body 已经加载完毕了 // 在这里就可以获取到 div，写不写 window.onload 就无所谓了 window.onload = function () { // 这个函数会在页面加载完毕以后在执行 // 那么这个时候页面的 DOM 元素都已经加载了，我们就可以获取 div 了 } </script> </body> </html> \"]},{\"header\":\"1.9 浏览器的onscroll事件\",\"slug\":\"_1-9-浏览器的onscroll事件\",\"contents\":[\"这个 onscroll 事件是当浏览器的滚动条滚动的时候触发或者鼠标滚轮滚动的时候触发\",\"window.onscroll = function () { console.log('浏览器滚动了') } \",\"注意：前提是页面的高度要超过浏览器的可是窗口才可以\"]},{\"header\":\"1.10 浏览器滚动的距离\",\"slug\":\"_1-10-浏览器滚动的距离\",\"contents\":[\"浏览器内的内容既然可以滚动，那么我们就可以获取到浏览器滚动的距离\",\"浏览器真的滚动了吗？\",\"其实我们的浏览器是没有滚动的，是一直在那里，那么滚动的是什么？是我们的页面，所以说，其实浏览器没有动，只不过是页面向上走了，所以，这个已经不能单纯的算是浏览器的内容了，而是我们页面的内容，所以不是再用 window 对象了，而是使用 document 对象\"]},{\"header\":\"1.10.1 scrollTop\",\"slug\":\"_1-10-1-scrolltop\",\"contents\":[\"获取的是页面向上滚动的距离\",\"一共有两个获取方式\",\"document.body.scrollTop\",\"document.documentElement.scrollTop\",\"window.onscroll = function () { console.log(document.body.scrollTop) console.log(document.documentElement.scrollTop) } \",\"区别：\",\"IE 浏览器 \",\"没有 DOCTYPE 声明的时候，用这两个都行\",\"有 DOCTYPE 声明的时候，只能用 document.documentElement.scrollTop\",\"Chrome 和 FireFox \",\"没有 DOCTYPE 声明的时候，用 document.body.scrollTop\",\"有 DOCTYPE 声明的时候，用 document.documentElement.scrollTop\",\"Safari \",\"两个都不用，使用一个单独的方法 window.pageYOffset \"]},{\"header\":\"1.10.2 scrollLeft\",\"slug\":\"_1-10-2-scrollleft\",\"contents\":[\"获取页面向左滚动的距离\",\"两个方法\",\"document.body.scrollLeft\",\"document.documentElementLeft\",\"window.onscroll = function () { console.log(document.body.scrollLeft) console.log(document.documentElement.scrollLeft) } \"]},{\"header\":\"1.11 navigator对象\",\"slug\":\"_1-11-navigator对象\",\"contents\":[\"window.navigator对象，该对象下记录了浏览器自身的相关信息\",\"常用属性和方法：\",\"通过 userAgent 检测浏览器的版本及平台\",\"// 检测 userAgent（浏览器信息） (function () { var userAgent = navigator.userAgent // 验证是否为Android或iPhone var android = userAgent.match(/(Android);?[\\\\s\\\\/]+([\\\\d.]+)?/) var iphone = userAgent.match(/(iPhone\\\\sOS)\\\\s([\\\\d_]+)/) // 如果是Android或iPhone，则跳转至移动站点 if (android || iphone) { location.href = '地址' }})(); \"]},{\"header\":\"1.12 本地存储\",\"slug\":\"_1-12-本地存储\",\"contents\":[\"本地存储：将数据存储在本地浏览器中\",\"优点：\",\"页面刷新或者关闭不丢失数据，实现数据持久化\",\"容量较大，sessionStorage 和 localStorage 约 5M 左右\"]},{\"header\":\"1.12.1 localStorage\",\"slug\":\"_1-12-1-localstorage\",\"contents\":[\"作用: 数据可以长期保留在本地浏览器中，刷新页面和关闭页面，数据也不会丢失, 除非手动删除\",\"特性：可以多窗口共享（同一浏览器可以共享），以键值对的形式存储，并且存储的是字符串，省略了 window\",\"语法： 存储数据：\",\"localStorage.setItem(key, value) \",\"获取数据：\",\"localStorage.getItem(key) \",\"删除数据：\",\"localStorage.removeItem(key) \",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>本地存储-localstorage</title> </head> <body> <script> // 本地存储 - localstorage 存储的是字符串 // 1. 存储 localStorage.setItem('age', 18) // 2. 获取 console.log(typeof localStorage.getItem('age')) // 3. 删除 localStorage.removeItem('age') </script> </body> </html> \",\"可以在浏览器使用 F12，通过 Application 查看本地数据\"]},{\"header\":\"1.12.2 sessionStorage\",\"slug\":\"_1-12-2-sessionstorage\",\"contents\":[\"特性：\",\"生命周期为关闭浏览器窗口\",\"在同一个窗口（页面）下数据可以共享\",\"以键值对的形式存储使用\",\"用法跟 localStorage 基本相同\",\"语法：\",\"// 存储 sessionStorage.setItem(key,value) // 获取 sessionStorage.getItem(key) // 删除 sessionStorage.removeItem(key) \"]},{\"header\":\"1.12.3 localStorage 存储复杂数据类型\",\"slug\":\"_1-12-3-localstorage-存储复杂数据类型\",\"contents\":[\"问题：本地只能存储字符串, 无法存储复杂数据类型\",\"解决方法：需要将复杂数据类型转换成 JSON 字符串, 再存储到本地\",\"语法：JSON.stringify(复杂数据类型)\",\"JSON 字符串：\",\"首先是1个字符串\",\"属性名使用双引号引起来，不能单引号\",\"属性值如果是字符串型也必须双引号\",\"<body> <script> // 本地存储复杂数据类型 var goods = { name: '小米', price: 1999 } // localStorage.setItem('goods', goods) // console.log(localStorage.getItem('goods')) // 1. 把对象转换为JSON字符串 JSON.stringify localStorage.setItem('goods', JSON.stringify(goods)) // console.log(typeof localStorage.getItem('goods')) </script> </body> \",\"问题：因为本地存储里面取出来的是字符串，不是对象，无法直接使用\",\"解决：把取出来的字符串转换为对象\",\"语法：JSON.parse(JSON字符串)\",\"<body> <script> // 本地存储复杂数据类型 var goods = { name: '小米', price: 1999 } // localStorage.setItem('goods', goods) // console.log(localStorage.getItem('goods')) // 1. 把对象转换为JSON字符串 JSON.stringify localStorage.setItem('goods', JSON.stringify(goods)) // console.log(typeof localStorage.getItem('goods')) // 2. 把JSON字符串转换为对象 JSON.parse console.log(JSON.parse(localStorage.getItem('goods'))) </script> </body> \"]},{\"header\":\"1.13cookie\",\"slug\":\"_1-13cookie\",\"contents\":[\"cookie的特点:\",\"只能存储文本\",\"单条存储有大小限制4KB左右，数量限制（一般浏览器，限制大概在50条左右）\",\"读取有域名限制：不可跨域读取，只能由来自 写入cookie的 同一域名 的网页可进行读取。简单的讲就是，哪个服务器发给你的cookie，只有哪个服务器有权利读取\",\"时效限制：每个cookie都有时效，默认的有效期是，会话级别：就是当浏览器关闭，那么cookie立即销毁，但是我们也可以在存储的时候手动设置cookie的过期时间\",\"路径限制：存cookie时候可以指定路径，只允许子路径读取外层cookie，外层不能读取内层\"]}]},\"/front-end/javascript-notes/20-JavaScript-DOM.html\":{\"title\":\"JavaScript-DOM\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"在JavaScript中，DOM (文档对象模型)是一种将HTML或XML文档表示为树形结构的API，它提供了访问和操作HTML或XML文档的方法\"]},{\"header\":\"1. DOM树\",\"slug\":\"_1-dom树\",\"contents\":[\"在JavaScript中，DOM (文档对象模型)是一种将HTML或XML文档表示为树形结构的API，它提供了访问和操作HTML或XML文档的方法\",\"JavaScript-DOM01.png\",\"元素节点其实就是 HTML 标签，如上图中 head、div、body 等都属于元素节点\",\"属性节点是指 HTML 标签中的属性，如上图中 a 标签的 href 属性、div 标签的 class 属性\",\"文本节点是指 HTML 标签的文字内容，如 title 标签中的文字\",\"根节点 特指 html 标签\"]},{\"header\":\"2. DOM元素节点\",\"slug\":\"_2-dom元素节点\",\"contents\":[\"元素节点是 DOM 树中的一个分支点，它包含元素标签的所有属性和内容\"]},{\"header\":\"2.1 获取元素\",\"slug\":\"_2-1-获取元素\",\"contents\":[\"通过 JS 代码来获取页面中的标签，获取到以后我们就可以操作这些标签了\"]},{\"header\":\"2.1.1 getElementById\",\"slug\":\"_2-1-1-getelementbyid\",\"contents\":[\"getElementById 是通过标签的 id 名称来获取标签的\",\"因为在一个页面中 id 是唯一的，所以获取到的就是一个元素\",\"<body> <div id=\\\"box\\\"></div> <script> // 获取到的就是页面中的那个 id 为 box 的 div 标签 var box = document.getElementById('box') console.log(box) // <div></div> </script> </body> \"]},{\"header\":\"2.1.2 getElementsByClassName\",\"slug\":\"_2-1-2-getelementsbyclassname\",\"contents\":[\"getElementsByClassName 是通过标签的 class 名称来获取标签的\",\"因为页面中可能有多个元素的 class 名称一样，所以获取到的是一组元素\",\"哪怕你获取的 class 只有一个，那也是获取一组元素，只不过这一组中只有一个 DOM 元素而已\",\"<body> <div calss=\\\"box\\\"></div> <script> var box = document.getElementsByClassName('box') console.log(box) // [<div></div>] console.log(box[0]) // <div></div> </script> </body> \",\"获取到的是一组元素，是一个长得和数组一样的数据结构，但是不是数组，是 伪数组，这组数据也是按照索引排列的，所以我们想要准确的拿到这个 div，需要用索引来获取\"]},{\"header\":\"2.1.3 getElementsByTagName\",\"slug\":\"_2-1-3-getelementsbytagname\",\"contents\":[\"getElementsByTagName 是用过标签的标签名称来获取标签的\",\"因为页面中可能有多个元素的标签名称一样，所以获取到的是一组元素\",\"哪怕只有一个这个标签名，那么也是获取一组元素，只不过这一组中只有一个 DOM 元素而已\",\"<body> <div></div> <script> var box = document.getElementsByTagName('div') console.log(box) // [<div></div>] console.log(box[0]) // <div></div> </script> </body> \",\"和 getElementsByClassName 一样，获取到的是一个长得很像数组的元素，必须要用索引才能得到准确的 DOM 元素\"]},{\"header\":\"2.1.4 querySelector\",\"slug\":\"_2-1-4-queryselector\",\"contents\":[\"querySelector 是按照选择器的方式来获取元素，也就是说，按照我们写 CSS 的时候的选择器来获取\",\"这个方法只能获取到一个元素，并且是页面中第一个满足条件的元素\",\"console.log(document.querySelector('div')) // 获取页面中的第一个 div 元素 console.log(docuemnt.querySelector('.box')) // 获取页面中第一个有 box 类名的元素 console.log(document.querySelector('#box')) // 获取页面中第一个 id 名为 box 的元素 \"]},{\"header\":\"2.1.5 querySelectorAll\",\"slug\":\"_2-1-5-queryselectorall\",\"contents\":[\"querySelectorAll 是按照选择器的方式来获取元素\",\"这个方法能获取到所有满足条件的元素，以一个伪数组的形式返回\",\"console.log(document.querySelectorAll('div')) // 获取页面中的所有的 div 元素 console.log(docuemnt.querySelectorAll('.box')) // 获取页面中所有有 box 类名的元素 \",\"获取到的是一组数据，也是需要用索引来获取到准确的每一个 DOM 元素，或者是用遍历的方式获得，没有 pop()push() 等数组方法\"]},{\"header\":\"2.1.6 获取特殊元素\",\"slug\":\"_2-1-6-获取特殊元素\",\"contents\":[\"获取body元素：doucumnet.body\",\"获取html元素：document.documentElement\"]},{\"header\":\"2.2 操作元素\",\"slug\":\"_2-2-操作元素\",\"contents\":[\"通过我们各种获取元素的方式获取到页面中的标签以后，我们可以通过操作 DOM 元素的内容和属性，就能直接把效果展示在页面上\"]},{\"header\":\"2.2.1 操作元素内容\",\"slug\":\"_2-2-1-操作元素内容\",\"contents\":[]},{\"header\":\"2.2.1.1 innerHTML\",\"slug\":\"_2-2-1-1-innerhtml\",\"contents\":[\"获取元素内部的 HTML 结构\",\"<body> <div> <p> <span>hello</span> </p> </div> <script> var div = document.querySelector('div') console.log(div.innerHTML) /* <p> <span>hello</span> </p> */ </script> </body> \",\"设置元素的内容\",\"<body> <div></div> <script> var div = document.querySelector('div') div.innerHTML = '<p>hello</p>' </script> </body> \",\"设置完以后，页面中的 div 元素里面就会嵌套一个 p 元素\"]},{\"header\":\"2.2.1.2 innerText\",\"slug\":\"_2-2-1-2-innertext\",\"contents\":[\"获取元素内部的文本（只能获取到文本内容，获取不到 html 标签）\",\"<body> <div> <p> <span>hello</span> </p> </div> <script> var div = document.querySelector('div') console.log(div.innerText) // hello </script> </body> \",\"可以设置元素内部的文本\",\"<body> <div></div> <script> var div = document.querySelector('div') div.innerText = '<p>hello</p>' </script> </body> \",\"设置完毕以后，会把 <p>hello</p> 当作一个文本出现在 div 元素里面，而不会把 p 解析成标签\"]},{\"header\":\"2.2.2 操作元素常用属性\",\"slug\":\"_2-2-2-操作元素常用属性\",\"contents\":[\"语法：\",\"对象.属性 = 值 \",\"例：\",\"<img src=\\\"./images/1.webp\\\" alt=\\\"\\\" /> \",\"//1.获取图片元素 var img = document.querySelector('img') //2.修改图片对象的属性 img.src = './images/2.webp' img.title = '小刘' \"]},{\"header\":\"2.2.3 样式属性操作\",\"slug\":\"_2-2-3-样式属性操作\",\"contents\":[]},{\"header\":\"2.2.3.1 style\",\"slug\":\"_2-2-3-1-style\",\"contents\":[\"专门用来给元素添加 css 样式的，添加的都是行内样式\",\"任何标签都有 style 属性，通过 style 属性可以动态更改网页标签的样式，如要遇到 CSS 属性中包含字符 - 时，要将 - 去掉并将其后面的字母改成大写，转换为小驼峰命名法，如 background-color 要写成 box.style.backgroundColor\",\"<body> <div></div> <script> var div = document.querySelector('div') div.style.width = \\\"100px\\\" div.style.height = \\\"100px\\\" div.style.backgroundColor = \\\"pink\\\" console.log(div) // <div style=\\\"width: 100px; height: 100px; background-color: pink;\\\"></div> </script> </body> \",\"页面中的 div 就会变成一个宽高都是 100，背景颜色是粉色\"]},{\"header\":\"2.2.3.2 获取元素的非行间样式\",\"slug\":\"_2-2-3-2-获取元素的非行间样式\",\"contents\":[\"我们在操作 DOM 的时候，很重要的一点就是要操作元素的 css 样式，那么在操作 css 样式的时候，我们避免不了就要获取元素的样式，之前我们说过可以用 元素.style.xxx 来获取，但是这个方法只能获取到元素 行间样式，也就是写在行内的样式\",\"<style> div { width: 100px; } </style> <body> <div style=\\\"height: 100px;\\\"> <p>我是一个 p 标签</p> </div> <script> var oDiv = document.querySelector('div') console.log(oDiv.style.height) // 100px console.log(oDIv.style.width) // '' </script> </body> \",\"不管是外链式还是内嵌式，我们都获取不到该元素的样式\",\"这里我们就要使用getComputedStyle和 currentStyle方法来获取，这两个方法的作用是一样的，只不过一个在 非 IE 浏览器，一个在 IE 浏览器\"]},{\"header\":\"2.2.3.2.1 getComputedStyle（非IE使用）\",\"slug\":\"_2-2-3-2-1-getcomputedstyle-非ie使用\",\"contents\":[\"语法：window.getComputedStyle(元素, null).要获取的属性\",\"<style> div { width: 100px; } </style> <body> <div style=\\\"height: 100px;\\\"> <p>我是一个 p 标签</p> </div> <script> var oDiv = document.querySelector('div') console.log(window.getComputedStyle(oDiv).width) // 100px console.log(window.getComputedStyle(oDiv).height) // 100px </script> </body> \",\"这个方法获取行间样式和非行间样式都可以\"]},{\"header\":\"2.2.3.2.1 currentStyle（IE使用）\",\"slug\":\"_2-2-3-2-1-currentstyle-ie使用\",\"contents\":[\"语法： 元素.currentStyle.要获取的属性\",\"<style> div { width: 100px; } </style> <body> <div style=\\\"height: 100px;\\\"> <p>我是一个 p 标签</p> </div> <script> var oDiv = document.querySelector('div') console.log(oDiv.currentStyle.width) // 100px console.log(oDiv.currentStyle.height) // 100px </script> </body> \"]},{\"header\":\"2.2.3.3 className\",\"slug\":\"_2-2-3-3-classname\",\"contents\":[\"专门用来操作元素的 类名的\",\"<body> <div class=\\\"box\\\"></div> <script> var div = document.querySelector('div') console.log(div.className) // box </script> </body> \",\"也可以设置元素的类名，不过是全覆盖式的操作\",\"<body> <div class=\\\"box\\\"></div> <script> var div = document.querySelector('div') div.className = 'test' console.log(div) // <div class=\\\"test\\\"></div> </script> </body> \",\"在设置的时候，不管之前有没有类名，都会全部被设置的值覆盖\"]},{\"header\":\"2.2.3.4 classList\",\"slug\":\"_2-2-3-4-classlist\",\"contents\":[\"为了解决 className 容易覆盖以前的类名的问题，我们可以通过 classList 方式追加或删除类名\",\"语法：\",\"// 追加一个类 对象.classList.add('类名') // 删除一个类 对象.classList.remove('类名') //切换一个类 对象.classList.toggle('类名') \",\"例：\",\"<div class=\\\"box\\\">文字</div> \",\".box { width: 200px; height: 200px; color: #333; } .active { color: red; background-color: pink; } \",\"var box = document.querySelector('.box') box.classList.toggle('active') //切换类 \"]},{\"header\":\"2.2.4 自定义属性的操作\",\"slug\":\"_2-2-4-自定义属性的操作\",\"contents\":[]},{\"header\":\"2.2.4.1 getAttribute\",\"slug\":\"_2-2-4-1-getattribute\",\"contents\":[\"获取元素的某个属性（包括自定义属性）\",\"<body> <div a=\\\"100\\\" class=\\\"box\\\"></div> <script> var div = document.querySelector('div') console.log(div.getAttribute('a')) // 100 console.log(div.getAttribute('class')) // box </script> </body> \"]},{\"header\":\"2.2.4.2 setAttribute\",\"slug\":\"_2-2-4-2-setattribute\",\"contents\":[\"给元素设置一个属性（包括自定义属性）\",\"<body> <div></div> <script> var div = document.querySelector('div') div.setAttribute('a', 100) div.setAttribute('class', 'box') console.log(div) // <div a=\\\"100\\\" class=\\\"box\\\"></div> </script> </body> \"]},{\"header\":\"2.2.4.3 removeAttribute\",\"slug\":\"_2-2-4-3-removeattribute\",\"contents\":[\"直接移除元素的某个属性\",\"<body> <div a=\\\"100\\\" class=\\\"box\\\"></div> <script> var div = document.querySelector('div') div.removeAttribute('class') console.log(div) // <div a=\\\"100\\\"></div> </script> </body> \"]},{\"header\":\"2.2.5 操作H5自定义属性\",\"slug\":\"_2-2-5-操作h5自定义属性\",\"contents\":[\"自定义属性目的：是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中\",\"自定义属性通过 getAttribute('属性') 获取，但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性，H5给我们新增了自定义属性\",\"自定义属性：\",\"在 HTML 5中推出来了专门的 data-自定义属性\",\"在标签上一律以 data- 开头\",\"在 DOM 对象上一律以 dataset 对象方式获取\",\"获取自定义属性：\",\"兼容性获取：element.getAttribute('data-index')\",\"H5新增：element.dataset.index或者element.dataset['index']\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>Document</title> </head> <body> <div data-id=\\\"1\\\"> 自定义属性 </div> <script> // 1. 获取元素 let div = document.querySelector('div') // 2. 获取自定义属性值 console.log(div.dataset.id) </script> </body> </html> \"]},{\"header\":\"3. DOM节点\",\"slug\":\"_3-dom节点\",\"contents\":[]},{\"header\":\"3.1 节点的分类\",\"slug\":\"_3-1-节点的分类\",\"contents\":[\"DOM 的节点我们一般分为常用的三大类 元素节点 、文本节点 、 属性节点\"]},{\"header\":\"3.2 获取节点\",\"slug\":\"_3-2-获取节点\",\"contents\":[\"childNodes：获取某一个节点下所有的子一级节点\",\"<body> <div> <p>hello</p> </div> <script> // 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点 var oDiv = document.querySelector('div') console.log(oDiv.childNodes) /* NodeList(3) [text, p, text] 0: text 1: p 2: text length: 3 __proto__: NodeList */ </script> </body> \",\"我们会发现，拿到以后是一个伪数组，里面有三个节点：\",\"一个 text：从 <div> 一直到 <p> 中间有一个换行和一堆空格，这个是第一个节点，是一个文本节点\",\"一个 p：这个 p 标签就是第二个节点，这个是一个元素节点\",\"一个 text：从 </p> 一直到 </div> 中间有一个换行和一堆空格，这个是第三个节点，是一个文本节点\",\"children ：获取某一节点下所有的子一级元素节点\",\"<body> <div> <p>hello</p> </div> <script> // 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点 var oDiv = document.querySelector('div') console.log(oDiv.children) /* HTMLCollection [p] 0: p length: 1 __proto__: HTMLCollection */ </script> </body> \",\"我们发现只有一个节点了，因为 children 只要元素节点，div 下面又只有一个元素节点，就是 p，所以就只有一个，虽然只有一个，但是也是一个 伪数组\",\"firstChild：获取某一节点下子一级的第一个节点\",\"<body> <div> <p>hello</p> </div> <script> // 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点 var oDiv = document.querySelector('div') console.log(oDiv.firstChild) // #text </script> </body> \",\"这个是只获取一个节点，不再是伪数组了，获取的是第一个，第一个就是 <div> 一直到 <p> 的那个换行和空格，是个文本节点\",\"lastChild：获取某一节点下子一级的最后一个节点\",\"<body> <div> <p>hello</p> </div> <script> // 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点 var oDiv = document.querySelector('div') console.log(oDiv.lastChild) // #text </script> </body> \",\"只获取一个节点，不再是伪数组，获取的是最后一个，最后一个就是 </p> 一直到 </div> 之间的换行和空格，是个文本节点\",\"firstElementChild：获取某一节点下子一级第一个元素节点\",\"<body> <div> <p>hello</p> </div> <script> // 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点 var oDiv = document.querySelector('div') console.log(oDiv.firstElementChild) // <p>hello</p> </script> </body> \",\"只获取一个节点，不再是伪数组，获取的是第一个 元素节点，第一个元素节点就是 p 标签，是一个元素节点\",\"lastElementChild：获取某一节点下子一级最后一个元素节点\",\"<body> <div> <p>hello</p> <p>world</p> </div> <script> // 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点 var oDiv = document.querySelector('div') console.log(oDiv.lastElementChild) // <p>world</p> </script> </body> \",\"只获取一个节点，不再是伪数组，获取的是最后一个 元素节点，最后一个元素节点是 <p>world</p>，是一个元素节点\",\"nextSibling：获取某一个节点的 下一个兄弟节点\",\"<body> <ul> <li id=\\\"a\\\">hello</li> <li id=\\\"b\\\">world</li> <li id=\\\"c\\\">!!!</li> </ul> <script> // 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点 var oLi = document.querySelector('#b') console.log(oLi.nextSibling) // #text </script> </body> \",\"只获取一个节点，不再是伪数组，获取的是 id=\\\"b\\\" 这个 li 的下一个兄弟节点，因为 id=\\\"b\\\" 的下一个节点，是两个 li 标签之间的换行和空格，所以是一个文本节点\",\"previousSibling：获取某一个节点的 上一个兄弟节点\",\"<body> <ul> <li id=\\\"a\\\">hello</li> <li id=\\\"b\\\">world</li> <li id=\\\"c\\\">!!!</li> </ul> <script> // 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点 var oLi = document.querySelector('#b') console.log(oLi.previousSibling) // #text </script> </body> \",\"只获取一个节点，不在是伪数组，获取的是 id=\\\"b\\\" 这个 li 的上一个兄弟节点，因为 id=\\\"b\\\" 的上一个节点，是两个 li 标签之间的换行和空格，所以是一个文本节点\",\"nextElementSibling：获取某一个节点的下一个元素节点\",\"<body> <ul> <li id=\\\"a\\\">hello</li> <li id=\\\"b\\\">world</li> <li id=\\\"c\\\">!!!</li> </ul> <script> // 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点 var oLi = document.querySelector('#b') console.log(oLi.nextElementSibling) // <li id=\\\"c\\\">!!!</li> </script> </body> \",\"只获取一个节点，不再是伪数组，获取的是 id=\\\"b\\\" 这个 li 的下一个兄弟元素节点，因为 id=\\\"b\\\" 的下一个兄弟元素节点就是 id=\\\"c\\\" 的 li，是一个元素节点\",\"previousElementSibling：获取某一个节点的上一个元素节点\",\"<body> <ul> <li id=\\\"a\\\">hello</li> <li id=\\\"b\\\">world</li> <li id=\\\"c\\\">!!!</li> </ul> <script> // 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点 var oLi = document.querySelector('#b') console.log(oLi.previousElementSibling) // <li id=\\\"a\\\">hello</li> </script> </body> \",\"只获取一个节点，不再是伪数组，获取的是 id=\\\"b\\\" 这个 li 的上一个兄弟元素节点，因为 id=\\\"b\\\" 的上一个兄弟元素节点就是 id=\\\"a\\\" 的 li，是一个元素节点\",\"parentNode：获取某一个节点的父节点\",\"<body> <ul> <li id=\\\"a\\\">hello</li> <li id=\\\"b\\\">world</li> <li id=\\\"c\\\">!!!</li> </ul> <script> // 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点 var oLi = document.querySelector('#b') console.log(oLi.parentNode) // <ul>...</ul> </script> </body> \",\"只获取一个节点，不再是伪数组，获取的是当前这个 li 的父元素节点，因为这个 li 的父亲就是 ul，所以获取到的就是 ul，是一个元素节点\",\"attributes：获取某一个 元素节点 的所有属性节点\",\"<body> <ul> <li id=\\\"a\\\" a=\\\"100\\\" test=\\\"test\\\">hello</li> </ul> <script> // 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点 var oLi = document.querySelector('#a') console.log(oLi.attributes) /* NamedNodeMap {0: id, 1: a, 2: test, id: id, a: a, test: test, length: 3} 0: id 1: a 2: test length: 3 a: a id: id test: test __proto__: NamedNodeMap */ </script> </body> \",\"获取的是一组数据，是该元素的所有属性，也是一个伪数组，这个 li 有三个属性，id 、 a 、 test 三个，所以就获取到了这三个\"]},{\"header\":\"3.3 节点属性\",\"slug\":\"_3-3-节点属性\",\"contents\":[\"我们已经知道节点会分成很多种，而且我们也能获取到各种不同的节点，接下来我们就来学习各种节点之间属性的区别\",\"我们先准备一段代码\",\"<body> <ul test=\\\"我是 ul 的一个属性\\\"> <li>hello</li> </ul> <script> // 先获取 ul var oUl = document.querySelector('ul') // 获取到 ul 下的第一个子元素节点，是一个元素节点 var eleNode = oUl.firstElementChild // 获取到 ul 的属性节点组合，因为是个组合，我们要拿到节点的话要用索引 var attrNode = oUl.attributes[0] // 获取到 ul 下的第一个子节点，是一个文本节点 var textNode = oUl.firstChild </script> </body> \"]},{\"header\":\"3.3.1 nodeType\",\"slug\":\"_3-3-1-nodetype\",\"contents\":[\"nodeType：获取节点的节点类型，用数字表示\",\"console.log(eleNode.nodeType) // 1 console.log(attrNode.nodeType) // 2 console.log(textNode.nodeType) // 3 \",\"nodeType === 1 就表示该节点是一个 元素节点\",\"nodeType === 2 就表示该节点是一个 属性节点\",\"nodeType === 3 就表示该节点是一个 文本节点\"]},{\"header\":\"3.3.2 nodeName\",\"slug\":\"_3-3-2-nodename\",\"contents\":[\"nodeName：获取节点的节点名称\",\"console.log(eleNode.nodeName) // LI console.log(attrNode.nodeName) // test console.log(textNode.nodeName) // #text \",\"元素节点的 nodeName 就是 大写标签名\",\"属性节点的 nodeName 就是 属性名\",\"文本节点的 nodeName 都是 #text\"]},{\"header\":\"3.3.3 nodeValue\",\"slug\":\"_3-3-3-nodevalue\",\"contents\":[\"nodeValue： 获取节点的值\",\"console.log(eleNode.nodeValue) // null console.log(attrNode.nodeValue) // 我是 ul 的一个属性 console.log(textNode.nodeValue) // 换行 + 空格 \",\"元素节点没有 nodeValue\",\"属性节点的 nodeValue 就是 属性值\",\"文本节点的 nodeValue 就是 文本内容\"]},{\"header\":\"3.3.4 总结\",\"slug\":\"_3-3-4-总结\",\"contents\":[\"nodeType\",\"nodeName\",\"nodeValue\",\"元素节点\",\"1\",\"大写标签名\",\"null\",\"属性节点\",\"2\",\"属性名\",\"属性值\",\"文本节点\",\"3\",\"#text\",\"文本内容\"]},{\"header\":\"3.4 操作节点\",\"slug\":\"_3-4-操作节点\",\"contents\":[\"我们所说的操作无非就是 增删改查（CRUD）\",\"创建一个节点（因为向页面中增加之前，我们需要先创建一个节点出来）\",\"向页面中增加一个节点\",\"删除页面中的某一个节点\",\"修改页面中的某一个节点\",\"获取页面中的某一个节点\"]},{\"header\":\"3.4.1 创建一个节点\",\"slug\":\"_3-4-1-创建一个节点\",\"contents\":[\"createElement：用于创建一个元素节点\",\"// 创建一个 div 元素节点 var oDiv = document.createElement('div') console.log(oDiv) // <div></div> \",\"createTextNode：用于创建一个文本节点\",\"// 创建一个文本节点 var oText = document.createTextNode('我是一个文本') console.log(oText) // \\\"我是一个文本\\\" \"]},{\"header\":\"3.4.2 追加一个节点\",\"slug\":\"_3-4-2-追加一个节点\",\"contents\":[\"appendChild：是向一个元素节点的末尾追加一个节点\",\"语法： 父节点.appendChild(要插入的子节点)\",\"// 创建一个 div 元素节点 var oDiv = document.createElement('div') var oText = document.createTextNode('我是一个文本') // 向 div 中追加一个文本节点 oDiv.appendChild(oText) console.log(oDiv) // <div>我是一个文本</div> \",\"insertBefore：向某一个节点前插入一个节点\",\"语法： 父节点.insertBefore(要插入的节点，插入在哪一个节点的前面)\",\"<body> <div> <p>我是一个 p 标签</p> </div> <script> var oDiv = document.querySelector('div') var oP = oDiv.querySelector('p') // 创建一个元素节点 var oSpan = document.createElement('span') // 将这个元素节点添加到 div 下的 p 的前面 oDiv.insertBefore(oSpan, oP) console.log(oDiv) /* <div> <span></span> <p>我是一个 p 标签</p> </div> */ </script> </body> \"]},{\"header\":\"3.4.3 删除一个节点\",\"slug\":\"_3-4-3-删除一个节点\",\"contents\":[\"removeChild：移除某一节点下的某一个节点\",\"语法：父节点.removeChild(要移除的字节点)\",\"<body> <div> <p>我是一个 p 标签</p> </div> <script> var oDiv = document.querySelector('div') var oP = oDiv.querySelector('p') // 移除 div 下面的 p 标签 oDiv.removeChild(oP) console.log(oDiv) // <div></div> </script> </body> \"]},{\"header\":\"3.4.4 修改一个节点\",\"slug\":\"_3-4-4-修改一个节点\",\"contents\":[\"replaceChild：将页面中的某一个节点替换掉\",\"语法： 父节点.replaceChild(新节点，旧节点)\",\"<body> <div> <p>我是一个 p 标签</p> </div> <script> var oDiv = document.querySelector('div') var oP = oDiv.querySelector('p') // 创建一个 span 节点 var oSpan = document.createElement('span') // 向 span 元素中加点文字 oSpan.innerHTML = '我是新创建的 span 标签' // 用创建的 span 标签替换原先 div 下的 p 标签 oDiv.replaceChild(oSpan, oP) console.log(oDiv) /* <div> <span>我是新创建的 span 标签</span> </div> */ </script> </body> \"]},{\"header\":\"3.4.5 克隆一个节点\",\"slug\":\"_3-4-5-克隆一个节点\",\"contents\":[\"cloneNode：克隆一个已有的节点\",\"语法：元素.cloneNode(布尔值)\",\"cloneNode 会克隆出一个跟原标签一样的元素，括号内传入布尔值\",\"若为 true，则代表克隆时会包含后代节点一起克隆\",\"若为 false，则代表克隆时不包含后代节点\",\"默认为 false\"]},{\"header\":\"4. 对比DOM节点与元素\",\"slug\":\"_4-对比dom节点与元素\",\"contents\":[]},{\"header\":\"4.1 异同\",\"slug\":\"_4-1-异同\",\"contents\":[\"在JavaScript中，每一个HTML标签都可以看做一个节点（Node）。节点是DOM的基本单位，而元素（Element）是节点的一种，是节点类型之一。可以将元素称为节点的子类。\",\"元素节点是 DOM 树中的一个分支点，它包含元素标签的所有属性和内容。它也可以包含其他类型的节点，例如文本节点（Text）、注释节点（Comment）和其他元素节点（Element）。\",\"其他种类的节点还包括属性节点（Attribute Node）、文本节点（Text Node）、注释节点（Comment Node）等。这些节点类型并不是元素，但它们可以成为元素的一部分\",\"区别：\",\"元素节点是节点中的一种，而不是全部节点的总称。\",\"元素节点只有在包含标记字符的时候才存在，而其他节点没有该限制。\",\"节点有多种类型，元素节点就是其中之一。元素节点指的是HTML标签所表示的节点类型，它包含了属性和内容。\",\"联系：\",\"元素节点是节点的一种，它们都是DOM树的组成部分。\",\"元素节点也是 DOM 树中的一种分支点，包含了很多其他类型的节点。\",\"在DOM操作中，既可以操作元素节点，也可以操作其他类型的节点。\",\"总之，元素可以看作是节点的一种特殊情况，是DOM树结构的重要组成部分。它们的关系并不是对立的，而是相互联系的。在进行DOM操作时必须区别开它们的特点，选取特定的操作方法\"]},{\"header\":\"4.2 何时使用\",\"slug\":\"_4-2-何时使用\",\"contents\":[\"在JavaScript中，开发人员可以通过操作DOM树来实现对HTML或XML文档的访问和修改。一般来说，当开发人员需要访问或修改文档中的HTML或XML元素元素时，它们可以操作DOM中的节点而不是元素。下面是操作DOM元素和操作DOM节点的区别：\",\"操作DOM元素\",\"当开发人员需要通过操作文档的HTML或XML元素更新文档中的视觉效果时，就需要DOM元素来操作。比如需要改变元素的样式、更新元素的内容、或动态的向文档添加或移除元素等。但是，DOM元素并不只包含对元素直接的修改，也需要操纵元素的属性等相关内容\",\"操作DOM节点\",\"在有些情况下，开发人员需要访问或修改节点本身而不是元素。比如获取一个元素的父节点或子节点、访问文本节点、或创建自定义的节点等。当需要插入新的元素时，也需要操作节点，因为需要向DOM结构中插入新的节点\",\"因此，在开发过程中，要根据需求来操作DOM元素或节点，具体取决于需要进行哪些文档操作。一般的解决方案就是通过操作节点，来达到更新或操纵元素的目的。\",\"需要注意的是，由于操作DOM可能对应页面的重新计算和渲染，频繁操作DOM会影响整个页面的性能。所以建议在操作DOM时，尽可能地减少对DOM的访问，以达到最佳性能表现\"]},{\"header\":\"5. 事件\",\"slug\":\"_5-事件\",\"contents\":[\"事件是编程语言中的术语，它是用来描述程序的行为或状态的，一旦行为或状态发生改变，便立即调用一个函数\",\"一个事件由什么东西组成\",\"触发谁的事件：事件源\",\"触发什么事件：事件类型\",\"触发以后做什么：事件处理函数\",\"var oDiv = document.querySelector('div') oDiv.onclick = function () {} // 谁来触发事件 => oDiv => 这个事件的事件源就是 oDiv // 触发什么事件 => onclick => 这个事件类型就是 click // 触发之后做什么 => function () {} => 这个事件的处理函数 \",\"我们想要在点击 div 以后做什么事情，就把我们要做的事情写在事件处理函数里面\",\"var oDiv = document.querySelector('div') oDiv.onclick = function () { console.log('你点击了 div') } \",\"当我们点击 div 的时候，就会执行事件处理函数内部的代码，每点击一次，就会执行一次事件处理函数\"]},{\"header\":\"5.1 事件的绑定方式\",\"slug\":\"_5-1-事件的绑定方式\",\"contents\":[\"我们现在给一个注册事件都是使用 onxxx 的方式，但是这个方式不是很好，只能给一个元素注册一个事件，一旦写了第二个事件，那么第一个就被覆盖了\",\"oDiv.onclick = function () { console.log('我是第一个事件') } oDiv.onclick = function () { console.log('我是第二个事件') } \",\"当你点击的时候，只会执行第二个，第一个就没有了，我们还有一种事件监听的方式去给元素绑定事件\",\"使用 addEventListener 的方式添加，这个方法不兼容，在 IE 里面要使用 attachEvent\",\"addEventListener : 非 IE7、8 下使用\",\"语法： 元素.addEventListener('事件类型'， 事件处理函数， 是否使用捕获)\",\"这里的第三个参数是可选的，后面事件的传播会详述\",\"oDiv.addEventListener('click', function () { console.log('我是第一个事件') }, false) oDiv.addEventListener('click', function () { console.log('我是第二个事件') }, false) \",\"当你点击 div 的时候，两个函数都会执行，并且会按照你注册的顺序执行，先打印 我是第一个事件 再打印 我是第二个事件\",\"注意： 事件类型的时候不要写 on，点击事件就是 click，不是 onclick\",\"attachEvent ：IE 7 8 下使用\",\"语法： 元素.attachEvent('事件类型'， 事件处理函数)\",\"oDiv.attachEvent('onclick', function () { console.log('我是第一个事件') }) oDiv.attachEvent('onclick', function () { console.log('我是第二个事件') }) \",\"当你点击 div 的时候，两个函数都会执行，并且会按照你注册的顺序倒叙执行，先打印 我是第二个事件 再打印 我是第一个事件\",\"注意： 事件类型的时候要写 on，点击事件就写 onclick\",\"两个方式的区别：\",\"注册事件的时候事件类型参数的书写 \",\"addEventListener ： 不用写 on\",\"attachEvent ： 要写 on\",\"参数个数 \",\"addEventListener ： 一般是三个常用参数\",\"attachEvent ： 两个参数\",\"执行顺序 \",\"addEventListener ： 顺序注册，顺序执行\",\"attachEvent ： 顺序注册，倒叙执行\",\"适用浏览器 \",\"addEventListener ： 非 IE7、8 的浏览器\",\"attachEvent ： IE7、8 浏览器\"]},{\"header\":\"5.2 常见的事件类型\",\"slug\":\"_5-2-常见的事件类型\",\"contents\":[\"我们在写页面的时候经常用到的一些事件，大致分为几类，浏览器事件 、 鼠标事件 、 键盘事件 、 表单事件 、 触摸事件、焦点事件等\"]},{\"header\":\"5.2.1 浏览器事件\",\"slug\":\"_5-2-1-浏览器事件\",\"contents\":[\"load ： 页面全部资源加载完毕\",\"scroll ： 浏览器滚动的时候触发\",\"resize：窗口改变时触发\",\"DOMContentLoaded：当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像等完全加载\",\"...\"]},{\"header\":\"5.2.2 鼠标事件\",\"slug\":\"_5-2-2-鼠标事件\",\"contents\":[\"click ：点击事件\",\"dblclick ：双击事件\",\"contextmenu ： 右键单击事件\",\"mousedown ：鼠标左键按下事件\",\"mouseup ：鼠标左键抬起事件\",\"mousemove ：鼠标移动\",\"mouseover ：鼠标移入事件，会有冒泡效果\",\"mouseout ：鼠标移出事件，会有冒泡效果\",\"mouseenter ：鼠标移入事件，没有冒泡效果\",\"mouseleave ：鼠标移出事件，没有冒泡效果\",\"...\"]},{\"header\":\"5.2.3 键盘事件\",\"slug\":\"_5-2-3-键盘事件\",\"contents\":[\"keyup ： 键盘抬起事件\",\"keydown ： 键盘按下事件\",\"keypress ： 键盘按下再抬起事件\",\"...\"]},{\"header\":\"5.2.4 表单事件\",\"slug\":\"_5-2-4-表单事件\",\"contents\":[\"change : 表单内容改变事件\",\"input : 表单内容输入事件\",\"submit : 表单提交事件\",\"...\"]},{\"header\":\"5.2.5 触摸事件\",\"slug\":\"_5-2-5-触摸事件\",\"contents\":[\"touchstart ： 触摸开始事件\",\"touchend ： 触摸结束事件\",\"touchmove ： 触摸移动事件\",\"...\"]},{\"header\":\"5.2.6 焦点事件\",\"slug\":\"_5-2-6-焦点事件\",\"contents\":[\"focus：获得焦点事件\",\"blur：失去焦点事件\"]},{\"header\":\"5.2.7 音视频事件\",\"slug\":\"_5-2-7-音视频事件\",\"contents\":[\"ontimeupdate 事件在视频或音频当前的播放位置发生改变时触发\",\"onloadeddate 事件在当前帧的数据加载完成且还没有足够的数据播放视频或音频的下一帧时触发\"]},{\"header\":\"5.3 事件对象\",\"slug\":\"_5-3-事件对象\",\"contents\":[\"什么是事件对象？就是当你触发了一个事件以后，对该事件的一些描述信息\",\"例如：\",\"你触发一个点击事件的时候，你点在哪个位置了，坐标是多少\",\"你触发一个键盘事件的时候，你按的是哪个按钮\",\"...\",\"每一个事件都会有一个对应的对象来描述这些信息，我们就把这个对象叫做 事件对象\",\"浏览器给了我们一个 黑盒子，叫做 window.event，就是对事件信息的所有描述，比如点击事件，你点在了 0，0 位置，那么你得到的这个事件对象里面对应的就会有这个点位的属性，你点在了 10, 10 位置，那么你得到的这个事件对象里面对应的就会有这个点位的属性\",\"oDiv.onclick = function () { console.log(window.event.X轴坐标点信息) console.log(window.event.Y轴坐标点信息) } \",\"这个玩意很好用，但是一般来说，好用的东西就会有 兼容性问题，在 IE低版本 里面这个东西好用，但是在 高版本IE 和 Chrome 里面不好使了，我们就得用另一种方式来获取 事件对象，在每一个事件处理函数的行参位置，默认第一个就是 事件对象\",\"oDiv.onclick = function (e) { // e 就是和 IE 的 window.event 一样的东西 console.log(e.X轴坐标点信息) console.log(e.Y轴坐标点信息) } \",\"综上所述，我们以后在每一个事件里面，想获取事件对象的时候，都用兼容写法\",\"oDiv.onclick = function (e) { e = e || window.event console.log(e.X轴坐标点信息) console.log(e.Y轴坐标点信息) } \",\"常用属性：\",\"type 当前事件的类型\",\"clientX/clientY 光标相对浏览器可见窗口左上角的位置\",\"offsetX/offsetY 光标相于当前 DOM 元素左上角的位置\",\"key 用户按下的键盘键的值，不提倡使用 keycode\"]},{\"header\":\"5.4 事件的传播\",\"slug\":\"_5-4-事件的传播\",\"contents\":[\"JavaScript-DOM02.png\",\"当元素触发一个事件的时候，其父元素也会触发相同的事件，父元素的父元素也会触发相同的事件，就像上面的图片一样，点击在红色盒子上的时候，会触发红色盒子的点击事件，也是点击在了粉色的盒子上，也会触发粉色盒子的点击事件，也是点击在了 body 上，也会触发 body 的点击事件，也是点击在了 html 上，也会触发 html 的点击事件，也是点击在了 document 上，也会触发 document 的点击事件，也是点击在了 window 上，也会触发 window 的点击事件，也就是说，页面上任何一个元素触发事件，都会一层一层最终导致 window 的相同事件触发，前提是各层级元素得有注册相同的事件，不然不会触发\",\"在事件传播的过程中，有一些注意的点：\",\"只会传播同类事件\",\"只会从点击元素开始按照 html 的结构逐层向上元素的事件会被触发\",\"内部元素不管有没有该事件，只要上层元素有该事件，那么上层元素的事件就会被触发\"]},{\"header\":\"5.4.1 冒泡、捕获、目标\",\"slug\":\"_5-4-1-冒泡、捕获、目标\",\"contents\":[\"我们刚才聊过了，每一个事件，都是有可能从自己到 window ，有可能要执行多个同类型事件，那么这个执行的顺序就有一些说法了\",\"目标：你是点击在哪个元素身上了，那么这个事件的 目标 就是什么\",\"冒泡：就是从事件 目标 的事件处理函数开始，依次向外，直到 window 的事件处理函数触发，也就是从下向上的执行事件处理函数\",\"捕获：就是从 window 的事件处理函数开始，依次向内，只要事件 目标 的事件处理函数执行，也就是从上向下的执行事件处理函数\",\"冒泡和捕获的区别：就是在事件的传播中，多个同类型事件处理函数的执行顺序不同\",\"addEventListener 第3个参数为 true 表示捕获阶段触发，false 表示冒泡阶段触发，默认值为 false\"]},{\"header\":\"5.5 事件委托\",\"slug\":\"_5-5-事件委托\",\"contents\":[\"事件委托利用了事件传播的特征来解决一些现实开发中的需求\",\"优点：减少注册次数，可以提高程序性能\",\"原理：事件委托其实是利用事件冒泡的特点 \",\"给父元素注册事件，当我们触发子元素的时候，会冒泡到父元素身上，从而触发父元素的事件\",\"实现：事件对象.target.tagName 可以获得真正触发事件的元素\"]},{\"header\":\"5.5.1 事件触发\",\"slug\":\"_5-5-1-事件触发\",\"contents\":[\"点击子元素的时候，不管子元素有没有点击事件，只要父元素有点击事件，那么就可以触发父元素的点击事件\",\"<body> <ul> <li>1</li> <li>2</li> <li>3</li> </ul> <script> var oUl = docuemnt.querySelector('ul') oUl.addEventListener('click', function (e) { console.log('我是 ul 的点击事件，我被触发了') }) </script> </body> \",\"像上面一段代码，当你点击 ul 的时候肯定会触发，但是当你点击 li 的时候，其实也会触发\"]},{\"header\":\"5.5.2 target\",\"slug\":\"_5-5-2-target\",\"contents\":[\"target 这个属性是事件对象里面的属性，表示你点击的目标，当你触发点击事件的时候，你点击在哪个元素上，target 就是哪个元素，这个 target 也不兼容，在 IE 下要使用 srcElement\",\"<body> <ul> <li>1</li> <li>2</li> <li>3</li> </ul> <script> var oUl = docuemnt.querySelector('ul') oUl.addEventListener('click', function (e) { e = e || window.event var target = e.target || e.srcElement console.log(target) }) </script> </body> \",\"上面的代码，当你点击 ul 的时候，target 就是 ul，当你点击在 li 上面的时候，target 就是 li\"]},{\"header\":\"5.5.3 委托\",\"slug\":\"_5-5-3-委托\",\"contents\":[\"这个时候，当我们点击 li 的时候，也可以触发 ul 的点事件，并且在事件内不，我们也可以拿到你点击的到底是 ul 还是 li，这个时候，我们就可以把 li 的事件委托给 ul 来做\",\"<body> <ul> <li>1</li> <li>2</li> <li>3</li> </ul> <script> var oUl = docuemnt.querySelector('ul') oUl.addEventListener('click', function (e) { e = e || window.event var target = e.target || e.srcElement // 判断你点击的是 li if (target.nodeName.toUpperCase === 'LI') { // 确定点击的是 li // 因为当你点击在 ul 上面的时候，nodeName 应该是 'UL' // 去做点击 li 的时候该做的事情了 console.log('我是 li，我被点击了') } }) </script> </body> \",\"上面的代码，我们就可以把 li 要做的事情委托给 ul 来做\"]},{\"header\":\"5.6 默认行为\",\"slug\":\"_5-6-默认行为\",\"contents\":[]},{\"header\":\"5.6.1 什么是默认行为\",\"slug\":\"_5-6-1-什么是默认行为\",\"contents\":[\"默认行为，就是不用我们注册，它自己就存在的事情，比如我们点击鼠标右键的时候，会自动弹出一个菜单，比如我们点击 a 标签的时候，我们不需要注册点击事件，他自己就会跳转页面...\",\"这些不需要我们注册就能实现的事情，我们叫做 默认行为\"]},{\"header\":\"5.6.2 阻止默认行为\",\"slug\":\"_5-6-2-阻止默认行为\",\"contents\":[\"有的时候，我们不希望浏览器执行默认事件，比如我给 a 标签绑定了一个点击事件，我点击你的时候希望你能告诉我你的地址是什么，而不是直接跳转链接，那么我们就要把 a 标签原先的默认事件阻止，不让他执行默认事件\",\"我们有两个方法来阻止默认事件\",\"e.preventDefault() : 非 IE 使用\",\"e.returnValue = false ：IE 使用\",\"我们阻止默认事件的时候也要写一个兼容的写法\",\"<a href=\\\"https://www.baidu.com\\\">点击我试试</a> <script> var oA = document.querySelector('a') a.addEventListener('click', function (e) { e = e || window.event console.log(this.href) e.preventDefault ? e.preventDefault() : e.returnValue = false }) </script> \",\"这样写完以后，你点击 a 标签的时候，就不会跳转链接了，而是会在控制台打印出 a 标签的 href 属性的值\"]},{\"header\":\"5.7 阻止冒泡\",\"slug\":\"_5-7-阻止冒泡\",\"contents\":[\"阻止冒泡是指阻断事件的流动，保证事件只在当前元素被执行，而不再去影响到其对应的祖先元素\",\"前提：阻止事件冒泡需要拿到事件对象\",\"语法：\",\"事件对象.stopPropagation() \",\"注意：此方法可以阻断事件流动传播，不光在冒泡阶段有效，捕获阶段也有效\",\"例：\",\"const father = document.querySelector('.father') const son = document.querySelector('.son') document.addEventListener('click', function () { alert('我是爷爷') }) father.addEventListener('click', function () { alert('我是爸爸') }) son.addEventListener('click', function (e) { alert('我是儿子') //阻止流动传播 e.stopPropagation() }) \"]},{\"header\":\"5.8 解绑事件\",\"slug\":\"_5-8-解绑事件\",\"contents\":[\"on 事件方式，直接使用 null 覆盖就可以实现事件的解绑\",\"例：\",\"//绑定事件 btn.onclick = function(){ alert('点击了') } //解绑事件 btn.onclick = null \",\"addEventListener 方式，必须使用：\",\"removeEventListener(事件类型,事件处理函数,[获取捕获或者冒泡阶段]) //[ ]内内容为可选的 \",\"例：\",\"function fn(){ alert('点击了') } //绑定了 btn.addEventListener('click',fn) //解绑事件 btn.removeEventListener('click',fn) \",\"注意：匿名函数无法被解绑\"]}]},\"/front-end/javascript-notes/21-JavaScript-this%E5%85%B3%E9%94%AE%E5%AD%97.html\":{\"title\":\"JavaScript-this关键字\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"每一个函数内部都有一个关键字是 this ，可以让我们直接使用的\",\"重点： 函数内部的 this 只和函数的调用方式有关系，和函数的定义方式没有关系\"]},{\"header\":\"1. this指向\",\"slug\":\"_1-this指向\",\"contents\":[\"函数内部的 this 指向谁，取决于函数的调用方式\",\"全局定义的函数直接调用，this => window\",\"普通函数没有明确调用者时 this 值为 window，严格模式下没有调用者时 this 的值为 undefined\",\"function fn() { console.log(this) } fn() // 此时 this 指向 window \",\"对象内部的方法调用，this => 调用者\",\"var obj = { fn: function () { console.log(this) } } obj.fn() // 此时 this 指向 obj \",\"定时器的处理函数，this => window\",\"setTimeout(function () { console.log(this) }, 0) // 此时定时器处理函数里面的 this 指向 window \",\"事件处理函数，this => 事件源\",\"div.onclick = function () { console.log(this) } // 当你点击 div 的时候，this 指向 div \",\"自调用函数（立即执行函数），this => window\",\"(function () { console.log(this) })() // 此时 this 指向 window \"]},{\"header\":\"2. call 和 apply 和 bind\",\"slug\":\"_2-call-和-apply-和-bind\",\"contents\":[\"刚才我们说过的都是函数的基本调用方式里面的 this 指向，我们还有三个可以忽略函数本身的 this 指向转而指向别的地方，这三个方法就是 call 、 apply 、 bind，它们是强行改变 this 指向的方法\"]},{\"header\":\"2.1 call\",\"slug\":\"_2-1-call\",\"contents\":[\"call 方法是附加在函数调用后面使用，可以忽略函数本身的 this 指向\",\"语法： 函数名.call(要改变的 this 指向，要给函数传递的参数1，要给函数传递的参数2， ...)\",\"var obj = { name: 'Jack' } function fn(a, b) { console.log(this) console.log(a) console.log(b) } fn(1, 2) fn.call(obj, 1, 2) \",\"fn() 的时候，函数内部的 this 指向 window，fn.call(obj, 1, 2) 的时候，函数内部的 this 就指向了 obj 这个对象，使用 call 方法的时候会立即执行函数，第一个参数是你要改变的函数内部的 this 指向，第二个参数开始，依次是向函数传递参数\"]},{\"header\":\"2.2 apply\",\"slug\":\"_2-2-apply\",\"contents\":[\"apply 方法是附加在函数调用后面使用，可以忽略函数本身的 this 指向\",\"语法： 函数名.apply(要改变的 this 指向，[要给函数传递的参数1， 要给函数传递的参数2， ...])\",\"var obj = { name: 'Jack' } function fn(a, b) { console.log(this) console.log(a) console.log(b) } fn(1, 2) fn.call(obj, [1, 2]) \",\"fn() 的时候，函数内部的 this 指向 window，fn.apply(obj, [1, 2]) 的时候，函数内部的 this 就指向了 obj 这个对象，使用 apply 方法的时候，会立即执行函数，第一个参数是你要改变的函数内部的 this 指向，第二个参数是一个 数组，数组里面的每一项依次是向函数传递的参数\"]},{\"header\":\"2.3 bind\",\"slug\":\"_2-3-bind\",\"contents\":[\"bind 方法是附加在函数调用后面使用，可以忽略函数本身的 this 指向，和 call、apply 有一些不一样，就是不会立即执行函数，而是返回一个已经改变了 this 指向的函数\",\"语法： var newFn = 函数名.bind(要改变的 this 指向); newFn(传递参数)\",\"var obj = { name: 'Jack' } function fn(a, b) { console.log(this) console.log(a) console.log(b) } fn(1, 2) var newFn = fn.bind(obj) newFn(1, 2) \",\"bind 调用的时候，不会执行 fn 这个函数，而是返回一个新的函数，这个新的函数就是一个改变了 this 指向以后的 fn 函数，fn(1, 2) 的时候 this 指向 window，newFn(1, 2) 的时候执行的是一个和 fn 一摸一样的函数，只不过里面的 this 指向改成了 obj\"]}]},\"/front-end/javascript-notes/22-JavaScript-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B.html\":{\"title\":\"JavaScript-面向对象编程\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"首先，我们要明确，面向对象不是语法，是一个思想，是一种编程思想\"]},{\"header\":\"1. 编程思想\",\"slug\":\"_1-编程思想\",\"contents\":[]},{\"header\":\"1.1 面向过程\",\"slug\":\"_1-1-面向过程\",\"contents\":[\"面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了\",\"优点：性能比面向对象高，适合跟硬件联系很紧密的东西\",\"缺点：没有面向对象易维护、易复用、易扩展\"]},{\"header\":\"1.2 面向对象\",\"slug\":\"_1-2-面向对象\",\"contents\":[\"面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作\",\"在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工\",\"面向对象编程具有灵活、代码可复用、容易维护和开发的优点，更适合多人合作的大型软件项目\",\"面向对象的特性：封装性、继承性、多态性\",\"优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护\",\"缺点：性能比面向过程低\"]},{\"header\":\"2. 创建对象的方式\",\"slug\":\"_2-创建对象的方式\",\"contents\":[\"因为面向对象就是一个找到对象的过程，所以我们先要了解如何创建一个对象\"]},{\"header\":\"2.1 使用构造函数创建对象\",\"slug\":\"_2-1-使用构造函数创建对象\",\"contents\":[\"构造函数是专门用于创建对象的函数，如果一个函数使用 new 关键字调用，那么这个函数就是构造函数\",\"JS 给我们内置了一个 Object 构造函数，这个构造函数就是用来创造对象的，当构造函数和new 关键字连用的时候，就可以为我们创造出一个对象，因为 JS 是一个动态的语言，那么我们就可以动态的向对象中添加成员了\",\"// 就能得到一个空对象 var o1 = new Object() // 正常操作对象 o1.name = 'Jack' o1.age = 18 o1.gender = '男' \"]},{\"header\":\"2.2 使用字面量创建对象\",\"slug\":\"_2-2-使用字面量创建对象\",\"contents\":[\"直接使用字面量的形式，也就是直接写 {}，可以在写的时候就添加好成员，也可以动态的添加\",\"// 字面量方式创建对象 var o1 = { name: 'Jack', age: 18, gender: '男' } // 再来一个 var o2 = {} o2.name = 'Rose' o2.age = 20 o2.gender = '女' \"]},{\"header\":\"2.3 使用工厂函数创建对象\",\"slug\":\"_2-3-使用工厂函数创建对象\",\"contents\":[\"先书写一个工厂函数，这个工厂函数里面可以创造出一个对象，并且给对象添加一些属性，还能把对象返回\",\"使用这个工厂函数创造对象\",\"// 1. 先创建一个工厂函数 function createObj() { // 手动创建一个对象 var obj = new Object() // 手动的向对象中添加成员 obj.name = 'Jack' obj.age = 18 obj.gender = '男' // 手动返回一个对象 return obj } // 2. 使用这个工厂函数创建对象 var o1 = createObj() var o2 = createObj() \"]},{\"header\":\"2.4 使用自定义构造函数创建对象\",\"slug\":\"_2-4-使用自定义构造函数创建对象\",\"contents\":[\"工厂函数需要经历三个步骤：\",\"手动创建对象\",\"手动添加成员\",\"手动返回对象\",\"构造函数会比工厂函数简单一些：\",\"自动创建对象\",\"手动添加成员\",\"自动返回对象\",\"先书写一个构造函数，在构造函数内向对象添加一些成员，使用这个构造函数创造一个对象（和 new 连用），构造函数可以创建对象，并且创建一个带有属性和方法的对象\",\"面向对象就是要想办法找到一个有属性和方法的对象，面向对象就是我们自己制造 构造函数 的过程\",\"// 1. 先创造一个构造函数 function Person(name, gender) { this.age = 18 this.name = name this.gender = gender } // 2. 使用构造函数创建对象 var p1 = new Person('Jack', 'man') var p2 = new Person('Rose', 'woman') \"]},{\"header\":\"3. 构造函数详解\",\"slug\":\"_3-构造函数详解\",\"contents\":[\"我们了解了对象的创建方式，我们的面向对象就是要么能直接得到一个对象，要么就弄出一个能创造对象的东西，我们自己创造对象。我们的构造函数就能创造对象，所以接下来我们就详细聊聊构造函数\"]},{\"header\":\"3.1 构造函数的基本使用\",\"slug\":\"_3-1-构造函数的基本使用\",\"contents\":[\"和普通函数一样，只不过调用的时候要和 new 连用，不然就是一个普通函数调用\",\"function Person() {} var o1 = new Person() // 能得到一个空对象 var o2 = Person() // 什么也得不到，这个就是普通函数调用 \",\"注意：不写 new 的时候就是普通函数调用，没有创造对象的能力\",\"习惯将首字母大写\",\"function person() {} var o1 = new person() // 能得到一个对象 function Person() {} var o2 = new Person() // 能得到一个对象 \",\"注意： 首字母不大写，只要和 new 连用，就有创造对象的能力\",\"当调用的时候如果不需要传递参数可以不写 ()，建议都写上\",\"function Person() {} var o1 = new Person() // 能得到一个空对象 var o2 = new Person // 能得到一个空对象 \",\"注意： 如果不需要传递参数，那么可以不写 ()，如果传递参数就必须写\",\"构造函数内部的 this，由于和 new 连用的关系，是指向当前实例对象的\",\"function Person() { console.log(this) } var o1 = new Person() // 本次调用的时候，this => o1 var o2 = new Person() // 本次调用的时候，this => o2 \",\"注意： 每次 new 的时候，函数内部的 this 都是指向当前这次的实例化对象\",\"因为构造函数会自动返回一个对象，所以构造函数内部不要写 return\",\"你如果 return 一个基本数据类型，那么写了没有意义\",\"如果你 return 一个引用数据类型，那么构造函数本身的意义就没有了\"]},{\"header\":\"3.2 使用构造函数封装对象\",\"slug\":\"_3-2-使用构造函数封装对象\",\"contents\":[\"我们在使用构造函数的时候，可以通过一些代码和内容来向当前的对象中添加一些内容\",\"function Person() { this.name = 'Jack' this.age = 18 } var o1 = new Person() var o2 = new Person() \",\"我们得到的两个对象里面都有自己的成员 name 和 age，我们在写构造函数的时候，是不是也可以添加一些方法进去呢？\",\"function Person() { this.name = 'Jack' this.age = 18 this.sayHi = function () { console.log('hello constructor') } } var o1 = new Person() var o2 = new Person() \",\"显然是可以的，我们的到的两个对象中都有 sayHi 这个函数，也都可以正常调用，但是这样好不好呢？缺点在哪里？\",\"function Person() { this.name = 'Jack' this.age = 18 this.sayHi = function () { console.log('hello constructor') } } // 第一次 new 的时候， Person 这个函数要执行一遍 // 执行一遍就会创造一个新的函数，并且把函数地址赋值给 this.sayHi var o1 = new Person() // 第二次 new 的时候， Person 这个函数要执行一遍 // 执行一遍就会创造一个新的函数，并且把函数地址赋值给 this.sayHi var o2 = new Person() \",\"这样的话，那么我们两个对象内的 sayHi 函数就是一个代码一模一样，功能一模一样，但是是两个空间函数，占用两个内存空间，也就是说 o1.sayHi 是一个地址，o2.sayHi 是一个地址，所以我们执行 console.log(o1 === o2.sayHi) 的到的结果是 false\",\"缺点： 一模一样的函数出现了两次，占用了两个空间地址，存在内存浪费问题\",\"怎么解决这个问题呢？就需要用到一个东西，叫做原型\"]},{\"header\":\"4. 原型\",\"slug\":\"_4-原型\",\"contents\":[\"原型的出现，就是为了解决构造函数的缺点，也就是给我们提供了一个给对象添加函数的方法，不然构造函数只能给对象添加属性，不能合理的添加函数\"]},{\"header\":\"4.1 prototype\",\"slug\":\"_4-1-prototype\",\"contents\":[\"每一个函数天生自带一个成员，叫做 prototype，这个 prototype 属性可以由函数名来访问，它是一个对象，我们称为原型对象\",\"function Person() {} console.log(Person.prototype) // 是一个对象 \",\"即然是个对象，那么我们就可以向里面放入一些东西\",\"function Person() { // 此处未定义任何方法 } // 为构造函数的原型对象添加方法 Person.prototype.sayHi = function () { console.log('Hi~'); } var p1 = new Person(); p1.sayHi(); // 输出结果为 Hi~ \",\"我们发现了一个叫做 prototype 的对象是和函数有关联的，并且可以向里面存储一些东西\",\"重点： 在函数的 prototype 里面存储的内容，不是给函数使用的，是给函数的每一个实例化对象使用的\"]},{\"header\":\"4.2 __proto__\",\"slug\":\"_4-2-proto\",\"contents\":[\"每一个对象都天生自带一个成员，叫做 __proto__，是一个对象空间，我们称为对象原型，[[prototype]] 和 __proto__ 意义相同\",\"即然每一个对象都有，实例化对象也是对象，那么每一个实例化对象也有这个成员，这个 __proto__ 对象空间是给每一个对象使用的\",\"当你访问一个对象中的成员的时候\",\"如果这个对象自己本身有这个成员，那么就会直接给你结果\",\"如果没有，就会去 __proto__ 这个对象空间里面找，里面有的话就给你结果\",\"那么这个 __proto__ 又指向哪里呢？这个对象是由哪个构造函数 new 出来的，那么这个对象的 __proto__ 就指向这个构造函数的 prototype\",\"function Person() {} var p1 = new Person() console.log(p1.__proto__ === Person.prototype) // true \",\"我们发现实例化对象的 __proto__ 和所属的构造函数的 prototype 是一个对象空间，我们可以通过构造函数名称来向 prototype 中添加成员，对象在访问的时候自己没有，可以自动去自己的 __proto__ 中查找\",\"那么，我们之前构造函数的缺点就可以解决了：我们可以把函数放在构造函数的 prototype 中，实例化对象访问的时候，自己没有，就会自动去 __proto__ 中找，那么也可以使用了\",\"function Person() {} Person.prototype.sayHi = function () { console.log('hello Person') } var p1 = new Person() p1.sayHi() \",\"p1 自己没有 sayHi 方法，就会去自己的 __proto__ 中查找，p1.__proto__ 就是 Person.prototype，我们又向 Person.prototype 中添加了 sayHi 方法，所以 p1.sayHi 就可以执行了\",\"到这里，当我们实例化多个对象的时候，每个对象里面都没有方法，都是去所属的构造函数的 prototype 中查找，那么每一个对象使用的函数，其实都是同一个函数，那么就解决了我们构造函数的缺点\",\"function Person() {} Person.prototype.sayHi = function () { console.log('hello') } var p1 = new Person() var p2 = new Person() console.log(p1.sayHi === p2.sayHi) \",\"p1 是 Person 的一个实例，p2 是 Person 的一个实例，也就是说 p1.__proto__ 和 p2.__proto__ 指向的都是 Person.prototype，当 p1 去调用 sayHi 方法的时候是去 Person.prototype 中找，当 p2 去调用 sayHi 方法的时候是去 Person.prototype 中找，那么两个实例化对象就是找到的一个方法，也是执行的一个方法\",\"结论：当我们写构造函数的时候，属性我们直接写在构造函数体内，方法我们写在原型对象上\"]},{\"header\":\"4.3 constructor\",\"slug\":\"_4-3-constructor\",\"contents\":[\"proto里面有一个成员叫做 constructor，这个属性就是指向当前这个对象所属的构造函数\",\"使用场景：如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了，此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数\",\"function Star(name){ this.name = name } Star.prototype = { sing:function(){console.log('唱歌')}, dance:function(){console.log('跳舞')} } console.log(Star.prototype.constructor) // 指向Object \",\"function Star(name){ this.name = name } Star.prototype = { //手动利用constructor指回Star构造函数 constructor:Star, sing:function(){console.log('唱歌')}, dance:function(){console.log('跳舞')} } console.log(Star.prototype.constructor) // 指向Star \",\"我们刚才聊过构造函数了，也聊了原型，那么问题出现了，我们说构造函数的 prototype 是一个对象，又说了每一个对象都天生自带一个 __proto__ 属性，那么 构造函数的 prototype 里面的 __proto__ 属性又指向哪里呢？\",\"__proto__里面也有一个成员叫做 constructor，这个属性就是指向当前这个对象所属的构造函数\",\"function Star() {} const ldh = new Star() //对象原型里面有constructor 指向构造函数 Star console.log(ldh.__proto__.constructor === Star) \"]},{\"header\":\"5. 原型链\",\"slug\":\"_5-原型链\",\"contents\":[]},{\"header\":\"5.1 链状结构\",\"slug\":\"_5-1-链状结构\",\"contents\":[\"当一个对象我们不知道准确的是谁构造的时候，我们呢就把它看成 Object 的实例化对象，也就是说，我们的 构造函数 的 prototype 的 __proto__ 指向的是 Object.prototype\",\"那么 Object.prototype 也是个对象，那么它的 __proto__ 又指向谁呢？因为 Object 的 JS 中的顶级构造函数，我们有一句话叫 万物皆对象，所以 Object.prototype 就到顶了，Object.prototype 的 __proto__ 就是 null\",\"JavaScript-面向对象编程01.png\",\" function Person() { } const xm = new Person() console.log(xm.__proto__ === Person.prototype) //true console.log(Person.prototype.__proto__ === Object.prototype) //true console.log(xm instanceof Person) //true console.log(xm instanceof Object) //true console.log(xm instanceof Array) //false console.log([1, 2, 3] instanceof Array) //true console.log(Array instanceof Object) //true \"]},{\"header\":\"5.2 原型链的访问原则\",\"slug\":\"_5-2-原型链的访问原则\",\"contents\":[\"当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性\",\"如果没有就查找它的原型（也就是 __proto__ 指向的 prototype 原型对象）\",\"如果还没有就查找原型对象的原型（Object 的原型对象）\",\"依此类推一直找到 Object 为止（null）\",\"__proto__ 对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线\",\"可以使用 instanceof 运算符来检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上\"]},{\"header\":\"6. 对象的赋值\",\"slug\":\"_6-对象的赋值\",\"contents\":[\"到这里，我们就会觉得，如果是赋值的话，那么也会按照原型链的规则来，但是： 并不是！并不是！并不是！ 重要的事情说三遍\",\"赋值的时候，就是直接给对象自己本身赋值，如果原先有就是修改，原先没有就是添加，不会和 __proto__ 有关系\"]},{\"header\":\"7. 继承\",\"slug\":\"_7-继承\",\"contents\":[]},{\"header\":\"7.1 构造函数继承\",\"slug\":\"_7-1-构造函数继承\",\"contents\":[\"function Student(name,age,classroom){ Person.call(this,name,age) this.classroom = classroom } \"]},{\"header\":\"7.2 原型继承\",\"slug\":\"_7-2-原型继承\",\"contents\":[\"Student.prototype = new Person() \"]},{\"header\":\"7.3 组合继承\",\"slug\":\"_7-3-组合继承\",\"contents\":[\"构造函数继承+原型继承\",\"function Person(name,age){ this.name = name this.age = age } Person.prototype.say = function(){ console.log(\\\"hello\\\") } function Student(name,age,classroom){ Person.call(this,name,age) this.classroom = classroom } Student.prototype = new Person() var obj = new Student(\\\"kerwin\\\",100,\\\"1班\\\") \"]}]},\"/front-end/javascript-notes/23-JavaScript-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html\":{\"title\":\"JavaScript-异常处理\",\"contents\":[{\"header\":\"1. throw\",\"slug\":\"_1-throw\",\"contents\":[\"异常处理是指预估代码执行过程中可能发生的错误，然后最大程度的避免错误的发生导致整个程序无法继续运行\",\"总结：\",\"throw 抛出异常信息，程序也会终止执行\",\"throw 后面跟的是错误提示信息\",\"Error 对象配合 throw 使用，能够设置更详细的错误信息\",\"<script> function counter(x, y) { if(!x || !y) { // throw '参数不能为空!'; throw new Error('参数不能为空!') } return x + y } counter() </script> \"]},{\"header\":\"2. try...catch\",\"slug\":\"_2-try-catch\",\"contents\":[\"<script> function foo() { try { // 查找 DOM 节点 const p = document.querySelector('.p') p.style.color = 'red' } catch (error) { // try 代码段中执行有错误时，会执行 catch 代码段 // 查看错误信息 console.log(error.message) // 终止代码继续执行 return } finally { alert('执行') } console.log('如果出现错误，我的语句不会执行') } foo() </script> \",\"总结：\",\"try...catch 用于捕获错误信息\",\"将预估可能发生错误的代码写在 try 代码段中\",\"如果 try 代码段中出现错误后，会执行 catch 代码段，并截获到错误信息\",\"finally 不管是否有错误，都会执行\"]},{\"header\":\"3. debugger\",\"slug\":\"_3-debugger\",\"contents\":[\"相当于断点调试\"]}]},\"/front-end/javascript-notes/24-JavaScript-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html\":{\"title\":\"JavaScript-正则表达式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"正则表达式（Regular Expression）是一种字符串匹配的模式（规则）\",\"使用场景：\",\"通常用来提取、匹配、替换那些符合正则表达式的文本 \",\"例如验证表单：手机号表单要求用户只能输入11位的数字 (匹配)\",\"过滤掉页面内容中的一些敏感词 (替换)\",\"从字符串中获取我们想要的特定部分 (提取)\"]},{\"header\":\"1. 正则基本使用\",\"slug\":\"_1-正则基本使用\",\"contents\":[]},{\"header\":\"1.1 定义规则\",\"slug\":\"_1-1-定义规则\",\"contents\":[\"var 变量名 = /表达式/ \",\"其中 / / 是正则表达式字面量\",\"正则表达式也是对象 \",\"比如：\",\"var reg = /前端/ \"]},{\"header\":\"1.2 判断是否有符合规则的字符串\",\"slug\":\"_1-2-判断是否有符合规则的字符串\",\"contents\":[\"test() 方法用来查看正则表达式与指定的字符串是否匹配\",\"如果正则表达式与指定的字符串匹配，返回 true，否则返回 false\",\"语法：\",\"正则表达式对象.test(被检测的字符串) \",\"<body> <script> // 正则表达式的基本使用 var str = 'web前端开发' // 1. 定义规则 var reg = /web/ // 2. 使用正则 test() console.log(reg.test(str)) // true 如果符合规则匹配上则返回true console.log(reg.test('java开发')) // false 如果不符合规则匹配上则返回 false </script> </body> \"]},{\"header\":\"1.3 检索(查找)符合规则的字符串\",\"slug\":\"_1-3-检索-查找-符合规则的字符串\",\"contents\":[\"exec() 方法用于在一个指定字符串中执行一个搜索匹配\",\"如果匹配成功，exec() 方法返回一个数组，否则返回 null\",\"语法：\",\"正则表达式对象.exec(被检测的字符串) \"]},{\"header\":\"1.4 替换符合规则的字符串\",\"slug\":\"_1-4-替换符合规则的字符串\",\"contents\":[\"replace() 方法用于替换字符串\",\"语法：\",\"字符串.replace(/正则表达式/,'替换的文本') \"]},{\"header\":\"2. 元字符\",\"slug\":\"_2-元字符\",\"contents\":[\"普通字符: \",\"大多数的字符仅能够描述它们本身，这些字符称作普通字符，例如所有的字母和数字\",\"普通字符只能够匹配字符串中与它们相同的字符\",\"比如，规定用户只能输入英文26个英文字母，普通字符的话 /[abcdefghijklmnopqrstuvwxyz]/\",\"元字符 (特殊字符） \",\"是一些具有特殊含义的字符，可以极大提高了灵活性和强大的匹配功能\",\"比如，规定用户只能输入英文26个英文字母，换成元字符写法：/[a-z]/\"]},{\"header\":\"2.1 边界符\",\"slug\":\"_2-1-边界符\",\"contents\":[\"正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符\",\"边界符\",\"说明\",\"^\",\"表示匹配行首的文本（以谁开始）\",\"$\",\"表示匹配行尾的文本（以谁结束）\",\"如果 ^ 和 $ 在一起，表示必须是精确匹配\",\"<body> <script> // 元字符之边界符 // 1. 匹配开头的位置 ^ var reg = /^web/ console.log(reg.test('web前端')) // true console.log(reg.test('前端web')) // false console.log(reg.test('前端web学习')) // false console.log(reg.test('we')) // false // 2. 匹配结束的位置 $ var reg1 = /web$/ console.log(reg1.test('web前端')) // false console.log(reg1.test('前端web')) // true console.log(reg1.test('前端web学习')) // false console.log(reg1.test('we')) // false // 3. 精确匹配 ^ $ var reg2 = /^web$/ console.log(reg2.test('web前端')) // false console.log(reg2.test('前端web')) // false console.log(reg2.test('前端web学习')) // false console.log(reg2.test('we')) // false console.log(reg2.test('web')) // true console.log(reg2.test('webweb')) // flase </script> </body> \"]},{\"header\":\"2.2 量词\",\"slug\":\"_2-2-量词\",\"contents\":[\"量词用来设定某个模式重复次数\",\"量词\",\"说明\",\"*\",\"重复零次或更多次\",\"+\",\"重复一次或更多次\",\"?\",\"重复零次或一次\",\"{n}\",\"重复 n 次\",\"{n,}\",\"重复 n 次或更多次\",\"{n,m}\",\"重复 n 到 m 次\",\"注意： 逗号左右两侧千万不要出现空格\",\"<body> <script> // 元字符之量词 // 1. * 重复次数 >= 0 次 var reg1 = /^w*$/ console.log(reg1.test('')) // true console.log(reg1.test('w')) // true console.log(reg1.test('ww')) // true console.log('-----------------------') // 2. + 重复次数 >= 1 次 var reg2 = /^w+$/ console.log(reg2.test('')) // false console.log(reg2.test('w')) // true console.log(reg2.test('ww')) // true console.log('-----------------------') // 3. ? 重复次数 0 || 1 var reg3 = /^w?$/ console.log(reg3.test('')) // true console.log(reg3.test('w')) // true console.log(reg3.test('ww')) // false console.log('-----------------------') // 4. {n} 重复 n 次 var reg4 = /^w{3}$/ console.log(reg4.test('')) // false console.log(reg4.test('w')) // flase console.log(reg4.test('ww')) // false console.log(reg4.test('www')) // true console.log(reg4.test('wwww')) // false console.log('-----------------------') // 5. {n,} 重复次数 >= n var reg5 = /^w{2,}$/ console.log(reg5.test('')) // false console.log(reg5.test('w')) // false console.log(reg5.test('ww')) // true console.log(reg5.test('www')) // true console.log('-----------------------') // 6. {n,m} n =< 重复次数 <= m var reg6 = /^w{2,4}$/ console.log(reg6.test('w')) // false console.log(reg6.test('ww')) // true console.log(reg6.test('www')) // true console.log(reg6.test('wwww')) // true console.log(reg6.test('wwwww')) // false // 7. 注意事项： 逗号两侧千万不要加空格否则会匹配失败 </script> \"]},{\"header\":\"2.3 字符集合\",\"slug\":\"_2-3-字符集合\",\"contents\":[\"[abc] 匹配包含的单个字符，也就是只有 a 或 b 或 c 这三个单字符则返回 true，可以理解为多选一\",\"[a-z]- 是连字符，用来指定字符范围，[a-z] 表示匹配 a 到 z 这26 个英文字母\",\"[^abc]^ 是取反符，[^abc] 表示匹配除了小写字母以外的字符\",\"[a-zA-Z] 表示匹配大小写字母\",\"[0-9] 表示匹配 0~9 的数字\",\". 表示匹配除换行符之外的任何单个字符\",\"<body> <script> // 元字符之范围 [] // 1. [abc] 匹配包含的单个字符， 多选1 var reg1 = /^[abc]$/ console.log(reg1.test('a')) // true console.log(reg1.test('b')) // true console.log(reg1.test('c')) // true console.log(reg1.test('d')) // false console.log(reg1.test('ab')) // false // 2. [a-z] 连字符 单个 var reg2 = /^[a-z]$/ console.log(reg2.test('a')) // true console.log(reg2.test('p')) // true console.log(reg2.test('0')) // false console.log(reg2.test('A')) // false // 想要包含小写字母，大写字母 ，数字 var reg3 = /^[a-zA-Z0-9]$/ console.log(reg3.test('B')) // true console.log(reg3.test('b')) // true console.log(reg3.test(9)) // true console.log(reg3.test(',')) // flase // 用户名可以输入英文字母，数字，可以加下划线，要求 6~16位 var reg4 = /^[a-zA-Z0-9_]{6,16}$/ console.log(reg4.test('abcd1')) // false console.log(reg4.test('abcd12')) // true console.log(reg4.test('ABcd12')) // true console.log(reg4.test('ABcd12_')) // true // 3. [^a-z] 取反符 var reg5 = /^[^a-z]$/ console.log(reg5.test('a')) // false console.log(reg5.test('A')) // true console.log(reg5.test(8)) // true </script> </body> \"]},{\"header\":\"2.4 常见模式的简写\",\"slug\":\"_2-4-常见模式的简写\",\"contents\":[\"某些常见模式的简写方式，区分字母和数字\",\"预定类\",\"说明\",\"\\\\d\",\"匹配 0~9 之间的任一数字，相当于 [0-9]\",\"\\\\D\",\"匹配一个非数字字符，相当于 [^0-9]\",\"\\\\w\",\"匹配任意的字母、数字和下划线，相当于 [A-Za-z0-9_]\",\"\\\\W\",\"匹配除所有字母、数字和下划线以外的字符，相当于 [^A-Za-z0-9_]\",\"\\\\s\",\"匹配空格（包括换行符、制表符、空格符等），相当于 [\\\\t\\\\r\\\\n\\\\v\\\\f]\",\"\\\\S\",\"匹配非空格的字符，相当于 [^\\\\t\\\\r\\\\n\\\\v\\\\f]\",\"如：日期格式：^\\\\d{4}-\\\\d{1,2}-\\\\d{1,2}\"]},{\"header\":\"3. 修饰符\",\"slug\":\"_3-修饰符\",\"contents\":[\"语法：\",\"/表达式/修饰符 \",\"i 是单词 ignore 的缩写，正则匹配时字母不区分大小写\",\"g 是单词 global 的缩写，匹配所有满足正则表达式的结果\",\"<body> <script> // 修饰符 var str = '欢迎大家学习前端，相信大家一定能学好前端，都成为前端大神' // 1. 替换 replace 需求：把前端替换为 web // 1.1 replace 返回值是替换完毕的字符串 // var strEnd = str.replace(/前端/, 'web') 只能替换一个 // 2. 修饰符 g 全部替换 var strEnd = str.replace(/前端/g, 'web') console.log(strEnd) </script> </body> \"]}]},\"/front-end/javascript-notes/25-JavaScript-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html\":{\"title\":\"JavaScript-垃圾回收机制\",\"contents\":[{\"header\":\"1. 什么是垃圾回收机制\",\"slug\":\"_1-什么是垃圾回收机制\",\"contents\":[\"垃圾回收机制（Garbage Collection）简称 GC\",\"JavaScript 中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收，如果不再用到的内存没有及时释放，则会产生内存泄漏\"]},{\"header\":\"2. 内存的生命周期\",\"slug\":\"_2-内存的生命周期\",\"contents\":[\"JavaScript 环境中分配的内存，一般有如下生命周期：\",\"内存分配：当我们声明变量、函数、对象的时候，系统会自动为它们分配内存\",\"内存使用：即读写内存，也就是使用变量、函数等\",\"内存回收：使用完毕，由垃圾回收器自动回收不再使用的内存\",\"说明：\",\"全局变量一般不会回收（关闭页面回收）\",\"一般情况下局部变量的值不用了，会被自动回收掉\"]},{\"header\":\"3. 垃圾回收算法\",\"slug\":\"_3-垃圾回收算法\",\"contents\":[]},{\"header\":\"3.1 引用计数\",\"slug\":\"_3-1-引用计数\",\"contents\":[\"定义“内存不再使用”，就是看一个对象是否有指向它的引用，没有引用了就回收对象\",\"算法：\",\"跟踪记录被引用的次数\",\"如果被引用了一次，那么就记录次数 1，多次引用会累加\",\"如果减少一个引用就减一\",\"如果引用次数是 0，则释放内存\",\"存在问题： 嵌套引用（循环引用），如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄漏\"]},{\"header\":\"3.2 标记清除法\",\"slug\":\"_3-2-标记清除法\",\"contents\":[\"现代浏览器大多使用该方法\",\"算法：标记清除法将“不再使用的对象”定义为“无法到达的对象”，就是从根部出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的，那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收\"]}]},\"/front-end/javascript-notes/26-ES6~ES13.html\":{\"title\":\"ES6~ES13\",\"contents\":[{\"header\":\"1. ES6\",\"slug\":\"_1-es6\",\"contents\":[]},{\"header\":\"1.1初识ES6\",\"slug\":\"_1-1初识es6\",\"contents\":[\"ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言\",\"1997年：ECMAScript 1.0\",\"1998年：ECMAScript 2.0\",\"1999年：ECMAScript 3.0\",\"2006年：ECMAScript 4.0 未通过\",\"2009年：ECMAScript 5.0\",\"2015年：ECMAScript 6.0\",\"至今，版本号改用年号的形式\"]},{\"header\":\"1.2 let和const关键字\",\"slug\":\"_1-2-let和const关键字\",\"contents\":[\"我们以前都是使用 var 关键字来声明变量的，在 ES6 的时候，多了两个关键字 let 和 const，也是用来声明变量的\",\"let、const与var的区别：\",\"let 和 const 不允许重复声明变量\",\"// 使用 var 的时候重复声明变量是没问题的，只不过就是后面会把前面覆盖掉 var num = 100 var num = 200 \",\"// 使用 let 重复声明变量的时候就会报错了 let num = 100 let num = 200 // 这里就会报错了 \",\"// 使用 const 重复声明变量的时候就会报错 const num = 100 const num = 200 // 这里就会报错了 \",\"let 和 const 声明的变量不会在预解析的时候解析（也就是没有变量提升）\",\"// 因为预解析（变量提升）的原因，在前面是有这个变量的，只不过没有赋值 console.log(num) // undefined var num = 100 \",\"// 因为 let 不会进行预解析（变量提升），所以直接报错了 console.log(num) // undefined let num = 100 \",\"// 因为 const 不会进行预解析（变量提升），所以直接报错了 console.log(num) // undefined const num = 100 \",\"let 和 const 声明的变量会被所有代码块限制作用范围\",\"// var 声明的变量只有函数能限制其作用域，其他的不能限制 if (true) { var num = 100 } console.log(num) // 100 \",\"// let 声明的变量，除了函数可以限制，所有的代码块都可以限制其作用域（if/while/for/...） if (true) { let num = 100 console.log(num) // 100 } console.log(num) // 报错 \",\"// const 声明的变量，除了函数可以限制，所有的代码块都可以限制其作用域（if/while/for/...） if (true) { const num = 100 console.log(num) // 100 } console.log(num) // 报错 \",\"let 和 const 的区别：\",\"let 声明的变量的值可以改变，const 声明的变量的值不可以改变\",\"let num = 100 num = 200 console.log(num) // 200 \",\"const num = 100 num = 200 // 这里就会报错了，因为 const 声明的变量值不可以改变（我们也叫做常量） \",\"let 声明的时候可以不赋值，const 声明的时候必须赋值，建议使用 const 来声明数组和对象\",\"let num num = 100 console.log(num) // 100 \",\"const num // 这里就会报错了，因为 const 声明的时候必须赋值 \"]},{\"header\":\"1.3 展开运算符\",\"slug\":\"_1-3-展开运算符\",\"contents\":[\"ES6 里面号新添加了一个运算符 ... ，叫做展开运算符\",\"作用：\",\"把数组展开，不会修改原数组\",\"let arr = [1, 2, 3, 4, 5] console.log(...arr) // 1 2 3 4 5 \",\"合并数组的时候可以使用\",\"let arr = [1, 2, 3, 4] let arr2 = [...arr, 5] console.log(arr2) \",\"也可以合并对象使用\",\"let obj = { name: 'Jack', age: 18 } let obj2 = { ...obj, gender: '男' } console.log(obj2) \",\"在函数传递参数的时候也可以使用\",\"let arr = [1, 2, 3] function fn(a, b, c) { console.log(a) console.log(b) console.log(c) } fn(...arr) // 等价于 fn(1, 2, 3) \"]},{\"header\":\"1.4 解构赋值\",\"slug\":\"_1-4-解构赋值\",\"contents\":[\"解构赋值，就是快速的从对象或者数组中取出成员的一个语法方式\"]},{\"header\":\"1.4.1 数组解构\",\"slug\":\"_1-4-1-数组解构\",\"contents\":[\"快速的从数组中获取成员\",\"// ES5 的方式从数组中获取成员 const arr = [1, 2, 3] let a = arr[0] let b = arr[1] let c = arr[2] console.log(a) // 1 console.log(b) // 2 console.log(c) // 3 \",\"// 使用解构赋值的方式从数组中获取成员 const arr = [1, 2, 3] // 前面的 [] 表示要从 arr 这个数组中获取成员了 // a b c 分别对应这数组中的索引 0 1 2 // arr 必须是一个数组 let [a, b, c] = arr console.log(a) // 1 console.log(b) // 2 console.log(c) // 3 \",\"// 数组解构的典型应用——交换两个变量的值 let a = 1 let b = 2 ;[a,b] = [b,a] console.log(a,b) //2 1 //注意： //1. 必须加分号，因为是数组开头->相当于 let b = 2[a,b] = [b,a]，所以不加分号控制台会报错 //2. 由于我们在JavaScript中习惯语句结束不加分号，而数组开头比较特别，所以这个分号主要是起到标记语句结束的作用 //3. 也可以在采取下面加分号的方式 let b = 2; \",\"//数组解构的一些特殊情况——变量多，单元值少 const [a,b,c,d] = [1,2,3] console.log(a,b,a,d) //1 2 3 undefined //为此防止有undefined传递单元值的情况，可以设置默认值 const [x=0,y=0] = [1] console.log(x) //1 console.log(y) //0 \",\"//数组解构的一些特殊情况——变量少，单元值多\\\\ const [a,b,...c] = [1,2,3,4,5] console.log(a) //1 console.log(b) //2 console.log(c) //[3,4,5] //为此可以按需导入赋值 const [x,y,,z] = [1,2,3,4] console.log(x,y,x) //1 2 4 \",\"总结：\",\"赋值运算符 = 左侧的 [] 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量\",\"变量的顺序对应数组单元值的位置依次进行赋值操作\",\"变量的数量大于单元值数量时，多余的变量将被赋值为 undefined\",\"变量的数量小于单元值数量时，可以通过 ... 获取剩余单元值，但只能置于最末位\",\"允许初始化变量的默认值，且只有单元值为 undefined 时默认值才会生效\",\"数组解构也支持多维解构赋值\"]},{\"header\":\"1.4.2 对象解构\",\"slug\":\"_1-4-2-对象解构\",\"contents\":[\"快速的从对象中获取成员\",\"// ES5 的方法获取对象中的成员 const obj = { name: 'Jack', age: 18, gender: '男' } let name = obj.name let age = obj.age let gender = obj.gender \",\"// 解构赋值的方式从对象中获取成员 const obj = { name: 'Jack', age: 18, gender: '男' } // 前面的 {} 表示我要从 obj 这个对象中获取成员了 // name age gender 都得是 obj 中有的成员 // obj 必须是一个对象 let { name, age, gender } = obj \",\"// 对象解构的一些语法注意点 // 对象解构的语法 const obj = { uname: '游戏', price: 58 } const {uname,price} = {uname: '游戏', price: 58} console.log(uname) //相当于uname = obj.uname console.log(price) //相当于price = obj.price // 解构的变量名必须与属性名一致 const {uname1,price1} = {uname: '游戏', price: 58} console.log(uname1) //undefined console.log(price1) //undefined // 对象解构变量名更改 旧变量名:新变量名 const {uname:game,price:money} = {uname: '游戏', price: 58} console.log(game) //游戏 console.log(money) //58 //数组对象解构 const arr = [{uname1: '游戏', price1: 58}] const [{p,n}] = [{n: '游戏', p: 58}] console.log(p) //58 console.log(n) //游戏 \",\"总结：\",\"赋值运算符 = 左侧的 {} 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量\",\"对象属性的值将被赋值给与属性名相同的变量\",\"对象中找不到与变量名一致的属性时变量值为 undefined\",\"允许初始化变量的默认值，属性不存在或单元值为 undefined 时默认值才会生效\",\"对象解构也支持多维解构赋值\"]},{\"header\":\"1.5 模版字符串\",\"slug\":\"_1-5-模版字符串\",\"contents\":[\"ES5 中我们表示字符串的时候使用 '' 或者 \\\"\\\"，在 ES6 中，我们还有一个东西可以表示字符串，就是`` （反引号）\",\"let str = `hello world` console.log(typeof str) // string \",\"反引号与单引号、双引号的区别：\",\"反引号可以换行书写\",\"// 这个单引号或者双引号不能换行，换行就会报错了 let str = 'hello world' // 下面这个就报错了 let str2 = 'hello world' \",\"let str = ` hello world ` console.log(str) // 是可以使用的 \",\"反引号可以直接在字符串里面拼接变量\",\"// ES5 需要字符串拼接变量的时候 let num = 100 let str = 'hello' + num + 'world' + num console.log(str) // hello100world100 // 直接写在字符串里面不好使 let str2 = 'hellonumworldnum' console.log(str2) // hellonumworldnum \",\"// 模版字符串拼接变量 let num = 100 let str = `hello${num}world${num}` console.log(str) // hello100world100 \",\"里面的 ${} 就是用来书写变量的位置\"]},{\"header\":\"1.6字符串扩展\",\"slug\":\"_1-6字符串扩展\",\"contents\":[]},{\"header\":\"1.6.1 includes函数\",\"slug\":\"_1-6-1-includes函数\",\"contents\":[\"判断字符串中是否存在指定字符\",\"let myname = \\\"kerwin\\\" console.log(myname.includes(\\\"e\\\")) //true console.log(myname.includes(\\\"ker\\\")) //true console.log(myname.includes(\\\"en\\\")) //false \",\"可以传入第二个参数，表示按索引值位置开始查找\",\"let myname = \\\"kerwin\\\" console.log(myname.includes(\\\"e\\\",1)) //true console.log(myname.includes(\\\"e\\\",3)) //false \"]},{\"header\":\"1.6.2 startsWith函数\",\"slug\":\"_1-6-2-startswith函数\",\"contents\":[\"判断字符串是否以某字符开头\",\"let myname = \\\"kerwin\\\" console.log(myname.startsWith(\\\"k\\\")) //true console.log(myname.startsWith(\\\"ker\\\")) //true console.log(myname.startsWith(\\\"er\\\")) //false \",\"可以传入第二个参数，表示按索引值位置开始查找\",\"let myname = \\\"kerwin\\\" console.log(myname.startsWith(\\\"k\\\",0)) //true console.log(myname.startsWith(\\\"k\\\",2)) //false \"]},{\"header\":\"1.6.3 endsWith函数\",\"slug\":\"_1-6-3-endswith函数\",\"contents\":[\"判断字符串是否以某字符结束\",\"let myname = \\\"kerwin\\\" console.log(myname.endsWith(\\\"n\\\")) //true console.log(myname.endsWith(\\\"in\\\")) //true console.log(myname.endsWith(\\\"k\\\")) //false \",\"可以传入第二个参数，表示按索引值位置开始往前查找\",\"let myname = \\\"kerwin\\\" console.log(myname.startsWith(\\\"n\\\",1)) //false console.log(myname.startsWith(\\\"n\\\",5)) //true \"]},{\"header\":\"1.6.4 repeat函数\",\"slug\":\"_1-6-4-repeat函数\",\"contents\":[\"repeat()方法返回一个新字符串,表示将原字符串重复n次\",\"let myname = \\\"kerwin\\\" console.log(myname.repeat(3)) //kerwinkerwinkerwin console.log(myname.repeat(0)) //\\\"\\\" console.log(myname.repeat(3.5)) //kerwinkerwinkerwin console.log(myname.repeat(\\\"3\\\"))//kerwinkerwinkerwin \"]},{\"header\":\"1.7 数值扩展\",\"slug\":\"_1-7-数值扩展\",\"contents\":[]},{\"header\":\"1.7.1 进制表示法\",\"slug\":\"_1-7-1-进制表示法\",\"contents\":[\"//十进制 let count1 = 100 //十六进制 let count2 = 0x100 //八进制 let count3 = 0o100 //二进制 let count4 = 0b100 \"]},{\"header\":\"1.7.2 isFinite与isNaN方法\",\"slug\":\"_1-7-2-isfinite与isnan方法\",\"contents\":[\"减少全局性方法，使得语言逐步模块化\",\"let num1 = Number.isFinite(100) console.log(num1) //true let num2 = Number.isFinite(100/0) console.log(num2) //false let num3 = Number.isFinite(Infinity) console.log(num3) // false let num4 = Number.isFinite(\\\"100\\\") console.log(num4) //false \",\"let num1 = Number.isNaN(100) console.log(num1) // false let num2 = Number.isNaN(NaN) console.log(num2) //true let num3 = Number.isNaN(\\\"kerwin\\\") console.log(num3) //false let num4 = Number.isNaN(\\\"100\\\") console.log(num4) // false \",\"它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false\"]},{\"header\":\"1.7.3 isInteger方法\",\"slug\":\"_1-7-3-isinteger方法\",\"contents\":[\"用来判断一个数值是否为整数\",\"let num1 = Number.isInteger(100) console.log(num1) //true let num2 = Number.isInteger(100.0) console.log(num2) //true let num3 = Number.isInteger(\\\"kerwin\\\") console.log(num3) //false let num4 = Number.isInteger(\\\"100\\\") console.log(num4) //false let num5 = Number.isInteger(100.1) console.log(num5) //false \"]},{\"header\":\"1.7.4 极小常量Number.EPSILON\",\"slug\":\"_1-7-4-极小常量number-epsilon\",\"contents\":[\"它表示 1 与大于 1 的最小浮点数之间的差。2.220446049250313e-16\",\"function isEqual(a,b){ return Math.abs(a-b)<Number.EPSILON } console.log(isEqual(0.1+0.2,0.3)) //true console.log(0.1+0.2===0.3) //false \"]},{\"header\":\"1.7.5 Math.trunc\",\"slug\":\"_1-7-5-math-trunc\",\"contents\":[\"将小数部分抹掉,返回一个整数\",\"console.log(Math.trunc(1.2)) //1 console.log(Math.trunc(1.8))// 1 console.log(Math.trunc(-1.8)) //-1 console.log(Math.trunc(-1.2))//-1 \"]},{\"header\":\"1.7.6 Math.sign\",\"slug\":\"_1-7-6-math-sign\",\"contents\":[\"Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值\",\"Math.sign(-100) // -1 Math.sign(100) // +1 Math.sign(0) // +0 Math.sign(-0) // -0 Math.sign(\\\"kerwin\\\") // NaN \"]},{\"header\":\"1.8 数组扩展\",\"slug\":\"_1-8-数组扩展\",\"contents\":[]},{\"header\":\"1.8.1 Array.from\",\"slug\":\"_1-8-1-array-from\",\"contents\":[\"将类数组对象转换为真正数组\",\"function test(){ console.log(Array.from(arguments)) } test(1,2,3) // [1,2,3] \"]},{\"header\":\"1.8.2 Array.of\",\"slug\":\"_1-8-2-array-of\",\"contents\":[\"将一组值转化为数组，即新建数组\",\"let arr1 = Array(3) console.log(arr1)// [,,] let arr2 = Array.of(3) console.log(arr2)// [3] \"]},{\"header\":\"1.8.3 find方法\",\"slug\":\"_1-8-3-find方法\",\"contents\":[\"该方法主要应用于查找第一个符合条件的数组元素\",\"它的参数是一个回调函数。在回调函数中可以写你要查找元素的条件，当条件成立为true时，返回该元素；如果没有符合条件的元素，返回值为undefined\",\"let arr = [11,12,13,14,15] let res1 = arr.find(function(item){ return item>13 }) let res2 = arr.findIndex(function(item){ return item>13 }) console.log(res1) //14 console.log(res2) //3 //findLast() findLastIndex() ES2022 let arr2 = [11,12,13,14,15] let res3 = arr.findLast(function(item){ return item>13 }) let res4 = arr.findLastIndex(function(item){ return item>13 }) console.log(res3) //15 console.log(res4) //4 \"]},{\"header\":\"1.8.4 fill方法\",\"slug\":\"_1-8-4-fill方法\",\"contents\":[\"使用自己想要的参数替换原数组内容，但是会改变原来的数组\",\"let arr1 = new Array(3).fill(\\\"kerwin\\\") let arr2 = ['a', 'b', 'c'].fill(\\\"kerwin\\\", 1, 2) console.log(arr1)//['kerwin', 'kerwin', 'kerwin'] console.log(arr2)// ['a', 'kerwin', 'c'] \"]},{\"header\":\"1.8.5 flat与flatMap方法\",\"slug\":\"_1-8-5-flat与flatmap方法\",\"contents\":[\"按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回\",\"let arr = [1,2,3,[4,5,6]] let arr1 = arr.flat() console.log(arr,arr1) //[1,2,3,4,5,6] var obj = [{ name: \\\"A\\\", list: [\\\"鞍山\\\", \\\"安庆\\\", \\\"安阳\\\"] }, { name: \\\"B\\\", list: [\\\"北京\\\", \\\"保定\\\", \\\"包头\\\"] } ] console.log(obj.flatMap(function(item){ return item.list }))// ['鞍山', '安庆', '安阳', '北京', '保定', '包头'] \"]},{\"header\":\"1.9 对象扩展\",\"slug\":\"_1-9-对象扩展\",\"contents\":[]},{\"header\":\"1.9.1 对象简写\",\"slug\":\"_1-9-1-对象简写\",\"contents\":[\"//原写法 let name =\\\"moduleA\\\" let obj = { name:name, test1:function(){ }, test2:function(){ } } //简写 let name =\\\"moduleA\\\" let obj = { name, test1(){ }, test2(){ } } \"]},{\"header\":\"1.9.2 属性名表达式\",\"slug\":\"_1-9-2-属性名表达式\",\"contents\":[\"let name =\\\"moduleA\\\" let obj = { name, [name+\\\"test1\\\"](){ }, [name+\\\"test2\\\"](){ } } console.log(obj) //{name: 'moduleA', moduleAtest1: ƒ, moduleAtest2: ƒ} \"]},{\"header\":\"1.9.3 Object.assign\",\"slug\":\"_1-9-3-object-assign\",\"contents\":[\"Object.assign(target, object1，object2)的第一个参数是目标对象，后面可以跟一个或多个源对象作为参数\",\"target：参数合并后存放的对象\",\"object1：参数1\",\"object2：参数2\",\"const obj = {} const obj1 = { name: \\\"kerwin\\\" } const obj2 = { name:\\\"tiechui\\\" } const obj3 = { age:100 } console.log(Object.assign(obj, obj1, obj2, obj3)) // {name: 'tiechui', age: 100} \"]},{\"header\":\"1.9.4 Object.is\",\"slug\":\"_1-9-4-object-is\",\"contents\":[\"方法判断两个值是否是相同的值\",\"// 之前存在的问题： console.log(NaN===NaN) //false console.log(+0===-0) //true //解决： console.log(Object.is(NaN,NaN)) //true console.log(Object.is(+0,-0)) //false \"]},{\"header\":\"1.10 函数扩展\",\"slug\":\"_1-10-函数扩展\",\"contents\":[]},{\"header\":\"1.10.1 箭头函数\",\"slug\":\"_1-10-1-箭头函数\",\"contents\":[\"箭头函数是 ES6 里面一个简写函数的语法方式\",\"重点： 箭头函数只能简写函数表达式，不能简写声明式函数\",\"function fn() {} // 不能简写 const fun = function () {} // 可以简写 const obj = { fn: function () {} // 可以简写 } \",\"语法： (函数的形参) => { 函数体内要执行的代码 }\",\"const fn = function (a, b) { console.log(a) console.log(b) } // 可以使用箭头函数写成 const fun = (a, b) => { console.log(a) console.log(b) } \",\"const obj = { fn: function (a, b) { console.log(a) console.log(b) } } // 可以使用箭头函数写成 const obj2 = { fn: (a, b) => { console.log(a) console.log(b) } } \"]},{\"header\":\"1.10.2 箭头函数的特殊性\",\"slug\":\"_1-10-2-箭头函数的特殊性\",\"contents\":[\"箭头函数内部没有 this，箭头函数的 this 是上下文的 this\",\"// 在箭头函数定义的位置往上数，这一行是可以打印出 this 的 // 因为这里的 this 是 window // 所以箭头函数内部的 this 就是 window const obj = { fn: function () { console.log(this) }, // 这个位置是箭头函数的上一行，但是不能打印出 this fun: () => { // 箭头函数内部的 this 是书写箭头函数的上一行一个可以打印出 this 的位置 console.log(this) } } obj.fn() obj.fun() \",\"按照我们之前的 this 指向来判断，两个都应该指向 obj，但是 fun 因为是箭头函数，所以 this 不指向 obj，而是指向 fun 的外层，就是 window\",\"箭头函数内部没有 arguments 这个参数集合\",\"const obj = { fn: function () { console.log(arguments) }, fun: () => { console.log(arguments) } } obj.fn(1, 2, 3) // 会打印一个伪数组 [1, 2, 3] obj.fun(1, 2, 3) // 会直接报错 \",\"函数的形参只有一个的时候可以不写 () 其余情况必须写\",\"const obj = { fn: () => { console.log('没有参数，必须写小括号') }, fn2: a => { console.log('一个形参，可以不写小括号') }, fn3: (a, b) => { console.log('两个或两个以上参数，必须写小括号') } } \",\"函数体只有一行代码的时候，可以不写 {} ，并且会自动 return\",\"const obj = { fn: a => { return a + 10 }, fun: a => a + 10 } console.log(fn(10)) // 20 console.log(fun(10)) // 20 \"]},{\"header\":\"1.10.3 函数参数默认值\",\"slug\":\"_1-10-3-函数参数默认值\",\"contents\":[\"我们在定义函数的时候，有的时候需要一个默认值出现，就是当我不传递参数的时候，使用默认值，传递参数了就使用传递的参数\",\"function fn(a) { a = a || 10 console.log(a) } fn() // 不传递参数的时候，函数内部的 a 就是 10 fn(20) // 传递了参数 20 的时候，函数内部的 a 就是 20 \",\"在 ES6 中我们可以直接把默认值写在函数的形参位置\",\"function fn(a = 10) { console.log(a) } fn() // 不传递参数的时候，函数内部的 a 就是 10 fn(20) // 传递了参数 20 的时候，函数内部的 a 就是 20 \",\"这个默认值的方式箭头函数也可以使用\",\"const fn = (a = 10) => { console.log(a) } fn() // 不传递参数的时候，函数内部的 a 就是 10 fn(20) // 传递了参数 20 的时候，函数内部的 a 就是 20 \",\"注意： 箭头函数如果你需要使用默认值的话，那么一个参数的时候也需要写 （）\"]},{\"header\":\"1.11 Symbol\",\"slug\":\"_1-11-symbol\",\"contents\":[\"ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它属于 JavaScript 语言的原生数据类型之一，其他数据类型是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）\",\"注意：symbol类型不能直接进行运算\",\"使用Symbol作为对象属性名\",\"let name = Symbol() // 生成了一个symbol类型数据 let age = Symbol() var obj ={ [name]:\\\"kerwin\\\", [age]:100 } console.log(obj) // {Symbol(): 'kerwin', Symbol(): 100} console.log(obj.name) // undefined console.log(obj[name]) // kerwin \",\"Symbol()函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述。这主要是为了在控制台显示，比较容易区分\",\"let name = Symbol(\\\"name\\\") let age = Symbol(\\\"age\\\") var obj ={ [name]:\\\"kerwin\\\", [age]:100 } console.log(obj) // {Symbol(name): 'kerwin', Symbol(age): 100} \",\"遍历问题\",\"// 使用for in 无法遍历symbol定义的 // 使用Object.getOwnPropertySymbols 可以遍历symbol定义的 // 使用Reflect.ownKeys可以 let keys = { name:Symbol(\\\"name\\\"), age:Symbol(\\\"age\\\") } var obj ={ [keys.name]:\\\"kerwin\\\", [keys.age]:100, a:1, b:2, c:3 } Reflect.ownKeys(obj).forEach(item=>{ console.log(item,obj[item]) }) // a 1 // b 2 // c 3 // Symbol(name) 'kerwin' // Symbol(age) 100 \",\"Symbol.for()可以重新使用同一个 Symbol 值\",\"var obj ={ [Symbol.for(\\\"name\\\")]:\\\"kerwin\\\", [Symbol.for(\\\"age\\\")]:100 } console.log(obj[Symbol.for(\\\"name\\\")]) \",\"Symbol可以作为常量\",\"const VIDEO = Symbol() const AUDIO = Symbol() const IMAGE = Symbol() function play(type){ switch(type){ case VIDEO: console.log('视频播放') break case AUDIO: console.log('音频播放') break case IMAGE: console.log('图片播放') break } } play(VIDEO) // 视频播放 \"]},{\"header\":\"1.12 Iterator迭代器\",\"slug\":\"_1-12-iterator迭代器\",\"contents\":[\"Iterator 的作用有三个：\",\"为各种数据结构，提供一个统一的、简便的访问接口\",\"使得数据结构的成员能够按某种次序排列\",\"ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of循环\",\"let arr = [\\\"kerwin\\\", \\\"tiechui\\\", \\\"gangdaner\\\"] for(let i of arr){ console.log(i) // kerwin tiechui gangdaner } \",\"Iterator 的遍历过程是这样的：\",\"创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象\",\"第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员\",\"第二次调用指针对象的next方法，指针就指向数据结构的第二个成员\",\"不断调用指针对象的next方法，直到它指向数据结构的结束位置\",\"let i = arr[Symbol.iterator]() console.log(i.next()) // {value: 'kerwin', done: false} console.log(i.next()) // {value: 'tiechui', done: false} console.log(i.next()) // {value: 'gangdaner', done: false} console.log(i.next()) // {value: undefined, done: true} \",\"ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器\",\"原生默认具备 Iterator 接口的数据结构如下：\",\"Array\",\"Set\",\"Map\",\"String\",\"arguments 对象\",\"NodeList 对象\",\"如何对对象进行for of遍历？\",\"let obj = { 0: \\\"kerwin\\\", 1: \\\"tiechui\\\", 2: \\\"gangdaner\\\", length: 3, [Symbol.iterator]: Array.prototype[Symbol.iterator] } for (let i of obj) { console.log(i) } // kerwin // tiechui // gangdaner let obj2 = { data: ['kerwin', 'tiechui', \\\"gangdaner\\\"], // 迭代器 [Symbol.iterator]() { // let _this = this let index = 0 return { next: () => { if (index < this.data.length) { return { value: this.data[index++], done: false } } else { return { value: undefined, done: true } } } } } } for (let i of obj2) { console.log(i) } // kerwin // tiechui // gangdaner \",\"...展开运算符会调用内置迭代器\",\"let obj2 = { data: ['kerwin', 'tiechui', \\\"gangdaner\\\"], // 迭代器 [Symbol.iterator]() { // let _this = this let index = 0 return { next: () => { if (index < this.data.length) { return { value: this.data[index++], done: false } } else { return { value: undefined, done: true } } } } } } console.log([...obj2]) // ['kerwin', 'tiechui', 'gangdaner'] \"]},{\"header\":\"1.13 Set结构\",\"slug\":\"_1-13-set结构\",\"contents\":[\"它类似于数组，但成员的值都是唯一的，没有重复的值\"]},{\"header\":\"1.13.1 初识Set\",\"slug\":\"_1-13-1-初识set\",\"contents\":[\"// 可以实现数组去重 let s1 = new Set([1, 2, 3, 2, 3]) console.log(s1) // {1,2,3} console.log([...s1]) // [1,2,3] let s2 = new Set() s2.add(1) s2.add(2) s2.add(3) console.log(s2) // {1, 2, 3} \"]},{\"header\":\"1.13.2 实例的属性和方法\",\"slug\":\"_1-13-2-实例的属性和方法\",\"contents\":[\"size：返回Set实例的成员总数\",\"Set.prototype.add(value)：添加某个value\",\"Set.prototype.delete(value)：删除某个value，返回一个布尔值，表示删除是否成功\",\"Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员\",\"Set.prototype.clear()：清除所有成员，没有返回值\",\"let s1 = new Set([1, 2, 3, 2, 3]) console.log(s1.size) // 3 s1.add(4).add(5).add(6) console.log(s1) // {1, 2, 3, 4, 5, 6} console.log(s1.has(8)) // false console.log(s1.has(5)) //true s1.delete(5) console.log(s1) // {1, 2, 3, 4, 6} s1.clear() console.log(s1) // {size: 0} \"]},{\"header\":\"1.13.3 遍历\",\"slug\":\"_1-13-3-遍历\",\"contents\":[\"Set.prototype.keys()：返回键名的遍历器\",\"Set.prototype.values()：返回键值的遍历器\",\"Set.prototype.entries()：返回键值对的遍历器\",\"Set.prototype.forEach()：遍历每个成员\",\"let s1 = new Set([1, 2, 3, 2, 3]) for(let i of s1){ console.log(i) } // 1 // 2 // 3 for(let i of s1.keys()){ console.log(i) } // 1 // 2 // 3 for(let i of s1.values()){ console.log(i) } // 1 // 2 // 3 for(let i of s1.entries()){ console.log(i) } // [1,1] // [2,2] // [3,3] for(let [index,item] of s1.entries()){ console.log(index,item) } // 1 1 // 2 2 // 3 3 s1.forEach((item,index)=>{ console.log(item,index) }) // 1 1 // 2 2 // 3 3 \"]},{\"header\":\"1.13.4 复杂数据结构去重\",\"slug\":\"_1-13-4-复杂数据结构去重\",\"contents\":[\"function uni(arr) { let res = new Set() return arr.filter(item => { let id = JSON.stringify(item) if (res.has(id)) { return false } else { res.add(id) return true } }) } var list = [1, 2, 3, \\\"data\\\", {name: \\\"kerwin\\\"}, {name: \\\"kerwin\\\"},[1, 2],[3, 4],[3, 4]] console.log(uni(list)) //[1,2,3,\\\"data\\\",{name:\\\"kerwin\\\"},[1,2],[3,4]] \"]},{\"header\":\"1.14 Map结构\",\"slug\":\"_1-14-map结构\",\"contents\":[\"类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键\"]},{\"header\":\"1.14.1 初识Map\",\"slug\":\"_1-14-1-初识map\",\"contents\":[\"let m1 = new Map() m1.set(\\\"name\\\",\\\"kerwin\\\") m1.set({a:1},\\\"大连\\\") console.log(m1) //{\\\"name\\\" => \\\"kerwin\\\",{ {a:1}=> \\\"大连\\\"} let m2= new Map([ [\\\"name\\\",\\\"kerwin\\\"], [{a:1},\\\"大连\\\"] ]) console.log(m2) //{\\\"name\\\" => \\\"kerwin\\\",{ {a:1}=> \\\"大连\\\"} \"]},{\"header\":\"1.14.2 实例的属性和方法\",\"slug\":\"_1-14-2-实例的属性和方法\",\"contents\":[\"size：返回 Map 结构的成员总数。\",\"Map.prototype.set(key,value)：添加key对应得value，返回 Map 结构本身。\",\"Map.prototype.get(key)：获取key对应的value\",\"Map.prototype.delete(key)：删除某个键（键名+键值）\",\"Map.prototype.has(key)：某个键是否在当前 Map 对象之中\",\"Map.prototype.clear()：清除所有成员，没有返回值。\",\"let o = {a:1} let m1= new Map([ [\\\"name\\\",\\\"kerwin\\\"], [o,\\\"大连\\\"] ]) m1.set(\\\"age\\\",18) console.log(m1) // {'name' => 'kerwin', {{a:1}} => '大连', 'age' => 18} console.log(m1.size) //3 console.log(m1.get(\\\"name\\\")) // kerwin console.log(m1.get(o)) // 大连 console.log(m1.has(\\\"age\\\")) // true m1.delete(\\\"age\\\") console.log(m1.has(\\\"age\\\")) //false m1.clear() console.log(m1) // {size:0} \"]},{\"header\":\"1.14.3 遍历\",\"slug\":\"_1-14-3-遍历\",\"contents\":[\"Map.prototype.keys()：返回键名的遍历器\",\"Map.prototype.values()：返回键值的遍历器\",\"Map.prototype.entries()：返回所有成员的遍历器\",\"Map.prototype.forEach()：遍历 Map 的所有成员\",\"let o = {a:1} let m1= new Map([ [\\\"name\\\",\\\"kerwin\\\"], [o,\\\"大连\\\"] ]) m1.set(\\\"age\\\",18) console.log(m1) // {'name' => 'kerwin', {{a:1}} => '大连', 'age' => 18} for(let i of m1.keys()){ console.log(i) } // name // {a:1} // age for(let i of m1.values()){ console.log(i) } // kerwin // 大连 // 18 for(let [index,item] of m1.entries()){ console.log(index,item) } // name kerwin // {a: 1} '大连' // age 18 m1.forEach((item,index)=>{ console.log(item,index) }) // kerwin name // 大连 {a: 1} // 18 'age' \"]},{\"header\":\"1.15 Proxy代理\",\"slug\":\"_1-15-proxy代理\",\"contents\":[\"Proxy如其名， 它的作用是在对象和和对象的属性值之间设置一个代理，获取该对象的值或者设置该对象的值， 以及实例化等等多种操作， 都会被拦截住， 经过这一层我们可以统一处理，我们可以认为它就是“代理器”\",\"在没有proxy之前，我们使用Object.defineProperty()\",\"<div id=\\\"box\\\"></div> \",\"let obj = {} Object.defineProperty(obj,\\\"data\\\",{ get(){ console.log(\\\"get\\\") return box.innerHTML }, set(value){ console.log(\\\"set\\\",value) box.innerHTML = value } }) \",\"使用obj.data即可设置\",\"ES6~ES1301.gif\",\"使用proxy实现：\",\"<div id=\\\"box\\\"></div> \",\"let obj = {} let proxy = new Proxy(obj,{ get(target,key){ console.log(\\\"get\\\",target[key]) return target[key] }, set(target,key,value){ console.log(\\\"set\\\",target,key,value) if(key===\\\"data\\\"){ box.innerHTML=value } target[key]=value } }) \",\"ES6~ES1302.gif\"]},{\"header\":\"1.15.1 get方法\",\"slug\":\"_1-15-1-get方法\",\"contents\":[\"let target = {} let proxy = new Proxy(target,{ get(target,prop){ return target[prop] } }) \"]},{\"header\":\"1.15.2 set方法\",\"slug\":\"_1-15-2-set方法\",\"contents\":[\"let target = {} let proxy = new Proxy(target,{ get(target,prop){ return target[prop] }, set(target,prop,value){ if(prop===\\\"data\\\"){ box.innerHTML = value } target[prop] = value } }) \"]},{\"header\":\"1.15.3 has方法\",\"slug\":\"_1-15-3-has方法\",\"contents\":[\"let target = { _prop: \\\"内部数据\\\" } let proxy = new Proxy(target, { get(target, prop) { return target[prop] }, set(target, prop, value) { if (prop === \\\"data\\\") { box.innerHTML = value } target[prop] = value; }, has(target, key) { if (key[0] === '_') { return false; } return key in target; } }) \"]},{\"header\":\"1.15.4 this问题\",\"slug\":\"_1-15-4-this问题\",\"contents\":[\"let target = new Set() const proxy = new Proxy(target, { get(target, key) { const value = target[key] // 遇到 Function 都手动绑定一下 this if (value instanceof Function) { console.log(`访问${value}方法了`) return value.bind(target) //不能 是 call apply } return value } }) proxy.add(1) //访问function add() { [native code] }方法了 \",\"Proxy本质上属于元编程非破坏性数据劫持，在原对象的基础上进行了功能的衍生而又不影响原对象，符合松耦合高内聚的设计理念\"]},{\"header\":\"1.16 Reflect对象\",\"slug\":\"_1-16-reflect对象\",\"contents\":[\"Reflect 可以用于获取目标对象的行为，它与 Object 类似，但是更易读，为操作对象提供了一种更优雅的方式。它的方法与 Proxy 是对应的\"]},{\"header\":\"1.16.1 代替Object的某些方法\",\"slug\":\"_1-16-1-代替object的某些方法\",\"contents\":[\"const obj = { } Reflect.defineProperty(obj, 'name', { value: 'kerwin', writable: false, configurable:false }) \"]},{\"header\":\"1.16.2 修改某些Object方法返回结果\",\"slug\":\"_1-16-2-修改某些object方法返回结果\",\"contents\":[\"// 老写法 try { Object.defineProperty(target, property, attributes); // success } catch (e) { // fail } // 新写法 if (Reflect.defineProperty(target, property, attributes)) { // success } else { // fail } \"]},{\"header\":\"1.16.3 命令式变为函数行为\",\"slug\":\"_1-16-3-命令式变为函数行为\",\"contents\":[\"const obj = { name:\\\"kerwin\\\" } //老写法 console.log(\\\"name\\\" in obj) //true //新写法 console.log(Reflect.has(obj, 'name')) //true //老写法 delete obj.name //新写法 Reflect.deleteProperty(obj, \\\"name\\\") \"]},{\"header\":\"1.16.4 配合Proxy\",\"slug\":\"_1-16-4-配合proxy\",\"contents\":[\"let target = new Set() const proxy = new Proxy(target, { get(target, key) { const value = Reflect.get(target,key) // 遇到 Function 都手动绑定一下 this if (value instanceof Function) { console.log(`访问${value}方法了`) return value.bind(target) //不能 是 call apply } return value }, set() { return Reflect.set(...arguments) } }) proxy.add(1) \",\"let arr = [1, 2, 3] let proxy = new Proxy(arr, { get(target, key) { console.log('get', key) return Reflect.get(...arguments) }, set(target, key, value) { console.log('set', key, value) return Reflect.set(...arguments) } }) proxy.push(4) // 能够打印出很多内容 // get push (寻找 proxy.push 方法) // get length (获取当前的 length) // set 3 4 (设置 proxy[3] = 4) // set length 4 (设置 proxy.length = 4) \"]},{\"header\":\"1.17 Promise\",\"slug\":\"_1-17-promise\",\"contents\":[\"Promise 是异步编程的一种解决方案，比传统的解决方案回调函数, 更合理和更强大。ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象\",\"详见Promise篇\"]},{\"header\":\"1.18 Generator函数\",\"slug\":\"_1-18-generator函数\",\"contents\":[\"Generator 函数是 ES6 提供的一种异步编程解决方案\",\"Generator 函数是一个状态机，封装了多个内部状态\",\"执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态\"]},{\"header\":\"1.18.1 基本语法\",\"slug\":\"_1-18-1-基本语法\",\"contents\":[\"function *gen(){ console.log(1) yield // 产出 console.log(2) yield // 产出 console.log(3) } let g = gen() g.next() g.next() g.next() // 1 // 2 // 3 \",\"yield(产出)表达式是暂停执行的标记，而next方法可以恢复执行\",\"function *gen(){ yield 1 yield 2 } let g = gen() let res1 = g.next() console.log(res1) let res2 = g.next() console.log(res2) let res3 = g.next() console.log(res3) // {value:'a',done:false} // {value:'b',done:false} // {value:undefined,done:true} \",\"function *gen(){ let res1 = yield console.log(\\\"gen内部\\\",res1) let res2 = yield console.log(\\\"gen内部\\\",res2) } let g = gen() g.next(\\\"data-1\\\") g.next(\\\"data-2\\\") g.next(\\\"data-3\\\") // gen内部 data-2 // gen内部 data-3 \"]},{\"header\":\"1.18.2 异步流程\",\"slug\":\"_1-18-2-异步流程\",\"contents\":[\"手动版本\",\"function *gen(){ let res1 = yield ajax(\\\"1.json\\\") console.log(res1) let res2 = yield ajax(\\\"2.json\\\",res1) console.log(res2) } let g = gen() g.next().value.then(data=>{ g.next(data).value.then(data=>{ g.next(data) }) }) \",\"自动版本\",\"function* gen() { let res1 = yield ajax(\\\"1.json\\\") console.log(res1) let res2 = yield ajax(\\\"2.json\\\") console.log(res2) } function AutoRun(gen) { let g = gen() function next(data) { let res = g.next(data) if (res.done) return res.value.then(function (data) { next(data) }) } next() } AutoRun(gen) \"]},{\"header\":\"1.19 Class语法\",\"slug\":\"_1-19-class语法\",\"contents\":[]},{\"header\":\"1.19.1 类的写法\",\"slug\":\"_1-19-1-类的写法\",\"contents\":[\"class Person { constructor(name,age){ this.name = name this.age = age } say(){ console.log(this.name,this.age) } } let obj = new Person(\\\"kerwin\\\",100) console.log(obj) //{name:\\\"kerwin\\\",age:100} \"]},{\"header\":\"1.19.2 getter与setter\",\"slug\":\"_1-19-2-getter与setter\",\"contents\":[\"<ul id=\\\"list\\\"></ul> \",\"class List{ constructor(ele){ this.element = ele } get html(){ return this.element.innerHTML } set html(arr){ this.element.innerHTML = arr.map(item=>`<li>${item}</li>`).join(\\\"\\\") } } let obj = new List(document.querySelector(\\\"#list\\\")) obj.html = [\\\"aaa\\\",\\\"bbb\\\",\\\"cccc\\\"] \",\"结果：\",\"aaa bbb ccc \"]},{\"header\":\"1.19.3 静态属性和静态方法\",\"slug\":\"_1-19-3-静态属性和静态方法\",\"contents\":[\"class Person { static name = \\\"Person这个类\\\" constructor(name,age){ this.name = name; this.age = age; } say(){ console.log(this.name,this.age) } static eat(){ console.log(\\\"eat\\\") } } let obj = new Person(\\\"kerwin\\\",100) console.log(Person.name) Person.eat() // Person这个类 // eat \"]},{\"header\":\"1.19.4 继承\",\"slug\":\"_1-19-4-继承\",\"contents\":[\"ES6 规定，子类必须在constructor()方法中调用super()，否则就会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，添加子类自己的实例属性和方法。如果不调用super()方法，子类就得不到自己的this对象\",\"class Person { static name = \\\"Person这个类\\\" constructor(name,age){ this.name = name this.age = age } say(){ console.log(this.name,this.age) } static eat(){ console.log(\\\"eat\\\") } } class Student extends Person{ constructor(name,age,score){ super(name,age) this.score = score } say(){ super.say() console.log(this.score) } static eat(){ super.eat() console.log(\\\"student eat\\\") } } let obj = new Student(\\\"kerwin\\\",100,200) console.log(obj) obj.say() Student.eat() // Student // kerwin 100 // 200 // eat // student eat \"]},{\"header\":\"1.20 模块化\",\"slug\":\"_1-20-模块化\",\"contents\":[\"JavaScript 现在有两种模块。一种是 ES6 模块，简称 ESM；另一种是 CommonJS 模块，简称 CJS\",\"CommonJS 模块是 Node.js 专用的，与 ES6 模块不兼容。语法上面，两者最明显的差异是，CommonJS 模块使用require()和module.exports，ES6 模块使用import和export\",\"ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入\",\"先看一个问题：\",\"1.js\",\"const odiv = document.querySelector(\\\"div\\\") console.log(odiv) \",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Document</title> <script src=\\\"1.js\\\"></script> </head> <body> <div></div> </body> </html> \",\"输出结果为null\",\"在没有模块化以前，可以使用如下方式解决：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Document</title> <script src=\\\"1.js\\\" defer></script> <!-- <script src=\\\"1.js\\\" async></script> --> </head> <body> <div></div> </body> </html> \",\"模块化方法：\",\"优点：\",\"异步加载\",\"私密不漏\",\"重名不怕\",\"依赖不乱\",\"1.js\",\"const odiv = document.querySelector(\\\"div\\\") console.log(odiv) \",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Document</title> <script src=\\\"1.js\\\" type=\\\"module\\\"></script> </head> <body> <div></div> </body> </html> \",\"可以解决异步加载问题\",\"导入和导出模块：\",\"写法1：\",\"//导出 export default A1 //导入 import a1 from \\\"./1.js\\\" \",\"例：\",\"1.js\",\"function A1() { a1() console.log('A1') } function A2() { console.log('A2') } function a1() { console.log('a1') } //导出暴露的方法 export default A1 \",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Document</title> </head> <body> <script type=\\\"module\\\"> //导入1.js中的方法，前面的A1名字可以随便起 import A1 from './1.js' console.log(A1) </script> </body> </html> \",\"写法2：\",\"export {A1,A2} import {A1,A2} from \\\"./1.js\\\" import {A1 as a1,A2 as a2} from \\\"./1.js\\\" //可以改名 import * as obj from \\\"./1.js\\\" //全部导入并且名为obj \",\"例：\",\"1.js\",\"function A1() { a1() console.log('A1') } function A2() { console.log('A2') } function a1() { console.log('a1') } //导出暴露的方法 export { A1, A2 } // export default { A1, A2 } \",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Document</title> </head> <body> <script type=\\\"module\\\"> //导入1.js中的方法 import { A1, A2 } from './1.js' // import obj from './1.js' console.log(A1) console.log(A2) // console.log(obj.A1) // console.log(obj.A2) </script> </body> </html> \",\"//还可以直接暴露函数 export function A1(){ console.log(\\\"A1\\\") } export function A2(){ console.log(\\\"A2\\\") } import {A1,A2} from \\\"./1.js\\\" import {A1 as a1,A2 as a2} from \\\"./1.js\\\" import * as obj from \\\"./1.js\\\" \",\"混合写法：\",\"export {A1} export default A2 import A2,{A1} from \\\"./1.js\\\" \"]},{\"header\":\"2. ES7\",\"slug\":\"_2-es7\",\"contents\":[]},{\"header\":\"2.1 求幂运算符\",\"slug\":\"_2-1-求幂运算符\",\"contents\":[\"Math.pow(3, 2) === 3 ** 2 // 9 \"]},{\"header\":\"2.2 数组的includes方法\",\"slug\":\"_2-2-数组的includes方法\",\"contents\":[\"[1, 2, NaN].includes(NaN) // true [1, 2, NaN].indexOf(NaN) // -1 \",\"如果仅仅查找数据是否在数组中，建议使用includes，如果是查找数据的索引位置，建议使用indexOf更好一些\"]},{\"header\":\"3. ES8\",\"slug\":\"_3-es8\",\"contents\":[]},{\"header\":\"3.1 async和await\",\"slug\":\"_3-1-async和await\",\"contents\":[\"详见Promise篇\"]},{\"header\":\"3.2 对象方法扩展\",\"slug\":\"_3-2-对象方法扩展\",\"contents\":[\"let obj = { name:\\\"kerwin\\\", age:100 } console.log(Object.values(obj)) // ['kerwin', 100] \",\"let obj = { name:\\\"kerwin\\\", age:100 } console.log(Object.entries(obj)) // [['name','kerwin'],['age',100]] \",\"let obj = { name:\\\"kerwin\\\", age:100 } console.log(Object.getOwnPropertyDescriptors(obj)) // {name:{...},age{...}} \",\"克隆对象\",\"let obj1 = { name:\\\"Kerwin\\\", age:100, location:{ provice:\\\"辽宁\\\", city:\\\"大连\\\" }, //只设置city，防止破坏province get city(){ return this.location.city }, set city(value){ this.location.city = value }, set nameset(value){ this.name = value.substring(0,1).toUpperCase()+value.substring(1) }, get nameset(){ return this.name } } console.log(Object.getOwnPropertyDescriptors(obj1)) var obj2= {} //Object.assign(obj2,obj1)//无法克隆 get set方法 Object.defineProperties(obj2,Object.getOwnPropertyDescriptors(obj1)) \"]},{\"header\":\"3.3 字符串填充\",\"slug\":\"_3-3-字符串填充\",\"contents\":[\"padStart()、padEnd()方法可以使得字符串达到固定长度，有两个参数，字符串目标长度和填充内容\",\"let str= \\\"kerwin\\\" console.log(str.padStart(10,\\\"x\\\"));//xxxxkerwin console.log(str.padEnd(10,\\\"x\\\"));//kerwinxxxx console.log(str.padStart(5,\\\"x\\\"))//kerwin console.log(str.padEnd(5,\\\"x\\\"))//kerwin \"]},{\"header\":\"3.4 函数参数的末尾加逗号\",\"slug\":\"_3-4-函数参数的末尾加逗号\",\"contents\":[\"function test( a, b, c, ){ console.log(a,b) } test( 1, 2, 3, ) \",\"『末尾逗号』在添加新的参数、属性、元素时是有用的，你可以直接新加一行而不必给上一行再补充一个逗号，这样使版本控制工具的修改记录也更加整洁\"]},{\"header\":\"4. ES9\",\"slug\":\"_4-es9\",\"contents\":[]},{\"header\":\"4.1 对象的剩余参数与扩展运算符\",\"slug\":\"_4-1-对象的剩余参数与扩展运算符\",\"contents\":[]},{\"header\":\"4.1.1 对象的剩余参数\",\"slug\":\"_4-1-1-对象的剩余参数\",\"contents\":[\"let obj = { name:\\\"kerwin\\\", age:100, location:\\\"dalian\\\" } let {name,...other} = obj console.log(name) //kerwin console.log(other) //{age: 100, location: 'dalian'} \"]},{\"header\":\"4.1.2 对象的扩展运算符\",\"slug\":\"_4-1-2-对象的扩展运算符\",\"contents\":[\"let obj1 = { name:\\\"kerwin\\\" } let obj2 = { age:100 } console.log({...obj1,...obj2}) // {name: 'kerwin', age: 100} \"]},{\"header\":\"4.2 正则表达式命名捕获组\",\"slug\":\"_4-2-正则表达式命名捕获组\",\"contents\":[\"JS正则表达式可以返回一个匹配的对象, 一个包含匹配字符串的类数组, 比如: 以 YYYY-MM-DD的格式解析日期，这样的代码可读性很差, 并且在改变正则表达式的结构的时候很有可能就会改变匹配对象的索引\",\"ES9允许使用命名捕获?<name>, 在打开捕获括号后立即命名\",\"let str = \\\"今天是2022-10-10\\\" let reg = /([0-9]{4})-([0-9]{2})-([0-9]{2})/g let res1 = reg.exec(str) console.log(res1) // ['2022-10-10', '2022', '10', '10', index: 3, input: '今天是2022-10-10', groups: undefined] \",\"let str = \\\"今天是2022-10-10\\\" let reg = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/g let res1 = reg.exec(str) console.log(res1) // ['2022-10-10', '2022', '10', '10', index: 3, input: '今天是2022-10-10', groups: {year: '2022', month: '10', day: '10'}] \"]},{\"header\":\"4.3 Promise.finally()\",\"slug\":\"_4-3-promise-finally\",\"contents\":[\"无论是成功还是失败，都运行同样的代码，比如隐藏对话框，关闭数据连接\",\"function ajax(){ return new Promise((resolve,reject)=>{ reject(1111) }) } //showloading ajax().then(res=>{ }).catch(err=>{ }).finally(()=>{ //hideloading console.log(\\\"finally\\\") }) \"]},{\"header\":\"4.4 异步遍历器\",\"slug\":\"_4-4-异步遍历器\",\"contents\":[]},{\"header\":\"4.4.1 同步遍历器的问题\",\"slug\":\"_4-4-1-同步遍历器的问题\",\"contents\":[\"function* fn() { yield 1111 yield 2222 } const syncI = fn(); console.log(syncI.next()) console.log(syncI.next()) console.log(syncI.next()) // {value: 1111, done: false} // {value: 2222, done: false} // {value: undefined, done: true} \",\"function* fn() { yield new Promise(resolve=>resolve(\\\"1111\\\")) yield new Promise(resolve=>resolve(\\\"2222\\\")) } const syncI = fn(); syncI.next().value.then(res=>{console.log(res)}) syncI.next().value.then(res=>{console.log(res)}) // 1111 // 2222 \",\"value属性的返回值是一个 Promise 对象，用来放置异步操作。但是这样写很麻烦，不太符合直觉，语义也比较绕\"]},{\"header\":\"4.4.2 异步遍历器生成函数\",\"slug\":\"_4-4-2-异步遍历器生成函数\",\"contents\":[\"Generator 函数返回一个同步遍历器，异步 Generator 函数的作用，是返回一个异步遍历器对象。在语法上，异步 Generator 函数就是 async 函数与 Generator 函数的结合\",\"async function* fn() { yield new Promise(resolve=>resolve(\\\"1111\\\")) yield new Promise(resolve=>resolve(\\\"2222\\\")) } const asyncI = fn(); asyncI.next().then(res=>{ console.log(res) return asyncI.next() }).then(res=>{ console.log(res) return asyncI.next() }).then(res=>{ console.log(res) }) // {value: '1111', done: false} // {value: '2222', done: false} // {value: undefined, done: true} \"]},{\"header\":\"4.4.3 for await of\",\"slug\":\"_4-4-3-for-await-of\",\"contents\":[\"for...of循环用于遍历同步的 Iterator 接口。新引入的for await...of循环，则是用于遍历异步的 Iterator 接口\",\"async function test() { for await (let i of asyncI) { console.log(i) } } test() \"]},{\"header\":\"4.4.4 案例改造\",\"slug\":\"_4-4-4-案例改造\",\"contents\":[\"function timer(t) { return new Promise(resolve => { setTimeout(() => { resolve(t) }, t) }) } async function* fn() { yield timer(1000)//任务1 yield timer(2000)//任务2 yield timer(3000)//任务3 } // 使用一下 for await ...of async function fn1() { for await(const val of fn()) { console.log(\\\"start\\\",Date.now()) console.log(val) console.log(\\\"end\\\",Date.now()) } } fn1() \"]},{\"header\":\"5. ES10\",\"slug\":\"_5-es10\",\"contents\":[]},{\"header\":\"5.1 Object.fromEntries\",\"slug\":\"_5-1-object-fromentries\",\"contents\":[\"Object.fromEntries()方法允许你轻松地将键值对列表转换为对象\",\"const arr = [[\\\"name\\\", \\\"kerwin\\\"], [\\\"age\\\", 100]] console.log(Object.fromEntries(arr))//{name: 'kerwin', age: 100} const m = new Map() m.set(\\\"name\\\",\\\"tiechui\\\") m.set(\\\"age\\\",18) console.log(Object.fromEntries(m))//{name: 'tiechui', age: 18} \",\"用处\",\"let str =\\\"name=kerwin&age=100\\\" let searchParams = new URLSearchParams(str) console.log(Object.fromEntries(searchParams))//{name: 'kerwin', age: '100'} \"]},{\"header\":\"5.2 trimStart()andtrimEnd()\",\"slug\":\"_5-2-trimstart-andtrimend\",\"contents\":[\"trimStart()和trimEnd()方法在实现与trimLeft()和trimRight()相同\",\"let str = \\\" kerwin \\\" console.log(\\\"|\\\"+str.trimStart(str)+\\\"|\\\") // |kerwin | console.log(\\\"|\\\"+str.trimEnd(str)+\\\"|\\\") // | kerwin| console.log(\\\"|\\\"+str.trimLeft(str)+\\\"|\\\") // |kerwin | console.log(\\\"|\\\"+str.trimRight(str)+\\\"|\\\") // | kerwin| \"]},{\"header\":\"5.3 Symbol对象的description属性\",\"slug\":\"_5-3-symbol对象的description属性\",\"contents\":[\"为Symbol对象添加了只读属性description，该对象返回包含Symbol描述的字符串\",\"let s = Symbol(\\\"kerwin\\\") console.log(s.description) //kerwin \"]},{\"header\":\"5.4 可选的catch\",\"slug\":\"_5-4-可选的catch\",\"contents\":[\"let pro1 = new Promise(function (resolve, reject) { //执行器函数 setTimeout(() => { resolve(\\\"成功的结果\\\") }, 30000) }) let pro2 = new Promise(function (resolve, reject) { //执行器函数 setTimeout(() => { reject() }, 2000) }) async function test() { try { await Promise.race([pro1, pro2]) } catch { console.log(\\\"不关心错误结果，网络超时\\\") } } test() \"]},{\"header\":\"6. ES11\",\"slug\":\"_6-es11\",\"contents\":[]},{\"header\":\"6.1 Promise.allSettled\",\"slug\":\"_6-1-promise-allsettled\",\"contents\":[\"Promise.allSettled() 方法返回一个在所有给定的 promise 都已经 fulfilled 或 rejected 后的 promise ，并带有一个对象数组，每个对象表示对应的 promise 结果\",\"const promises = [ ajax('/200接口'), ajax('/401接口') ]; Promise.allSettled(promises).then(results=>{ // 过滤出成功的请求 results.filter(item =>item.status === 'fulfilled'); 过滤出失败的请求 results.filter(item=> item.status === 'rejected'); }) \"]},{\"header\":\"6.2 module新增\",\"slug\":\"_6-2-module新增\",\"contents\":[]},{\"header\":\"6.2.1 动态导入import()\",\"slug\":\"_6-2-1-动态导入import\",\"contents\":[\"标准用法的 import 导入的模块是静态的，会使所有被导入的模块，在加载时就被编译（无法做到按需编译，降低首页加载速度）。有些场景中，你可能希望根据条件导入模块或者按需导入模块，这时你可以使用动态导入代替静态导入\",\"例：\",\"<body> <button>login</button> <script type=\\\"module\\\"> let role1 = \\\"管理员\\\" let role2 = \\\"普通用户\\\" function login(){ return \\\"普通用户\\\" } async function render(role){ if(role===role1){ let res1 = await import(\\\"./1.js\\\") console.log(res1.default) }else{ let res2 = await import(\\\"./2.js\\\") console.log(res2.default) } } let obtn = document.querySelector(\\\"button\\\") obtn.onclick = function(){ let role = login() render(role) } </script> </body> \"]},{\"header\":\"6.2.2 import.meta\",\"slug\":\"_6-2-2-import-meta\",\"contents\":[\"import.meta 会返回一个对象，有一个 url 属性，返回当前模块的url路径，只能在模块内部使用\",\"<script type=\\\"module\\\"> import obj from './1.js' </script> //1.js console.log(import.meta) export default { } \"]},{\"header\":\"6.2.3 export * as obj from 'module'\",\"slug\":\"_6-2-3-export-as-obj-from-module\",\"contents\":[\"//1.js export default { name:'111111' } export function test1(){ } //2.js export default { name:\\\"22222\\\" } export function test2(){ } export * as obj1 from './1.js' //把1.js注入到2.js //html <script type=\\\"module\\\"> import * as obj from './2.js' console.log(obj) </script> \"]},{\"header\":\"6.3 字符串的matchAll方法\",\"slug\":\"_6-3-字符串的matchall方法\",\"contents\":[\"matchAll() 方法返回一个包含所有匹配正则表达式的结果的迭代器。可以使用 for...of 遍历，或者使用展开运算符... 或者 Array.from 转换为数组\",\"例：\",\"let str = ` <ul> <li>1111</li> <li>2222</li> <li>3333</li> <li>4444</li> </ul> ` let reg = /<li>(.*)<\\\\/li>/g console.log(str.match(reg)) //'<li>1111</li>', '<li>2222</li>', '<li>3333</li>', '<li>4444</li>' \",\"let str = ` <ul> <li>1111</li> <li>2222</li> <li>3333</li> <li>4444</li> </ul> ` let reg = /<li>(.*)<\\\\/li>/g let match = null while(match = reg.exec(str)){ console.log(match[0]) console.log(match[1]) } // <li>1111</li> // 1111 // <li>2222</li> // 2222 // <li>3333</li> // 3333 // <li>4444</li> // 4444 \",\"let str = ` <ul> <li>1111</li> <li>2222</li> <li>3333</li> <li>4444</li> </ul> ` let reg = /<li>(.*)<\\\\/li>/g for(let i of str.matchAll(reg)){ console.log(i) } \"]},{\"header\":\"6.4 BigInt\",\"slug\":\"_6-4-bigint\",\"contents\":[\"JavaScript 能够准确表示的整数范围在-253到253之间（不含两个端点），超过这个范围，无法精确表示这个值，这使得 JavaScript 不适合进行科学和金融方面的精确计算\",\"9007199254740992 //9007199254740992 9007199254740993 //9007199254740992 Math.pow(2,53) === Math.pow(2,53)+1 //true \",\"为了与 Number 类型区别，BigInt 类型的数据必须添加后缀n\",\"1234 // 普通整数 1234n // BigInt // BigInt 的运算 1n + 2n // 3n \",\"// BigInt函数 console.log(BigInt(2)) //2n console.log(BigInt(2**53)+BigInt(1)) // 9007199254740993n \"]},{\"header\":\"6.5 globalThis\",\"slug\":\"_6-5-globalthis\",\"contents\":[\"globalThis 提供了一个标准的方式来获取不同环境下的全局 this 对象（也就是全局对象自身）。不像window或者self这些属性，它确保可以在有无窗口的各种环境下正常工作。所以，你可以安心的使用 globalThis，不必担心它的运行环境。为便于记忆，你只需要记住，全局作用域中的 this 就是globalThis\",\"例：es6-shim库\",\"//es6-shim var getGlobal = function () { // the only reliable means to get the global object is // Function('return this')() // However, this causes CSP violations in Chrome apps. if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } throw new Error('unable to locate global object'); }; var globals = getGlobal(); if (!globals.Reflect) { defineProperty(globals, ‘Reflect’, {}, true); } \",\"//以前 var getGlobal = function () { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } throw new Error('unable to locate global object'); }; let globals = getGlobal() if (globals.document) { console.log(\\\"进行dom操作相关\\\") } else { console.log(\\\"不能进行dom操作\\\") } //现在 if (globalThis.document) { console.log(\\\"进行dom操作相关\\\") } else { console.log(\\\"不能进行dom操作\\\") } \"]},{\"header\":\"6.6 空值合并运算符\",\"slug\":\"_6-6-空值合并运算符\",\"contents\":[\"空值合并运算符??是一个逻辑运算符。当左侧操作数为 null 或 undefined 时，其返回右侧的操作数。否则返回左侧的操作数\",\"let obj = { name:\\\"kerwin\\\", introduction:0 } console.log(obj.introduction || \\\"这个人很懒，什么也没有留下\\\") // 这个人很懒，什么也没有留下 console.log(obj.introduction ?? \\\"这个人很懒，什么也没有留下\\\") // 0 \",\"??和 || 的区别是什么呢?\",\"他们两个最大的区别就是''和0，??的左侧为''或者为0的时候，依然会返回左侧的值\",\"|| 会对左侧的数据进行boolean类型转换，所以''和0会被转换成false，返回右侧的值\"]},{\"header\":\"6.7 可选链操作符\",\"slug\":\"_6-7-可选链操作符\",\"contents\":[\"可选链前面的值如果是null或undefined，则不再执行后面的，之前返回可选链前面的值\",\"let obj = { name:\\\"kerwin\\\", introduction:0, // location:{ // city:\\\"dalian\\\" // } } //如果没有location，之前的写法 console.log(obj && obj.location && obj.location.city) //现在的写法 console.log(obj?.location?.city) \"]},{\"header\":\"7. ES12\",\"slug\":\"_7-es12\",\"contents\":[]},{\"header\":\"7.1 逻辑赋值操作符\",\"slug\":\"_7-1-逻辑赋值操作符\",\"contents\":[\"逻辑赋值操作符??=、&&=、 ||=\",\"let a = true let b = false //a &&= b //false a ||= b ; //true console.log(a) let obj = { name:\\\"kerwin\\\", introduction:0 } obj.introduction = obj.introduction??\\\"很懒\\\" obj.introduction??=\\\"很懒\\\" \"]},{\"header\":\"7.2 数字分隔符\",\"slug\":\"_7-2-数字分隔符\",\"contents\":[\"这个新特性是为了方便程序员看代码而出现的，如果数字比较大，那么看起来就不是那么一目了然\",\"const num= 123456789 \",\"分隔符不仅可以分割十进制，也可以分割二进制或者十六进制的数据，非常好用\",\"const number = 1_000_000_000_000 const binary = 0b1010_0101_1111_1101 const hex = 0xA1_B2_C3 \"]},{\"header\":\"7.3 replaceAll\",\"slug\":\"_7-3-replaceall\",\"contents\":[\"所有匹配都会被替代项替换。模式可以是字符串或正则表达式，而替换项可以是字符串或针对每次匹配执行的函数。并返回一个全新的字符串\",\"const str = \\\"I wish to wish the wish you wish to wish, but if you wish the wish the witch wishes, I won't wish the wish you wish to wish. \\\" const newStr = str.replaceAll(\\\"wish\\\", \\\"kerwin\\\") console.log(newStr) // I kerwin to kerwin the kerwin you kerwin to kerwin, but if you kerwin the kerwin the witch kerwines, I won't kerwin the kerwin you kerwin to kerwin. \"]},{\"header\":\"7.4 Promise.any\",\"slug\":\"_7-4-promise-any\",\"contents\":[\"只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态\",\"Promise.any()跟Promise.race()方法很像，只有一点不同，就是Promise.any()不会因为某个 Promise 变成rejected状态而结束，必须等到所有参数 Promise 变成rejected状态才会结束\"]},{\"header\":\"7.5 WeakRef\",\"slug\":\"_7-5-weakref\",\"contents\":[\"在一般情况下，对象的引用是强引用的，这意味着只要持有对象的引用，它就不会被垃圾回收。只有当该对象没有任何的强引用时，垃圾回收才会销毁该对象并且回收该对象所占的内存空间\",\"而 WeakRef 允许您保留对另一个对象的弱引用，而不会阻止被弱引用对象被垃圾回收\",\"let target = {} let wr = new WeakRef(target) \",\"WeakRef 实例对象有一个deref()方法，如果原始对象存在，该方法返回原始对象；如果原始对象已经被垃圾回收机制清除，该方法返回undefined\",\"let target = {} let wr = new WeakRef(target) let obj = wr.deref() if (obj) { // target 未被垃圾回收机制清除 // ... } \",\"let like = new WeakRef(document.getElementById(\\\"like\\\")) let mymap = new WeakMap() mymap.set(like.deref(), { click: 0 }) like.deref().onclick = function () { let times = mymap.get(like.deref()) times.click++ } setTimeout(() => { document.body.removeChild(like.deref()) }, 2000) \"]},{\"header\":\"7.6 FinalizationRegistry\",\"slug\":\"_7-6-finalizationregistry\",\"contents\":[\"清理器注册表功能 FinalizationRegistry，用来指定目标对象被垃圾回收机制清除以后，所要执行的回调函数\",\"首先，新建一个注册表实例\",\"const registry = new FinalizationRegistry(data => { // .... }) \",\"registry.register(obj, \\\"some value\\\") registry.unregister(obj) \",\"let like = new WeakRef(document.getElementById(\\\"like\\\")) let mymap = new WeakMap() mymap.set(like.deref(), { click: 0 }) like.deref().onclick = function () { let times = mymap.get(like.deref()) times.click++ } setTimeout(() => { // registry.register(document.getElementById(\\\"like\\\"), mymap.get(like.deref())); registry.register(like.deref(), mymap.get(like.deref())); document.body.removeChild(like.deref()) }, 2000) const registry = new FinalizationRegistry(data => { // .... console.log(\\\"被销毁了\\\", data) }) \"]},{\"header\":\"8. ES13\",\"slug\":\"_8-es13\",\"contents\":[]},{\"header\":\"8.1 私有属性和方法\",\"slug\":\"_8-1-私有属性和方法\",\"contents\":[\"class Cache{ #obj ={} get(key){ return this.#obj[key] } set(key,value){ this.#obj[key] =value } } let cache = new Cache() cache.set(\\\"name\\\",\\\"kerwin\\\") \"]},{\"header\":\"8.2 静态成员的私有属性和方法\",\"slug\":\"_8-2-静态成员的私有属性和方法\",\"contents\":[\"我们还可以给类定义静态成员和静态私有函数。类的静态方法可以使用this关键字访问其他的私有或者公有静态成员\",\" class Cache{ static #count = 0; static getCount(){ return this.#count } #obj ={} get(key){ return this.#obj[key] } set(key,value){ this.#obj[key] =value } } let cache = new Cache() cache.set(\\\"name\\\",\\\"kerwin\\\") console.log(Cache.getCount()) \"]},{\"header\":\"8.3 静态代码块\",\"slug\":\"_8-3-静态代码块\",\"contents\":[\"ES13允许在类中通过static关键字定义一系列静态代码块，这些代码块只会在类被创造的时候执行一次。这其实有点像一些其他的如C#和Java等面向对象的编程语言的静态构造函数的用法\",\"一个类可以定义任意多的静态代码块，这些代码块会和穿插在它们之间的静态成员变量一起按照定义的顺序在类初始化的时候执行一次。我们还可以使用super关键字来访问父类的属性\",\" class Cache{ static obj = new Map() static { this.obj.set(\\\"name\\\",\\\"kerwin\\\") this.obj.set(\\\"age\\\",100) } static{ console.log(this.obj) } } console.log(Cache.obj) \"]},{\"header\":\"8.4 使用in来判断某个对象是否拥有某个私有属性\",\"slug\":\"_8-4-使用in来判断某个对象是否拥有某个私有属性\",\"contents\":[\"class Cache { #obj = {} get(key) { return this.#obj[key] } set(key, value) { this.#obj[key] = value } hasObj(){ return #obj in this } } let cache = new Cache() console.log(cache.hasObj()) \"]},{\"header\":\"8.5 支持在最外层写await\",\"slug\":\"_8-5-支持在最外层写await\",\"contents\":[\"顶层await只能用在 ES6 模块，不能用在 CommonJS 模块。这是因为 CommonJS 模块的require()是同步加载，如果有顶层await，就没法处理加载了\",\"<script type=\\\"module\\\"> function ajax() { return new Promise((resolve) => { setTimeout(() => { resolve(\\\"data-1111\\\"); }, 1000); }) } let res = await ajax(); console.log(res) </script> \"]},{\"header\":\"8.6 at函数来索引元素\",\"slug\":\"_8-6-at函数来索引元素\",\"contents\":[\"let arr = [\\\"kerwin\\\",\\\"tiechui\\\",\\\"gangdan\\\",\\\"xiaoming\\\"] console.log(arr[1]) console.log(arr[arr.length-1]) console.log(arr[arr.length-2]) console.log(arr.at(1)) console.log(arr.at(-1)) console.log(arr.at(-2)) \"]},{\"header\":\"8.7 正则匹配的开始和结束索引\",\"slug\":\"_8-7-正则匹配的开始和结束索引\",\"contents\":[\"// d let str = \\\"今天是2022-11-10\\\" let reg = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/d //exec let res = reg.exec(str) console.log(res) \"]},{\"header\":\"8.8 findLast()和findLastIndex()函数\",\"slug\":\"_8-8-findlast-和findlastindex-函数\",\"contents\":[\"let arr = [11,12,13,14,15] // let res = arr.find(function(value){ // return value % 2 === 0 // }) // let res = arr.findIndex(function(value){ // return value % 2 === 0 // }) // let res = arr.findLast(function(value){ // return value % 2 === 0 // }) let res = arr.findLastIndex(function(value){ return value % 2 === 0 }) console.log(res) \"]},{\"header\":\"8.9 Error对象的Cause属性\",\"slug\":\"_8-9-error对象的cause属性\",\"contents\":[\"Error对象多了一个cause属性来指明错误出现的原因。这个属性可以帮助我们为错误添加更多的上下文信息，从而帮助使用者们更好地定位错误\",\"function getData(){ try{ console.log(kerwin) } catch(e){ throw new Error('New error 1111111',{cause:\\\"这是因为,,,,,,,,,\\\"}) } } try{ getData() }catch(e){ console.log(e.cause) } \"]}]},\"/front-end/javascript-notes/27-JavaScript-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html\":{\"title\":\"JavaScript-性能优化\",\"contents\":[{\"header\":\"1. 防抖 (debounce)\",\"slug\":\"_1-防抖-debounce\",\"contents\":[\"防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Document</title> <style> .box { width: 500px; height: 500px; background-color: #ccc; color: #fff; text-align: center; font-size: 100px; } </style> </head> <body> <div class=\\\"box\\\"></div> <script src=\\\"./lodash.min.js\\\"></script> <script> //利用防抖实现性能优化 //需求：鼠标在盒子上移动，里面的数字就会+1 const box = document.querySelector('.box') let i = 1 function mouseMove() { box.innerHTML = i++ //如果里面存在大量消耗性能的代码，比如DOM操作，比如数据处理，可能会导致卡顿 } //添加事件 //box.addEventListener('mousemove', mouseMove) //利用lodash库实现防抖 //语法：_.debounce(fun,时间) //box.addEventListener('mousemove', _.debounce(mouseMove, 500)) //手写防抖函数 //核心是利用setTimeout定时器来实现 //1.声明定时器变量 //2.每次鼠标移动（事件触发）的时候都要先判断是否有定时器，如果有，先清除以前的定时器 //3.如果没有定时器，则开启定时器，存入到定时器变量里面 //4.定时器里面写函数调用 function debounce(fn, t) { let timer //return 返回一个匿名函数 return function () { if (timer) clearTimeout(timer) timer = setTimeout(function () { fn() //加小括号调用fn函数 }, t) } } box.addEventListener('mousemove', debounce(mouseMove, 500)) </script> </body> </html> \"]},{\"header\":\"2. 节流 (throttle)\",\"slug\":\"_2-节流-throttle\",\"contents\":[\"节流，就是指连续触发事件但是在 n 秒中只执行一次函数\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Document</title> <style> .box { width: 500px; height: 500px; background-color: #ccc; color: #fff; text-align: center; font-size: 100px; } </style> </head> <body> <div class=\\\"box\\\"></div> <script src=\\\"./lodash.min.js\\\"></script> <script> //利用节流实现性能优化 //需求：鼠标在盒子上移动，里面的数字就会+1 const box = document.querySelector('.box') let i = 1 function mouseMove() { box.innerHTML = i++ } //添加事件 //box.addEventListener('mousemove', mouseMove) //利用lodash库实现节流---500毫秒之后采取+1 //语法：_.throttle(fun,时间) //box.addEventListener('mousemove', _.throttle(mouseMove, 3000)) //手写一个节流函数---每隔500ms +1 //核心是利用setTimeout定时器来实现 //1.声明定时器变量 //2.每次鼠标移动（事件触发）的时候都要先判断是否有定时器，如果有则不开启新定时器 //3.如果没有定时器，则开启定时器，存入到定时器变量里面 //4.定时器里面写函数调用，定时器里面要把定时器清空 function throttle(fn, t) { let timer = null return function () { if (!timer) { timer = setTimeout(function () { fn() //清空定时器 timer = null }, t) } } } box.addEventListener('mousemove', throttle(mouseMove, 500)) </script> </body> </html> \"]}]},\"/front-end/javascript-notes/28-JavaScript-%E6%8B%B7%E8%B4%9D.html\":{\"title\":\"JavaScript-拷贝\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"浅拷贝和深拷贝只针对引用类型\"]},{\"header\":\"1. 浅拷贝\",\"slug\":\"_1-浅拷贝\",\"contents\":[\"浅拷贝：拷贝的是地址\",\"常见方法：\",\"拷贝对象：Object.assgin() 或展开运算符 {... obj} 拷贝对象\",\"拷贝数组：Array.prototype.concat() 或 [...arr]\",\"如果是简单数据类型拷贝值，引用数据类型拷贝的是地址 (简单理解： 如果是单层对象，没问题，如果有多层就有问题)\",\"直接赋值和浅拷贝的区别：\",\"直接赋值的方法，只要是对象，都会相互影响，因为是直接拷贝对象栈里面的地址\",\"浅拷贝如果是一层对象，不相互影响，如果出现多层对象拷贝会相互影响\",\"浅拷贝的理解：拷贝对象之后，里面的属性值是简单数据类型直接拷贝值，如果属性值是引用数据类型则拷贝的是地址\"]},{\"header\":\"2. 深拷贝\",\"slug\":\"_2-深拷贝\",\"contents\":[\"深拷贝：拷贝的是对象，不是地址\",\"常见方法：\",\"通过递归实现深拷贝\",\"lodash/cloneDeep\",\"通过JSON.stringify()实现\"]},{\"header\":\"2.1 递归实现深拷贝\",\"slug\":\"_2-1-递归实现深拷贝\",\"contents\":[\"函数递归：如果一个函数在内部可以调用其本身，那么这个函数就是递归函数\",\"简单理解:函数内部自己调用自己, 这个函数就是递归函数\",\"递归函数的作用和循环效果类似\",\"由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件 return\",\"<body> <script> const obj = { uname: 'pink', age: 18, hobby: ['乒乓球', '足球'], family: { baby: '小pink' } } const o = {} // 拷贝函数 function deepCopy(newObj, oldObj) { debugger for (let k in oldObj) { // 处理数组的问题 一定先写数组 再写 对象 不能颠倒 if (oldObj[k] instanceof Array) { newObj[k] = [] // newObj[k] 接收 [] hobby // oldObj[k] ['乒乓球', '足球'] deepCopy(newObj[k], oldObj[k]) } else if (oldObj[k] instanceof Object) { newObj[k] = {} deepCopy(newObj[k], oldObj[k]) } else { // k 属性名 uname age oldObj[k] 属性值 18 // newObj[k] === o.uname 给新对象添加属性 newObj[k] = oldObj[k] } } } deepCopy(o, obj) // 函数调用 两个参数 o 新对象 obj 旧对象 console.log(o) o.age = 20 o.hobby[0] = '篮球' o.family.baby = '老pink' console.log(obj) console.log([1, 23] instanceof Object) // 复习 // const obj = { // uname: 'pink', // age: 18, // hobby: ['乒乓球', '足球'] // } // function deepCopy({ }, oldObj) { // // k 属性名 oldObj[k] 属性值 // for (let k in oldObj) { // // 处理数组的问题 k 变量 // newObj[k] = oldObj[k] // // o.uname = 'pink' // // newObj.k = 'pink' // } // } </script> </body> \"]},{\"header\":\"2.2 js库lodash里面cloneDeep内部实现了深拷贝\",\"slug\":\"_2-2-js库lodash里面clonedeep内部实现了深拷贝\",\"contents\":[\"<body> <!-- 先引用 --> <script src=\\\"./lodash.min.js\\\"></script> <script> const obj = { uname: 'pink', age: 18, hobby: ['乒乓球', '足球'], family: { baby: '小pink' } } const o = _.cloneDeep(obj) console.log(o) o.family.baby = '老pink' console.log(obj) </script> </body> \"]}]},\"/front-end/javascript-notes/29-JavaScript-%E9%97%AD%E5%8C%85.html\":{\"title\":\"JavaScript-闭包\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"概念：一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域\",\"闭包是一种比较特殊的函数，使用闭包能够访问函数作用域中的变量\",\"从代码形式上看闭包是一个做为返回值的函数，如下代码所示：\",\"<body> <script> // 1. 闭包 : 内层函数 + 外层函数变量 // function outer() { // const a = 1 // function f() { // console.log(a) // } // f() // } // outer() // 2. 闭包的应用： 实现数据的私有。统计函数的调用次数 // let count = 1 // function fn() { // count++ // console.log(`函数被调用${count}次`) // } // 3. 闭包的写法 统计函数的调用次数 function outer() { let count = 1 function fn() { count++ console.log(`函数被调用${count}次`) } return fn } const re = outer() // const re = function fn() { // count++ // console.log(`函数被调用${count}次`) // } re() re() // const fn = function() { } 函数表达式 // 4. 闭包存在的问题： 可能会造成内存泄漏 </script> </body> \",\"总结：\",\"怎么理解闭包？ \",\"闭包 = 内层函数 + 外层函数的变量\",\"闭包的作用？ \",\"封闭数据，实现数据私有，外部也可以访问函数内部的变量\",\"闭包允许将函数与其所操作的某些数据（环境）关联起来\",\"闭包可能引起的问题？ \",\"内存泄漏\"]}]},\"/front-end/javascript-notes/30-Ajax.html\":{\"title\":\"Ajax\",\"contents\":[{\"header\":\"Ajax简介\",\"slug\":\"ajax简介\",\"contents\":[\"Ajax 全称为 Asynchronous JavaScript And XML，就是异步 JS 和 XML\",\"通过 AJAX 可以在浏览器中向服务器发送异步请求，AJAX 不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式，是前后台交互的能力\",\"传统网站的问题：\",\"为了获取数据，需要重新加载，浪费资源，增加等待时间，性能不好\",\"验证表单过程中，一项内容不合格，页面需要重新加载，体验不好\",\"解决问题:\",\"使用 Ajax 可以无刷新获取数据\"]},{\"header\":\"Ajax的特点\",\"slug\":\"ajax的特点\",\"contents\":[\"Ajax 的优点：\",\"可以无需刷新页面而与服务器端进行通信\",\"允许你根据用户事件来更新部分页面内容\",\"JS 原生支持\",\"Ajax 的缺点：\",\"没有浏览历史，不能回退\",\"存在跨域问题（同源）\",\"SEO（Search Engine Optimization，搜索引擎优化）不友好，爬虫无法爬取\"]},{\"header\":\"XML简介\",\"slug\":\"xml简介\",\"contents\":[\"XML 可扩展标记语言，被设计用来传输和存储数据\",\"XML 和 HTML 类似，不同的是 HTML 中都是预定义标签，而 XML 中没有预定义标签，全都是自定义标签，用来表示一些数据\",\"比如说我有一个学生数据：name=\\\"孙悟空\\\";age=18;gender=\\\"男\\\";\",\"用 XML 表示：\",\"<student> <name>孙悟空</name> <age>18</age> <gender>男</gender> </student> \",\"现在已经被 JSON 取代了，用 JSON 表示：\",\"{\\\"name\\\":\\\"孙悟空\\\",\\\"age\\\":18,\\\"gender\\\":\\\"男\\\"} \"]},{\"header\":\"原生Ajax\",\"slug\":\"原生ajax\",\"contents\":[]},{\"header\":\"Ajax基础\",\"slug\":\"ajax基础\",\"contents\":[\"在 JS 中有内置的构造函数来创建 Ajax 对象，创建 Ajax 对象以后，我们就可以使用 Ajax 对象的方法去发送请求和接受响应\"]},{\"header\":\"创建一个Ajax对象\",\"slug\":\"创建一个ajax对象\",\"contents\":[\"// IE9及以上 const xhr = new XMLHttpRequest() // IE9以下 const xhr = new ActiveXObject('Mricosoft.XMLHTTP') \",\"上面代码就创建了一个 Ajax 对象，我们就可以使用这个 xhr 对象来发送 Ajax 请求了\"]},{\"header\":\"配置链接信息\",\"slug\":\"配置链接信息\",\"contents\":[\"const xhr = new XMLHttpRequest() // xhr 对象中的 open 方法是来配置请求信息的 // 第一个参数是本次请求的请求方式 get / post / put / ... // 第二个参数是本次请求的 url // 第三个参数是本次请求是否异步，默认 true 表示异步，false 表示同步 // xhr.open('请求方式', '请求地址', 是否异步) xhr.open('get', './data.json') \",\"上面的代码执行完毕以后，本次请求的基本配置信息就写完了\"]},{\"header\":\"发送请求\",\"slug\":\"发送请求\",\"contents\":[\"const xhr = new XMLHttpRequest() xhr.open('get', './data.json') // 使用 xhr 对象中的 send 方法来发送请求 xhr.send() \",\"上面代码是把配置好信息的 Ajax 对象发送到服务端\"]},{\"header\":\"一个基本的Ajax请求\",\"slug\":\"一个基本的ajax请求\",\"contents\":[\"一个最基本的 Ajax 请求就是上面三步，但是光有上面的三个步骤，我们确实能把请求发送的到服务端，如果服务端正常的话，响应也能回到客户端，但是我们拿不到响应，如果想拿到响应，有两个前提条件：\",\"本次 HTTP 请求是成功的，也就是 HTTP 状态码为 200 ~ 299\",\"Ajax 对象也有自己的状态码，用来表示本次 Ajax 请求中各个阶段\"]},{\"header\":\"Ajax状态码\",\"slug\":\"ajax状态码\",\"contents\":[\"Ajax 状态码 xhr.readyState，是用来表示一个 Ajax 请求的全部过程中的某一个状态：\",\"readyState === 0： 表示未初始化完成，也就是 open 方法还没有执行\",\"readyState === 1： 表示配置信息已经完成，也就是执行完 open 之后\",\"readyState === 2： 表示 send 方法已经执行完成\",\"readyState === 3： 表示正在解析响应内容\",\"readyState === 4： 表示响应内容已经解析完毕，可以在客户端使用了\",\"这个时候我们就会发现，当一个 Ajax 请求的全部过程中，只有当 readyState === 4 的时候，我们才可以正常使用服务端给我们的数据\",\"一个 Ajax 对象中有一个成员叫做 xhr.status ，这个成员就是记录本次请求的 HTTP 状态码的，两个条件都满足的时候，才是本次请求正常完成\"]},{\"header\":\"readyStateChange\",\"slug\":\"readystatechange\",\"contents\":[\"在 Ajax 对象中有一个事件，叫做 readyStateChange 事件，这个事件是专门用来监听 Ajax 对象的 readyState 值改变的的行为，也就是说只要 readyState 的值发生变化了，那么就会触发该事件，所以我们就在这个事件中来监听 Ajax 的 readyState 是不是到 4 了\",\"const xhr = new XMLHttpRequest() xhr.open('get', './data.json') xhr.send() xhr.onreadyStateChange = function () { // 每次 readyState 改变的时候都会触发该事件 // 我们就在这里判断 readyState 的值是不是到 4 // 并且 http 的状态码是不是 200 ~ 299 if (xhr.readyState === 4 && /^2\\\\d{2}$/.test(xhr.status)) { // 这里表示验证通过 // 我们就可以获取服务端给我们响应的内容了 } } \"]},{\"header\":\"responseText\",\"slug\":\"responsetext\",\"contents\":[\"Ajax 对象中的 responseText 成员就是用来记录服务端给我们的响应体内容的，所以我们就用这个成员来获取响应体的内容\",\"const xhr = new XMLHttpRequest() xhr.open('get', './data.json') xhr.send() xhr.onreadyStateChange = function () { if (xhr.readyState === 4 && /^2\\\\d{2}$/.test(xhr.status)) { // 我们在这里直接打印 xhr.responseText 来查看服务端给我们返回的内容 console.log(xhr.responseText) } } \"]},{\"header\":\"使用Ajax发送请求时携带参数\",\"slug\":\"使用ajax发送请求时携带参数\",\"contents\":[\"我们使用 Ajax 发送请求也是可以携带参数的，参数就是和后台交互的时候给他的一些信息，携带参数 get 和 post 两个方式还是有区别的\"]},{\"header\":\"发送一个带有参数的get请求\",\"slug\":\"发送一个带有参数的get请求\",\"contents\":[\"get 请求的参数就直接在 url 后面进行拼接就可以\",\"const xhr = new XMLHttpRequest() // 直接在地址后面加一个 ?，然后以 key=value 的形式传递 // 两个数据之间以 & 分割 xhr.open('get', './data.json?a=100&b=200') xhr.send() \",\"这样服务端就能接受到两个参数\",\"一个是 a，值是 100\",\"一个是 b，值是 200\"]},{\"header\":\"发送一个带有参数的post请求\",\"slug\":\"发送一个带有参数的post请求\",\"contents\":[\"post 请求的参数是携带在请求体中的，所以不需要在 url 后面拼接\",\"const xhr = new XMLHttpRequest() xhr.open('get', './data.json') // 如果是用 Ajax 对象发送 post 请求，必须要先设置一下请求头中的 content-type // 告诉一下服务端我给你的是一个什么样子的数据格式 xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded') // 请求体直接在 send 的时候写在 () 里面就行 // 不需要问号，直接就是 'key=value&key=value' 的形式 xhr.send('a=100&b=200') \",\"application/x-www-form-urlencoded 表示的数据格式就是 key=value&key=value，还可以发送 JSON 格式\"]},{\"header\":\"不同的请求方式\",\"slug\":\"不同的请求方式\",\"contents\":[\"get 偏向获取\",\"post 偏向提交\",\"put 偏向更新\",\"patch 偏向修改部分\",\"delete 偏向删除信息\",\"head 偏向获取服务器头的信息\",\"option 偏向获取服务器设备信息\",\"connnect 保留请求方式\"]},{\"header\":\"实例\",\"slug\":\"实例\",\"contents\":[\"我们可以使用 json-server 来演示，JSON-Server 是一个 Node 模块，通过在本地搭建一个 json 服务器，产生测试数据，来模拟服务器端接口数据。用于前端开发人员，在进行前后端分离开发时，后端还没有搭建好时，可以使用 json-server 模拟 REST API\",\"安装 json-server：\",\"npm install -g json-server \",\"在当前目录下创建一个 db.json 文件\",\"{ \\\"list\\\": [ \\\"111\\\", \\\"222\\\", \\\"333\\\" ], \\\"users\\\": [ { \\\"id\\\": 1, \\\"name\\\": \\\"zhf\\\" }, { \\\"id\\\": 2, \\\"name\\\": \\\"xt\\\" }, ], \\\"shopcar\\\": [], \\\"detail\\\": { \\\"name\\\": \\\"手机\\\" } } \",\"在当前目录下打开终端环境，键入：json-server db.json --watch 即可\",\"测试代码：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Document</title> </head> <body> <button id=\\\"get\\\">get</button> <button id=\\\"post\\\">post</button> <button id=\\\"put\\\">put</button> <button id=\\\"patch\\\">patch</button> <button id=\\\"delete\\\">delete</button> <script> const oGet = document.querySelector('#get') const oPost = document.querySelector('#post') const oPut = document.querySelector('#put') const oPatch = document.querySelector('#patch') const oDelete = document.querySelector('#delete') oGet.addEventListener('click', function () { //console.log('get') let xhr = new XMLHttpRequest() xhr.open('GET', 'http://localhost:3000/users?id=1', true) xhr.send() xhr.onload = function () { //console.log(xhr.readyState) if (/^2\\\\d{2}$/.test(xhr.status)) { console.log(JSON.parse(xhr.responseText)) } else { console.log('error', xhr.responseText) } } }) oPost.addEventListener('click', function () { //console.log('post') let xhr = new XMLHttpRequest() xhr.open('POST', 'http://localhost:3000/users', true) //form编码 name=zhf&age=18 //json {name:\\\"zhf\\\",age:18} // xhr.setRequestHeader('content-type','application/x-www-form-urlencoded') // xhr.send(`name=tc&age=18`)//数据放在这里 xhr.setRequestHeader('content-type', 'application/json') xhr.send( JSON.stringify({ name: 'gl', age: 90, }) ) xhr.onload = function () { //console.log(xhr.readyState) if (/^2\\\\d{2}$/.test(xhr.status)) { console.log(JSON.parse(xhr.responseText)) } else { console.log('error', xhr.responseText) } } }) oPut.addEventListener('click', function () { //console.log('put') let xhr = new XMLHttpRequest() xhr.open('PUT', 'http://localhost:3000/users/4', true) //form编码 name=zhf&age=18 //json {name:\\\"zhf\\\",age:18} // xhr.setRequestHeader('content-type','application/x-www-form-urlencoded') // xhr.send(`name=tc&age=18`)//数据放在这里 xhr.setRequestHeader('content-type', 'application/json') xhr.send( JSON.stringify({ age: 80, }) ) xhr.onload = function () { //console.log(xhr.readyState) if (/^2\\\\d{2}$/.test(xhr.status)) { console.log(JSON.parse(xhr.responseText)) } else { console.log('error', xhr.responseText) } } }) oPatch.addEventListener('click', function () { //console.log('patch') let xhr = new XMLHttpRequest() xhr.open('PATCH', 'http://localhost:3000/users/5', true) //form编码 name=zhf&age=18 //json {name:\\\"zhf\\\",age:18} // xhr.setRequestHeader('content-type','application/x-www-form-urlencoded') // xhr.send(`name=tc&age=18`)//数据放在这里 xhr.setRequestHeader('content-type', 'application/json') xhr.send( JSON.stringify({ age: 180, }) ) xhr.onload = function () { //console.log(xhr.readyState) if (/^2\\\\d{2}$/.test(xhr.status)) { console.log(JSON.parse(xhr.responseText)) } else { console.log('error', xhr.responseText) } } }) oDelete.addEventListener('click', function () { //console.log('delete') let xhr = new XMLHttpRequest() xhr.open('DELETE', 'http://localhost:3000/users/7', true) xhr.send() xhr.onload = function () { //console.log(xhr.readyState) if (/^2\\\\d{2}$/.test(xhr.status)) { console.log(JSON.parse(xhr.responseText)) } else { console.log('error', xhr.responseText) } } }) </script> </body> </html> \"]},{\"header\":\"Fetch\",\"slug\":\"fetch\",\"contents\":[\"XMLHttpRequest 是一个设计粗糙的 API，配置和调用方式非常混乱，而且基于事件的异步模型写起来不友好\"]},{\"header\":\"用法\",\"slug\":\"用法\",\"contents\":[\"fetch(\\\"http://localhost:3000/users\\\") .then(res=>res.json()) .then(res=>{ console.log(res) }) fetch(\\\"http://localhost:3000/users\\\",{ method:\\\"POST\\\", headers:{ \\\"content-type\\\":\\\"application/json\\\" }, body:JSON.stringify({ username:\\\"kerwin\\\", password:\\\"123\\\" }) }) .then(res=>res.json()) .then(res=>{ console.log(res) }) fetch(\\\"http://localhost:3000/users/5\\\",{ method:\\\"PUT\\\", headers:{ \\\"content-type\\\":\\\"application/json\\\" }, body:JSON.stringify({ username:\\\"kerwin\\\", password:\\\"456\\\" }) }) .then(res=>res.json()) .then(res=>{ console.log(res) }) fetch(\\\"http://localhost:3000/users/5\\\",{ method:\\\"DELETE\\\" }) .then(res=>res.json()) .then(res=>{ console.log(res) }) \"]},{\"header\":\"错误处理\",\"slug\":\"错误处理\",\"contents\":[\"// fetch(\\\"http://localhost:3000/users1\\\") .then(res=>{ if(res.ok){ return res.json() }else{ return Promise.reject({ status:res.status, statusText:res.statusText }) } }) .then(res=>{ console.log(res) }) .catch(err=>{ console.log(err) }) \"]},{\"header\":\"实例\",\"slug\":\"实例-1\",\"contents\":[\"db.json 文件\",\"{ \\\"list\\\": [ \\\"111\\\", \\\"222\\\", \\\"333\\\" ], \\\"users\\\": [ { \\\"name\\\": \\\"kerwin\\\", \\\"age\\\": \\\"100\\\", \\\"id\\\": 1 } ], \\\"shopcar\\\": [], \\\"detail\\\": { \\\"name\\\": \\\"手机\\\" } } \",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Document</title> </head> <body> <button id=\\\"get\\\">get</button> <button id=\\\"post\\\">post</button> <button id=\\\"put\\\">put</button> <button id=\\\"patch\\\">patch</button> <button id=\\\"delete\\\">delete</button> <script> const oGet = document.querySelector('#get') const oPost = document.querySelector('#post') const oPut = document.querySelector('#put') const oPatch = document.querySelector('#patch') const oDelete = document.querySelector('#delete') oGet.addEventListener('click', function () { fetch('http://localhost:3000/users111?id=1') .then((res) => { if (res.ok) { return res.json() } else { return Promise.reject({ status: res.status, statusText: res.statusText, }) } }) .then((res) => { console.log(res) }) .catch((err) => { console.log('err', err) }) }) oPost.addEventListener('click', function () { fetch('http://localhost:3000/users', { method: 'POST', headers: { //\\\"content-type\\\":\\\"application/x-www-form-urlencoded\\\" 'content-type': 'application/json', }, //body:\\\"name=kerwin&age=100\\\" body: JSON.stringify({ name: 'zhf', age: 18, }), }) .then((res) => { return res.json() }) .then((res) => { console.log(res) }) }) oPut.addEventListener('click', function () { fetch('http://localhost:3000/users/2', { method: 'PUT', headers: { //\\\"content-type\\\":\\\"application/x-www-form-urlencoded\\\" 'content-type': 'application/json', }, //body:\\\"name=kerwin&age=100\\\" body: JSON.stringify({ age: 20, }), }) .then((res) => { return res.json() }) .then((res) => { console.log(res) }) }) oPatch.addEventListener('click', function () { fetch('http://localhost:3000/users/2', { method: 'PATCH', //必须大写 headers: { //\\\"content-type\\\":\\\"application/x-www-form-urlencoded\\\" 'content-type': 'application/json', }, //body:\\\"name=kerwin&age=100\\\" body: JSON.stringify({ age: 280, }), }) .then((res) => { return res.json() }) .then((res) => { console.log(res) }) }) oDelete.addEventListener('click', function () { fetch('http://localhost:3000/users/2', { method: 'DELETE', }) .then((res) => { return res.json() }) .then((res) => { console.log(res) }) }) </script> </body> </html> \"]},{\"header\":\"axios\",\"slug\":\"axios\",\"contents\":[\"Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中\",\"https://www.npmjs.com/package/axios\",\"<script src=\\\"https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js\\\"></script> \"]},{\"header\":\"get请求\",\"slug\":\"get请求\",\"contents\":[\"axios.get(\\\"http://localhost:3000/users\\\",{ params:{ name:\\\"kerwin\\\" } }).then(res=>{ console.log(res.data) }) \"]},{\"header\":\"post请求\",\"slug\":\"post请求\",\"contents\":[\"axios.post(\\\"http://localhost:3000/users\\\",{ name:\\\"kerwin\\\", age:100 }).then(res=>{ console.log(res.data) }) \"]},{\"header\":\"put请求\",\"slug\":\"put请求\",\"contents\":[\"axios.put(\\\"http://localhost:3000/users/12\\\",{ name:\\\"kerwin111\\\", age:200 }).then(res=>{ console.log(res.data) }) \"]},{\"header\":\"delete请求\",\"slug\":\"delete请求\",\"contents\":[\"axios.delete(\\\"http://localhost:3000/users/11\\\").then(res=>{ console.log(res.data) }) \"]},{\"header\":\"axios(config)配置\",\"slug\":\"axios-config-配置\",\"contents\":[\" axios({ method: 'post', url: 'http://localhost:3000/users', data: { name: 'kerwin', age: 100 } }) .then(res => { console.log(res.data) }).catch(err=>{ console.log(err) }) \"]},{\"header\":\"axios拦截器\",\"slug\":\"axios拦截器\",\"contents\":[\"axios.interceptors.request.use(function (config) { // Do something before request is sent console.log(\\\"loading-开始\\\") return config; }, function (error) { // Do something with request error return Promise.reject(error); }); // Add a response interceptor axios.interceptors.response.use(function (response) { // Any status code that lie within the range of 2xx cause this function to trigger // Do something with response data console.log(\\\"loading-结束\\\") return response; }, function (error) { // Any status codes that falls outside the range of 2xx cause this function to trigger // Do something with response error console.log(\\\"loading---结束\\\") return Promise.reject(error); }); \"]},{\"header\":\"axios中断器\",\"slug\":\"axios中断器\",\"contents\":[\"const controller = new AbortController(); axios.get('/foo/bar', { signal: controller.signal }).then(function(response) { //... }); // cancel the request controller.abort() \"]},{\"header\":\"实例\",\"slug\":\"实例-2\",\"contents\":[]},{\"header\":\"axios基础\",\"slug\":\"axios基础\",\"contents\":[\"db.json\",\"{ \\\"list\\\": [ \\\"111\\\", \\\"222\\\", \\\"333\\\" ], \\\"users\\\": [ { \\\"name\\\": \\\"kerwin\\\", \\\"age\\\": \\\"100\\\", \\\"id\\\": 1 }, { \\\"name\\\": \\\"zhf\\\", \\\"age\\\": 18, \\\"id\\\": 2 } ], \\\"shopcar\\\": [], \\\"detail\\\": { \\\"name\\\": \\\"手机\\\" } } \",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Document</title> <script src=\\\"https://cdn.bootcdn.net/ajax/libs/axios/1.3.4/axios.js\\\"></script> </head> <body> <button id=\\\"get\\\">get</button> <button id=\\\"post\\\">post</button> <button id=\\\"put\\\">put</button> <button id=\\\"patch\\\">patch</button> <button id=\\\"delete\\\">delete</button> <script> const oGet = document.querySelector('#get') const oPost = document.querySelector('#post') const oPut = document.querySelector('#put') const oPatch = document.querySelector('#patch') const oDelete = document.querySelector('#delete') oGet.addEventListener('click', function () { axios .get('http://localhost:3000/users', { params: { name: 'kerwin' }, }) .then((res) => { console.log(res.data) }) .catch((err) => { console.log('err', err) }) }) oPost.addEventListener('click', function () { axios .post('http://localhost:3000/users', { name: 'zhf', age: 18, }) //\\\"name=xt&age=18\\\" 传入form格式 .then((res) => { console.log(res.data) }) .catch((err) => { console.log('err', err) }) }) oPut.addEventListener('click', function () { axios .put('http://localhost:3000/users/3', { age: 180, }) .then((res) => { console.log(res.data) }) .catch((err) => { console.log('err', err) }) }) oPatch.addEventListener('click', function () { axios .patch('http://localhost:3000/users/2', { age: 18, }) .then((res) => { console.log(res.data) }) .catch((err) => { console.log('err', err) }) }) oDelete.addEventListener('click', function () { axios .delete('http://localhost:3000/users/3') .then((res) => { console.log(res.data) }) .catch((err) => { console.log('err', err) }) }) //使用配置写法 // axios({ // method: 'post', // url: 'http://localhost:3000/users', // //get 用params // //put post patch 用data // data: { // name: 'gangdan', // age: 60, // }, // }).then((res) => { // console.log(res.data).catch((err) => { // console.log('err', err) // }) // }) </script> </body> </html> \"]},{\"header\":\"axios拦截、中断\",\"slug\":\"axios拦截、中断\",\"contents\":[\"db.json\",\"{ \\\"news\\\": [ { \\\"id\\\": 1, \\\"title\\\": \\\"男人看了沉默,女人看了流泪\\\", \\\"author\\\": \\\"kerwin\\\" }, { \\\"id\\\": 2, \\\"title\\\": \\\"震惊！他年薪仅1元\\\", \\\"author\\\": \\\"tiechui\\\" }, { \\\"id\\\": 3, \\\"title\\\": \\\"速看！万分危急！\\\", \\\"author\\\": \\\"gangdan\\\" } ], \\\"comments\\\": [ { \\\"id\\\": 1, \\\"body\\\": \\\"我是男人\\\", \\\"newsId\\\": 1 }, { \\\"id\\\": 2, \\\"body\\\": \\\"我是女人\\\", \\\"newsId\\\": 1 }, { \\\"id\\\": 3, \\\"body\\\": \\\"我年薪2元\\\", \\\"newsId\\\": 2 }, { \\\"id\\\": 4, \\\"body\\\": \\\"我年薪3元\\\", \\\"newsId\\\": 2 }, { \\\"id\\\": 5, \\\"body\\\": \\\"1块钱就能买1块钱的东西\\\", \\\"newsId\\\": 3 }, { \\\"id\\\": 6, \\\"body\\\": \\\"2块钱就能买2块钱的东西\\\", \\\"newsId\\\": 3 } ] } \",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Document</title> <script src=\\\"https://cdn.bootcdn.net/ajax/libs/axios/1.3.4/axios.js\\\"></script> </head> <body> <button id=\\\"get\\\">get</button> <button id=\\\"abort\\\">abort</button> <script> const oGet = document.querySelector('#get') const oAbort = document.querySelector('#abort') // Add a request interceptor axios.interceptors.request.use( function (config) { // Do something before request is sent console.log('loading显示...') return config }, function (error) { // Do something with request error return Promise.reject(error) } ) // Add a response interceptor axios.interceptors.response.use( function (response) { // Any status code that lie within the range of 2xx cause this function to trigger // Do something with response data console.log('成功-隐藏loading') return response }, function (error) { // Any status codes that falls outside the range of 2xx cause this function to trigger // Do something with response error console.log('失败-隐藏loading') return Promise.reject(error) } ) const controller = new AbortController() oGet.onclick = function () { axios .get('http://localhost:3000/news', { signal: controller.signal, }) .then((res) => { console.log(res.data) }) .catch((err) => { console.log('err', err) }) } oAbort.onclick = function () { controller.abort() } </script> </body> </html> \"]},{\"header\":\"同源策略(Same-origin policy)\",\"slug\":\"同源策略-same-origin-policy\",\"contents\":[\"一个 URL 有三部分组成：协议、域名 (指向主机)、端口，只有这三个完全相同的 URL 才能称之为同源。如下，能和 http://www.example.com/dir1/index.html 同源的是\",\"URL\",\"结果\",\"原因\",\"http://www.example.com/dir2/api\",\"同源\",\"只有路径不同\",\"https://www.example.com/api\",\"不同源\",\"协议不同\",\"http://www.example.com:81/dir1/etc.html\",\"不同源\",\"端口不同 ( http:// 默认端口是80)\",\"http://www.kerwin.com/dir1/other.html\",\"不同源\",\"域名不同\",\"无法读取非同源网页的 Cookie、LocalStorage\",\"无法接触非同源网页的 DOM\",\"无法向非同源地址发送 AJAX 请求（可以发送，但浏览器会拒绝接受响应）\",\"注意：同源策略是浏览器的行为，是为了保护本地数据不被 JavaScript 代码获取回来的数据污染，因此拦截的是客户端发出的请求回来的数据接收，即请求发送了，服务器响应了，但是无法被浏览器接收\"]},{\"header\":\"Jsonp\",\"slug\":\"jsonp\",\"contents\":[\"Jsonp (JSON with Padding) 是 json 的一种\\\"使用模式\\\"，可以让网页从别的域名（网站）那获取资料，即跨域读取数据\",\"为什么我们从不同的域（网站）访问数据需要一个特殊的技术 ( JSONP )呢？这是因为同源策略\",\"script 标签可以做到这一点：\",\" function test(data) { console.log('111', data) } const script = document.createElement('script') script.src = 'http://www.runoob.com/try/ajax/jsonp.php?jsoncallback=test' document.body.appendChild(script) //1.script 没有跨域限制 //2.后端配合返回的是 函数()调用 //3.前端提前声明好这个函数 //jsonp只能get请求 无法post put delete \",\"实例：\",\"<body> <input type=\\\"text\\\" id=\\\"mysearch\\\" /> <ul id=\\\"list\\\"></ul> <script> mysearch.oninput = function(evt){ console.log(evt.target.value) if(!evt.target.value){ list.innerHTML = \\\"\\\" return } const oscript = document.createElement(\\\"script\\\") oscript.src = `https://www.baidu.com/sugrec?pre=1&p=3&ie=utf-8&json=1&prod=pc&from=pc_web&sugsid=36542,36464,36673,36454,31660,36692,36166,36695,36697,36570,36074,36655,36345,26350,36469,36314&wd=${evt.target.value}&req=2&csor=1&cb=test&_=1656294200527` document.body.appendChild(oscript) oscript.onload = function(){ oscript.remove() } } function test(obj){ console.log(obj.g) list.innerHTML = obj.g.map(item=> `<li>${item.q}</li>` ).join(\\\"\\\") } </script> </body> \"]},{\"header\":\"其他方法解决跨域问题\",\"slug\":\"其他方法解决跨域问题\",\"contents\":[\"可以通过设置响应头解决，还可以使用反向代理来解决\"]}]},\"/front-end/javascript-notes/31-Promise.html\":{\"title\":\"Promise\",\"contents\":[{\"header\":\"Promise是什么\",\"slug\":\"promise是什么\",\"contents\":[\"Promise 是异步编程的一种解决方案，比传统的解决方案使用回调函数, 更合理、更强大。ES6 将其写进了语言标准，统一了用法，原生提供了 Promise 对象\",\"指定回调函数方式更灵活易懂\",\"解决异步回调地狱的问题\"]},{\"header\":\"回调地狱\",\"slug\":\"回调地狱\",\"contents\":[\"当一个回调函数嵌套一个回调函数的时候，就会出现一个嵌套结构，当嵌套的多了就会出现回调地狱的情况\",\"比如我们发送三个 Ajax 请求\",\"第一个正常发送\",\"第二个请求需要第一个请求的结果中的某一个值作为参数\",\"第三个请求需要第二个请求的结果中的某一个值作为参数\",\"ajax({ url: '我是第一个请求', success (res) { // 现在发送第二个请求 ajax({ url: '我是第二个请求'， data: { a: res.a, b: res.b }, success (res2) { // 进行第三个请求 ajax({ url: '我是第三个请求', data: { a: res2.a, b: res2.b }, success (res3) { console.log(res3) } }) } }) } }) \",\"回调地狱，其实就是回调函数嵌套过多导致的\"]},{\"header\":\"Promise使用\",\"slug\":\"promise使用\",\"contents\":[\"语法：\",\"new Promise(function (resolve, reject) { // resolve 表示成功的回调 // reject 表示失败的回调 }).then(function (res) { // 成功的函数 }).catch(function (err) { // 失败的函数 }) \",\"例：\",\"let pro = new Promise(function(resolve,reject){ setTimeout(()=>{ reject() },1000) }) // pro.then(()=>{ // console.log(\\\"奖金\\\") // },()=>{ // console.log(\\\"没有\\\") // }) pro.then(()=>{ console.log(\\\"奖金\\\") }).catch(()=>{ console.log(\\\"没有\\\") }) // 没有 \"]},{\"header\":\"Promise对象的状态\",\"slug\":\"promise对象的状态\",\"contents\":[\"Promise 对象通过自身的状态，来控制异步操作\",\"Promise 实例具有三种状态\",\"异步操作未完成（pending） 异步操作成功（fulfilled） 异步操作失败（rejected） \",\"这三种的状态的变化途径只有两种\",\"从“未完成”到“成功” 从“未完成”到“失败” \",\"一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺生效，就不再改变了。这也意味着，Promise 实例的状态变化只可能发生一次\",\"因此，Promise 的最终结果只有两种\",\"异步操作成功，Promise 实例传回一个值（value），状态变为fulfilled 异步操作失败，Promise 实例抛出一个错误（error），状态变为rejected \",\"Promise01.png\"]},{\"header\":\"Promise对象方法\",\"slug\":\"promise对象方法\",\"contents\":[\"Promise 是一个对象，也是一个构造函数\"]},{\"header\":\"Promise.resolve\",\"slug\":\"promise-resolve\",\"contents\":[\"将现有对象转为 Promise 对象\",\"Promise.resolve('kerwin') // 等价于 new Promise(resolve => resolve('kerwin')) \"]},{\"header\":\"Promise.reject\",\"slug\":\"promise-reject\",\"contents\":[\"Promise.reject(reason) 方法也会返回一个新的 Promise 实例，该实例的状态为 rejected\",\"const p = Promise.reject('error'); // 等同于 const p = new Promise((resolve, reject) => reject('error')) \"]},{\"header\":\"Promise.all\",\"slug\":\"promise-all\",\"contents\":[\"Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例\",\"const p = Promise.all([p1, p2, p3]); \",\"p 的状态由 p1, p2, p3 决定，分成两种情况：\",\"只有 p1、p2、p3 的状态都变成 fulfilled，p 的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数\",\"只要 p1、p2、p3 之中有一个被 rejected，p 的状态就变成 rejected，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数\"]},{\"header\":\"Promise.race\",\"slug\":\"promise-race\",\"contents\":[\"Promise.race() 方法同样是将多个 Promise 实例包装成一个新的 Promise 实例\",\"const p = Promise.race([p1, p2, p3]); \",\"上面代码中，只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数\"]},{\"header\":\"Promise.allSettled\",\"slug\":\"promise-allsettled\",\"contents\":[\"Promise.allSettled() 方法，用来确定一组异步操作是否都结束了（不管成功或失败）。所以，名为\\\"Settled\\\"，包含了\\\"fulfilled\\\"和\\\"rejected\\\"两种情况\",\"const promises = [ ajax('/200接口'), ajax('/401接口') ]; Promise.allSettled(promises).then(results=>{ // 过滤出成功的请求 results.filter(item =>item.status === 'fulfilled'); 过滤出失败的请求 results.filter(item=> item.status === 'rejected'); }) \"]},{\"header\":\"Promise.any\",\"slug\":\"promise-any\",\"contents\":[\"只要参数实例有一个变成 fulfilled 状态，包装实例就会变成 fulfilled 状态；如果所有参数实例都变成 rejected 状态，包装实例就会变成 rejected 状态\",\"Promise.any()跟Promise.race()方法很像，只有一点不同，就是Promise.any()不会因为某个 Promise 变成rejected状态而结束，必须等到所有参数 Promise 变成rejected状态才会结束\"]},{\"header\":\"finally方法\",\"slug\":\"finally方法\",\"contents\":[\"不管 promise 最后的状态，在执行完 then 或 catch 指定的回调函数以后，都会执行 finally 方法指定的回调函数\",\"const p = new Promise((resolve, reject) => { resolve() //reject() }) p.then((res) => { console.log('then') }).catch((err) => { console.log('then') }).finally(() => { console.log('finally') }) //结果：then finally \"]},{\"header\":\"手写Promise\",\"slug\":\"手写promise\",\"contents\":[\"/* * @作者: kerwin */ function KerwinPromise(executor) { this.status = \\\"pending\\\"; this.result = undefined; this.cb = [] var _this = this; function resolve(res) { if (_this.status !== \\\"pending\\\") return; // console.log(_this) _this.status = \\\"fulfilled\\\" _this.result = res; _this.cb.forEach(item => { item.successCB && item.successCB(_this.result) }); } function reject(res) { if (_this.status !== \\\"pending\\\") return; // console.log(\\\"reject\\\") _this.status = \\\"rejected\\\" _this.result = res; _this.cb.forEach(item => { item.failCB && item.failCB(_this.result) }); } executor(resolve, reject) } KerwinPromise.prototype.then = function (successCB, failCB) { if(!successCB){ successCB = value=>value } if(!failCB){ failCB = error=>error } // successCB() return new KerwinPromise((resolve, reject) => { if (this.status === \\\"fulfilled\\\") { var result = successCB && successCB(this.result) // console.log(result); if (result instanceof KerwinPromise) { result.then(res => { // console.log(res) resolve(res); }, err => { // console.log(err) reject(err) }) } else { resolve(result); } } if (this.status === \\\"rejected\\\") { var result = failCB && failCB(this.result) if (result instanceof KerwinPromise) { result.then(res => { // console.log(res) resolve(res); }, err => { // console.log(err) reject(err) }) } else { reject(result); } } if (this.status === \\\"pending\\\") { //收集回调 this.cb.push({ successCB: () => { var result = successCB && successCB(this.result) if (result instanceof KerwinPromise) { result.then(res => { // console.log(res) resolve(res); }, err => { // console.log(err) reject(err) }) } else { resolve(result); } }, failCB: () => { var result = failCB && failCB(this.result) if (result instanceof KerwinPromise) { result.then(res => { // console.log(res) resolve(res); }, err => { // console.log(err) reject(err) }) } else { reject(result); } } }) } }) } KerwinPromise.prototype.catch= function(failCB){ this.then(undefined,failCB) } \"]},{\"header\":\"Async与Await\",\"slug\":\"async与await\",\"contents\":[]},{\"header\":\"Async\",\"slug\":\"async\",\"contents\":[\"async 函数，使得异步操作变得更加方便\",\"更好的语义\",\"返回值是 Promise\",\"async function test(){ } test() \"]},{\"header\":\"Await\",\"slug\":\"await\",\"contents\":[\"await 命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值\",\"async function test(){ var res1 = await ajax(\\\"http://localhost:3000/news1\\\") var res2 = await ajax(\\\"http://localhost:3000/news2\\\") return res2 } test().then(res=>{ console.log(\\\"返回结果\\\",res) }).catch(err=>{ console.log(\\\"err\\\",err) }) \"]},{\"header\":\"错误处理\",\"slug\":\"错误处理\",\"contents\":[\"try{ var res1 = await ajax(\\\"http://localhost:3000/news1\\\") var res2 = await ajax(\\\"http://localhost:3000/news2\\\") }catch(err){ console.log(\\\"err\\\",err) } \"]}]},\"/front-end/javascript-notes/32-JavaScript-%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.html\":{\"title\":\"JavaScript-执行机制\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"JavaScript 语言的一大特点就是单线程，也就是说，同一时间只能做一件事\",\"这是因为 JavaScript 这门脚本语言诞生的使命所致——JavaScript 是为处理页面中用户的交互，以及操作 DOM 而诞生的。比如我们对某个 DOM 元素进行添加和删除操作，不能同时进行。应该先进行添加，然后再删除\",\"单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样导致的问题是：如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉\",\"为了解决这个问题，利用多核 CPU 的计算能力，HTML 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程。于是，JS 中出现了同步和异步\"]},{\"header\":\"同步和异步\",\"slug\":\"同步和异步\",\"contents\":[\"前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做法：我们要烧水做饭，等水开了（十分钟后），再去切菜、炒菜\",\"在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做饭的异步做法：我们在烧水的同时，利用这十分钟去切菜、炒菜\",\"它们的本质区别：这条流水线上各个流程的执行顺序不同\"]},{\"header\":\"同步任务\",\"slug\":\"同步任务\",\"contents\":[\"同步任务都在主线程上执行，形成一个执行栈\"]},{\"header\":\"异步任务\",\"slug\":\"异步任务\",\"contents\":[\"JS 的异步是通过回调函数实现的，异步任务相关的添加到任务队列中（任务队列也称为消息队列）\",\"一般而言，异步任务有以下三种类型：\",\"普通事件，如 click、resize 等\",\"资源加载，如 load、error 等\",\"定时器，如 setInterval、setTimeout 等\"]},{\"header\":\"执行顺序\",\"slug\":\"执行顺序\",\"contents\":[\"先执行执行栈中的同步任务\",\"异步任务放入任务队列中\",\"一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行\",\"由于主线程不断的重复获得任务、执行任务、再获得任务、再执行，这种机制被称为事件循环（event loop）\"]}]},\"/front-end/javascript-notes/\":{\"title\":\"JavaScript笔记\",\"contents\":[]},\"/front-end/vue-notes/01-Vue%E6%A0%B8%E5%BF%83-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B.html\":{\"title\":\"Vue核心-快速上手\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/01-Vue核心-快速上手\"]},{\"header\":\"Vue 简介\",\"slug\":\"vue-简介\",\"contents\":[]},{\"header\":\"官网\",\"slug\":\"官网\",\"contents\":[\"英文官网\",\"中文官网\"]},{\"header\":\"介绍与描述\",\"slug\":\"介绍与描述\",\"contents\":[\"Vue 是一套用来动态构建用户界面的渐进式 JavaScript 框架 \",\"构建用户界面：把数据通过某种办法变成用户界面\",\"渐进式：Vue 可以自底向上逐层的应用，简单应用只需要一个轻量小巧的核心库，复杂应用可以引入各式各样的 Vue 插件\",\"作者 \",\"尤雨溪\"]},{\"header\":\"Vue 的特点\",\"slug\":\"vue-的特点\",\"contents\":[\"遵循 MVVM 模式\",\"编码简洁，体积小，运行效率高，适合移动/PC 端开发\",\"它本身只关注 UI，可以引入其它第三方库开发项目\",\"采用组件化模式，提高代码复用率、且让代码更好维护\",\"声明式编码，让编码人员无需直接操作 DOM，提高开发效率\",\"使用虚拟 DOM 和 Diff 算法，尽量复用 DOM 节点\"]},{\"header\":\"与其他 JS 框架的关联\",\"slug\":\"与其他-js-框架的关联\",\"contents\":[\"借鉴 angular 的模板和数据绑定技术\",\"借鉴 react 的组件化和虚拟 DOM 技术\"]},{\"header\":\"Vue 周边库\",\"slug\":\"vue-周边库\",\"contents\":[\"vue-cli：vue 脚手架\",\"vue-resource (axios)：ajax 请求\",\"vue-router：路由\",\"vuex：状态管理（它是 vue 的插件，但是没有用 vue-xxx 的命名规则）\",\"vue-lazyload：图片懒加载\",\"vue-scroller：页面滑动相关\",\"mint-ui：基于 vue 的 UI 组件库（移动端）\",\"element-ui：基于 vue 的 UI 组件库（PC 端）\"]},{\"header\":\"初识 Vue\",\"slug\":\"初识-vue\",\"contents\":[]},{\"header\":\"前置工作\",\"slug\":\"前置工作\",\"contents\":[\"给浏览器安装 Vue Devtools 插件\",\"标签引入 Vue 包\",\"（可选）阻止 Vue 在启动时生成生产提示 Vue.config.productionTip = false\"]},{\"header\":\"代码演示\",\"slug\":\"代码演示\",\"contents\":[\"想让 Vue 工作，就必须创建一个 Vue实例，且要传入一个配置对象\",\"容器里的代码依然符合 HTML 规范，只不过混入了一些特殊的 Vue 语法\",\"容器里的代码被称为 Vue 模板\",\"Vue 实例与容器是一一对应的\",\"真实开发中只有一个 Vue 实例，并且会配合着组件一起使用\",\"{{xxx}} 中的 xxx 要写 JS 表达式，且 xxx 可以自动读取到 data 中的所有属性\",\"一旦 data 中的数据发生变化，那么页面中用到该数据的地方也会自动更新\",\"<!DOCTYPE html> <html> <head> <meta charset=\\\"UTF-8\\\" /> <title>初识Vue</title> <!-- 引入Vue --> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器 --> <div id=\\\"demo\\\"> <h1>Hello，{{ name.toUpperCase() }}，{{ address }}</h1> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false //阻止 Vue 在启动时生成生产提示 // 创建Vue实例 new Vue({ el: '#demo', // el用于指定当前Vue实例为哪个容器服务，值通常为CSS选择器字符串 data: { // data中用于存储数据，数据供el所指定的容器去使用，值暂时先写成一个对象 name: 'zhf', address: '山东', }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-快速上手01.png\",\"注意区分：JS 表达式和 JS 代码（语句）\",\"JS 表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方，如：a、a+b、demo(1)、x === y ? 'a' : 'b'\",\"JS 代码（语句），只控制代码的走向，不生成值，如：if (){}、for (){}\"]},{\"header\":\"el 和 data\",\"slug\":\"el-和-data\",\"contents\":[]},{\"header\":\"el\",\"slug\":\"el\",\"contents\":[\"el 用于指定当前 Vue 实例为哪个容器服务，值通常为 CSS 选择器字符串\"]},{\"header\":\"data\",\"slug\":\"data\",\"contents\":[\"data 中用于存储数据，数据供 el 所指定的容器去使用，值暂时先写成一个对象\"]},{\"header\":\"el 和 data 的两种写法\",\"slug\":\"el-和-data-的两种写法\",\"contents\":[\"el 有两种写法：\",\"创建 Vue 实例对象的时候配置 el 属性\",\"const v = new Vue({ el:'#root', //第一种写法 data:{ name:'zhf' } }) \",\"先创建 Vue 实例，随后再通过 vm.$mount('选择器') 指定 el 的值\",\"const v = new Vue({ data:{ name:'zhf' } }) v.$mount('#root') //第二种写法 \",\"data 有两种写法：\",\"对象式：data:{}\",\"data:{ name:'zhf' } \",\"函数式：data(){return{}}\",\"data(){ console.log('@@@',this) //此处的this是Vue实例对象 return{ name:'zhf' } } \",\"如何选择：组件时，data 必须使用函数式，否则会报错\",\"重要原则：由 Vue 管理的函数，一定不要写箭头函数，否则 this 就不再是 Vue 实例了\"]}]},\"/front-end/vue-notes/02-Vue%E6%A0%B8%E5%BF%83-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95.html\":{\"title\":\"Vue核心-模板语法\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/02-Vue核心-模板语法\"]},{\"header\":\"模板的理解\",\"slug\":\"模板的理解\",\"contents\":[\"模板就是动态 HTML 页面，这里面包含了一些 JS 语法代码\"]},{\"header\":\"Vue 模板语法\",\"slug\":\"vue-模板语法\",\"contents\":[\"Vue 模板语法包括两大类，分别是：\",\"插值语法：双大括号表示\",\"指令语法：指令（以 v- 开头的自定义标签属性）\"]},{\"header\":\"插值语法\",\"slug\":\"插值语法\",\"contents\":[\"功能：用于解析标签体内容\",\"写法：{{xxx}}，xxx 是 JS 表达式，可以直接读取到 data 中的所有属性\"]},{\"header\":\"指令语法\",\"slug\":\"指令语法\",\"contents\":[\"功能：用于解析标签（包括：标签属性、标签体内容、绑定事件等）\",\"举例：<a v-bind:href=\\\"xxx\\\"> 或简写为 <a :href='xxx'>，xxx 同样要写 JS 表达式，可以直接读取到 data 中所有属性\",\"备注：Vue 中有很多的指令，且形式都是 v-xxx，此处只是以 v-bind 举例\",\"例：\",\"<!DOCTYPE html> <html> <head> <meta charset=\\\"UTF-8\\\" /> <title>模板语法</title> <!-- 引入Vue --> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>插值语法</h2> <h4>你好，{{ name }}</h4> <hr /> <h2>指令语法</h2> <a v-bind:href=\\\"baidu.url.toUpperCase()\\\">点我去{{ baidu.name }}1</a> <a :href=\\\"baidu.url\\\">点我去{{ baidu.name }}2</a> </div> </body> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 new Vue({ el: '#root', data: { name: 'zhf', baidu: { name: '百度', url: 'https://www.baidu.com/', }, }, }) </script> </html> \",\"效果：\",\"Vue核心-模板语法01.gif\"]}]},\"/front-end/vue-notes/03-Vue%E6%A0%B8%E5%BF%83-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.html\":{\"title\":\"Vue核心-数据绑定\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/03-Vue核心-数据绑定\"]},{\"header\":\"数据绑定\",\"slug\":\"数据绑定\",\"contents\":[\"Vue 中有两种数据绑定的方式：\",\"单向绑定 v-bind 数据只能从 data 流向页面\",\"双向绑定 v-model 数据不仅能从 data 流向页面，还可以从页面流向 data\",\"备注：\",\"双向绑定一般都应用在表单类元素上，如 <input>、<select>、<textarea> 等\",\"v-model:value 可以简写为 v-model，因为 v-model 默认收集的就是 value 值\",\"例：\",\"<!DOCTYPE html> <html> <head> <meta charset=\\\"UTF-8\\\" /> <title>数据绑定</title> <!-- 引入Vue --> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <!-- 普通写法 --> <!-- 单向数据绑定：<input type=\\\"text\\\" v-bind:value=\\\"name\\\" /><br /> --> <!-- 双向数据绑定：<input type=\\\"text\\\" v-model:value=\\\"name\\\" /> --> <!-- 简写 --> 单向数据绑定：<input type=\\\"text\\\" :value=\\\"name\\\" /><br /> 双向数据绑定：<input type=\\\"text\\\" v-model=\\\"name\\\" /> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { name: 'zhf', }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-数据绑定01.gif\"]},{\"header\":\"v-model 指令的修饰符\",\"slug\":\"v-model-指令的修饰符\",\"contents\":[]},{\"header\":\"v-model. number\",\"slug\":\"v-model-number\",\"contents\":[\"使用修饰符 .number 可以将输入的数据转换为 Number 类型，否则虽然你输入的是数字. 但它的类型其实是 String\"]},{\"header\":\"v-model. trim\",\"slug\":\"v-model-trim\",\"contents\":[\"给 v-model 添加修饰符 .trim 可以自动过滤用户输入的首尾空格\"]},{\"header\":\"v-model. lazy\",\"slug\":\"v-model-lazy\",\"contents\":[\"并不是实时改变，而是在失去焦点或者按回车时才会更新\",\"在输入框中，v-model默认是在input事件中同步输入框的数据（除了输入法中文输入的情况），使用修饰符 .lazy 会转变为 change 事件中同步（类似懒加载）\"]}]},\"/front-end/vue-notes/04-Vue%E6%A0%B8%E5%BF%83-MVVM%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86.html\":{\"title\":\"Vue核心-MVVM模型与数据代理\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/04-Vue核心-MVVM模型与数据代理\"]},{\"header\":\"MVVM 模型\",\"slug\":\"mvvm-模型\",\"contents\":[\"Vue核心-MVVM模型与数据代理01.png\",\"MVVM 本质上是 MVC （Model-View- Controller）的改进版。即模型-视图-视图模型\",\"模型 model 指的是后端传递的数据，视图 view 指的是所看到的页面\",\"视图模型 viewModel 是 MVVM 模式的核心，它是连接 view 和 model 的桥梁。它有两个方向：\",\"将模型转化成视图，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定\",\"将视图转化成模型，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听\",\"MVVM：\",\"M：模型 Model，data 中的数据\",\"V：视图 View，模板代码（不是静态页面）（两个语法：指令，大括号表达式）\",\"VM：视图模型 ViewModel，Vue 实例 \",\"Dom Listeners（Dom 监听）\",\"Data Bindings（数据绑定）\",\"观察发现：\",\"data 中所有的属性，最后都出现在了 vm 身上\",\"vm 身上所有的属性及 Vue 原型身上所有的属性，在 Vue 模板中都可以直接使用\",\"Vue核心-MVVM模型与数据代理02.png\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>MVVM</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h1>学校名称：{{name}}</h1> <h1>学校地址：{{address}}</h1> <h1>测试：{{$options}}</h1> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: '曲阜师范大学', address: '曲阜', }, }) console.log(vm) </script> </body> </html> \",\"效果：\",\"Vue核心-MVVM模型与数据代理03.png\"]},{\"header\":\"Vue 中的数据代理\",\"slug\":\"vue-中的数据代理\",\"contents\":[]},{\"header\":\"Object. defineproperty 方法\",\"slug\":\"object-defineproperty-方法\",\"contents\":[\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Object.defineproperty方法</title> </head> <body> <script> let number = 18 let person = { name: '张三', sex: '男', } Object.defineProperty(person, 'age', { // value:18, // enumerable:true, // 控制属性是否可以枚举，默认值是false // writable:true, // 控制属性是否可以被修改，默认值是false // configurable:true // 控制属性是否可以被删除，默认值是false // 当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值 get() { console.log('有人读取age属性了') return number }, // 当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值 set(value) { console.log('有人修改了age属性，且值是', value) number = value }, }) console.log(person) </script> </body> </html> \",\"效果：\",\"Vue核心-MVVM模型与数据代理04.png\"]},{\"header\":\"数据代理\",\"slug\":\"数据代理\",\"contents\":[\"数据代理：通过一个对象代理对另一个对象中属性的操作（读/写）\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>模拟一个数据代理</title> </head> <body> <script> let obj1 = { x: 100 } let obj2 = { y: 200 } Object.defineProperty(obj2, 'x', { get() { return obj1.x }, set(value) { obj1.x = value }, }) console.log(obj1.x) console.log(obj1.y) console.log(obj2.x) console.log(obj2.y) </script> </body> </html> \",\"效果：\",\"Vue核心-MVVM模型与数据代理05.png\",\"Vue 中的数据代理通过 vm 对象来代理 data 对象中属性的操作（读/写）\",\"Vue 中数据代理的好处：更加方便的操作 data 中的数据\",\"基本原理 \",\"通过 Object.defineProperty()把 data 对象中所有属性添加到 vm 上\",\"为每一个添加到 vm 上的属性，都指定一个 gettersetter\",\"在 gettersetter 内部去操作（读/写）data 中对应的属性\",\"Vue核心-MVVM模型与数据代理06.png\",\"Vue 将 data 中的数据拷贝了一份到 _data 属性中，又将 _data 里面的属性提到 Vue 实例中（如 name），通过 defineProperty 实现数据代理，这样通过 geter/setter 操作 name，进而操作 _data 中的 name。而 _data 又对 data 进行数据劫持，实现响应式\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Vue中的数据代理</title> <!-- 引入Vue --> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>学校名称：{{ name }}</h2> <h2>学校地址：{{ address }}</h2> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: '曲阜师范大学', address: '曲阜', }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-MVVM模型与数据代理07.png\"]}]},\"/front-end/vue-notes/05-Vue%E6%A0%B8%E5%BF%83-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86.html\":{\"title\":\"Vue核心-事件处理\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/05-Vue核心-事件处理\"]},{\"header\":\"事件的基本用法\",\"slug\":\"事件的基本用法\",\"contents\":[\"使用 v-on:xxx 或 @xxx 绑定事件，其中 xxx 是事件名\",\"事件的回调需要配置在 methods 对象中，最终会在 vm 上\",\"methods 中配置的函数，不要用箭头函数，否则 this 就不是 vm 了\",\"methods 中配置的函数，都是被 Vue 所管理的函数，this 的指向是 vm 或组件实例对象\",\"@click=\\\"xxx\\\" 和 @click=\\\"xxx()\\\" 效果一致，但后者括号里面可以传参\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>事件的基本使用</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>欢迎阅读{{name}}的笔记</h2> <button v-on:click=\\\"showInfo\\\">点我提示信息</button> <button @click=\\\"showInfo1()\\\">点我提示信息1（不传参）</button> <button @click=\\\"showInfo2($event,66)\\\">点我提示信息2（传参）</button> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', }, methods: { showInfo() { alert('你好呀！这是完整写法绑定事件') }, showInfo1() { alert('你好呀！这是简写方法绑定事件，不传参') }, showInfo2(event, number) { alert(`你好呀！这是简写方法绑定事件，传参，传递到参数是${number}`) console.log(event) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-事件处理01.gif\"]},{\"header\":\"事件修饰符\",\"slug\":\"事件修饰符\",\"contents\":[\"Vue 中的事件修饰符：\",\"prevent 阻止默认事件（常用）\",\"stop 阻止事件冒泡（常用）\",\"once 事件只触发一次（常用）\",\"capture 使用事件的捕获模式\",\"self 只有 event.target 是当前操作的元素时才触发事件\",\"passive 事件的默认行为立即执行，无需等待事件回调执行完毕\",\"注意：修饰符可以连续写，比如可以这么用：@click. prevent.stop=\\\"xxx\\\"\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>事件修饰符</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> <style> * { margin-top: 20px; } .box { height: 50px; background-color: skyblue; } .box1 { padding: 5px; background-color: skyblue; } .box2 { padding: 5px; background-color: white; } .list { width: 200px; height: 200px; background-color: skyblue; overflow: auto; } li { height: 100px; } </style> </head> <body> <div id=\\\"root\\\"> <h2>欢迎来{{name}}学习</h2> <!-- 阻止默认事件（常用） --> <a href=\\\"https://www.qfnu.edu.cn/\\\" @click.prevent=\\\"showInfo\\\">点我提示信息</a> <!-- 阻止事件冒泡（常用） --> <div class=\\\"box\\\" @click=\\\"showInfo\\\"> <button @click1=\\\"showInfo\\\">点我提示信息</button> </div> <!-- 事件只触发一次（常用） --> <button @click.once=\\\"showInfo\\\">点我提示信息</button> <!-- 使用事件的捕获模式 --> <div class=\\\"box1\\\" @click.capture=\\\"showMsg(1)\\\"> div1 <div class=\\\"box2\\\" @click=\\\"showMsg(2)\\\">div2</div> </div> <!-- 只有event.target是当前操作的元素时才触发事件 --> <div class=\\\"box\\\" @click.self=\\\"showInfo\\\"> <button @click=\\\"showInfo\\\">点我提示信息</button> </div> <!-- 事件的默认行为立即执行，无需等待事件回调执行完毕--> <!-- scroll是滚动条滚动，passive没有影响 --> <!-- wheel是鼠标滚轮滚动，passive有影响 --> <ul @wheel.passive=\\\"demo\\\" class=\\\"list\\\"> <li>1</li> <li>2</li> <li>3</li> <li>4</li> </ul> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { name: '曲阜师范大学', }, methods: { showInfo() { alert('同学你好！') }, showMsg(msg) { alert(`${msg}`) }, demo() { for (let i = 0; i < 100000; i++) { console.log('#') } console.log('累坏了') }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-事件处理02.gif\"]},{\"header\":\"键盘事件\",\"slug\":\"键盘事件\",\"contents\":[\"键盘上的每个按键都有自己的名称和编码，例如：Enter（13），而 Vue 还对一些常用按键起了别名方便使用\",\"Vue 中常用的按键别名： 回车 enter 删除 delete 捕获“删除”和“退格”键 退出 esc 空格 space 换行 tab 特殊，必须配合 keydown 去使用 上 up 下 down 左 left 右 right\",\"Vue 未提供别名的按键，可以使用按键原始的 key 值去绑定，但注意要转为 kebab-case（多单词小写短横线写法）\",\"系统修饰键（用法特殊）ctrlaltshiftmeta（meta 就是 win 键） \",\"配合 keyup 使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发，指定 ctr+y 使用 @keyup.ctr.y\",\"配合 keydown 使用：正常触发事件\",\"也可以使用 keyCode 去指定具体的按键（不推荐）\",\"Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>键盘事件</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>欢迎阅读{{name}}的笔记</h2> <input type=\\\"text\\\" placeholder=\\\"按下回车提示输入\\\" @keyup.enter=\\\"showInfo\\\" /> <br /> <input type=\\\"text\\\" placeholder=\\\"按下tab提示输入\\\" @keydown.tab=\\\"showInfo\\\" /> <br /> <input type=\\\"text\\\" placeholder=\\\"按下回车提示输入\\\" @keydown.huiche=\\\"showInfo\\\" /> <br /> </div> <script> Vue.config.productionTip = false Vue.config.keyCodes.huiche = 13 // 定义了一个别名按键 new Vue({ el: '#root', data: { name: 'zhf', }, methods: { showInfo(e) { alert(`${e.target.value}`) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-事件处理03.gif\"]}]},\"/front-end/vue-notes/06-Vue%E6%A0%B8%E5%BF%83-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7.html\":{\"title\":\"Vue核心-计算属性与侦听属性\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/06-Vue核心-计算属性与侦听属性\"]},{\"header\":\"计算属性\",\"slug\":\"计算属性\",\"contents\":[\"姓名案例：\",\"Vue核心-计算属性与侦听属性01.gif\",\"插值语法实现：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>插值语法实现姓名案例</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> 姓：<input type=\\\"text\\\" v-model=\\\"firstName\\\" /> <br /> 名：<input type=\\\"text\\\" v-model=\\\"lastName\\\" /> <br /> 全名：<span>{{ firstName }}-{{ lastName }}</span> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false new Vue({ el: '#root', data: { firstName: '张', lastName: '三', }, }) </script> </body> </html> \",\"methods 实现：\",\"数据发生变化，模板就会被重新解析\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>methods实现姓名案例</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> 姓：<input type=\\\"text\\\" v-model=\\\"firstName\\\" /><br /> 名：<input type=\\\"text\\\" v-model=\\\"lastName\\\" /><br /> 全名：<span>{{fullName()}}</span> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { firstName: '张', lastName: '三', }, methods: { fullName() { return this.firstName + '-' + this.lastName }, }, }) </script> </body> </html> \",\"computed 计算属性实现：\",\"定义：要用的属性不存在，需要通过已有属性计算得来\",\"原理：底层借助了 Objcet.defineproperty() 方法提供的 getter 和 setter\",\"get 函数什么时候执行？ \",\"初次读取时会执行一次\",\"当依赖的数据发生改变时会被再次调用\",\"优势：与 methods 实现相比，内部有缓存机制（复用），效率更高，调试方便\",\"备注 \",\"计算属性最终会出现在 vm 上，直接读取使用即可\",\"如果计算属性要被修改，那必须写 set 函数去响应修改，且 set 中要引起计算时依赖的数据发生改变\",\"如果计算属性确定不考虑修改，可以使用计算属性的简写形式\",\"我们用计算属性实现姓名案例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>计算属性实现姓名案例</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> 姓：<input type=\\\"text\\\" v-model=\\\"firstName\\\" /> <br /> 名：<input type=\\\"text\\\" v-model=\\\"lastName\\\" /> <br /> 全名：<span>{{fullName}}</span> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { firstName: '张', lastName: '三', }, computed: { //完整写法 /*fullName: { get() { return this.firstName + '-' + this.lastName }, set(value) { const arr = value.split('-') this.firstName = arr[0] this.lastName = arr[1] }, },*/ //简写形式 fullName() { return this.firstName + '-' + this.lastName }, }, }) </script> </body> </html> \"]},{\"header\":\"侦听属性\",\"slug\":\"侦听属性\",\"contents\":[]},{\"header\":\"侦听属性基本用法\",\"slug\":\"侦听属性基本用法\",\"contents\":[\"watch 侦听属性\",\"当被侦听的属性变化时，回调函数自动调用，进行相关操作\",\"侦听的属性必须存在，才能进行侦听，既可以侦听 data，也可以侦听计算属性\",\"配置项属性 immediate:false，改为 true，则初始化时调用一次 handler(newValue,oldValue)\",\"侦听有两种写法 \",\"创建 Vue 时传入 watch:{}配置\",\"通过 vm.$watch() 侦听\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>侦听的基本用法</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>今天天气很{{info}}</h2> <button @click=\\\"changeWeather\\\">切换天气</button> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { isHot: true, }, computed: { info() { return this.isHot ? '炎热' : '凉爽' }, }, methods: { changeWeather() { this.isHot = !this.isHot }, }, //方式一 /*watch: { isHot: { immediate: true, handler(newValue, oldValue) { console.log('isHot被修改了', newValue, oldValue) }, }, },*/ }) //方式二 vm.$watch('isHot', { immediate: true, //初始化时让handler调用一下 //handler什么时候调用？当isHot发生改变时 handler(newValue, oldValue) { console.log('isHot被修改了', newValue, oldValue) }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-计算属性与侦听属性02.gif\"]},{\"header\":\"深度侦听\",\"slug\":\"深度侦听\",\"contents\":[\"Vue 中的 watch 默认不侦听对象内部值的改变（一层）\",\"在 watch 中配置 deep:true 可以侦听对象内部值的改变（多层）\",\"注意：\",\"Vue 自身可以侦听对象内部值的改变，但 Vue 提供的 watch 默认不可以\",\"使用 watch 时根据侦听数据的具体结构，决定是否采用深度侦听\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>深度侦听</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h3>a的值是:{{ numbers.a }}</h3> <button @click=\\\"numbers.a++\\\">点我让a+1</button> <h3>b的值是:{{ numbers.b }}</h3> <button @click=\\\"numbers.b++\\\">点我让b+1</button> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { numbers: { a: 1, b: 1, }, }, watch: { // 监视多级结构中某个属性的变化 /*'numbers.a': { handler() { console.log('a被改变了') }, },*/ //监视多级结构中所有属性的变化 numbers: { deep: true, handler() { console.log('numbers改变了') }, }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-计算属性与侦听属性03.gif\"]},{\"header\":\"侦听属性简写\",\"slug\":\"侦听属性简写\",\"contents\":[\"如果侦听属性除了 handler 没有其他配置项的话，可以进行简写\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>侦听属性简写</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h3>今天天气很{{ info }}</h3> <button @click=\\\"changeWeather\\\">切换天气</button> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { isHot: true }, computed: { info() { return this.isHot ? '炎热' : '凉爽' }, }, methods: { changeWeather() { this.isHot = !this.isHot }, }, watch: { // 正常写法 // isHot: { // // immediate:true, //初始化时让handler调用一下 // // deep:true, //深度监视 // handler(newValue, oldValue) { // console.log('isHot被修改了', newValue, oldValue) // } // }, //简写 isHot(newValue, oldValue) { console.log('isHot被修改了', newValue, oldValue, this) }, }, }) //正常写法 // vm.$watch('isHot', { // immediate: true, //初始化时让handler调用一下 // deep: true,//深度监视 // handler(newValue, oldValue) { // console.log('isHot被修改了', newValue, oldValue) // } // })l //简写 // vm.$watch('isHot', (newValue, oldValue) => { // console.log('isHot被修改了', newValue, oldValue, this) // }) </script> </body> </html> \"]},{\"header\":\"计算属性 VS 侦听属性\",\"slug\":\"计算属性-vs-侦听属性\",\"contents\":[\"computed 和 watch 之间的区别：\",\"computed 能完成的功能，watch 都可以完成\",\"watch 能完成的功能，computed 不一定能完成，例如 watch 可以进行异步操作\",\"两个重要的小原则：\",\"所有被 Vue 管理的函数，最好写成普通函数，这样 this 的指向才是 vm 或组件实例对象\",\"所有不被 Vue 所管理的函数（定时器的回调函数、Ajax 的回调函数、Promise 的回调函数等），最好写成箭头函数，这样 this 的指向才是 vm 或组件实例对象\",\"上面的姓名案例：\",\"使用计算属性：\",\"new Vue({ el:'#root', data:{ firstName:'张', lastName:'三' }, computed:{ fullName(){ return this.firstName + '-' + this.lastName } } }) \",\"使用监听属性：\",\"new Vue({ el:'#root', data:{ firstName:'张', lastName:'三', fullName:'张-三' }, watch:{ firstName(val){ setTimeout(()=>{ this.fullName = val + '-' + this.lastName },1000); }, lastName(val){ this.fullName = this.firstName + '-' + val } } }) \"]}]},\"/front-end/vue-notes/07-Vue%E6%A0%B8%E5%BF%83-%E7%BB%91%E5%AE%9A%E6%A0%B7%E5%BC%8F.html\":{\"title\":\"Vue核心-绑定样式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/07-Vue核心-绑定样式\"]},{\"header\":\"绑定 class 样式\",\"slug\":\"绑定-class-样式\",\"contents\":[\":class=\\\"xxx\\\" //xxx 可以是字符串、数组、对象 \"]},{\"header\":\"字符串写法\",\"slug\":\"字符串写法\",\"contents\":[\"字符串写法适用于：类名不确定，要动态获取\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>绑定class样式-字符串写法</title> <style> .basic { width: 400px; height: 100px; border: 1px solid black; } .happy { border: 4px solid red; background-color: rgba(255, 255, 0, 0.644); background: linear-gradient(30deg, yellow, pink, orange, yellow); } .sad { border: 4px dashed rgb(2, 197, 2); background-color: gray; } .normal { background-color: skyblue; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器 --> <div id=\\\"root\\\"> <!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 --> <div class=\\\"basic\\\" :class=\\\"mood\\\" @click=\\\"changeMood\\\">{{name}}</div> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', mood: 'normal', }, methods: { changeMood() { const arr = ['happy', 'sad', 'normal'] const index = Math.floor(Math.random() * 3) this.mood = arr[index] }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-绑定样式01.gif\"]},{\"header\":\"数组写法\",\"slug\":\"数组写法\",\"contents\":[\"数组写法适用于：要绑定多个样式，个数不确定，名字也不确定\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>绑定class样式-数组写法</title> <style> .basic { width: 400px; height: 100px; border: 1px solid black; } .zhf1 { background-color: yellowgreen; } .zhf2 { font-size: 30px; text-shadow: 2px 2px 10px red; } .zhf3 { border-radius: 20px; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器--> <div id=\\\"root\\\"> <!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 --> <div class=\\\"basic\\\" :class=\\\"classArr\\\">{{name}}</div> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', classArr: ['zhf1', 'zhf2', 'zhf3'], }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-绑定样式02.png\"]},{\"header\":\"对象写法\",\"slug\":\"对象写法\",\"contents\":[\"对象写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>绑定class样式-对象写法</title> <style> .basic { width: 400px; height: 100px; border: 1px solid black; } .zhf1 { background-color: yellowgreen; } .zhf2 { font-size: 30px; text-shadow: 2px 2px 10px red; } .zhf3 { border-radius: 20px; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器--> <div id=\\\"root\\\"> <!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 --> <div class=\\\"basic\\\" :class=\\\"classObj\\\">{{name}}</div> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', classObj: { zhf1: true, zhf2: false, zhf3: true, }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-绑定样式03.png\"]},{\"header\":\"绑定 style 样式\",\"slug\":\"绑定-style-样式\",\"contents\":[\":style=\\\"xxx\\\" \",\"样式对象中的 key，必须是存在的 CSS 属性，如 fontSize、backgroundColor（小驼峰命名法）\"]},{\"header\":\"对象写法\",\"slug\":\"对象写法-1\",\"contents\":[\":style=\\\"对象\\\"\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>绑定style样式-对象写法</title> <style> .basic { width: 400px; height: 100px; border: 1px solid black; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器--> <div id=\\\"root\\\"> <!-- 绑定style样式--对象写法 --> <div class=\\\"basic\\\" :style=\\\"styleObj, styleObj2\\\">{{name}}</div> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', styleObj: { fontSize: '40px', color: 'red', }, styleObj2: { backgroundColor: 'orange', }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-绑定样式04.png\"]},{\"header\":\"数组写法\",\"slug\":\"数组写法-1\",\"contents\":[\":style=\\\"数组\\\"\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>绑定style样式-数组写法</title> <style> .basic { width: 400px; height: 100px; border: 1px solid black; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器--> <div id=\\\"root\\\"> <!-- 绑定style样式--数组写法 --> <div class=\\\"basic\\\" :style=\\\"styleArr\\\">{{name}}</div> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', styleArr: [ { fontSize: '40px', color: 'blue', }, { backgroundColor: 'gray', }, ], }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-绑定样式05.png\"]}]},\"/front-end/vue-notes/08-Vue%E6%A0%B8%E5%BF%83-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93.html\":{\"title\":\"Vue核心-条件渲染\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/08-Vue核心-条件渲染\"]},{\"header\":\"条件渲染\",\"slug\":\"条件渲染\",\"contents\":[\"v-if\",\"写法跟 if else 语法类似 \",\"v-if=\\\"表达式\\\"\",\"v-else-if=\\\"表达式\\\"\",\"v-else\",\"适用于：切换频率较低的场景，因为不展示的 DOM 元素直接被移除\",\"注意：v-if 可以和 v-else-ifv-else 一起使用，但要求结构不能被打断\",\"v-show\",\"写法：v-show=\\\"表达式\\\"\",\"适用于：切换频率较高的场景\",\"特点：不展示的 DOM 元素未被移除，仅仅是使用样式隐藏掉 display:none;\",\"备注：\",\"使用 v-if 的时，元素可能无法获取到，而使用 v-show 一定可以获取到\",\"template 标签不影响结构，页面 html 中不会有此标签，但只能配合 v-if，不能配合 v-show\",\"例：\",\"v-if\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>条件渲染v-if</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>当前的n值是：{{n}}</h2> <button @click=\\\"n++\\\">点我n+1</button> <!-- 使用v-if做条件渲染 --> <h2 v-if=\\\"false\\\">欢迎来到{{name}}</h2> <h2 v-if=\\\"1 === 1\\\">欢迎来到{{name}}</h2> <!-- v-else和v-else-if --> <div v-if=\\\"n === 1\\\">A</div> <div v-else-if=\\\"n === 2\\\">B</div> <div v-else-if=\\\"n === 3\\\">C</div> <div v-else>哈哈哈</div> <!-- v-if与template的配合使用 --> <template v-if=\\\"n === 1\\\"> <h3>你好</h3> <h3>QFNU</h3> <h3>曲阜</h3> </template> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'QFNU', n: 0, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-条件渲染01.gif\",\"v-show\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>条件渲染v-show</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>当前的n值是:{{ n }}</h2> <button @click=\\\"n++\\\">点我n+1</button> <!-- 使用v-show做条件渲染 --> <h2 v-show=\\\"false\\\">欢迎来到{{name}}</h2> <h2 v-show=\\\"n===1\\\">欢迎来到{{name}}</h2> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'QFNU', n: 0, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-条件渲染02.gif\"]}]},\"/front-end/vue-notes/09-Vue%E6%A0%B8%E5%BF%83-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%9B%91%E8%A7%86.html\":{\"title\":\"Vue核心-列表渲染与数据监视\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/09-Vue核心-列表渲染与数据监视\"]},{\"header\":\"列表渲染\",\"slug\":\"列表渲染\",\"contents\":[]},{\"header\":\"基本列表\",\"slug\":\"基本列表\",\"contents\":[\"v-for 指令\",\"用于展示列表数据\",\"语法：<li v-for=\\\"(item, index) of items\\\" :key=\\\"index\\\">，这里 key 可以是 index，更好的是遍历对象的唯一标识，这里的 of 也可以用 in\",\"可遍历：数组、对象、字符串（用的少）、指定次数（用的少）\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>基本列表</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <!-- 遍历数组 --> <h3>人员列表（遍历数组）</h3> <ul> <li v-for=\\\"(p,index) of persons\\\" :key=\\\"index\\\">{{p.name}}-{{p.age}}</li> </ul> <!-- 遍历对象 --> <h3>汽车信息（遍历对象）</h3> <ul> <li v-for=\\\"(value,k) of car\\\" :key=\\\"k\\\">{{k}}-{{value}}</li> </ul> <!-- 遍历字符串 --> <h3>演示遍历字符串（用得少）</h3> <ul> <li v-for=\\\"(char,index) of str\\\" :key=\\\"index\\\">{{char}}-{{index}}</li> </ul> <!-- 遍历指定次数 --> <h3>演示遍历指定次数（用得少）</h3> <ul> <li v-for=\\\"(number,index) of 5\\\" :key=\\\"index\\\"> {{ index }}-{{ number }} </li> </ul> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { persons: [ { id: '001', name: '张三', age: 18 }, { id: '002', name: '李四', age: 19 }, { id: '003', name: '王五', age: 20 }, ], car: { name: '奥迪', price: '70万', color: '黑色', }, str: 'hello', }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视01.png\"]},{\"header\":\"key 的作用与原理\",\"slug\":\"key-的作用与原理\",\"contents\":[\"原理：\",\"Vue核心-列表渲染与数据监视02.jpg\",\"Vue核心-列表渲染与数据监视03.jpg\",\"面试题：react、vue 中的 key 有什么作用？（key 的内部原理）\",\"虚拟 DOM 中 key 的作用：key 是虚拟 DOM 中对象的标识，当数据发生变化时，Vue 会根据新数据生成新的虚拟 DOM，随后 Vue 进行新虚拟 DOM 与旧虚拟 DOM 的差异比较，比较规则如下： \",\"旧虚拟 DOM 中找到了与新虚拟 DOM 相同的 key \",\"若虚拟 DOM 中内容没变, 直接使用之前的真实 DOM\",\"若虚拟 DOM 中内容变了, 则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM\",\"旧虚拟 DOM 中未找到与新虚拟 DOM 相同的 key \",\"创建新的真实 DOM，随后渲染到到页面\",\"用 index 作为 key 可能会引发的问题 \",\"若对数据进行逆序添加、逆序删除等破坏顺序操作，会产生没有必要的真实 DOM 更新 ==> 界面效果没问题，但效率低\",\"若结构中还包含输入类的 DOM：会产生错误 DOM 更新 ==> 界面有问题\",\"开发中如何选择 key？ \",\"最好使用每条数据的唯一标识作为 key，比如 id、手机号、身份证号、学号等唯一值\",\"如果不存在对数据的逆序添加、逆序删除等破坏顺序的操作，仅用于渲染列表，使用 index 作为 key 是没有问题的\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>key的原理</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>人员列表（遍历数组）</h2> <button @click.once=\\\"add\\\">添加一个老刘</button> <ul> <li v-for=\\\"(p,index) of persons\\\" :key=\\\"index\\\"> {{p.name}}-{{p.age}} <input type=\\\"text\\\" /> </li> </ul> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false new Vue({ el: '#root', data: { persons: [ { id: '001', name: '张三', age: 18 }, { id: '002', name: '李四', age: 19 }, { id: '003', name: '王五', age: 20 }, ], }, methods: { add() { const p = { id: '004', name: '老刘', age: 40 } this.persons.unshift(p) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视04.gif\"]},{\"header\":\"列表过滤\",\"slug\":\"列表过滤\",\"contents\":[\"可以使用 watch 也可以使用计算属性，使用计算属性更加简单方便一点\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>列表过滤</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>人员列表</h2> <input type=\\\"text\\\" placeholder=\\\"请输入名字\\\" v-model=\\\"keyWord\\\" /> <ul> <li v-for=\\\"(p,index) of filPersons\\\" :key=\\\"p.id\\\"> {{p.name}}-{{p.age}}-{{p.sex}} </li> </ul> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { keyWord: '', persons: [ { id: '001', name: '马冬梅', age: 19, sex: '女' }, { id: '002', name: '周冬雨', age: 20, sex: '女' }, { id: '003', name: '周杰伦', age: 21, sex: '男' }, { id: '004', name: '温兆伦', age: 22, sex: '男' }, ], //用watch实现 //filPersons: [], }, //用watch实现 /*watch: { keyWord: { immediate: true, handler(val) { this.filPersons = this.persons.filter((p) => { return p.name.indexOf(val) !== -1 }) }, }, },*/ //用computed实现 computed: { filPersons() { return this.persons.filter((p) => { return p.name.indexOf(this.keyWord) !== -1 }) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视05.gif\"]},{\"header\":\"列表排序\",\"slug\":\"列表排序\",\"contents\":[\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>列表排序</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>人员列表</h2> <input type=\\\"text\\\" placeholder=\\\"请输入名字\\\" v-model=\\\"keyWord\\\" /> <button @click=\\\"sortType = 2\\\">年龄升序</button> <button @click=\\\"sortType = 1\\\">年龄降序</button> <button @click=\\\"sortType = 0\\\">原顺序</button> <ul> <li v-for=\\\"(p,index) of filPersons\\\" :key=\\\"p.id\\\"> {{p.name}}-{{p.age}}-{{p.sex}} </li> </ul> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { keyWord: '', sortType: 0, //0原顺序，1降序，2升序 persons: [ { id: '001', name: '马冬梅', age: 30, sex: '女' }, { id: '002', name: '周冬雨', age: 31, sex: '女' }, { id: '003', name: '周杰伦', age: 18, sex: '男' }, { id: '004', name: '温兆伦', age: 19, sex: '男' }, ], }, computed: { filPersons() { const arr = this.persons.filter((p) => { return p.name.indexOf(this.keyWord) !== -1 }) //判断是否需要排序 if (this.sortType) { arr.sort((p1, p2) => { return this.sortType === 1 ? p2.age - p1.age : p1.age - p2.age }) } return arr }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视06.gif\"]},{\"header\":\"Vue 数据监视\",\"slug\":\"vue-数据监视\",\"contents\":[\"更新时的一个问题：this.persons[0] = {id:'001',name:'马老师',age:50,sex:'男'} 更改 data 数据，Vue 不监听，模板不改变\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>更新时的一个问题</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>人员列表</h2> <button @click=\\\"updateMei\\\">更新马冬梅的信息</button> <ul> <li v-for=\\\"(p,index) of persons\\\" :key=\\\"p.id\\\"> {{p.name}}-{{p.age}}-{{p.sex}} </li> </ul> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { persons: [ { id: '001', name: '马冬梅', age: 30, sex: '女' }, { id: '002', name: '周冬雨', age: 31, sex: '女' }, { id: '003', name: '周杰伦', age: 18, sex: '男' }, { id: '004', name: '温兆伦', age: 19, sex: '男' }, ], }, methods: { updateMei() { // this.persons[0].name = '马老师' //奏效 // this.persons[0].age = 50 //奏效 // this.persons[0].sex = '男' //奏效 // this.persons[0] = {id:'001',name:'马老师',age:50,sex:'男'} //不奏效 this.persons.splice(0, 1, { id: '001', name: '马老师', age: 50, sex: '男', }) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视07.gif\",\"我们先来研究一下 Vue 是如何监测对象里面属性的改变的\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Vue监测数据改变的原理-对象</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器 --> <div id=\\\"root\\\"> <h2>学校名称：{{name }}</h2> <h2>学校地址：{{address}}</h2> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: '曲阜师范大学', address: '曲阜', }, }) </script> </body> </html> \",\"我们打开控制台，由于数据代理，data 中的数据最终会出现在 vm 身上\",\"Vue核心-列表渲染与数据监视08.png\",\"我们复习一下数据代理：\",\"Vue核心-MVVM模型与数据代理06.png\",\"Vue 将 data 中的数据拷贝了一份到 _data 属性中，其实在这一步之前还有一步，那就是对 data 中的数据进行加工\",\"若没有加工的过程，那么 _data 和 data 中的内容应该就是一模一样的, 而 _data 中内容如下图：\",\"Vue核心-列表渲染与数据监视09.png\",\"所谓加工简单来说就是把 data 中的每一组 key-value 都生成一个 getter 和 setter，那么为什么要加工 data 呢，因为这样可以做响应式：例如当我们修改了 data 中的 name 属性，name 的 setter 就会被调用，在 setter 中调用了一个方法，会重新解析模板，生成新的虚拟 DOM，然后 diff 算法对比，然后更新页面，从而实现对数据的监视\",\"我们来模拟一个数据监视（Vue 中实现的更加完善）\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>模拟数据监视</title> </head> <body> <script> let data = { name: '曲阜师范大学', address: '曲阜', } //创建一个监视的实例对象，用于监视data中属性的变化 const obs = new Observer(data) console.log(obs) // 准备一个vm实例对象 let vm = {} vm._data = data = obs function Observer(obj) { // 汇总对象中所有的属性形成一个数组 const keys = Object.keys(obj) console.log(keys) // 遍历 keys.forEach((k) => { Object.defineProperty(this, k, { get() { return obj[k] }, set(val) { console.log( `${k}被改了，我要去解析模板，生成虚拟DOM.....我要开始忙了` ) obj[k] = val }, }) }) } </script> </body> </html> \",\"Observer 构造函数会将 data 中的每个属性都添加到 Observer 实例对象中（通过 defineProperty()），并生成相应的 getter 和 setter，实现对 data 中属性的代理（data 是创建实例时传入的参数）\",\"效果：\",\"Vue核心-列表渲染与数据监视10.png\",\"存在两个问题：\",\"在 Vue 中还对 _data（data） 中的属性进行了代理，可以直接通过 vm.xxx 操作数据，而这里需要通过 vm._data.xxx 来操作数据\",\"只能监测一层数据，如果 data 中有对象，对象中还有属性，就监测不到\",\"下面我们认识一个 API：Vue.set()\",\"首先我们应该知道：读取一个对象中不存在的属性，是 undefined，不报错，如果一个属性值是 undefined，Vue 不会把他展示到页面上\",\"假设需要给某个对象添加一个新的属性（该属性一开始没有定下来，没有在源代码中写，后来随着用户的交互发现需要添加这么一个性别属性），如果直接在 vm._data.某对象 或者 vm 中添加该属性，是做不到响应式的，没有 getter 和 setter 方法，而通过 Vue.set() 或者 vm.$set() 方法，可以做到“后添加的数据也可以实现响应式“\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Vue.set的使用</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器 --> <div id=\\\"root\\\"> <h2>学校名称：{{name}}</h2> <h2>学校地址：{{address}}</h2> <hr /> <h1>学生信息</h1> <button @click=\\\"addSex\\\">添加一个性别，默认值男</button> <h2>学生姓名：{{student.name}}</h2> <h2 v-if=\\\"student.sex\\\">学生性别：{{student.sex}}</h2> <h2>学生年龄：真实{{student.age.rAge}}，对外{{student.age.sAge}}</h2> <h2>朋友们</h2> <ul> <li v-for=\\\"(f,index) in student.friends\\\" :key=\\\"index\\\"> {{f.name}}--{{f.age}} </li> </ul> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: '曲阜师范大学', address: '曲阜', student: { name: 'tom', age: { rAge: 21, sAge: 18, }, friends: [ { name: 'jerry', age: 23 }, { name: 'tony', age: 24 }, ], }, }, methods: { addSex() { //Vue.set(this.student, 'sex', '男') this.$set(this.student, 'sex', '男') }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视11.gif\",\"接下来我们研究一下 Vue 是如何监测数组里面属性的改变的\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Vue监测数据改变的原理-数组</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>学校名称：{{name}}</h2> <h2>学校地址：{{address}}</h2> <hr /> <h1>学生信息</h1> <button @click=\\\"addSex\\\">添加一个性别，默认值男</button> <h2>学生姓名：{{student.name}}</h2> <h2 v-if=\\\"student.sex\\\">学生性别：{{student.sex}}</h2> <h2>学生年龄：真实{{student.age.rAge}}，对外{{student.age.sAge}}</h2> <h2>朋友们</h2> <ul> <li v-for=\\\"(f,index) in student.friends\\\" :key=\\\"index\\\"> {{f.name}}--{{f.age}} </li> </ul> <h2>爱好</h2> <ul> <li v-for=\\\"(h,index) in student.hobby\\\" :key=\\\"index\\\">{{h}}</li> </ul> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: '曲阜师范大学', address: '曲阜', student: { name: 'tom', age: { rAge: 21, sAge: 18, }, hobby: ['唱', '跳', 'rap'], friends: [ { name: 'jerry', age: 23 }, { name: 'tony', age: 24 }, ], }, }, methods: { addSex() { //Vue.set(this.student, 'sex', '男') this.$set(this.student, 'sex', '男') }, }, }) </script> </body> </html> \",\"我们在控制台中会发现：\",\"Vue 核心-列表渲染与数据监视12.png\",\"数组中的数据并没有 getter 和 setter 方法，这也就解释了上面的更新数组的问题\",\"总结\",\"vue 会监视 data 中所有层次的数据\",\"如何监测对象中的数据？通过 setter 实现监视，且要在 new Vue() 时就传入要监测的数据 \",\"对象创建后追加的属性，Vue 默认不做响应式处理\",\"如需给后添加的属性做响应式，请使用如下 API Vue.set(target,propertyName/index,value) 或 vm.$set(target,propertyName/index,value)\",\"如何监测数组中的数据？ 通过包裹数组更新元素的方法实现，本质就是做了两件事 \",\"调用原生对应的方法对数组进行更新\",\"重新解析模板，进而更新页面\",\"在 Vue 修改数组中的某个元素一定要用如下方法 \",\"push() 、pop() 、unshift()、shift()、splice()、sort()、reverse() ，这几个方法被 Vue 重写了\",\"Vue.set() 或 vm.$set()，特别注意：Vue.set() 和 vm.$set() 不能给 vm 或 vm 的根数据对象（data 等）添加属性\",\"综合案例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>总结数据监视</title> <style> button { margin-top: 10px; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h1>学生信息</h1> <button @click=\\\"student.age++\\\">年龄+1岁</button> <br /> <button @click=\\\"addSex\\\">添加性别属性，默认值：男</button> <br /> <button @click=\\\"student.sex = '未知' \\\">修改性别</button> <br /> <button @click=\\\"addFriend\\\">在列表首位添加一个朋友</button> <br /> <button @click=\\\"updateFirstFriendName\\\"> 修改第一个朋友的名字为：张三 </button> <br /> <button @click=\\\"addHobby\\\">添加一个爱好</button> <br /> <button @click=\\\"updateHobby\\\">修改第一个爱好为：开车</button> <br /> <button @click=\\\"removeSmoke\\\">过滤掉爱好中的rap</button> <br /> <h3>姓名：{{ student.name }}</h3> <h3>年龄：{{ student.age }}</h3> <h3 v-if=\\\"student.sex\\\">性别：{{student.sex}}</h3> <h3>爱好：</h3> <ul> <li v-for=\\\"(h,index) in student.hobby\\\" :key=\\\"index\\\">{{ h }}</li> </ul> <h3>朋友们：</h3> <ul> <li v-for=\\\"(f,index) in student.friends\\\" :key=\\\"index\\\"> {{ f.name }}--{{ f.age }} </li> </ul> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { student: { name: 'tom', age: 18, hobby: ['唱', '跳', 'rap'], friends: [ { name: 'jerry', age: 35 }, { name: 'tony', age: 36 }, ], }, }, methods: { addSex() { // Vue.set(this.student,'sex','男') this.$set(this.student, 'sex', '男') }, addFriend() { this.student.friends.unshift({ name: 'jack', age: 70 }) }, updateFirstFriendName() { this.student.friends[0].name = '张三' }, addHobby() { this.student.hobby.push('学习') }, updateHobby() { // this.student.hobby.splice(0,1,'开车') // Vue.set(this.student.hobby,0,'开车') this.$set(this.student.hobby, 0, '开车') }, removeSmoke() { this.student.hobby = this.student.hobby.filter((h) => { return h !== 'rap' }) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue 核心-列表渲染与数据监视13.gif\"]}]},\"/front-end/vue-notes/10-Vue%E6%A0%B8%E5%BF%83-%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE.html\":{\"title\":\"Vue核心-收集表单数据\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/10-Vue核心-收集表单数据\"]},{\"header\":\"收集表单数据\",\"slug\":\"收集表单数据\",\"contents\":[\"收集表单数据\",\"若 <input type=\\\"text\\\"/>，则 v-model 收集的是 value 值，用户输入的内容就是 value 值\",\"若 <input type=\\\"radio\\\"/>，则 v-model 收集的是 value 值，且要给标签配置 value 属性\",\"若 <input type=\\\"checkbox\\\"/>\",\"没有配置 value 属性，那么收集的是 checked 属性（勾选 or 未勾选，是布尔值）\",\"配置了 value 属性 \",\"v-model 的初始值是非数组，那么收集的就是 checked（勾选 or 未勾选，是布尔值）\",\"v-model 的初始值是数组，那么收集的就是 value 组成的数组\",\"v-model 的三个修饰符：\",\"lazy 失去焦点后再收集数据\",\"number 输入字符串转为有效的数字\",\"trim 输入首尾空格过滤\",\"form 表单中 @submit.prevent 作用方法\",\"<form @submit.prevent=\\\"Demo\\\"></form> \",\"submit：表示通常与 form 联合使用，在表单中有提交或按钮，立马触发后面紧跟的方法\",\".prevent：表示阻止默认事件的修饰符，提交以后不会刷新页面。阻止默认事件就是指有些标签本身会存在事件，如 a 标签的跳转，form 表单中的 submit 按钮的提交事件等，某些时候想执行自己设置的事件，这个时候就需要阻止标签的默认事件的执行。在 Vue 中，只需要使用 .prevent 修饰符就可以\",\"注：.prevent 不一定非要跟 submit 绑定在一起\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>收集表单数据</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <form @submit.prevent=\\\"test\\\"> 账号：<input type=\\\"text\\\" v-model.trim=\\\"userInfo.account\\\" /><br /> 密码：<input type=\\\"password\\\" v-model=\\\"userInfo.passWord\\\" /><br /> 年龄：<input type=\\\"number\\\" v-model.number=\\\"userInfo.age\\\" /><br /> 性别：<br /> 男<input type=\\\"radio\\\" v-model=\\\"userInfo.sex\\\" value=\\\"male\\\" /> 女<input type=\\\"radio\\\" v-model=\\\"userInfo.sex\\\" value=\\\"female\\\" /><br /> 爱好：<br /> 学习<input type=\\\"checkbox\\\" v-model=\\\"userInfo.hobby\\\" value=\\\"study\\\" /> 打游戏<input type=\\\"checkbox\\\" v-model=\\\"userInfo.hobby\\\" value=\\\"game\\\" /> 吃饭<input type=\\\"checkbox\\\" v-model=\\\"userInfo.hobby\\\" value=\\\"eat\\\" /> <br /> 所属校区: <br /> <select v-model=\\\"userInfo.area\\\"> <option value=\\\"\\\">请选择校区</option> <option value=\\\"QuFuL\\\">曲阜老校区</option> <option value=\\\"QuFuX\\\">曲阜新校区</option> <option value=\\\"RiZhao\\\">日照校区</option> </select> <br /> 其他信息：<br /> <textarea v-model.lazy=\\\"userInfo.other\\\"></textarea> <br /> <input type=\\\"checkbox\\\" v-model=\\\"userInfo.agree\\\" />阅读并接受 <a href=\\\"https://www.qfnu.edu.cn\\\">《用户协议》</a> <br /> <button>提交</button> </form> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { userInfo: { account: '', passWord: '', age: 18, sex: 'female', hobby: [], area: '', other: '', agree: '', }, }, methods: { test() { console.log(JSON.stringify(this.userInfo)) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-收集表单数据01.png\"]}]},\"/front-end/vue-notes/11-Vue%E6%A0%B8%E5%BF%83-%E8%BF%87%E6%BB%A4%E5%99%A8.html\":{\"title\":\"Vue核心-过滤器\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/11-Vue核心-过滤器\"]},{\"header\":\"过滤器 (Vue 3 已经移除)\",\"slug\":\"过滤器-vue-3-已经移除\",\"contents\":[\"定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）\",\"注册过滤器：Vue.filter(name, callback) 全局过滤器new Vue {filters: {}} 局部过滤器\",\"使用过滤器：{{ xxx | 过滤器名}} 或 v-bind:属性 = \\\"xxx | 过滤器名\\\"\",\"备注：\",\"过滤器可以接收额外参数，多个过滤器也可以串联\",\"并没有改变原本的数据，而是产生新的对应的数据\",\"处理时间的库：moment 体积较大，dayjs 轻量级\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>过滤器</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> <!-- //引入dayjs库 --> <script src=\\\"https://cdn.bootcdn.net/ajax/libs/dayjs/1.11.7/dayjs.min.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>时间</h2> <h3>当前时间戳：{{time}}</h3> <h3>转换后的时间：{{time|timeFilter()}}</h3> <h3>转换后的时间：{{time|timeFilter('YYYY-MM-DD HH:mm:ss')}}</h3> <h3>截取年月日：{{time|timeFilter() | mySlice}}</h3> </div> <script> Vue.config.productionTip = false //全局过滤器 Vue.filter('mySlice', function (value) { return value.slice(0, 11) }) new Vue({ el: '#root', data: { time: 1683621034195, }, //局部过滤器 filters: { timeFilter(value, str = 'YYYY年MM月DD日HH:mm:ss') { return dayjs(value).format(str) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-过滤器01.png\"]}]},\"/front-end/vue-notes/12-Vue%E6%A0%B8%E5%BF%83-%E5%86%85%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4.html\":{\"title\":\"Vue核心-内置指令与自定义指令\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/12-Vue核心-内置指令与自定义指令\"]},{\"header\":\"内置指令\",\"slug\":\"内置指令\",\"contents\":[\"常用的内置指令： v-bind 单向绑定解析表达式，可简写为 :v-model 双向数据绑定v-for 遍历数组 / 对象 / 字符串v-on 绑定事件监听，可简写为 @v-show 条件渲染 (动态控制节点是否展示)v-if 条件渲染（动态控制节点是否存在）v-else-if 条件渲染（动态控制节点是否存在）v-else 条件渲染（动态控制节点是否存在）\"]},{\"header\":\"v-text 指令\",\"slug\":\"v-text-指令\",\"contents\":[\"v-text 指令\",\"作用：向其所在的节点中渲染文本内容\",\"与插值语法的区别：v-text 会替换掉节点中的内容，{{xxx}} 则不会，更灵活\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>v-text指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <div>你好，{{name}}</div> <div v-text=\\\"name\\\"></div> <div v-text=\\\"str\\\"></div> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { name: 'zhf', str: '<h3>你好呀！</h3>', }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-内置指令与自定义指令01.png\"]},{\"header\":\"v-html 指令\",\"slug\":\"v-html-指令\",\"contents\":[\"作用：向指定节点中渲染包含 html 结构的内容\",\"与插值语法的区别：\",\"v-html 会替换掉节点中所有的内容，{{xxx}} 则不会\",\"v-html 可以识别 html 结构\",\"严重注意 v-html 有安全性问题！！！\",\"在网站上动态渲染任意 html 是非常危险的，容易导致 XSS 攻击\",\"一定要在可信的内容上使用 v-html，永远不要用在用户提交的内容上！！！\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>v-html指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <div>你好，{{name}}</div> <div v-html=\\\"str1\\\"></div> <div v-html=\\\"str2\\\"></div> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { name: 'zhf', str1: '<h3>你好呀！</h3>', str2: '<a href=javascript:location.href=\\\"http://www.baidu.com?\\\"+document.cookie>兄弟我找到你想要的资源了，快来！</a>', }, }) </script> </body> </html> \",\"我们在 cookie 中存放如下数据\",\"Vue核心-内置指令与自定义指令02.png\",\"点击案例中的链接就可以获取\",\"效果：\",\"Vue核心-内置指令与自定义指令03.gif\"]},{\"header\":\"v-cloak 指令\",\"slug\":\"v-cloak-指令\",\"contents\":[\"v-cloak 指令（没有值）\",\"本质是一个特殊属性，Vue 实例创建完毕并接管容器后，会删掉 v-cloak 属性\",\"使用 CSS 配合 v-cloak 可以解决网速慢时页面展示出 {{xxx}} 的问题\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>v-cloak指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> <style> [v-cloak] { display: none; } </style> </head> <body> <div id=\\\"root\\\"> <!-- 如果网速慢则一开始不显示 --> <h2 v-cloak>{{name}}</h2> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { name: 'zhf', }, }) </script> </body> </html> \"]},{\"header\":\"v-once 指令\",\"slug\":\"v-once-指令\",\"contents\":[\"v-once 所在节点在初次动态渲染后，就视为静态内容了\",\"以后数据的改变不会引起 v-once 所在结构的更新，可以用于优化性能\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>v-once指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2 v-once>初始化的n值是：{{n}}</h2> <h2>当前的n值是：{{n}}</h2> <button @click=\\\"n++\\\">点我n+1</button> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { n: 1, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-内置指令与自定义指令04.gif\"]},{\"header\":\"v-pre 指令\",\"slug\":\"v-pre-指令\",\"contents\":[\"跳过 v-pre 所在节点的编译过程\",\"可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>v-pre指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2 v-pre>Vue其实很简单</h2> <h2>当前的n值是:{{n}}</h2> <button @click=\\\"n++\\\">点我n+1</button> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { n: 1, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-内置指令与自定义指令05.gif\"]},{\"header\":\"自定义指令\",\"slug\":\"自定义指令\",\"contents\":[\"directives\"]},{\"header\":\"定义语法\",\"slug\":\"定义语法\",\"contents\":[]},{\"header\":\"局部指令\",\"slug\":\"局部指令\",\"contents\":[\"new Vue({ directives:{ 指令名:配置对象 } }) \",\"或\",\"new Vue({ directives:{ 指令名:回调函数 } }) \",\"例：\",\"directives : { 'my-directive' : { bind (el, binding) { el.innerHTML = binding.value.toupperCase() } } } \"]},{\"header\":\"全局指令\",\"slug\":\"全局指令\",\"contents\":[\"Vue.directive(指令名, 配置对象) \",\"或\",\"Vue.directive(指令名, 回调函数) \",\"例：\",\"Vue.directive('my-directive', function(el, binding){ el.innerHTML = binding.value.toupperCase() }) \"]},{\"header\":\"配置对象中常用的3个回调函数\",\"slug\":\"配置对象中常用的3个回调函数\",\"contents\":[\"bind (element, binding) 指令与元素成功绑定时调用\",\"inserted (element, binding) 指令所在元素被插入页面时调用\",\"update(element, binding) 指令所在模板结构被重新解析时调用\",\"element 就是 DOM 元素，binding 就是要绑定的对象，它包含以下属性：name 、value、oldValue、expression、arg、modifiers\",\"例：\",\"Vue.directive('fbind', { // 指令与元素成功绑定时（一上来） bind(element, binding) { // element就是DOM元素，binding就是要绑定的 element.value = binding.value }, // 指令所在元素被插入页面时 inserted(element, binding) { element.focus() }, // 指令所在的模板被重新解析时 update(element, binding) { element.value = binding.value } }) \"]},{\"header\":\"注意\",\"slug\":\"注意\",\"contents\":[\"指令定义时不加 v-，但使用时要加 v-\",\"指令名如果是多个单词，要使用 kebab-case 命名方式，不要用 camelCase 命名\"]},{\"header\":\"使用指令\",\"slug\":\"使用指令\",\"contents\":[\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>自定义指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>当前n值是：<span v-text=\\\"n\\\"></span></h2> <h2>放大10倍后的n值是：<span v-big=\\\"n\\\"></span></h2> <button @click=\\\"n++\\\">点我n+1</button> <hr /> <input type=\\\"text\\\" v-fbind:value=\\\"n\\\" /> </div> <script> Vue.config.productionTip = false //定义全局指令 /*Vue.directive('fbind', { //指令与元素成功绑定时（一上来） bind(element, binding) { element.value = binding.value }, //指令所在元素被插入页面时 inserted(element, binding) { element.focus() }, //指令所在的模板被重新解析时 update(element, binding) { element.value = binding.value }, })*/ new Vue({ el: '#root', data: { n: 1, }, directives: { //big函数何时会被调用？ //1.指令与元素成功绑定时（一上来） //2.指令所在的模板被重新解析时 big(element, binding) { //console.log('big', this) //注意此处的this是window element.innerText = binding.value * 10 }, fbind: { //指令与元素成功绑定时（一上来） bind(element, binding) { element.value = binding.value }, //指令所在元素被插入页面时 inserted(element, binding) { element.focus() }, //指令所在的模板被重新解析时 update(element, binding) { element.value = binding.value }, }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-内置指令与自定义指令06.gif\"]}]},\"/front-end/vue-notes/13-Vue%E6%A0%B8%E5%BF%83-Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html\":{\"title\":\"Vue核心-Vue生命周期\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/13-Vue核心-Vue生命周期\"]},{\"header\":\"1. 引出生命周期\",\"slug\":\"_1-引出生命周期\",\"contents\":[\"生命周期：\",\"又名生命周期回调函数、生命周期函数、生命周期钩子\",\"是什么：Vue 在关键时刻帮我们调用的一些特殊名称的函数\",\"生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的\",\"生命周期函数中的 this 指向是 vm 或组件实例对象\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>引出生命周期</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2 v-if=\\\"a\\\">你好啊</h2> <h2 :style=\\\"{opacity}\\\">看笔记学Vue</h2> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { a: false, opacity: 1, }, methods: {}, // Vue 完成模板的解析并把初始的真实 DOM 元素放入页面后（挂载完毕）调用 mounted mounted() { console.log('mounted', this) setInterval(() => { this.opacity -= 0.01 if (this.opacity <= 0) this.opacity = 1 }, 16) }, }) // 通过外部的定时器实现（不推荐） // setInterval(() => { // vm.opacity -= 0.01 // if(vm.opacity <= 0) vm.opacity = 1 // },16) </script> </body> </html> \",\"效果：\",\"Vue核心-Vue生命周期01.gif\"]},{\"header\":\"2. 分析生命周期\",\"slug\":\"_2-分析生命周期\",\"contents\":[\"初始化显示 \",\"beforeCreate()\",\"created()\",\"beforeMount()\",\"mounted()\",\"更新状态 \",\"beforeUpdate()\",\"updated()\",\"销毁 Vue 实例：vm.$destory()\",\"beforeDestory()\",\"destoryed()\",\"Vue核心-Vue生命周期02.png\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>分析生命周期</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\" :x=\\\"n\\\"> <h2>当前的n值是：{{n}}</h2> <button @click=\\\"add\\\">点我n+1</button> <button @click=\\\"bye\\\">点我销毁</button> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { n: 1, }, methods: { add() { console.log('add') this.n++ }, bye() { console.log('bye') this.$destroy() }, }, watch: { n() { console.log('n变了') }, }, beforeCreate() { console.log('beforeCreate') }, created() { console.log('created') }, beforeMount() { console.log('beforeMount') }, mounted() { console.log('mounted') }, beforeUpdate() { console.log('beforeUpdate') }, updated() { console.log('updated') }, beforeDestroy() { console.log('beforeDestroy') }, destroyed() { console.log('destroyed') }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-Vue生命周期03.gif\"]},{\"header\":\"3. 总结生命周期\",\"slug\":\"_3-总结生命周期\",\"contents\":[\"常用的生命周期钩子：\",\"mounted 发送 ajax 请求、启动定时器、绑定自定义事件、订阅消息等初始化操作\",\"beforeDestroy 清除定时器、解绑自定义事件、取消订阅消息等收尾工作\",\"关于销毁 Vue 实例：\",\"销毁后借助 Vue 开发者工具看不到任何信息\",\"销毁后自定义事件会失效，但原生 DOM 事件依然有效\",\"一般不会在 beforeDestroy 操作数据，因为即便操作数据，也不会再触发更新流程了\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>总结生命周期</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2 :style=\\\"{opacity}\\\">欢迎学习Vue</h2> <button @click=\\\"opacity = 1\\\">透明度设置为1</button> <button @click=\\\"stop\\\">点我停止变换</button> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false new Vue({ el: '#root', data: { opacity: 1, }, methods: { stop() { this.$destroy() }, }, // Vue完成模板的解析并把初始的真实DOM元素放入页面后（挂载完毕）调用mounted mounted() { console.log('mounted', this) this.timer = setInterval(() => { console.log('setInterval') this.opacity -= 0.01 if (this.opacity <= 0) this.opacity = 1 }, 16) }, beforeDestroy() { clearInterval(this.timer) console.log('vm即将驾鹤西游了') }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-Vue生命周期04.gif\"]}]},\"/front-end/vue-notes/14-Vue%E6%A0%B8%E5%BF%83-Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B.html\":{\"title\":\"Vue核心-Vue组件化编程\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/14-Vue核心-Vue组件化编程\"]},{\"header\":\"1. 模块与组件、模块化与组件化\",\"slug\":\"_1-模块与组件、模块化与组件化\",\"contents\":[\"Vue核心-Vue组件化编程01.png\",\"Vue核心-Vue组件化编程02.png\"]},{\"header\":\"1.1 模块\",\"slug\":\"_1-1-模块\",\"contents\":[\"理解：向外提供特定功能的 js 程序，一般就是一个 js 文件\",\"为什么：js 文件很多，很复杂\",\"作用：复用、简化 js 的编写，提高 js 运行效率\"]},{\"header\":\"1.2 组件\",\"slug\":\"_1-2-组件\",\"contents\":[\"定义：用来实现局部功能的代码和资源的集合（html/css/js/image…）\",\"为什么：一个界面的功能很复杂\",\"作用：复用编码，简化项目编码，提高运行效率\"]},{\"header\":\"1.3 模块化\",\"slug\":\"_1-3-模块化\",\"contents\":[\"当应用中的 js 都以模块来编写的，那这个应用就是一个模块化的应用\"]},{\"header\":\"1.4 组件化\",\"slug\":\"_1-4-组件化\",\"contents\":[\"当应用中的功能都是多组件的方式来编写的，那这个应用就是一个组件化的应用\"]},{\"header\":\"2. 非单文件组件\",\"slug\":\"_2-非单文件组件\",\"contents\":[\"非单文件组件：一个文件中包含有 n 个组件\",\"单文件组件：一个文件中只包含有 1 个组件\"]},{\"header\":\"2.1 基本使用\",\"slug\":\"_2-1-基本使用\",\"contents\":[\"Vue 中使用组件的三大步骤：\",\"定义组件 \",\"使用 Vue.extend(options) 创建，其中 options 和 new Vue(options) 时传入的 options 几乎一样，但也有点区别 \",\"el 不要写，因为最终所有的组件都要经过一个 vm 的管理，由 vm 中的 el 才决定服务哪个容器\",\"data 必须写成函数式，避免组件被复用时数据存在引用关系\",\"注册组件 \",\"局部注册：new Vue() 的时候 options 传入 components 选项\",\"全局注册：Vue.component('组件名',组件)\",\"使用组件 \",\"编写组件标签，如 <school></school>\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>基本使用</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器--> <div id=\\\"root\\\"> <hello></hello> <hr /> <h1>{{msg}}</h1> <hr /> <!-- 第三步：编写组件标签 --> <school></school> <hr /> <!-- 第三步：编写组件标签 --> <student></student> </div> <div id=\\\"root2\\\"> <hello></hello> </div> <script> Vue.config.productionTip = false //第一步：创建school组件 const school = Vue.extend({ template: ` <div class=\\\"demo\\\"> <h2>学校名称：{{schoolName}}</h2> <h2>学校地址：{{address}}</h2> <button @click=\\\"showName\\\">点我提示学校名</button> </div> `, // el:'#root', //组件定义时，一定不要写el配置项，因为最终所有的组件都要被一个vm管理，由vm决定服务于哪个容器。 data() { return { schoolName: 'QFNU', address: '山东曲阜', } }, methods: { showName() { alert(this.schoolName) }, }, }) //第一步：创建student组件 const student = Vue.extend({ template: ` <div> <h2>学生姓名：{{studentName}}</h2> <h2>学生年龄：{{age}}</h2> </div> `, data() { return { studentName: '张三', age: 18, } }, }) //第一步：创建hello组件 const hello = Vue.extend({ template: ` <div> <h2>你好啊！{{name}}</h2> </div> `, data() { return { name: 'Tom', } }, }) //第二步：全局注册组件 Vue.component('hello', hello) //创建vm new Vue({ el: '#root', data: { msg: '你好啊！', }, //第二步：注册组件（局部注册） components: { school, student, }, }) new Vue({ el: '#root2', }) </script> </body> </html> \",\"效果：\",\"Vue核心-Vue组件化编程03.gif\"]},{\"header\":\"2.2 组件注意事项\",\"slug\":\"_2-2-组件注意事项\",\"contents\":[\"关于组件名：\",\"一个单词组成 \",\"第一种写法（首字母小写）：school\",\"第二种写法（首字母大写）：School\",\"多个单词组成 \",\"第一种写法（kebab-case 命名）：my-school\",\"第二种写法（CamelCase 命名）：MySchool（需要 Vue 脚手架支持）\",\"备注 \",\"组件名尽可能回避 HTML 中已有的元素名称，例如：h2、H2 都不行\",\"可以使用 name 配置项指定组件在开发者工具中呈现的名字\",\"关于组件标签：\",\"第一种写法：<school></school>\",\"第二种写法：<school/>（需要 Vue 脚手架支持）\",\"备注：不使用脚手架时，<school/> 会导致后续组件不能渲染\",\"一个简写方式：const school = Vue.extend(options) 可简写为 const school = options，因为父组件 components 引入的时候会自动创建\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>组件注意事项</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器--> <div id=\\\"root\\\"> <h1>{{msg}}</h1> <school></school> </div> <script> Vue.config.productionTip = false //定义组件 const s = Vue.extend({ name: 'qfnu', template: ` <div> <h2>学校名称：{{name}}</h2> <h2>学校地址：{{address}}</h2> </div> `, data() { return { name: 'QFNU', address: '山东', } }, }) new Vue({ el: '#root', data: { msg: '欢迎学习Vue!', }, components: { school: s, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-Vue组件化编程04.png\"]},{\"header\":\"2.3 组件的嵌套\",\"slug\":\"_2-3-组件的嵌套\",\"contents\":[\"Vue核心-Vue组件化编程05.png\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>组件的嵌套</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器--> <div id=\\\"root\\\"></div> <script> Vue.config.productionTip = false //定义student组件 const student = Vue.extend({ name: 'student', template: ` <div> <h2>学生姓名：{{name}}</h2> <h2>学生年龄：{{age}}</h2> </div> `, data() { return { name: 'zhf', age: 18, } }, }) //定义school组件 const school = Vue.extend({ name: 'school', template: ` <div> <h2>学校名称：{{name}}</h2> <h2>学校地址：{{address}}</h2> <student></student> </div> `, data() { return { name: 'QFNU', address: '山东', } }, //注册组件（局部） components: { student, }, }) //定义hello组件 const hello = Vue.extend({ template: `<h1>{{msg}}</h1>`, data() { return { msg: '欢迎来到QFNU学习！', } }, }) //定义app组件 const app = Vue.extend({ template: ` <div> <hello></hello> <school></school> </div> `, components: { school, hello, }, }) //创建vm new Vue({ template: '<app></app>', el: '#root', //注册组件（局部） components: { app, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-Vue组件化编程06.png\"]},{\"header\":\"2.4 VueComponent\",\"slug\":\"_2-4-vuecomponent\",\"contents\":[\"关于 VueComponent：\",\"school 组件本质是一个名为 VueComponent 的构造函数，且不是程序员定义的，而是 Vue.extend() 生成的\",\"我们只需要写 <school/> 或 <school></school>，Vue 解析时会帮我们创建 school 组件的实例对象，即 Vue 帮我们执行的 new VueComponent(options)\",\"每次调用 Vue.extend，返回的都是一个全新的 VueComponent，即不同组件是不同的对象\",\"关于 this 指向 \",\"组件配置中 data 函数、methods 中的函数、watch 中的函数、computed 中的函数它们的 this 均是 VueComponent 实例对象\",\"new Vue(options) 配置中：data 函数、methods 中的函数、watch 中的函数、computed 中的函数它们的 this 均是 Vue 实例对象\",\"VueComponent 的实例对象，以后简称 vc（组件实例对象），Vue 的实例对象，以后简称 vm\"]},{\"header\":\"2.5 一个重要的内置关系\",\"slug\":\"_2-5-一个重要的内置关系\",\"contents\":[\"Vue核心-Vue组件化编程07.png\",\"一个重要的内置关系：VueComponent.prototype.__proto__ === Vue.prototype\",\"为什么要有这个关系：让组件实例对象 vc 可以访问到 Vue原型 上的属性、方法\"]},{\"header\":\"3. 单文件组件\",\"slug\":\"_3-单文件组件\",\"contents\":[]},{\"header\":\"3.1 组成\",\"slug\":\"_3-1-组成\",\"contents\":[\"模板页面：\",\"<template> 页面模板 </template> \",\"JS 模块对象：\",\"<script> export default { data() {return {}}, methods: {}, computed: {}, components: {} } </script> \",\"样式：\",\"<style> 样式定义 </style> \"]},{\"header\":\"3.2 基本使用\",\"slug\":\"_3-2-基本使用\",\"contents\":[\"引入组件\",\"映射成标签\",\"使用组件标签\",\"School.vue\",\"<template> <div id='Demo'> <h2>学校名称：{{name}}</h2> <h2>学校地址：{{address}}</h2> <button @click=\\\"showName\\\">点我提示学校名</button> </div> </template> <script> export default { name:'School', data() { return { name:'QFNU', address:'曲阜' } }, methods: { showName(){ alert(this.name) } }, } </script> <style> #Demo{ background: orange; } </style> \",\"Student.vue\",\"<template> <div> <h2>学生姓名：{{name}}</h2> <h2>学生年龄：{{age}}</h2> </div> </template> <script> export default { name:'Student', data() { return { name:'zhf', age:21 } }, } </script> \",\"App.vue\",\"<template> <div> <School></School> <Student></Student> </div> </template> <script> import School from './School.vue' import Student from './Student.vue' export default { name:'App', components:{ School, Student } } </script> \",\"main.js\",\"import App from './App.vue' new Vue({ template:`<App></App>`, el:'#root', components:{App} }) \",\"index.html\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>单文件组件</title> </head> <body> <div id=\\\"root\\\"></div> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> <script src=\\\"./main.js\\\"></script> </body> </html> \",\"此时无法运行，应该使用脚手架才可以\"]},{\"header\":\"4. 组件化编码流程\",\"slug\":\"_4-组件化编码流程\",\"contents\":[\"拆分静态组件：组件要按照功能点拆分，命名不要与 html 元素冲突\",\"实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用\",\"一个组件在用：放在组件自身即可\",\"一些组件在用：放在他们共同的父组件上（状态提升）\",\"实现交互：从绑定事件开始\"]}]},\"/front-end/vue-notes/15-Vue%E6%A0%B8%E5%BF%83-%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB.html\":{\"title\":\"Vue核心-过渡与动画\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/15-Vue核心-过渡与动画\"]},{\"header\":\"1. Vue动画的理解\",\"slug\":\"_1-vue动画的理解\",\"contents\":[\"操作 CSS 的 transition 或 animation\",\"Vue 会给目标元素添加/移除特定的 class\"]},{\"header\":\"2. 基本过渡动画的编码\",\"slug\":\"_2-基本过渡动画的编码\",\"contents\":[\"在目标元素外包裹 <transition name=\\\"xxx\\\">\",\"定义 class 样式 \",\"指定过渡样式：transition\",\"指定隐藏时的样式：opacity/其它\"]},{\"header\":\"3. 过渡的类名\",\"slug\":\"_3-过渡的类名\",\"contents\":[\"xxx-enter-active：指定显示的 transition\",\"xxx-leave-active：指定隐藏的 transition\",\"xxx-enter：指定隐藏时的样式\",\"Vue核心-过渡与动画01.png\"]},{\"header\":\"4. 过渡代码演示\",\"slug\":\"_4-过渡代码演示\",\"contents\":[\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>过渡</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> <style> /* 显示/隐藏的过渡效果 */ .xxx-enter-active, .xxx-leave-active { transition: opacity 0.5s; } /* 隐藏时的样式 */ .xxx-enter, .xxx-leave-to { opacity: 0; } .move-enter-active { transition: all 1s; } .move-leave-active { transition: all 3s; } .move-enter, .move-leave-to { opacity: 0; transition: translateX(20px); } </style> </head> <body> <div id=\\\"demo1\\\"> <button @click=\\\"isShow=!isShow\\\">过渡1</button> <transition name=\\\"xxx\\\"> <p v-show=\\\"isShow\\\">学前端</p> </transition> </div> <div id=\\\"demo2\\\"> <button @click=\\\"isShow=!isShow\\\">过渡2</button> <transition name=\\\"move\\\"> <p v-show=\\\"isShow\\\">天天学前端</p> </transition> </div> <script> new Vue({ el: '#demo1', data() { return { isShow: true, } }, }) new Vue({ el: '#demo2', data: { isShow: true, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-过渡与动画02.gif\"]},{\"header\":\"5. 动画代码演示\",\"slug\":\"_5-动画代码演示\",\"contents\":[\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>动画</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> <style> .bounce-enter-active { animation: bounce-in 0.5s; } .bounce-leave-active { animation: bounce-in 0.5s reverse; } @keyframes bounce-in { 0% { transform: scale(0); } 50% { transform: scale(1.5); } 100% { transform: scale(1); } } </style> </head> <body> <div id=\\\"example-2\\\"> <button @click=\\\"show = !show\\\">Toggle show</button><br /> <transition name=\\\"bounce\\\"> <p v-if=\\\"show\\\" style=\\\"display: inline-block\\\">一直在学前端</p> </transition> </div> <script> new Vue({ el: '#example-2', data: { show: true, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-过渡与动画03.gif\"]},{\"header\":\"6. 使用第三方动画库\",\"slug\":\"_6-使用第三方动画库\",\"contents\":[\"第三方动画库 Animate.css\",\"安装第三方库： npm i animate.css\",\"使用：直接引用就可以 import 'animate.css'\",\"代码演示：\",\"<template> <div> <button @click=\\\"isShow = !isShow\\\">显示/隐藏</button> <transition-group appear name=\\\"animate__animated animate__bounce\\\" enter-active-class=\\\"animate__swing\\\" leave-active-class=\\\"animate__backOutUp\\\" > <h1 v-show=\\\"!isShow\\\" key=\\\"1\\\">你好啊！</h1> <h1 v-show=\\\"isShow\\\" key=\\\"2\\\">哈哈哈！</h1> </transition-group> </div> </template> <script> import 'animate.css' export default { name:'Test', data() { return { isShow:true } }, } </script> <style scoped> h1{ background-color: orange; } </style> \"]},{\"header\":\"7. 总结\",\"slug\":\"_7-总结\",\"contents\":[\"作用：在插入、更新或移除 DOM 元素时，在合适的时候给元素添加样式类名\",\"写法：\",\"准备好样式 \",\"元素进入的样式 \",\"v-enter 进入的起点\",\"v-enter-active 进入过程中\",\"v-enter-to 进入的终点\",\"元素离开的样式 \",\"v-leave 离开的起点\",\"v-leave-active 离开过程中\",\"v-leave-to 离开的终点\",\"使用 <transition> 包裹要过度的元素，并配置 name 属性，此时需要将上面样式名的 v 换为 name 的值\",\"要让页面一开始就显示动画，需要添加 appear\",\"备注：若有多个元素需要过度，则需要使用 <transition-group>，且每个元素都要指定 key 值\",\"<transition-group name=\\\"hello\\\" appear> <h1 v-show=\\\"!isShow\\\" key=\\\"1\\\">你好啊！</h1> <h1 v-show=\\\"isShow\\\" key=\\\"2\\\">哈哈哈！</h1> </transition-group> \"]}]},\"/front-end/vue-notes/16-VueCLI%E8%84%9A%E6%89%8B%E6%9E%B6.html\":{\"title\":\"VueCLI脚手架\",\"contents\":[{\"header\":\"1. 说明\",\"slug\":\"_1-说明\",\"contents\":[\"Vue 脚手架是 Vue 官方提供的标准化开发工具（开发平台）\",\"文档 Vue CLI\"]},{\"header\":\"2. 具体步骤\",\"slug\":\"_2-具体步骤\",\"contents\":[\"如果下载缓慢请配置 npm 淘宝镜像\",\"npm config set registry http://registry.npm.taobao.org \",\"全局安装 @vue/cli\",\"npm install -g @vue/cli \",\"切换到创建项目的目录，使用命令创建项目\",\"vue create xxx \",\"选择使用 vue 的版本\",\"启动项目\",\"npm run serve \",\"打包项目\",\"npm run build \",\"暂停项目 Ctrl+C\",\"注意：Vue 脚手架隐藏了所有 webpack 相关的配置，若想查看具体的 webpack 配置，请执行vue inspect > output.js\"]},{\"header\":\"3. 脚手架文件结构\",\"slug\":\"_3-脚手架文件结构\",\"contents\":[\".文件目录 ├── node_modules ├── public │ ├── favicon.ico: 页签图标 │ └── index.html: 主页面 ├── src │ ├── assets: 存放静态资源 │ │ └── logo.png │ │── component: 存放组件 │ │ └── HelloWorld.vue │ │── App.vue: 汇总所有组件 │ └── main.js: 入口文件 ├── .gitignore: git版本管制忽略的配置 ├── babel.config.js: babel的配置文件 ├── package.json: 应用包配置文件 ├── README.md: 应用描述文件 └── package-lock.json: 包版本控制文件 \",\"src/components/School.vue\",\"<template> <div class=\\\"demo\\\"> <h2>学校名称：{{ name }}</h2> <h2>学校地址：{{ address }}</h2> <button @click=\\\"showName\\\">点我提示学校名</button> </div> </template> <script> export default { name: \\\"School\\\", data() { return { name: \\\"QFNU\\\", address: \\\"曲阜\\\", }; }, methods: {showName() {alert(this.name);},}, }; </script> <style> .demo {background-color: orange;} </style> \",\"src/components/Student.vue\",\"<template> <div> <h2>学生姓名：{{ name }}</h2> <h2>学生年龄：{{ age }}</h2> </div> </template> <script> export default { name: \\\"Student\\\", data() { return { name: \\\"zhf\\\", age: 18, }; }, }; </script> \",\"src/App.vue\",\"<template> <div> <img src=\\\"./assets/logo.png\\\" alt=\\\"\\\"> <School></School> <Student></Student> </div> </template> <script> // 引入组件 import School from './components/School.vue' import Student from './components/Student.vue' export default { name:'App', components:{ School, Student } } </script> \",\"src/main.js\",\"// 该文件是整个项目的入口文件 import Vue from 'vue' // 引入Vue import App from './App.vue' // 引入App组件，它是所有组件的父组件 Vue.config.productionTip = false new Vue({ el:'#app', render: h => h(App), // render函数完成了这个功能：将App组件放入容器中 })// .$mount('#app') \",\"public/index.html\",\"<!DOCTYPE html> <html lang=\\\"\\\"> <head> <meta charset=\\\"UTF-8\\\"> <!-- 针对IE浏览器的特殊配置，含义是让IE浏览器以最高渲染级别渲染页面 --> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <!-- 开启移动端的理想端口 --> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <!-- 配置页签图标 <%= BASE_URL %> 是public所在路径，使用绝对路径 --> <link rel=\\\"icon\\\" href=\\\" <%= BASE_URL %> favicon.ico\\\"> <!-- 配置网页标题 --> <title> <%= htmlWebpackPlugin. options. title %> </title> </head> <body> <!-- 当浏览器不支持js时，noscript中的元素就会被渲染 --> <noscript> <strong>We're sorry but <%= htmlWebpackPlugin. options. title %> doesn't work properly without JavaScript enabled. Please enable it to continue.</strong> </noscript> <!-- 容器 --> <div id=\\\"app\\\"></div> </body> </html> \"]},{\"header\":\"4. render函数\",\"slug\":\"_4-render函数\",\"contents\":[\"render 是一个函数，应用于残缺版 vue, 能够接收参数 createElement (类型是一个函数)，借助它来渲染内容\",\"render(createElement){ //createElement创建标签<h1>你好啊</h1> return createElement('h1','你好啊') } \",\"简写为：\",\"render p=>p('h1','你好啊') // 如果只有模板的话可直接写为如下格式 render p=>p(App) //App是以一个模板的名称 \",\"import Vue from 'vue' import App from './App.vue' Vue.config.productionTip = false new Vue({ el:'#app', // render函数功能：将App组件放入容器中 // 简写形式 render: h => h(App), // 完整形式 // render(createElement){ // return createElement(App) // } }) \"]},{\"header\":\"5. 关于不同版本的函数\",\"slug\":\"_5-关于不同版本的函数\",\"contents\":[\"vue.js 与 vue.runtime.xxx.js 的区别 \",\"vue.js 是完整版的 Vue，包含：核心功能+模板解析器\",\"vue.runtime.xxx.js 是运行版的 Vue，只包含核心功能，没有模板解析器\",\"因为 vue.runtime.xxx.js 没有模板解析器，所以不能使用 template 配置项，需要使用 render 函数接收到的 createElement 函数去指定具体内容\"]},{\"header\":\"6. vue.config.js配置文件\",\"slug\":\"_6-vue-config-js配置文件\",\"contents\":[\"vue inspect > output.js命令可以查看到 Vue 脚手架的默认配置\",\"使用 vue.config.js 可以对脚手架进行个性化定制，和 package.json 同级目录，详见 配置参考 | Vue CLI\",\"module.exports = { pages: { index: { entry: 'src/main.js' // 入口 } }, lintOnSave: false // 关闭语法检查 } \"]}]},\"/front-end/vue-notes/17-Vue%E6%A0%B8%E5%BF%83-%E5%85%B6%E5%AE%83%E5%B0%8F%E7%9F%A5%E8%AF%86.html\":{\"title\":\"Vue核心-其它小知识\",\"contents\":[{\"header\":\"1. ref属性\",\"slug\":\"_1-ref属性\",\"contents\":[\"ref 被用来给元素或子组件注册引用信息（id 的替代者）\",\"应用在 html 标签上获取的是真实 DOM 元素，应用在组件标签上获取的是组件实例对象 vc\",\"使用方式 \",\"打标识：<h1 ref=\\\"xxx\\\"></h1> 或 <School ref=\\\"xxx\\\"></School>\",\"获取：this.$refs.xxx\",\"例：\",\"<template> <div> <h1 v-text=\\\"msg\\\" ref=\\\"title\\\"></h1> <button ref=\\\"btn\\\" @click=\\\"showDOM\\\">点我输出上方的DOM元素</button> <School ref=\\\"sch\\\"/> </div> </template> <script> import School from './components/School' export default { name:'App', components:{ School }, data() { return { msg:'欢迎学习Vue！' } }, methods: { showDOM(){ console.log(this.$refs.title) // 真实DOM元素 console.log(this.$refs.btn) // 真实DOM元素 console.log(this.$refs.sch) // School组件的实例对象（vc） } }, } </script> \"]},{\"header\":\"2. props配置项\",\"slug\":\"_2-props配置项\",\"contents\":[\"功能：props 让组件接收外部传过来的数据\",\"props 适用于：\",\"父组件 ==> 子组件 通信\",\"子组件 ==> 父组件 通信（要求父组件先给子组件一个函数）\"]},{\"header\":\"2.1 传递数据\",\"slug\":\"_2-1-传递数据\",\"contents\":[\"<Demo name=\\\"xxx\\\" :age=\\\"18\\\"/> 这里 age 前加 :，通过 v-bind 使得里面的 18 是数字，否则 Vue 会认为是字符串，即只有传递字符串时不加 :\"]},{\"header\":\"2.2 接收数据\",\"slug\":\"_2-2-接收数据\",\"contents\":[\"第一种方式（只接收）\",\"props:['name','age'] \",\"第二种方式（限制类型）\",\"props:{name:String, age:Number} \",\"第三种方式（限制类型、限制必要性、指定默认值）\",\"props: { name: { type: String, // 类型 required: true,// 必要性 default: 'cess'// 默认值 } } \",\"备注：props 是只读的，Vue 底层会监测你对 props 的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制 props 的内容到 data 中，然后去修改 data 中的数据\",\"src/App.vue\",\"<template> <div> <Student name=\\\"李四\\\" sex=\\\"女\\\" :age=\\\"18\\\"/> //传递数据 <Student name=\\\"王五\\\" sex=\\\"男\\\" :age=\\\"18\\\"/> //传递数据 </div> </template> <script> import Student from './components/Student' export default { name:'App', components:{ Student } } </script> \",\"src/components/Student.vue\",\"<template> <div> <h1>{{ msg }}</h1> <h2>学生姓名：{{ name }}</h2> <h2>学生性别：{{ sex }}</h2> <h2>学生年龄：{{ myAge + 1 }}</h2> <button @click=\\\"updateAge\\\">尝试修改收到的年龄</button> </div> </template> <script> export default { name: \\\"Student\\\", data() { console.log(this); return { msg: \\\"我是一个QFNU的学生\\\", myAge: this.age, }; }, methods: { updateAge() { this.myAge++; }, }, // 简单声明接收 // props:['name','age','sex'] // 接收的同时对数据进行类型限制 // props: { // name: String, // age: Number, // sex: String, // } // 接收的同时对数据：进行类型限制+默认值的指定+必要性的限制 props: { name: { type: String, //name的类型是字符串 required: true, //name是必要的 }, age: { type: Number, default: 99, //默认值 }, sex: { type: String, required: true, }, }, }; </script> \"]},{\"header\":\"3. mixin混入\",\"slug\":\"_3-mixin混入\",\"contents\":[\"功能：可以把多个组件共用的配置提取成一个混入对象\",\"使用方式：\",\"先定义混入\",\"const mixin = { data() {....}, methods: {....} .... } \",\"再使用混入\",\"全局混入 Vue.mixin(xxx)\",\"局部混入 mixins:['xxx']\",\"备注：组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”，在发生冲突时以组件优先\",\"var mixin = { data: function () { return { message: 'hello', foo: 'abc' } } } new Vue({ mixins: [mixin], data () { return { message: 'goodbye', bar: 'def' } }, created () { console.log(this.$data) // => { message: \\\"goodbye\\\", foo: \\\"abc\\\", bar: \\\"def\\\" } } }) \",\"同名生命周期钩子将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用\",\"var mixin = { created () { console.log('混入对象的钩子被调用') } } new Vue({ mixins: [mixin], created () { console.log('组件钩子被调用') } }) // => \\\"混入对象的钩子被调用\\\" // => \\\"组件钩子被调用\\\" \",\"src/mixin.js\",\"export const hunhe = { methods: { showName(){ alert(this.name) } }, mounted() { console.log('你好啊！') }, } export const hunhe2 = { data() { return { x:100, y:200 } }, } \",\"src/components/School.vue\",\"<template> <div> <h2 @click=\\\"showName\\\">学校名称：{{name}}</h2> <h2>学校地址：{{address}}</h2> </div> </template> <script> //引入一个hunhe import {hunhe,hunhe2} from '../mixin' export default { name:'School', data() { return { name:'QFNU', address:'山东', x:666 } }, mixins:[hunhe,hunhe2] // 局部混入 } </script> \",\"src/components/Student.vue\",\"<template> <div> <h2 @click=\\\"showName\\\">学生姓名：{{name}}</h2> <h2>学生性别：{{sex}}</h2> </div> </template> <script> import {hunhe,hunhe2} from '../mixin' export default { name:'Student', data() { return { name:'张三', sex:'男' } }, mixins:[hunhe,hunhe2] // 局部混入 } </script> \",\"src/App.vue\",\"<template> <div> <School/> <hr> <Student/> </div> </template> <script> import School from './components/School' import Student from './components/Student' export default { name:'App', components:{School,Student} } </script> \",\"src/main.js\",\"import Vue from 'vue' import App from './App.vue' // import {mixin} from './mixin' Vue.config.productionTip = false // Vue.mixin(hunhe) // 全局混合引入 // Vue.mixin(hunhe2) // 全局混合 new Vue({ el:\\\"#app\\\", render: h => h(App) }) \"]},{\"header\":\"4. plugin插件\",\"slug\":\"_4-plugin插件\",\"contents\":[\"功能：用于增强 Vue\",\"本质：包含 install 方法的一个对象，install 的第一个参数是 Vue，第二个以后的参数是插件使用者传递的数据\",\"定义插件（见下 src/plugin.js）\",\"使用插件：Vue.use()\",\"src/plugin.js\",\"export default { install(Vue,x,y,z){ console.log(x,y,z) //全局过滤器 Vue.filter('mySlice', function(value){return value.slice(0,4)}) //定义全局指令 Vue.directive('fbind',{ //指令与元素成功绑定时（一上来） bind(element,binding){element.value = binding.value}, //指令所在元素被插入页面时 inserted(element,binding){element.focus()}, //指令所在的模板被重新解析时 update(element,binding){element.value = binding.value} }) //定义混入 Vue.mixin({ data() {return {x:100,y:200}}, }) //给Vue原型上添加一个方法（vm和vc就都能用了） Vue.prototype.hello = ()=>{alert('你好啊')} } } \",\"src/main.js\",\"import Vue from 'vue' import App from './App.vue' import plugins from './plugins' // 引入插件 Vue.config.productionTip = false Vue.use(plugins,1,2,3) // 应用（使用）插件 new Vue({ el:'#app', render: h => h(App) }) \",\"src/components/School.vue\",\"<template> <div> <h2>学校名称：{{ name | mySlice }}</h2> <h2>学校地址：{{ address }}</h2> <button @click=\\\"test\\\">点我测试一个hello方法</button> </div> </template> <script> export default { name:'School', data() { return { name:'曲阜师范大学QFNU', address:'山东', } }, methods: { test(){ this.hello() } }, } </script> \",\"src/components/Student.vue\",\"<template> <div> <h2>学生姓名：{{ name }}</h2> <h2>学生性别：{{ sex }}</h2> <input type=\\\"text\\\" v-fbind:value=\\\"name\\\"> </div> </template> <script> export default { name:'Student', data() { return { name:'张三', sex:'男' } }, } </script> \"]},{\"header\":\"5. scoped样式\",\"slug\":\"_5-scoped样式\",\"contents\":[\"作用：让样式在局部生效，防止冲突\",\"写法：<style scoped>\",\"src/components/School.vue\",\"<template> <div class=\\\"demo\\\"> <h2 class=\\\"title\\\">学校名称：{{ name }}</h2> <h2>学校地址：{{ address }}</h2> </div> </template> <script> export default { name:'School', data() { return { name:'曲阜师范大学QFNU', address:'山东', } } } </script> <style scoped> .demo{ background-color: skyblue; } </style> \",\"src/components/Student.vue\",\"<template> <div class=\\\"demo\\\"> <h2 class=\\\"title\\\">学生姓名：{{ name }}</h2> <h2 class=\\\"atguigu\\\">学生性别：{{ sex }}</h2> </div> </template> <script> export default { name: 'Student', data() { return { name: '张三', sex: '男' } } } </script> <style lang=\\\"less\\\" scoped> .demo { background-color: pink; .atguigu { font-size: 40px; } } </style> \",\"src/App.vue\",\"<template> <div> <h1 class=\\\"title\\\">你好啊</h1> <School/> <Student/> </div> </template> <script> import Student from './components/Student' import School from './components/School' export default { name: 'App', components: { School, Student } } </script> <style scoped> .title { color: red; } </style> \"]},{\"header\":\"6. $nextTick\",\"slug\":\"_6-nexttick\",\"contents\":[\"这是一个生命周期钩子\",\"语法：this.$nextTick(回调函数)\",\"作用：在下一次 DOM 更新结束后执行其指定的回调\",\"什么时候用：当改变数据后，要基于更新后的新 DOM 进行某些操作时，要在 $nextTick 所指定的回调函数中执行\",\"比如：点击编辑按钮使文本变成表单且自动获取焦点\",\"点击表单时会用一个布尔值配合v-show使表单显示，可是改变布尔值的时候，后面的focus方法会跟着执行，然后再渲染模板\"]}]},\"/front-end/vue-notes/18-Vue%E6%A0%B8%E5%BF%83-slot%E6%8F%92%E6%A7%BD.html\":{\"title\":\"Vue核心-slot插槽\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"作用：<slot> 插槽让父组件可以向子组件指定位置插入 html 结构，也是一种组件间通信的方式，适用于 父组件 ===> 子组件\",\"分类：默认插槽、具名插槽、作用域插槽\"]},{\"header\":\"1. 默认插槽\",\"slug\":\"_1-默认插槽\",\"contents\":[\"父组件中：\",\"<Category> <div>html结构1</div> </Category> \",\"子组件中：\",\"<template> <div> <!-- 定义插槽 --> <slot>插槽默认内容...</slot> </div> </template> \",\"案例：\",\"src/App.vue\",\"<template> <div class=\\\"container\\\"> <Category title=\\\"美食\\\" > <img src=\\\"https://s3.ax1x.com/2021/01/16/srJlq0.jpg\\\" alt=\\\"\\\"> </Category> <Category title=\\\"游戏\\\" > <ul> <li v-for=\\\"(g,index) in games\\\" :key=\\\"index\\\">{{g}}</li> </ul> </Category> <Category title=\\\"电影\\\"> <video controls src=\\\"http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4\\\"></video> </Category> </div> </template> <script> import Category from './components/Category' export default { name:'App', components:{ Category }, data() { return { foods:['火锅','烧烤','小龙虾','牛排'], games:['红色警戒','穿越火线','劲舞团','超级玛丽'], films:['《教父》','《拆弹专家》','《你好，李焕英》','《尚硅谷》'] } }, } </script> <style scoped>.container{display: flex;justify-content: space-around;}</style> \",\"src/components/Category.vue\",\"<template> <div class=\\\"category\\\"> <h3>{{ title }}分类</h3> <!-- 定义一个插槽（挖个坑，等着组件的使用者进行填充） --> <slot>我是一些默认值，当使用者没有传递具体结构时，我会出现</slot> </div> </template> <script> export default { name:'Category', props:['title'] } </script> <style scoped> .category {background-color: skyblue;width: 200px;height: 300px;} h3 {text-align: center;background-color: orange;} video {width: 100%;} img {width: 100%;} </style> \",\"效果：\"]},{\"header\":\"2. 具名插槽\",\"slug\":\"_2-具名插槽\",\"contents\":[\"父组件指明放入子组件的哪个插槽 slot=\\\"footer\\\"，如果是 template 可以写成 v-slot:footer\",\"父组件中：\",\"<Category> <template slot=\\\"center\\\"> <div>html结构1</div> </template> <template v-slot:footer> <div>html结构2</div> </template> </Category> \",\"子组件中：\",\"<template> <div> <!-- 定义插槽 --> <slot name=\\\"center\\\">插槽默认内容...</slot> <slot name=\\\"footer\\\">插槽默认内容...</slot> </div> </template> \",\"案例：\",\"src/App.vue\",\"<template> <div class=\\\"container\\\"> <Category title=\\\"美食\\\" > <img slot=\\\"conter\\\" src=\\\"https://s3.ax1x.com/2021/01/16/srJlq0.jpg\\\" alt=\\\"\\\"> <a slot=\\\"footer\\\" href=\\\"http://www.atguigu.com\\\">更多美食</a> </Category> <Category title=\\\"游戏\\\" > <ul slot=\\\"center\\\"> <li v-for=\\\"(g,index) in games\\\" :key=\\\"index\\\">{{g}}</li> </ul> <div class=\\\"foot\\\" slot=\\\"footer\\\"> <a href=\\\"http://www.atguigu.com\\\">单机游戏</a> <a href=\\\"http://www.atguigu.com\\\">网络游戏</a> </div> </Category> <Category title=\\\"电影\\\"> <video slot=\\\"center\\\" controls src=\\\"http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4\\\"></video> <template v-slot:footer> <div class=\\\"foot\\\"> <a href=\\\"http://www.atguigu.com\\\">经典</a> <a href=\\\"http://www.atguigu.com\\\">热门</a> <a href=\\\"http://www.atguigu.com\\\">推荐</a> </div> <h4>欢迎前来观影</h4> </template> </Category> </div> </template> <script> import Category from './components/Category' export default { name:'App', components:{Category}, data() { return { foods:['火锅','烧烤','小龙虾','牛排'], games:['红色警戒','穿越火线','劲舞团','超级玛丽'], films:['《教父》','《拆弹专家》','《你好，李焕英》','《尚硅谷》'] } }, } </script> <style scoped> .container,.foot{display: flex;justify-content: space-around;} h4{text-align: center;} </style> \",\"src/components/Category.vue\",\"<template> <div class=\\\"category\\\"> <h3>{{title}}分类</h3> <!-- 定义一个插槽（挖个坑，等着组件的使用者进行填充） --> <slot name=\\\"center\\\">我是一些默认值，当使用者没有传递具体结构时，我会出现1</slot> <slot name=\\\"footer\\\">我是一些默认值，当使用者没有传递具体结构时，我会出现2</slot> </div> </template> <script> export default { name:'Category', props:['title'] } </script> <style scoped> .category{background-color: skyblue;width: 200px;height: 300px;} h3{text-align: center;background-color: orange;} video{width: 100%;} img{width: 100%;} </style> \"]},{\"header\":\"3. 作用域插槽\",\"slug\":\"_3-作用域插槽\",\"contents\":[\"scope 用于父组件往子组件插槽放的 html 结构接收子组件的数据\",\"理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定\",\"如：games 数据在 Category 组件中，但使用数据所遍历出来的结构由 App 组件决定\",\"父组件中：\",\"<Category> <template scope=\\\"scopeData\\\"> <!-- 生成的是ul列表 --> <ul> <li v-for=\\\"g in scopeData.games\\\" :key=\\\"g\\\">{{g}}</li> </ul> </template> </Category> <Category> <template slot-scope=\\\"scopeData\\\"> <!-- 生成的是h4标题 --> <h4 v-for=\\\"g in scopeData.games\\\" :key=\\\"g\\\">{{g}}</h4> </template> </Category> \",\"子组件中：\",\"<template> <div> <slot :games=\\\"games\\\"></slot> </div> </template> <script> export default { name:'Category', props:['title'], //数据在子组件自身 data() { return { games:['红色警戒','穿越火线','劲舞团','超级玛丽'] } }, } </script> \",\"注意：关于样式，既可以写在父组件中，解析后放入子组件插槽；也可以放在子组件中，传给子组件再解析\",\"案例：\",\"src/App.vue\",\"<template> <div class=\\\"container\\\"> <Category title=\\\"游戏\\\"> <template scope=\\\"atguigu\\\"> <ul> <li v-for=\\\"(g,index) in atguigu.games\\\" :key=\\\"index\\\">{{g}}</li> </ul> </template> </Category> <Category title=\\\"游戏\\\"> <template scope=\\\"{games}\\\"> <ol> <li style=\\\"color:red\\\" v-for=\\\"(g,index) in games\\\" :key=\\\"index\\\">{{g}}</li> </ol> </template> </Category> <Category title=\\\"游戏\\\"> <template slot-scope=\\\"{games}\\\"> <h4 v-for=\\\"(g,index) in games\\\" :key=\\\"index\\\">{{g}}</h4> </template> </Category> </div> </template> <script> import Category from './components/Category' export default { name:'App', components:{ Category }, } </script> <style scoped> .container,.foot{display: flex;justify-content: space-around;} h4{text-align: center;} </style> \",\"src/components/Category.vue\",\"<template> <div class=\\\"category\\\"> <h3>{{title}}分类</h3> <slot :games=\\\"games\\\" msg=\\\"hello\\\">我是默认的一些内容</slot> </div> </template> <script> export default { name:'Category', props:['title'], data() { return { games:['红色警戒','穿越火线','劲舞团','超级玛丽'], } }, } </script> <style scoped> .category{background-color: skyblue;width: 200px;height: 300px;} h3{text-align: center;background-color: orange;} video{width: 100%;} img{width: 100%;} </style> \"]}]},\"/front-end/vue-notes/\":{\"title\":\"Vue笔记\",\"contents\":[]},\"/software-tool/alist/01-%E5%AE%89%E5%8D%93%E7%AB%AF%E5%AE%89%E8%A3%85Alist.html\":{\"title\":\"安卓端安装Alist\",\"contents\":[{\"header\":\"安装 termux\",\"slug\":\"安装-termux\",\"contents\":[\"从 F-Droid 下载 termux 和 Termux:Widget\",\"更换清华源：termux | 镜像站使用帮助 | 清华大学开源软件镜像站\"]},{\"header\":\"安装 Alist\",\"slug\":\"安装-alist\",\"contents\":[\"在 termux 中输入如下命令：\",\"apt update && apt install alist \",\"安装成功后输入如下命令查看管理员密码：\",\"alist admin \",\"复制密码备用\",\"启动 Alist\",\"alist server \",\"进入 localhost:5244 访问即可\"]},{\"header\":\"添加存储\",\"slug\":\"添加存储\",\"contents\":[\"查看官方文档即可AList文档\"]},{\"header\":\"设置一键启动脚本\",\"slug\":\"设置一键启动脚本\",\"contents\":[\"下载 vim\",\"pkg install vim \",\"建立文件夹\",\"mkdir .shortcuts \",\"进入文件夹\",\"cd .shortcuts \",\"编辑脚本\",\"vim start_alist.sh \",\"进入脚本编辑界面，按 i 进入编辑模式，输入以下内容\",\"alist server \",\"输入完成后，按 esc 退出，输入 :wq 保存\",\"进入桌面，添加安卓小部件，将脚本添加到桌面即可\"]},{\"header\":\"更新\",\"slug\":\"更新\",\"contents\":[\"在 termux 中输入 pkg upgrade alist 即可\"]}]},\"/software-tool/alist/02-Windows%E7%AB%AF%E5%AE%89%E8%A3%85Alist.html\":{\"title\":\"Windows端安装Alist\",\"contents\":[{\"header\":\"安装\",\"slug\":\"安装\",\"contents\":[\"Alist\",\"去 releases 里下载最新版 Windows 安装包\",\"下载完成后解压即可\",\"然后在文件资源管理器中找到 alist.exe 文件，在地址栏输入 cmd 后回车\",\"进入命令提示符后输入 alist server 即可\",\"进入浏览器进入 localhost:5244 即可访问\",\"使用 alist admin 命令可以查看管理员密码\"]},{\"header\":\"开机自启\",\"slug\":\"开机自启\",\"contents\":[\"在 alist.exe 文件的目录里新建一个文件名为 alist.vbs\",\"文件内容为：\",\"Set ws = CreateObject(\\\"Wscript.Shell\\\") ws.run \\\"alist.exe server\\\",vbhide \",\"然后右键该文件创建快捷方式，将快捷方式剪切，在地址栏输入 shell:startup\",\"将快捷方式粘贴进来即可\"]},{\"header\":\"更新\",\"slug\":\"更新\",\"contents\":[\"去官网下载最新安装包，将 alist.exe 文件替换为最新的即可\"]}]},\"/software-tool/alist/\":{\"title\":\"Alist\",\"contents\":[]},\"/software-tool/emmet/01-Emmet%E8%AF%AD%E6%B3%95.html\":{\"title\":\"Emmet语法\",\"contents\":[{\"header\":\"简介\",\"slug\":\"简介\",\"contents\":[\"Emmet 语法的前身是 Zen coding, 它使用缩写, 来提高 html/css 的编写速度, Vscode 内部已经集成该语法\"]},{\"header\":\"快速生成 HTML 结构语法\",\"slug\":\"快速生成-html-结构语法\",\"contents\":[\"生成标签直接输入标签名按 tab 键即可比如 div 然后 tab 键，就可以生成 <div></div>\",\"如果想要生成多个相同标签加上 * 就可以了比如 div*3 就可以快速生成 3 个 div\",\"如果有父子级关系的标签，可以用 > 比如 ul > li 就可以了\",\"如果有兄弟关系的标签，用 + 就可以了比如 div+p\",\"如果生成带有类名或者 id 名字的，直接写 .demo 或者 #two tab 键就可以了\",\"如果生成的 div 类名是有顺序的，可以用自增符号 $\",\"如果想要在生成的标签内部写内容可以用 { } 表示\"]},{\"header\":\"快速生成 CSS 样式语法\",\"slug\":\"快速生成-css-样式语法\",\"contents\":[\"CSS 基本采取简写形式即可\",\"比如 w 200 按 tab 可以生成 width: 200 px;\",\"比如 lh 26 px 按 tab 可以生成  line-height: 26 px;\"]}]},\"/software-tool/emmet/\":{\"title\":\"Emmet\",\"contents\":[]},\"/software-tool/git/01-Git%E6%95%99%E7%A8%8B.html\":{\"title\":\"Git教程\",\"contents\":[{\"header\":\"Git 简介\",\"slug\":\"git-简介\",\"contents\":[\"Git 是目前世界上最先进的分布式版本控制系统。\",\"版本控制系统（version control system）, 是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。\"]},{\"header\":\"Git 的诞生\",\"slug\":\"git-的诞生\",\"contents\":[\"Git 是由 Linux 之父 Linus 开发的，在 2005 年 4 月 3 号开始开发，到 4 月 7 号仅四天时间 Git 就可以投入使用了。到同年 6 月份，Linux 已经在使用 Git 管理代码了。\",\"Git 是用什么语言开发的：C 语言。\"]},{\"header\":\"集中式 vs 分布式\",\"slug\":\"集中式-vs-分布式\",\"contents\":[\"集中式和分布式的区别是： 你的本地是否有完整的版本库历史！ 假设 SVN 服务器没了，那你丢掉了所有历史信息，因为你的本地只有当前版本以及部分历史信息。必须联网才能工作。 假设 GitHub 服务器没了，你不会丢掉任何 git 历史信息，因为你的本地有完整的版本库信息。你可以把本地的 git 库重新上传到另外的 git 服务商。可以离线工作。\"]},{\"header\":\"安装 Git\",\"slug\":\"安装-git\",\"contents\":[\"在 Windows 上使用 Git，可以从 Git 官网直接下载安装程序，然后按默认选项安装即可。\",\"安装完成后，在开始菜单里找到“Git”->“Git Bash”，会出现一个类似如下图命令行窗口的东西，就说明 Git 安装成功！\",\"Git教程01.png\"]},{\"header\":\"Git 初始化\",\"slug\":\"git-初始化\",\"contents\":[]},{\"header\":\"设置用户签名\",\"slug\":\"设置用户签名\",\"contents\":[\"签名的作用就是用来标识用户，以区分不同的开发人员\",\"==安装完成后，还需要最后一步设置，==在命令行输入：\",\"$ git config --global user.name \\\"Your Name\\\" $ git config --global user.email \\\"email@example.com\\\" \",\"注意 git config 命令的 --global 参数，用了这个参数，表示你这台机器上所有的 Git 仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和 Email 地址。\"]},{\"header\":\"初始化仓库\",\"slug\":\"初始化仓库\",\"contents\":[\"如果你使用 Windows 系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。\",\"通过 git init 命令可以把目录变成 Git 可以管理的仓库：\",\"# git 初始化的指令 $ git init \",\"瞬间 Git 就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），可以发现当前目录下多了一个 .git 的目录，这个目录是 Git 来跟踪仓库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把 Git 仓库给破坏了。\",\"如果你没有看到 .git 目录，那是因为这个目录默认是隐藏的，用 ls -ah 命令就可以看见。\",\"也不一定必须在空目录下创建 Git 仓库，选择一个已经有东西的目录也是可以的。\"]},{\"header\":\"Git 工作机制\",\"slug\":\"git-工作机制\",\"contents\":[\"分为 Git 工作区、暂存区和版本库 具体流程：代码提交到暂存区（暂时保存），然后暂存区提交到 master 分支（版本库）\"]},{\"header\":\"Git 工作区\",\"slug\":\"git-工作区\",\"contents\":[\"在电脑里面能够看得到的项目目录，但是项目目录下隐藏了一个 .git 目录，这个目录不属于工作区，而是版本库\"]},{\"header\":\"Git 暂存区\",\"slug\":\"git-暂存区\",\"contents\":[\"英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。\"]},{\"header\":\"Git 版本库\",\"slug\":\"git-版本库\",\"contents\":[\".git 目录就是版本库\"]},{\"header\":\"托管平台\",\"slug\":\"托管平台\",\"contents\":[\"局域网（内网） \",\"GitLab\",\"公网（外网） \",\"GitLab\",\"GitHub\",\"Gitee\"]},{\"header\":\"添加文件到暂存区\",\"slug\":\"添加文件到暂存区\",\"contents\":[\"我们要放入暂存区，要使用 git add 命令\",\"把单独一个文件放在暂存区\",\"# 把文件夹下的index.txt文本放在暂存区 $ git add index.txt \",\"把单独一个文件夹放在暂存区（暂存区不能存放空文件夹）\",\"# 把文件夹下的test文件夹放在暂存区 $ git add test/ \",\"把所有文件都放在暂存区\",\"# 把文件夹下所有的内容都放在暂存区 $ git add --all # git add --all 有一个简单的写法 $ git add . \",\"可以使用 git status 命令来掌握仓库当前的状态可以使用 git rm --cached <file>... 命令来从暂存区中删除 file\"]},{\"header\":\"提交暂存区到本地仓库\",\"slug\":\"提交暂存区到本地仓库\",\"contents\":[\"将暂存区文件提交到本地仓库，使用 git commit 命令\",\"# 把暂存区的内容放到本地仓库 $ git commit -m \\\"备注\\\" \",\"我们使用 git log 命令来查看版本信息\",\"# 查看当前历史区版本信息 $ git log \"]},{\"header\":\"版本穿梭\",\"slug\":\"版本穿梭\",\"contents\":[]},{\"header\":\"版本回退\",\"slug\":\"版本回退\",\"contents\":[\"使用 git reset --hard 版本编号 进行版本回退（回退到工作区）\",\"# 回退到上一次提交的版本 $ git reset --hard HEAD^ # 回退到上上次提交的版本 $ git reset --hard HEAD^ $ git reset --hard HEAD~2 \",\"Git 的版本回退速度非常快，因为 Git 在内部有个指向当前版本的 HEAD 指针，当你回退版本的时候，Git 仅仅是把 HEAD 从指向 当前版本 ，改为指向 要回到的版本\",\"Git教程02.gif\",\"然后顺便把工作区的文件更新了。所以你让 HEAD 指向哪个版本号，你就把当前版本定位在哪。 如果回退错了，可以使用 git reflog 命令来查看所有的操作记录，可以通过前面的标识符（版本号）来回退 使用 git reset --soft 版本编号 可以回退到暂存区，用处：备注重写和版本合并\"]},{\"header\":\"git revert 和 git reset\",\"slug\":\"git-revert-和-git-reset\",\"contents\":[\"git reset 是回滚到对应的 commit-id，相当于是删除了 commit-id 以后的所有的提交，并且不会产生新的 commit-id 记录，如果要推送到远程服务器的话，需要强制推送-f\",\"git revert 是反做撤销其中的 commit-id，然后重新生成一个 commit-id。本身不会对其他的提交 commit-id 产生影响，如果要推送到远程服务器的话，就是普通的操作 git push 就可以 git reset：\",\"Git教程03.gif\",\"git revert：\",\"Git教程04.gif\"]},{\"header\":\"Git 分支\",\"slug\":\"git-分支\",\"contents\":[]},{\"header\":\"初识分支\",\"slug\":\"初识分支\",\"contents\":[\"git 分支，就是我们自己把我们的整个文件夹分成一个一个独立的区域\",\"比如我们在开发 登录 功能的时候，可以放在 login 分支下进行开发；在开发 列表 功能的时候，可以放在 list 分支下进行开发，大家互不干扰，每一个功能都是一个独立的功能分支，这样开发会更好\",\"git 在初始化的时候，会自动生成一个分支，叫做 master，是表示主要分支的意思\",\"我们可以自己开辟出很多独立分支\"]},{\"header\":\"分支管理\",\"slug\":\"分支管理\",\"contents\":[\"开辟一个分支，使用 git branch 分支名称 命令\",\"# 开辟一个login分支 $ git branch login \",\"查看一下当前分支情况，前面有个 * 的，并且有高亮显示的，表示你当前所处的分支\",\"# 查看当前分支情况 $ git branch \",\"切换分支（HEAD 指向会跟着一起变），使用 git checkout 分支名称 命令\",\"# 切换到master分支 $ git checkout master \",\"注意：切换分支时，记得将当前分支提交到暂存区（git add）\",\"合并分支，使用 git merge 分支名称 命令\",\"# 合并login分支到master分支 # 首先切换到master分支 $ git checkout master # 合并分支 $ git merge login \",\"删除分支，使用 git branch -d 分支名称 命令\",\"# 删除login分支 # 先切换到别的分支 $ git checkout master # 删除login分支 $ git branch -d login \"]},{\"header\":\"分支合并冲突\",\"slug\":\"分支合并冲突\",\"contents\":[\"分支合并后如有冲突，git 会在文件中标识出来，需要我们人工解决冲突\"]},{\"header\":\"初识团队协作\",\"slug\":\"初识团队协作\",\"contents\":[\"需要使用托管平台来实现，如 GitHub\"]},{\"header\":\"GitHub 远端仓库\",\"slug\":\"github-远端仓库\",\"contents\":[\"首先，登陆 GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库，在 Repository name 填入你的仓库名，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的 Git 仓库。\",\"目前，在GitHub上的这个仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。\",\"现在，我们根据 GitHub 的提示，在本地的要上传的仓库下运行命令：\",\"$ git remote add origin git@github.com:你的账户名/你的仓库名.git # 如：$ git remote add origin git@github.com:zhf521/learngit.git # 这里的origin是你的远端库的别名，可以是任意的，以后你提交的时候就可以向origin提交即可 # 使用 $ git remote remove origin 命令即可删除,这里的origin是仓库的别名，可以使用git remote -v查看 \",\"使用 git remote -v 可以查看连接的远程库\"]},{\"header\":\"推送\",\"slug\":\"推送\",\"contents\":[\"使用 git push 推送\",\"$ git push origin master # 将本地分支推送到远程库（别名为origin）master分支上 \",\"加上 -u 参数即可以后只使用 git push 来推送\",\"$ git push -u origin master \"]},{\"header\":\"拉取\",\"slug\":\"拉取\",\"contents\":[\"使用 git pull 拉取更新的文件\",\"$ git pull origin master # 将远程库（别名为origin）master分支拉取到本地分支上 \",\"加上 -u 参数即可以后只使用 git pull 来推送\",\"$ git pull -u origin master \"]},{\"header\":\"克隆\",\"slug\":\"克隆\",\"contents\":[\"使用 git clone 仓库地址 克隆远程仓库里面的内容到本地==（注意：克隆只能克隆主分支）== 可以克隆别人的公开的仓库，也可以克隆自己的仓库，克隆别人的仓库，我们只能拿来用，修改后不能重新上传；克隆自己的仓库，我们修改后还可以再次上传更新\",\"# 直接克隆仓库 $ git clone 仓库地址 \"]},{\"header\":\"团队协作的分支管理\",\"slug\":\"团队协作的分支管理\",\"contents\":[\"本地分支推送到远程分支 使用 git push 推送\",\"$ git push origin login # 将本地分支推送到远程库（别名为origin）login分支上 \",\"注意：克隆只能克隆主分支，需要拉取分支 使用 git pull 拉取更新的文件\",\"$ git pull origin login # 将远程库（别名为origin）login分支拉取到本地分支上 \",\"删除远程分支\",\"$ git pull origin :login # 将远程库（别名为origin）login分支删除 \"]},{\"header\":\"跨团队协作\",\"slug\":\"跨团队协作\",\"contents\":[\"先 fork 到自己的仓库，然后修改，然后 pull request，等待原作者审核\"]},{\"header\":\"VSCode 集成 Git\",\"slug\":\"vscode-集成-git\",\"contents\":[\"VSCode 中已经集成了 Git .gitignore 文件可以忽略文件，这个文件将不会上传\"]},{\"header\":\"一图总结\",\"slug\":\"一图总结\",\"contents\":[\"Git教程05.png\"]}]},\"/software-tool/git/02-gitignore%E6%96%87%E4%BB%B6.html\":{\"title\":\"gitignore文件\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"在使用 git 过程中，我们可能有些文件不需要上传上去，比如一些缓存文件，生成的图片，运行环境的一些配置等等，这时就需要用到 .gitignore 文件来忽略掉这些文件\"]},{\"header\":\"创建. gitignore 文件\",\"slug\":\"创建-gitignore-文件\",\"contents\":[\"在要管理的根目录下（即 .git 文件夹同级目录中）创建一个 .gitignore\",\"# 创建.gitignore文件命令 $ touch .gitignore \"]},{\"header\":\"写入要忽略的文件或文件夹\",\"slug\":\"写入要忽略的文件或文件夹\",\"contents\":[\"使用 Vim 来写入\",\"# 命令 $ vim .gitignore \",\"使用 Vim 插入模式来编写，在文件末尾一行要写入 .gitignore 然后退出保存即可\",\"注意：.gitignore 只能忽略那些原来没有被 track 的文件，如果某些文件已经被纳入了版本管理中，则修改 .gitignore 是无效的。那么解决方法就是先把本地缓存删除（改变成未 track 状态），然后再提交\",\"# 命令 $ git rm -r --cached $ git add . $ git commit -m 'update .gitignore' \"]},{\"header\":\". gitignore 的格式规范\",\"slug\":\"gitignore-的格式规范\",\"contents\":[\"# 为注释\",\"可以使用 shell 所使用的正则表达式来进行模式匹配\",\"匹配模式最后跟 / 说明要忽略的是目录\",\"使用 ! 取反，（例如目录中包含 test.a，并且 .gitignore 文件中包含 *.[oa]，如果在文件中加入 !test.a 表明忽略除 test.a 文件以外的后缀名为 .a 或者 .o 的文件）\"]},{\"header\":\"配置语法\",\"slug\":\"配置语法\",\"contents\":[\"以斜杠 / 开头表示目录\",\"以星号 * 通配多个字符\",\"以问号 ? 通配多个字符\",\"以方括号 [] 包含单个字符的匹配列表\",\"以感叹号 ! 表示不忽略（跟踪）匹配到的文件或目录\",\"例如：\",\"*.a # 忽略所有 .a 结尾的文件 !lib.a # 但 lib.a 除外 /TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括subdir/TODO build/ # 忽略 build/ 目录下的所有文件 doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt \",\"注意：git 对于 .gitignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效\"]}]},\"/software-tool/git/\":{\"title\":\"Git\",\"contents\":[]},\"/software-tool/halo/01-Halo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA.html\":{\"title\":\"Halo博客搭建\",\"contents\":[{\"header\":\"购买服务器\",\"slug\":\"购买服务器\",\"contents\":[\"需要购买服务器，内存至少 1G，这里以腾讯云为例，进入官网腾讯云选购自己的服务器即可，推荐轻量应用服务器。购买以后装入 centos 系统。 防火墙开放 8090 端口 \"]},{\"header\":\"安装 Docker\",\"slug\":\"安装-docker\",\"contents\":[\"以下为 centos 系统安装教程，其他系统请参照官网教程官网\"]},{\"header\":\"登录自己的服务器\",\"slug\":\"登录自己的服务器\",\"contents\":[\"Halo博客搭建03.png\"]},{\"header\":\"卸载旧版本\",\"slug\":\"卸载旧版本\",\"contents\":[\"sudo yum remove docker \\\\ docker-client \\\\ docker-client-latest \\\\ docker-common \\\\ docker-latest \\\\ docker-latest-logrotate \\\\ docker-logrotate \\\\ docker-engine \"]},{\"header\":\"更新、安装必备软件\",\"slug\":\"更新、安装必备软件\",\"contents\":[\"apt-get update && apt-get install -y wget vim \"]},{\"header\":\"获取安装包\",\"slug\":\"获取安装包\",\"contents\":[\"sudo yum install -y yum-utils \"]},{\"header\":\"设置镜像仓库\",\"slug\":\"设置镜像仓库\",\"contents\":[\"官方镜像：（比较慢，不推荐）\",\"sudo yum-config-manager \\\\ --add-repo \\\\ https://download.docker.com/linux/centos/docker-ce.repo \",\"阿里镜像仓库 ：（推荐）\",\"sudo yum-config-manager \\\\ --add-repo \\\\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo \"]},{\"header\":\"安装 docker\",\"slug\":\"安装-docker-1\",\"contents\":[\"安装前先更新 yum 软件包索引\",\"yum makecache fast \",\"安装 docker-ce（社区版-免费的）\",\"sudo yum install docker-ce docker-ce-cli containerd.io \"]},{\"header\":\"启动 docker\",\"slug\":\"启动-docker\",\"contents\":[\"sudo systemctl start docker \"]},{\"header\":\"判断是否成功安装 docker 查看版本\",\"slug\":\"判断是否成功安装-docker-查看版本\",\"contents\":[\"docker version \"]},{\"header\":\"设置 docker 开机自启动\",\"slug\":\"设置-docker-开机自启动\",\"contents\":[\"systemctl enable docker \"]},{\"header\":\"使用 Docker 部署 Halo\",\"slug\":\"使用-docker-部署-halo\",\"contents\":[\"建议查看官方教程 使用 Docker 部署 Halo\"]},{\"header\":\"进入后台安装\",\"slug\":\"进入后台安装\",\"contents\":[\"通过访问 IP：端口号即可访问安装引导界面 安装完即可\"]},{\"header\":\"购买域名 (可选)\",\"slug\":\"购买域名-可选\",\"contents\":[\"进入腾讯云官网腾讯云选购。 注意：服务器与域名最好选用同一厂商，不然可能会莫名报错，配置失败。 添加域名解析，如图 \"]},{\"header\":\"反向代理 (可选)\",\"slug\":\"反向代理-可选\",\"contents\":[]},{\"header\":\"安装 Docker Compose\",\"slug\":\"安装-docker-compose\",\"contents\":[]},{\"header\":\"下载安装\",\"slug\":\"下载安装\",\"contents\":[\"sudo curl -L https://github.com/docker/compose/releases/download/1.16.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose \",\"推荐使用下面这个，国内访问较快\",\"sudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose \"]},{\"header\":\"给执行权限\",\"slug\":\"给执行权限\",\"contents\":[\"sudo chmod +x /usr/local/bin/docker-compose \"]},{\"header\":\"查看 docker-compose 版本\",\"slug\":\"查看-docker-compose-版本\",\"contents\":[\"docker-compose --version \"]},{\"header\":\"部署 Nginx Proxy Manager 服务\",\"slug\":\"部署-nginx-proxy-manager-服务\",\"contents\":[]},{\"header\":\"创建一个与此类似的 docker-compose. yml 文件\",\"slug\":\"创建一个与此类似的-docker-compose-yml-文件\",\"contents\":[\"mkdir ~/npm #创建一个目录用来安装此服务 cd ~/npm #进入目录 \",\"vim docker-compose.yml #将以下代码粘贴到里面然后保存退出 \",\"version: \\\"3\\\" services: app: image: 'jc21/nginx-proxy-manager:latest' restart: unless-stopped ports: # These ports are in format <host-port>:<container-port> - '80:80' # Public HTTP Port - '443:443' # Public HTTPS Port - '81:81' # Admin Web Port # Add any other Stream port you want to expose # - '21:21' # FTP environment: DB_MYSQL_HOST: \\\"db\\\" DB_MYSQL_PORT: 3306 DB_MYSQL_USER: \\\"npm\\\" DB_MYSQL_PASSWORD: \\\"npm\\\" DB_MYSQL_NAME: \\\"npm\\\" # Uncomment this if IPv6 is not enabled on your host # DISABLE_IPV6: 'true' volumes: - ./data:/data - ./letsencrypt:/etc/letsencrypt depends_on: - db db: image: 'jc21/mariadb-aria:latest' restart: unless-stopped environment: MYSQL_ROOT_PASSWORD: 'npm' MYSQL_DATABASE: 'npm' MYSQL_USER: 'npm' MYSQL_PASSWORD: 'npm' volumes: - ./data/mysql:/var/lib/mysql \"]},{\"header\":\"在当前目录运行以下命令安装此服务\",\"slug\":\"在当前目录运行以下命令安装此服务\",\"contents\":[\"sudo docker-compose up -d #部署服务 \"]},{\"header\":\"安装完以后进入 81 端口登录\",\"slug\":\"安装完以后进入-81-端口登录\",\"contents\":[\"默认登陆名和密码： Email: admin@example. com Password: changeme 按如下图设置即可\",\"Halo博客搭建05.gif\",\"最后就可以通过域名进行访问了\"]},{\"header\":\"开始写博客\",\"slug\":\"开始写博客\",\"contents\":[\"配置好图床使用 GitHub 图床或阿里云对象存储搭建图床，使用 MarkDown 语法就可以愉快的发布文章啦!\"]}]},\"/software-tool/halo/\":{\"title\":\"Halo\",\"contents\":[]},\"/software-tool/image-hosting-website/01-%E9%98%BF%E9%87%8C%E4%BA%91%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A.html\":{\"title\":\"阿里云对象存储搭建图床\",\"contents\":[{\"header\":\"开通阿里云对象存储服务\",\"slug\":\"开通阿里云对象存储服务\",\"contents\":[\"进入官网，开通阿里云对象存储服务\"]},{\"header\":\"创建 Bucket\",\"slug\":\"创建-bucket\",\"contents\":[\"进入控制台，选择 Bucket 列表，创建 Bucket\",\"阿里云对象存储搭建图床01.png\",\"填写信息 注意：1. 存储类型选择标准存储2. 读写权限选择公共读\",\"阿里云对象存储搭建图床02.png\",\"然后点击设置的 Bucket，然后点击 Bucket 下的概览 在 访问域名 一栏找到你的地域节点，后面会用到\",\"阿里云对象存储搭建图床03.png\"]},{\"header\":\"管理 Accesskey\",\"slug\":\"管理-accesskey\",\"contents\":[\"点击头像，选择 Accesskey 管理\",\"阿里云对象存储搭建图床04.png\",\"在弹出的选项框里，选择“继续使用” 进入后，创建一个 AccessKey 在弹出的界面里，记住你的 accessKeyId 和 accessKeySecret\"]},{\"header\":\"购买存储包\",\"slug\":\"购买存储包\",\"contents\":[\"阿里云对象存储搭建图床05.png\",\"购买完成后还要充值余额，即需要购买流量。\"]},{\"header\":\"配置 PicGo\",\"slug\":\"配置-picgo\",\"contents\":[\"下载 PicGo，官网 PicGo，安装完成。 打开图床设置 在图床设置里面选择阿里云 OSS，依照以下步骤填写信息\",\"设定 KeyId：填写刚刚获得的 AccessKeyID\",\"设定 KeySecret：填写 AccessKeyIDSecret\",\"设定储存空间名：填写 bucket 名称，这里填写的是 bucket 名称，不是浏览器里的域名\",\"确认存储区域：填写你的地域节点，注意复制的格式\",\"指定存储路径：其实就是自定义一个文件夹的名字，以/结尾 设置完成\",\"阿里云对象存储搭建图床06.png\",\"它会自动在你的 bucket 里面创建一个文件夹，并把图片上传进去\"]}]},\"/software-tool/image-hosting-website/02-GitHub%E5%9B%BE%E5%BA%8A.html\":{\"title\":\"GitHub图床\",\"contents\":[{\"header\":\"创建一个仓库\",\"slug\":\"创建一个仓库\",\"contents\":[\"首先创建一个仓库\",\"GitHub图床01.png\"]},{\"header\":\"设置 token\",\"slug\":\"设置-token\",\"contents\":[\"点击头像，点击设置\",\" 点击开发者设置\",\"GitHub图床03.png\",\"设置个人访问令牌\",\"GitHub图床04.png\",\"设置完成以后请务必复制并保存 token\"]},{\"header\":\"下载 PicGo\",\"slug\":\"下载-picgo\",\"contents\":[\"官网 PicGo 下载完成并安装\"]},{\"header\":\"设置 GitHub 图床\",\"slug\":\"设置-github-图床\",\"contents\":[\" 确定即可，上传图片验证是否成功\",\"注意：如果上传失败，请关闭加速器\"]}]},\"/software-tool/image-hosting-website/\":{\"title\":\"图床\",\"contents\":[]},\"/software-tool/markdown/01-MarkDown%E8%AF%AD%E6%B3%95.html\":{\"title\":\"MarkDown语法\",\"contents\":[{\"header\":\"标题\",\"slug\":\"标题\",\"contents\":[\"# 标题名字（井号的个数代表标题的级数） \",\"一级标题使用 1 个#\",\"二级标题使用 2 个#\",\"三级标题使用 3 个#\",\"四级标题使 4 用个#\",\"五级标题使用 5 个#\",\"六级标题使用 6 个#\",\"最多支持六级标题#\"]},{\"header\":\"文字\",\"slug\":\"文字\",\"contents\":[]},{\"header\":\"删除线\",\"slug\":\"删除线\",\"contents\":[\"这就是 ~~删除线~~ (使用波浪号) \",\"这就是 删除线 (使用波浪号)\"]},{\"header\":\"斜体\",\"slug\":\"斜体\",\"contents\":[\"这是用来 *斜体* 的 _文本_ \",\"这是用来 斜体 的 文本\"]},{\"header\":\"加粗\",\"slug\":\"加粗\",\"contents\":[\"这是用来 **加粗** 的 __文本__ \",\"这是用来 加粗 的 文本\"]},{\"header\":\"斜体+加粗\",\"slug\":\"斜体-加粗\",\"contents\":[\"这是用来 ***斜体+加粗*** 的 ___文本___ \",\"这是用来 斜体+加粗 的 文本\"]},{\"header\":\"下划线\",\"slug\":\"下划线\",\"contents\":[\"下划线是 HTML 语法\",\"下划线 下划线 (快捷键 ctrl + u) \"]},{\"header\":\"高亮（需勾选扩展语法）\",\"slug\":\"高亮-需勾选扩展语法\",\"contents\":[\"这是用来 ==斜体+加粗== 的文本 \",\"这是用来 斜体+加粗 的文本\"]},{\"header\":\"符号及数学公式\",\"slug\":\"符号及数学公式\",\"contents\":[]},{\"header\":\"下标 (需勾选扩展语法)\",\"slug\":\"下标-需勾选扩展语法\",\"contents\":[\"水 $H_2O$ 双氧水 $H_2O_2$ \",\"水 H2​O 双氧水 H2​O2​\"]},{\"header\":\"上标 (需勾选扩展语法)\",\"slug\":\"上标-需勾选扩展语法\",\"contents\":[\"面积 $m^2$ 体积 $m^3$ 3的xy次方 $3^{xy}$ \",\"面积 m2 体积 m3 3 的 xy 次方 3xy\"]},{\"header\":\"运算符\",\"slug\":\"运算符\",\"contents\":[\"乘号: $\\\\times$ $10 = 2 \\\\times 5$ 除号: $\\\\div$ 加减号: $\\\\pm$ 开方：$\\\\sqrt{ x }$ 开n次方：$\\\\sqrt[ n ]{ x }$ \",\"乘号: ×10=2×5 除号: ÷ 加减号: ± 开方：x​ 开 n 次方：nx​\",\"如果要把符号往正上方或者正下方放\",\"比如 :\",\"$\\\\max \\\\limits_{x_0}$ $\\\\min \\\\limits^{x_0}$ $\\\\min \\\\limits^{x_0}_{x_0}$ \",\"x0​max​minx0​x0​minx0​​\",\"但 limits 只允许用于运算符上, 其他的不行\"]},{\"header\":\"向量\",\"slug\":\"向量\",\"contents\":[\"$\\\\vec{ a }$ $\\\\vec a \\\\cdot \\\\vec b = 0$ \",\"aa⋅b=0\"]},{\"header\":\"微积分\",\"slug\":\"微积分\",\"contents\":[\"$\\\\int_0^2 x^2 {\\\\rm d}x$ $\\\\lim\\\\limits_{n \\\\rightarrow +\\\\infty} \\\\frac{1}{n(n+1)}$ \",\"∫02​x2dxn→+∞lim​n(n+1)1​\"]},{\"header\":\"求和求极限\",\"slug\":\"求和求极限\",\"contents\":[\"$\\\\sum_{i = 1}^n{x_i}$ $\\\\sum\\\\limits_{i = 1}^n{x_i}$ $\\\\sum_{i=0}^n \\\\frac{1}{i^2}$ $\\\\sum\\\\limits_{i=0}^n \\\\frac{1}{i^2}$ $\\\\frac{\\\\sum_{i = 1}^n{x_i}}{n}$ $\\\\prod_{i=0}^n \\\\frac{1}{i^2}$ \",\"∑i=1n​xi​i=1∑n​xi​∑i=0n​i21​i=0∑n​i21​n∑i=1n​xi​​∏i=0n​i21​\"]},{\"header\":\"括号\",\"slug\":\"括号\",\"contents\":[\"$\\\\{ \\\\}$ ${a\\\\choose b}$ $\\\\frac{x}{y}$ $\\\\left ()\\\\right.$ \",\"{}(ba​)yx​()\"]},{\"header\":\"省略号\",\"slug\":\"省略号\",\"contents\":[\"跟文本底线对齐的省略号 $\\\\ldots$ 横向的省略号 $\\\\cdots$ 竖向的省略号 $\\\\vdots$ 对角线方向的省略号 $\\\\ddots$ \",\"跟文本底线对齐的省略号 … 横向的省略号 ⋯ 竖向的省略号 ⋮ 对角线方向的省略号 ⋱\"]},{\"header\":\"数学符号\",\"slug\":\"数学符号\",\"contents\":[\"因为：$\\\\because$ 所以：$\\\\therefore$ 任意：$\\\\forall$ 存在：$\\\\exists$ ∣ ：$\\\\mid$ \\\\ ：$\\\\backslash$ ∗ ：$\\\\ast$ ≤ ：$\\\\leq$ ≥ ：$\\\\geq$ ≠ ：$\\\\neq$ ≈ ：$\\\\approx$ ≡ ：$\\\\equiv$ ∑ ：$\\\\sum$ ∏ ：$\\\\prod$ ∐ ：$\\\\coprod$ ⨀ ：$\\\\bigodot$ ⨂ ：$\\\\bigotimes$ ⨁ ：$\\\\bigoplus$ \",\"因为：∵ 所以：∴ 任意：∀ 存在：∃ ∣ ：∣ \\\\ ：\\\\ ∗ ：∗ ≤ ：≤ ≥ ：≥ ≠ ：= ≈ ：≈ ≡ ：≡ ∑ ：∑ ∏ ：∏ ∐ ：∐ ⨀ ：⨀ ⨂ ：⨂ ⨁ ：⨁\"]},{\"header\":\"百分号、约等号\",\"slug\":\"百分号、约等号\",\"contents\":[\"$\\\\%$ $\\\\approx$ \",\"%≈\"]},{\"header\":\"向上/下取整\",\"slug\":\"向上-下取整\",\"contents\":[\"向上: $\\\\lceil$ $\\\\rceil$ 向下: $\\\\lfloor$ $\\\\rfloor$ $\\\\lceil$\\\\frac{4}{5}$\\\\rceil$ $\\\\lfloor$\\\\frac{4}{5}$\\\\rfloor$ \",\"向上:\",\"⌈⌉\",\"向下:\",\"⌊⌋\",\"⌈54​⌉⌊54​⌋\"]},{\"header\":\"希腊字母\",\"slug\":\"希腊字母\",\"contents\":[\"希腊字母\",\"写法\",\"希腊字母\",\"写法\",\"α\",\"$\\\\alpha$\",\"β\",\"$\\\\beta$\",\"γ\",\"$\\\\gamma$\",\"Γ\",\"$\\\\Gamma$\",\"δ\",\"$\\\\delta$\",\"Δ\",\"$\\\\Delta$\",\"ϵ\",\"$\\\\epsilon$\",\"ε\",\"$\\\\varepsilon$\",\"ζ\",\"$\\\\zeta$\",\"η\",\"$\\\\eta$\",\"θ\",\"$\\\\theta$\",\"Θ\",\"$\\\\Theta$\",\"ϑ\",\"$\\\\vartheta$\",\"ι\",\"$\\\\iota$\",\"κ\",\"$\\\\kappa$\",\"λ\",\"$\\\\lambda$\",\"Λ\",\"$\\\\Lambda$\",\"μ\",\"$\\\\mu$\",\"ν\",\"$\\\\nu$\",\"ξ\",\"$\\\\xi$\",\"Ξ\",\"$\\\\Xi$\",\"π\",\"$\\\\pi$\",\"Π\",\"$\\\\Pi$\",\"ϖ\",\"$\\\\varpi$\",\"ρ\",\"$\\\\rho$\",\"ϱ\",\"$\\\\varrho$\",\"σ\",\"$\\\\sigma$\",\"Σ\",\"$\\\\Sigma$\",\"ς\",\"$\\\\varsigma$\",\"τ\",\"$\\\\tau$\",\"υ\",\"$\\\\upsilon$\",\"Υ\",\"$\\\\Upsilon$\",\"ϕ\",\"$\\\\phi$\",\"Φ\",\"$\\\\Phi$\",\"φ\",\"$\\\\varphi$\",\"χ\",\"$\\\\chi$\",\"ψ\",\"$\\\\psi$\",\"Ψ\",\"$\\\\Psi$\",\"Ω\",\"$\\\\Omega$\",\"ω\",\"$\\\\omega$\"]},{\"header\":\"集合运算符\",\"slug\":\"集合运算符\",\"contents\":[\"∅: $\\\\emptyset$ ∈: $\\\\in$ ∉: $\\\\notin$ ⊂: $\\\\subset$ ⊃: $\\\\supset$ ⊆: $\\\\subseteq$ ⊇: $\\\\supseteq$ ⋂: $\\\\bigcap$ ⋃: $\\\\bigcup$ ⋁: $\\\\bigvee$ ⋀: $\\\\bigwedge$ ⨄: $\\\\biguplus$ ⨆: $\\\\bigsqcup$ $A\\\\\\\\2$ \",\"∅: ∅ ∈: ∈ ∉: ∈/ ⊂: ⊂ ⊃: ⊃ ⊆: ⊆ ⊇: ⊇ ⋂: ⋂ ⋃: ⋃ ⋁: ⋁ ⋀: ⋀ ⨄: ⨄ ⨆: ⨆A2\"]},{\"header\":\"对数符号\",\"slug\":\"对数符号\",\"contents\":[\"log:$\\\\log$ lg:$\\\\lg$ ln:$\\\\ln$ \",\"log: log lg: lg ln: ln\"]},{\"header\":\"箭头符号\",\"slug\":\"箭头符号\",\"contents\":[\"↑:$\\\\uparrow$ ↓:$\\\\downarrow$ ⇑:$\\\\Uparrow$ ⇓:$\\\\Downarrow$ →:$\\\\rightarrow$ ←:$\\\\leftarrow$ ⇒:$\\\\Rightarrow$ ⇐:$\\\\Leftarrow$ ⟶:$\\\\longrightarrow$ ⟵:$\\\\longleftarrow$ ⟹:$\\\\Longrightarrow$ ⟸:$\\\\Longleftarrow$ $\\\\stackrel{+}{\\\\Rightarrow}$ $\\\\stackrel{*}{\\\\Rightarrow}$ \",\"↑: ↑ ↓: ↓ ⇑: ⇑ ⇓: ⇓ →: → ←: ← ⇒: ⇒ ⇐: ⇐ ⟶: ⟶ ⟵: ⟵ ⟹: ⟹ ⟸: ⟸⇒+⇒∗\"]},{\"header\":\"三角运算符\",\"slug\":\"三角运算符\",\"contents\":[\"⊥:$\\\\bot$ ∠:$\\\\angle$ 度数:$30^\\\\circ$ sin:$\\\\sin$ cos:$\\\\cos$ tan:$\\\\tan$ cot:$\\\\cot$ sec:$\\\\sec$ csc:$\\\\csc$ \",\"⊥: ⊥ ∠: ∠ 度数: 30∘ sin: sin cos: cos tan: tan cot: cot sec: sec csc: csc\"]},{\"header\":\"分段函数的写法\",\"slug\":\"分段函数的写法\",\"contents\":[\"用法：\\\\begin{cases}xxxxxxx \\\\\\\\ xxxxxxx \\\\end{cases}\",\"$L(Y,f(x))=\\\\begin{cases}1, Y!=f(x) \\\\\\\\0, Y = f(x)\\\\end{cases}$ \",\"L(Y,f(x))={1,Y!=f(x)0,Y=f(x)​\",\"$L(Y,f(x))=\\\\begin{cases}1, Y!=f(x) \\\\\\\\0, Y = f(x)\\\\\\\\ -1,Y=\\\\infty \\\\end{cases}$ \",\"L(Y,f(x))=⎩⎨⎧​1,Y!=f(x)0,Y=f(x)−1,Y=∞​\",\"$M_p=\\\\begin{cases}x_{([np]+1)} {\\\\quad}{\\\\quad} np不是整数 \\\\\\\\ \\\\frac{1}{2}(x_{(np)}+x_{(np+1)}) {\\\\quad}{\\\\quad} np为整数\\\\end{cases}$ \",\"Mp​={x([np]+1)​np不是整数21​(x(np)​+x(np+1)​)np为整数​\"]},{\"header\":\"在数学公式中加空格\",\"slug\":\"在数学公式中加空格\",\"contents\":[\"${\\\\quad}$ : 输出一个空格\",\"${\\\\,}$ : 输出半个空格\",\"在数学模式下如果输不出空格就先加大括号 {}; 在复杂的公式下可能识别不出, 就需要加 {}\",\"空格宽度\",\"写法\",\"示例 : x y\",\"两个空格\",\"$x \\\\qquad y$\",\"xy\",\"一个空格\",\"$x \\\\quad y$\",\"xy\",\"大空格\",\"$x \\\\ y$\",\"xy\",\"中等空格\",\"$x \\\\; y$\",\"xy\",\"小空格\",\"$x\\\\,y$\",\"xy\",\"紧贴\",\"$x\\\\!y$\",\"xy\"]},{\"header\":\"绝对值\",\"slug\":\"绝对值\",\"contents\":[\"$|\\\\overline{x}|$ $|x|$ \",\"∣x∣∣x∣\"]},{\"header\":\"输出矩阵\",\"slug\":\"输出矩阵\",\"contents\":[\"$\\\\begin{matrix} 1 & 2 & 3 \\\\\\\\ 4 & 5 & 6 \\\\\\\\ 7 & 8 & 9 \\\\end{matrix}$ \\\\\\\\:换行 \",\"147​258​369​\"]},{\"header\":\"带大圆括号的矩阵\",\"slug\":\"带大圆括号的矩阵\",\"contents\":[\"$\\\\left( \\\\begin{matrix} 1 & 2 & 3 \\\\\\\\ 4 & 5 & 6 \\\\\\\\ 7 & 8 & 9 \\\\end{matrix} \\\\right)$ \",\"​147​258​369​​ 格式 : \\\\left( : 代表左圆括号 \\\\right) : 代表右圆括号\"]},{\"header\":\"带中/方括号的矩阵\",\"slug\":\"带中-方括号的矩阵\",\"contents\":[\"$\\\\left[ \\\\begin{matrix} 1 & 2 & 3 \\\\\\\\ 4 & 5 & 6 \\\\\\\\ 7 & 8 & 9 \\\\end{matrix} \\\\right]$ \",\"​147​258​369​​ 格式 : \\\\left[ : 代表左中括号 \\\\right] : 代表右中括号\"]},{\"header\":\"带大括号的矩阵\",\"slug\":\"带大括号的矩阵\",\"contents\":[\"$\\\\left\\\\{ \\\\begin{matrix} 1 & 2 & 3 \\\\\\\\ 4 & 5 & 6 \\\\\\\\ 7 & 8 & 9 \\\\end{matrix} \\\\right\\\\}$ \",\"⎩⎨⎧​147​258​369​⎭⎬⎫​ 格式 : \\\\left\\\\{ : 代表左大括号 \\\\right\\\\} : 代表右大括号\"]},{\"header\":\"阵列\",\"slug\":\"阵列\",\"contents\":[\"$\\\\begin{array}{c|ccc} {↓}&{a}&{b}&{c}\\\\\\\\ \\\\hline {R_1}&{c}&{b}&{a}\\\\\\\\ {R_2}&{b}&{c}&{c}\\\\\\\\ \\\\end{array}$ \",\"↓R1​R2​​acb​bbc​cac​​\",\"需要 array 环境：起始、结束处以 {array} 声明\",\"对齐方式：在{array}后以 \",\"左对齐：l ；剧中：c；右对齐：r\",\"竖直线：在声明对齐方式时，插入 | 建立竖直线\",\"$\\\\begin{array}{r|c|c|l|} {p}&{x}&{y}&{z}\\\\\\\\ \\\\hline {R_1}&{1}&{2}&{3}\\\\\\\\ {R_2}&{3}&{2}&{1}\\\\\\\\ \\\\end{array}$ \",\"pR1​R2​​x13​y22​z31​​\"]},{\"header\":\"公式推导\",\"slug\":\"公式推导\",\"contents\":[\"$\\\\begin {aligned} 推导内容1 &\\\\Rightarrow 推导内容2 \\\\\\\\ &\\\\Rightarrow 推导内容3 \\\\\\\\ &\\\\Rightarrow 推导内容4 \\\\end {aligned}$ \",\"推导内容1​⇒推导内容2⇒推导内容3⇒推导内容4​& 符号对齐列, \\\\\\\\符号换行, \\\\ 转义作用\",\"$\\\\begin {aligned} 式子1 &= 式子2 \\\\\\\\ &= 式子3 \\\\\\\\ &= 式子4 \\\\end {aligned}$ \",\"式子1​=式子2=式子3=式子4​\"]},{\"header\":\"回归方程符号\",\"slug\":\"回归方程符号\",\"contents\":[\"样式\",\"写法\",\"样式\",\"写法\",\"xˉ\",\"$\\\\bar{x}$\",\"ηˋ​\",\"$\\\\grave{\\\\eta}$\",\"x˙\",\"$\\\\dot{x}$\",\"a˘\",\"$\\\\breve{a}$\",\"α^\",\"$\\\\hat{\\\\alpha}$\",\"αˇ\",\"$\\\\check{\\\\alpha}$\",\"y¨​\",\"$\\\\ddot{y}$\",\"ι~\",\"$\\\\tilde{\\\\iota}$\",\"ηˊ​\",\"$\\\\acute{\\\\eta}$\"]},{\"header\":\"表格\",\"slug\":\"表格\",\"contents\":[\"使用 | [[#转换规则]] 来分隔不同的单元格，使用 - 来分隔表头和其他行：\",\"| 名称 | 价格 | | ---- | ---- | | 炸鸡 | 19 | | 可乐 | 5 | \",\"为了使 Markdown 更清晰，| 和 - 两侧需要至少有一个空格（最左侧和最右侧的 | 外就不需要了）。\",\"名称\",\"价格\",\"炸鸡\",\"19\",\"可乐\",\"5\",\"为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 | 来标记单元格边界，在表头下方的分隔线标记中加入 :，即可标记下方单元格内容的对齐方式：\",\"| 名称 | 价格 | | :------------ | :---: | | 炸鸡 | 19 | | 可乐 | 32 | \",\"名称\",\"价格\",\"炸鸡\",\"19\",\"可乐\",\"32\",\"若想对一段长文本进行换行，可以在 中间 插入一个 ** <br> ** （ 换行标签 )\"]},{\"header\":\"引用\",\"slug\":\"引用\",\"contents\":[\">“大风起兮云飞扬” \",\"“大风起兮云飞扬”\",\">也可以在引用中 >>使用嵌套的引用 \",\"也可以在引用中\",\"使用嵌套的引用\"]},{\"header\":\"列表\",\"slug\":\"列表\",\"contents\":[]},{\"header\":\"无序列表\",\"slug\":\"无序列表\",\"contents\":[\"* 可以使用 `*` 作为标记 + 也可以使用 `+` - 或者 `-` + 使用tab键可以使用多级列表 \",\"可以使用 * 作为标记\",\"也可以使用 +\",\"或者 -\",\"使用 tab 键可以使用多级列表\"]},{\"header\":\"有序列表\",\"slug\":\"有序列表\",\"contents\":[\"1. 有序列表以数字和 `.` 开始； 3. 数字的序列并不会影响生成的列表序列； 4. 但仍然推荐按照自然顺序（1.2.3...）编写。 \",\"有序列表以数字和 . 开始；\",\"数字的序列并不会影响生成的列表序列；\",\"但仍然推荐按照自然顺序（1.2.3...）编写。\",\"可以使用：数字\\\\. 来取消显示为列表（用反斜杠进行转义） \"]},{\"header\":\"代码\",\"slug\":\"代码\",\"contents\":[]},{\"header\":\"代码块\",\"slug\":\"代码块\",\"contents\":[\" ```语言 代码 \",\"```java public static void main(String[] args) { } \"]},{\"header\":\"行内代码\",\"slug\":\"行内代码\",\"contents\":[\"也可以通过 ``，插入行内代码（` 是 `Tab` 键上边、数字 `1` 键左侧的那个按键）： 例如 `Markdown` \",\"Markdown\"]},{\"header\":\"转换规则\",\"slug\":\"转换规则\",\"contents\":[\"代码块中的文本（包括 Markdown 语法）都会显示为原始内容\"]},{\"header\":\"分隔线\",\"slug\":\"分隔线\",\"contents\":[\"可以在一行中使用三个或更多的 *、- 或 _ 来添加分隔线（``）：\",\"*** ------ ___ \"]},{\"header\":\"待办事项\",\"slug\":\"待办事项\",\"contents\":[\"- [ ] \",\"[ ]\",\"[x]\"]},{\"header\":\"空格\",\"slug\":\"空格\",\"contents\":[\"在一些编辑器或者支持 MD 的笔记软件里，无论你打多少个空格，它只会显示单个 空格 的距离\",\"可以使用 HTML 中 空格 的 字符实体 —— ** &nbsp; **\",\"若要添加 多个 空格，就输入多个——** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ** 例如：\",\"这里有&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6个空格分隔 \",\"结果： 这里有 6 个空格分隔\"]},{\"header\":\"链接\",\"slug\":\"链接\",\"contents\":[]},{\"header\":\"超链接\",\"slug\":\"超链接\",\"contents\":[\"格式为 [link text](link)。\",\"[帮助文档](https://support.typora.io/Links/#faq) \",\"帮助文档\"]},{\"header\":\"自动链接\",\"slug\":\"自动链接\",\"contents\":[\"使用 <> 包括的 URL 或邮箱地址会被自动转换为超链接：\",\"<https://www.baidu.com> <123@email.com> \",\"https://www.baidu.com\",\"123@email.com\"]},{\"header\":\"图片\",\"slug\":\"图片\",\"contents\":[\"![自己起的图片名字](图片地址或者图片本地存储的路径) \"]},{\"header\":\"网上的图片\",\"slug\":\"网上的图片\",\"contents\":[\"![炸鸡](https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&quality=100&size=b4000_4000&sec=1580814517&di=2630beac440e5dab0e44c7286a3b2b61&src=http://imgsrc.baidu.com/forum/w=580/sign=12c730c4ff03738dde4a0c2a831ab073/9497794f9258d1091818e6d6d858ccbf6d814d1b.jpg) \",\"炸鸡\"]},{\"header\":\"本地图片\",\"slug\":\"本地图片\",\"contents\":[\"![美食](美食.jpg) 在同一个文件夹里（用相对路径） 或者直接拷贝 \"]},{\"header\":\"画图\",\"slug\":\"画图\",\"contents\":[\"markdown 画图也是轻量级的，功能并不全。\",\"Mermaid 是一个用于画流程图、状态图、时序图、甘特图的库，使用 JS 进行本地渲染，广泛集成于许多 Markdown 编辑器中。Mermaid 作为一个使用 JS 渲染的库，生成的不是一个“图片”，而是一段 HTML 代码。\",\"（不同的编辑器渲染的可能不一样）\"]},{\"header\":\"流程图 (graph)\",\"slug\":\"流程图-graph\",\"contents\":[]},{\"header\":\"概述\",\"slug\":\"概述\",\"contents\":[\"graph 方向描述 图表中的其他语句... \",\"关键字 graph 表示一个流程图的开始，同时需要指定该图的方向。\",\"其中“方向描述”为：\",\"用词\",\"含义\",\"TB\",\"从上到下\",\"BT\",\"从下到上\",\"RL\",\"从右到左\",\"LR\",\"从左到右\",\"T = TOP，B = BOTTOM，L = LEFT，R = RIGHT，D = DOWN\",\"最常用的布局方向是 TB、LR。\",\"graph TB; A-->B B-->C C-->A \",\"graph LR; A-->B B-->C C-->A \"]},{\"header\":\"流程图常用符号及含义\",\"slug\":\"流程图常用符号及含义\",\"contents\":[]},{\"header\":\"节点形状\",\"slug\":\"节点形状\",\"contents\":[\"表述\",\"说明\",\"含义\",\"id[文字]\",\"矩形节点\",\"表示过程，也就是整个流程中的一个环节\",\"id (文字)\",\"圆角矩形节点\",\"表示开始和结束\",\"id ((文字))\",\"圆形节点\",\"表示连接。为避免流程过长或有交叉，可将流程切开。成对\",\"id\",\"菱形节点\",\"表示判断、决策\",\"id>文字]\",\"右向旗帜状节点\",\"单向箭头线段：表示流程进行方向\",\"id 即为节点的唯一标识，A~F 是当前节点名字，类似于变量名，画图时便于引用\",\"括号内是节点中要显示的文字，默认节点的名字和显示的文字都为 A\",\"graph TB A B(圆角矩形节点) C[矩形节点] D((圆形节点)) E{菱形节点} F>右向旗帜状节点] \",\"graph TB begin(出门)--> buy[买东西] buy --> IsRemaining{\\\"没有？\\\"} IsRemaining -->|有|happy[买到了开心]--> goBack(回家) IsRemaining --没有--> sad[\\\"伤心\\\"]--> goBack \"]},{\"header\":\"连线\",\"slug\":\"连线\",\"contents\":[\"graph TB A1-->B1 A2---B2 A3--text---B3 A4--text-->B4 A5-.-B5 A6-.->B6 A7-.text.-B7 A8-.text.->B8 A9===B9 A10==>B10 A11==text===B11 A12==text==>B12 \"]},{\"header\":\"子图表\",\"slug\":\"子图表\",\"contents\":[\"使用以下语法添加子图表\",\"subgraph 子图表名称 子图表中的描述语句... end \",\"graph TB subgraph 买东西前 begin(出门)--> buy[出门买东西] end buy --> IsRemaining{\\\"还有没有？\\\"} IsRemaining --没有--> sad[\\\"伤心\\\"]--> goBack(回家) IsRemaining -->|有|happy[买到啦]--> goBack \"]},{\"header\":\"饼图（Pie）\",\"slug\":\"饼图-pie\",\"contents\":[\"pie title 销售图 \\\"苹果\\\" : 100 \\\"橘子\\\" : 200.4 \\\"香蕉\\\" : 50 \"]},{\"header\":\"甘特图（gantt）\",\"slug\":\"甘特图-gantt\",\"contents\":[\" title 标题 dateFormat 日期格式 section 部分名 任务名:参数一, 参数二, 参数三, 参数四，参数五 //参数一：crit（是否重要，红框框） 或者 不填 //参数二：done（已完成）、active（正在进行） 或者 不填(表示为待完成状态) //参数三：取小名 或者 不填 //参数四：任务开始时间 //参数五：任务结束时间 \",\"官方教程\",\"gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page :20h Add another diagram to demo page :48h \"]}]},\"/software-tool/markdown/\":{\"title\":\"MarkDown\",\"contents\":[]},\"/software-tool/nodejs/01-NodeJS%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE.html\":{\"title\":\"NodeJS下载安装与配置\",\"contents\":[{\"header\":\"什么是 Node JS\",\"slug\":\"什么是-node-js\",\"contents\":[\"Node. js is a JavaScript runtime built on Chrome's V8 JavaScript engine。 Node. js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境\"]},{\"header\":\"下载\",\"slug\":\"下载\",\"contents\":[\"官网下载：Node.js\",\"NodeJS下载安装与配置01.png\"]},{\"header\":\"安装\",\"slug\":\"安装\",\"contents\":[\"打开安装包，默认 next 下一步即可，等待安装完成。 打开安装目录：\",\"NodeJS下载安装与配置02.png\",\"打开命令提示符，输入如下命令，出现版本号即说明安装成功。\",\"node -v \",\"和\",\"npm -v \",\"NodeJS下载安装与配置03.gif\"]},{\"header\":\"配置\",\"slug\":\"配置\",\"contents\":[\"配置全局安装的模块路径和缓存路径\"]},{\"header\":\"模块路径\",\"slug\":\"模块路径\",\"contents\":[\"在 nodejs 根目录, 创建 node_global，node_cache 文件夹，如图：\",\"NodeJS下载安装与配置04.png\",\"然后以管理员身份打开 cmd，配置路径：\",\"npm config set prefix \\\"D:\\\\nodejs\\\\node_global\\\" \",\"和\",\"npm config set cache \\\"D:\\\\nodejs\\\\node_cache\\\" \",\"NodeJS下载安装与配置05.png\",\"使用如下命令查看：\",\"npm config get prefix \",\"和\",\"npm config get cache \",\"NodeJS下载安装与配置06.png\"]},{\"header\":\"安装 vue\",\"slug\":\"安装-vue\",\"contents\":[\"使用命令：\",\"npm install -g vue \",\"如图：\",\"NodeJS下载安装与配置07.png\"]},{\"header\":\"缓存路径\",\"slug\":\"缓存路径\",\"contents\":[\"找到环境变量：右键此电脑——属性——高级系统设置——高级——环境变量\",\"在用户变量下，将 AppData\\\\Roaming\\\\npm 更改为\",\"D:\\\\nodejs\\\\node_global \",\"NodeJS下载安装与配置08.png\",\"创建 NODE_PATH 变量 变量值为：\",\"D:\\\\nodejs\\\\node_global\\\\node_modules \",\"添加系统变量，在 path 中添加\",\"%NODE_PATH% \",\"步骤如下：\",\"NodeJS下载安装与配置09.gif\",\"最终结果如图： 用户变量，path 中\",\"NodeJS下载安装与配置10.png\",\"系统变量：\",\"NodeJS下载安装与配置11.png\",\"系统变量，path 中：\",\"NodeJS下载安装与配置12.png\"]},{\"header\":\"测试\",\"slug\":\"测试\",\"contents\":[\"打开命令提示符： 输入如下命令：\",\"node \",\"然后输入：\",\"require('vue') \",\"出现如图即测试成功：\",\"NodeJS下载安装与配置13.png\"]},{\"header\":\"配置镜像\",\"slug\":\"配置镜像\",\"contents\":[\"使用国内的镜像可以提高下载速度 命令：\",\"npm config set registry https://registry.npm.taobao.org \",\"查看镜像：\",\"npm config get registry \",\"如图：\",\"NodeJS下载安装与配置14.png\"]}]},\"/software-tool/nodejs/\":{\"title\":\"NodeJS\",\"contents\":[]},\"/software-tool/photoshop/01-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html\":{\"title\":\"基本操作\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"部分操作：\",\"文件→打开 ：可以打开我们要测量的图片\",\"Ctrl+R：可以打开标尺，或者视图→标尺\",\"右击标尺，把里面的单位改为像素\",\"Ctrl+ 加号 (+)可以放大视图， Ctrl+ 减号 (-)可以缩小视图\",\"按住空格键，鼠标可以变成小手，拖动 PS 视图\",\"用选区拖动可以测量大小\",\"Ctrl+ D 可以取消选区，或者在旁边空白处点击一下也可以取消选区\"]}]},\"/software-tool/photoshop/02-PS%E5%88%87%E5%9B%BE.html\":{\"title\":\"PS切图\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"PS 有很多的切图方式：图层切图、切片切图、PS 插件切图等\"]},{\"header\":\"图层切图\",\"slug\":\"图层切图\",\"contents\":[\"简单版步骤：\",\"使用移动工具，点击需要的图片\",\"查看右侧，找到图片对应的图层，右击图层 → 快速导出为 PNG\",\"但是很多情况下, 我们需要合并图层再导出:\",\"步骤：\",\"选中需要的若干个图层：选择一个图层，再按住 shift 键，继续选第二个图层\",\"然后选择图层菜单 → 合并图层 (ctrl+e)\",\"查看右侧生成的新图层，在合并后的图层上，右击 → 快速导出为 PNG\"]},{\"header\":\"切片切图\",\"slug\":\"切片切图\",\"contents\":[\"步骤：\",\"利用切片选中图片：利用切片工具手动划出\",\"导出选中的图片：文件菜单 → 导出 → 存储为 web 设备所用格式 → 选择我们要的图片格式 → 存储\",\"注意：保存的时候，要选“选中的切片”\"]},{\"header\":\"插件切图\",\"slug\":\"插件切图\",\"contents\":[]},{\"header\":\"介绍\",\"slug\":\"介绍\",\"contents\":[\"Cutterman 是一款运行在 Photoshop 中的插件，能够自动将你需要的图层进行输出，以替代传统的手工 \\\"导出 web 所用格式\\\" 以及使用切片工具进行挨个切图的繁琐流程\",\"它支持各种各样的图片尺寸、格式、形态输出，方便你在 PC、IOS、Android 等端上使用。它不需要你记住一堆的语法、规则，纯点击操作，方便、快捷，易于上手\"]},{\"header\":\"安装\",\"slug\":\"安装\",\"contents\":[\"注意： cutterman 插件要求你的 ps 必须是完整版，不能是绿色版\",\"查看 “窗口菜单”里面的“扩展功能”：\",\"如果是扩展功能的是灰色的，表示就是绿色版的，需要重新安装 PS\",\"如果是扩展功能右侧是可以使用的，表示就是完整版的，可以安装 cutterman 插件快速切图\",\"官网: http://www.cutterman.cn/zh/cutterman\",\"当 cutterman 安装完成后，重启 PS，会发现扩展功能里面多了一个 cutterman 工具\",\"使用步骤：\",\"选择需要的图层\",\"选择 web 端\",\"选择需要的图片格式\",\"设置好存储路径\",\"点击 “导出选中图层” 按钮\"]}]},\"/software-tool/photoshop/\":{\"title\":\"Photoshop\",\"contents\":[]},\"/software-tool/vscode/01-VSCode%E7%BC%96%E5%86%99HTML%E5%92%8CCSS.html\":{\"title\":\"VSCode编写HTML和CSS\",\"contents\":[{\"header\":\"写 HTML/CSS 文件\",\"slug\":\"写-html-css-文件\",\"contents\":[\"新建一个文件，名为 test.html, 输入如下代码：\",\"<html> <body> <h1>这是第一个标题</h1> <p>这是第一个段落</p> </body> </html> \"]},{\"header\":\"运行\",\"slug\":\"运行\",\"contents\":[\"VSCode和HTML和CSS01.png\",\"推荐使用 Live Server 插件，可以实时查看效果。以及 HTML CSS Support 插件，来支持 HTML 和 CSS 语法\"]}]},\"/software-tool/vscode/02-VSCode%E5%BC%80%E5%8F%91%E5%B5%8C%E5%85%A5%E5%BC%8F.html\":{\"title\":\"VSCode开发嵌入式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"使用 Embedded IDE 配合 SDCC 来开发嵌入式 网站中有详细的使用方法\",\"注意：安装时. NET 可能无法自动安装，需自行安装\"]}]},\"/software-tool/vscode/03-VSCode%E9%85%8D%E7%BD%AEC%E5%92%8CCPP%E7%8E%AF%E5%A2%83.html\":{\"title\":\"VSCode配置C和C++环境\",\"contents\":[{\"header\":\"C/C++的编译过程\",\"slug\":\"c-c-的编译过程\",\"contents\":[\"从 .c 或 .cpp 文件通过 编译器 来生成 .exe 文件（可执行程序）\",\"编译器将执行以下步骤\",\"预编译 将 .c 中的头文件展开、宏展开，生成的文件是 .i 文件\",\"编译 将预处理之后的 .i 文件生成 .s 汇编文件\",\"汇编 将 .s 汇编文件生成 .o 目标文件\",\"链接 将 .o 文件链接成目标文件\",\"使用命令行为：\",\"$ cd C++文件目录 $ g++ -c test.cpp $ g++ test.o $ ./a.exe \",\"可以使用 -o 来自定义目标文件的名字\",\"$ cd C++文件目录 $ g++ -c test.cpp -o a.o $ g++ a.o -o test.exe $ ./test.exe \",\"或直接使用\",\"$ cd C++文件目录 $ g++ test.cpp $ ./a.exe \",\"可以使用 -o 来自定义目标文件的名字\"]},{\"header\":\"GCC 编译器下载和配置\",\"slug\":\"gcc-编译器下载和配置\",\"contents\":[\"GCC 中 C 语言编译器是 gcc，c++编译器是 g++，调试器是 gdb\",\"下载 TDM-GCC 联想应用商店下载链接：TDM-GCC-联想应用商店 下载安装即可\"]},{\"header\":\"VSCode 配置 C/C++\",\"slug\":\"vscode-配置-c-c\",\"contents\":[\"下载 C/C++插件\",\"VSCode和C01.png\",\"下载完成后重启 VSCode\",\"配置 新建文件夹（用来放 VSCode 的项目，必须是英文）\",\"在文件夹下创建一个 test1.c 文件 代码如下：\",\"#include <stdio.h> #include <stdlib.h> int main() { printf(\\\"hello world\\\\n\\\"); printf(\\\"你好\\\\n\\\"); system(\\\"pause\\\"); return 0; } \",\"创建一个 test2.cpp 文件 代码如下：\",\"int main() { std::cout << \\\"Hello World 哈哈\\\\n\\\"; system(\\\"pause\\\"); return 0; } \",\"运行,选择 g++编译器，会在文件夹中自动创建 .vscode 文件夹 4. 测试是否成功 5. 设置外部窗口执行 点击右上角齿轮按钮\",\"VSCode和C02.png\",\"点击生成和调试活动文件\",\"VSCode和C03.png\",\"此时 .vscode 文件夹中出现 launch.json 文件 在 launch.json 文件中设置 \\\"externalConsole\\\": false, 将 false 改为 true 6. 中文乱码解决 在 tasks.json 文件中找到 \\\"${fileDirname}\\\\\\\\${fileBasenameNoExtension}.exe\\\", 在其后面添加 , 然后下一行添加 \\\"-fexec-charset=GBK\\\" 即可 9. 设置隐藏. exe 文件 点击设置，搜索：Files: Exclude\",\"VSCode和C04.png\",\"点击添加模式，添加\",\"例如：**/*.exe**/*.class\"]},{\"header\":\"使用命令行进行多文件编译\",\"slug\":\"使用命令行进行多文件编译\",\"contents\":[\"文件目录结构如下\",\"D:. │ main.cpp │ ├─include │ fun.h │ └─src fun.cpp \",\"使用命令\",\"$ g++ .\\\\src\\\\fun.cpp .\\\\main.cpp -o test -I.\\\\include\\\\ \",\"在目录中会生成名称为 test 的可执行文件\"]},{\"header\":\"配置 CMake\",\"slug\":\"配置-cmake\",\"contents\":[]},{\"header\":\"CMake 环境配置\",\"slug\":\"cmake-环境配置\",\"contents\":[\"下载 CMake Download | CMake\",\"安装过程中注意勾选添加系统环境变量\",\"VSCode和C05.png\",\"安装插件 CMake 和 CMake Tools\",\"VSCode和C06.png\",\"安装完成后重启即可\"]},{\"header\":\"CMake 使用\",\"slug\":\"cmake-使用\",\"contents\":[]},{\"header\":\"单文件编译\",\"slug\":\"单文件编译\",\"contents\":[\"在项目文件中创建一个 CMakeLists.txt 文件，注意，名称不能改变，区分大小写\",\"首先进入文件，文件第一行（第一行必须填写）填写本项目对 CMake 最低版本的要求\",\"# 本项目对 CMake 最低版本的要求 cmake_minimum_required(VERSION 版本号) \",\"注：使用 cmake -version 命令可以查看当前设备的版本号\",\"第二行我们编写项目名称\",\"# 项目名称 project(项目名称) \",\"该命令会创建项目本身，并指定项目名称，每个 CMakeLists 文件只能定义一个项目\",\"第三行我们编写生成可执行文件的名称和包含的文件\",\"# 将源文件编译成一个可执行文件 add_executable(可执行文件名称 源文件) \",\"例：\",\"# 将名为 main.cpp 的源文件编译成一个名称为 myProject 的可执行文件 add_executable(myProject main.cpp) \",\"以上三行是必须的\",\"然后使用快捷键 ctrl+shift+p, 运行 CMake config, 等待配置完成即可\",\"然后运行 CMake build\",\"以上是简单的单文件的编译\"]},{\"header\":\"多文件编译\",\"slug\":\"多文件编译\",\"contents\":[\"文件目录结构如下\",\"D:. │ main.cpp │ ├─include │ fun.h │ └─src fun.cpp \",\"在项目文件中创建一个 CMakeLists.txt 文件，注意，名称不能改变，区分大小写\",\"CMakeLists.txt 文件中的内容如下\",\"cmake_minimum_required(VERSION 3.25.1) project(myProject) aux_source_directory(src SRC_SUB) aux_source_directory(. SRC_CUR) add_executable(Project ${SRC_SUB} ${SRC_CUR}) include_directories(include) \",\"cmake_minimum_required (VERSION 版本号) : 本项目对 CMake 最低版本的要求\",\"project() ：设置项目名称，参数可以随意指定\",\"aux_source_directory (dir VAR) : 搜索 dir 目录下所有的源文件，并将结果列表存储在变量 VAR 中\",\"add_executable (target src) : 指定使用源文件 src，生成可执行程序 target , ${变量名} 是取变量的值\",\"include_directories (headDir) : 设置包含的头文件目录\",\"然后使用快捷键 ctrl+shift+p, 运行 CMake config, 等待配置完成即可\",\"然后运行 CMake build\",\"或者使用命令行 在终端中进入 build 目录\",\"$ cd build $ cmake .. $ mingw32-make.exe \",\"最终可执行程序就生成到 build 目录中了\"]}]},\"/software-tool/vscode/04-VSCode%E9%85%8D%E7%BD%AEPython%E7%8E%AF%E5%A2%83.html\":{\"title\":\"VSCode配置Python环境\",\"contents\":[{\"header\":\"下载 Python\",\"slug\":\"下载-python\",\"contents\":[\"打开 Python 官网：https://www.python.org/ ，点击 “Download”下载最新 python 版本\",\"VSCode和Python01.png\",\"下载完成后自动弹出安装界面，务必先把下方两个对勾打上，把想要安装的文件夹路径复制下来，再点击 “Install Now”安装。\",\"等待 Python 安装完成。\"]},{\"header\":\"在 VSCode 中安装 Python 插件\",\"slug\":\"在-vscode-中安装-python-插件\",\"contents\":[\"点击 VSCode 界面左边的 “扩展”，在扩展搜索框中输入 Python，选中第一个框后点击 “安装”\",\"VSCode和Python02.png\"]},{\"header\":\"添加环境变量\",\"slug\":\"添加环境变量\",\"contents\":[\"右键点击 “此电脑”，选择 “属性”，点击 “高级系统设置–环境变量”。在系统变量中找到 “Path”，然后点击 “编辑”\",\"VSCode和Python03.png\",\"进入后，点击 “新建”，把复制的 python. exe 路径粘贴上去，点击 “确定”就完成了 Python 环境的配置\",\"VSCode和Python04.png\"]},{\"header\":\"测试 Python\",\"slug\":\"测试-python\",\"contents\":[\"打开 VSCode，点击“新建文件”，并选择保存为 python 类型\",\"VSCode和Python05.png\",\"输入 print (“hello!”) 并运行\",\"VSCode和Python06.png\",\"如果终端出现 “hello!”，表示 Python 程序测试正常。\",\"这样就配置成功了\"]}]},\"/software-tool/vscode/05-VSCode%E4%BD%BF%E7%94%A8%E5%9B%9E%E8%BD%A6%E9%94%AE%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8.html\":{\"title\":\"VSCode使用回车键代码补全\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"在 （一般都是这个路径）C:\\\\Users\\\\你的用户名\\\\AppData\\\\Roaming\\\\Code\\\\User 下的 keybindings. json 文件中添加一段代码。\",\"{ \\\"key\\\": \\\"enter\\\", \\\"command\\\": \\\"acceptSelectedSuggestion\\\", \\\"when\\\": \\\"editorTextFocus && suggestWidgetVisible\\\" } \",\"然后重启即可\"]}]},\"/software-tool/vscode/06-VSCode%E4%BD%BF%E7%94%A8EasyX%E5%9B%BE%E5%BD%A2%E5%BA%93.html\":{\"title\":\"VSCode使用EasyX图形库\",\"contents\":[{\"header\":\"安装 TDM-GCC\",\"slug\":\"安装-tdm-gcc\",\"contents\":[\"联想应用商店下载链接：TDM-GCC-联想应用商店 官方网站： tdm-gcc 下载安装即可\"]},{\"header\":\"下载 EasyX 图形库\",\"slug\":\"下载-easyx-图形库\",\"contents\":[\"网址: EasyX，下载库文件，解压完之后将 include 文件夹下的头文件和 lib32/lib64 文件夹下的库文件，分别拷贝到 MinGW 的头文件和库文件文件夹中\",\"VSCode和EasyX01.png\",\"(1) 将 include 文件夹下的 easyx. h 和 graphics. h 拷贝到 C:\\\\TDM-GCC-64\\\\x86_64-w64-mingw32\\\\include\\\\ 文件夹里 (2) 将 lib64\\\\libeasyx. a 拷贝到 C:\\\\TDM-GCC-64\\\\x86_64-w64-mingw32\\\\lib\\\\ 文件夹里 (3) 将 lib32\\\\libeasyx. a 拷贝到 C:\\\\TDM-GCC-64\\\\x86_64-w64-mingw32\\\\lib32\\\\ 文件夹里\"]},{\"header\":\"配置 VSCode\",\"slug\":\"配置-vscode\",\"contents\":[\"在 tasks. json 文件中添加链接\",\"{ \\\"tasks\\\": [ { \\\"type\\\": \\\"cppbuild\\\", \\\"label\\\": \\\"C/C++: g++.exe 生成活动文件\\\", \\\"command\\\": \\\"C:\\\\\\\\TDM-GCC-64\\\\\\\\bin\\\\\\\\g++.exe\\\", \\\"args\\\": [ \\\"-fdiagnostics-color=always\\\", \\\"-g\\\", \\\"${file}\\\", \\\"-o\\\", \\\"${fileDirname}\\\\\\\\${fileBasenameNoExtension}.exe\\\", \\\"-fexec-charset=GBK\\\", \\\"-leasyx\\\"//添加此链接 ], \\\"options\\\": { \\\"cwd\\\": \\\"${fileDirname}\\\" }, \\\"problemMatcher\\\": [ \\\"$gcc\\\" ], \\\"group\\\": { \\\"kind\\\": \\\"build\\\", \\\"isDefault\\\": true }, \\\"detail\\\": \\\"调试器生成的任务。\\\" } ], \\\"version\\\": \\\"2.0.0\\\" } \"]},{\"header\":\"测试\",\"slug\":\"测试\",\"contents\":[\"输入如下代码\",\"#include <graphics.h> #include <conio.h> int main() { initgraph(640, 480); circle(320, 240, 100); getch(); closegraph(); return 0; } \",\"运行出现圆圈即成功\"]}]},\"/software-tool/vscode/07-VSCode%E4%BD%BF%E7%94%A8Vim.html\":{\"title\":\"VSCode使用Vim\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"使用 Vim 可以大幅提高编码效率 找到扩展，安装 Vim 扩展即可 添加如下代码到 setting.json 文件中即可设置 jj 键替代 esc 键\",\"{ \\\"vim.insertModeKeyBindings\\\": [ { \\\"before\\\": [\\\"j\\\", \\\"j\\\"], \\\"after\\\": [\\\"<Esc>\\\"] } ], \",\"添加如下代码到 setting.json 文件中即可设置相对行号\",\"\\\"editor.lineNumbers\\\": \\\"relative\\\", \"]}]},\"/software-tool/vscode/\":{\"title\":\"VSCode\",\"contents\":[]}}}");self.onmessage=({data:o})=>{self.postMessage($(o.query,m[o.routeLocale]))};
//# sourceMappingURL=original.js.map
