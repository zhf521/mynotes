---
title: 身份认证
order: 2
---

我们已经实现了登录注册，我们需要在登录成功后，每次请求时在请求头中携带token来访问受保护的路由，下面我们来看一下如何保护要认证的路由

通过要求请求中存在有效的 JWT 来保护端点

首先，在 `auth` 文件夹中创建一个名为 `jwt.strategy.ts` 的文件，并添加以下代码：

```typescript
// jwt.strategy.ts

import { ExtractJwt, Strategy } from 'passport-jwt';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable } from '@nestjs/common';
import { jwtConstants } from './constants';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor() {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: jwtConstants.secret,
    });
  }

  async validate(payload: any) {
    return { userId: payload.sub, username: payload.username };
  }
}
```

将新的 `JwtStrategy` 作为提供者添加到 `AuthModule` 中：

```typescript
// auth.module.ts

import { Module } from '@nestjs/common';
import { AuthController } from './auth.controller';
import { AuthService } from './auth.service';
import { JwtModule } from '@nestjs/jwt';
import { jwtConstants } from './constants';
import { JwtStrategy } from './jwt.strategy';

@Module({
  imports: [
    JwtModule.register({
      global: true,
      secret: jwtConstants.secret,
      signOptions: { expiresIn: '100d' },
    }),
  ],
  controllers: [AuthController],
  providers: [AuthService, JwtStrategy],
})
export class AuthModule {}
```

在auth文件夹下，新建一个`jwt-auth.guard.ts`文件，定义一个扩展了内置 `AuthGuard` 的 `JwtAuthGuard` 类：

```typescript
// jwt-auth.guard.ts

import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}
```

我们现在可以实现受保护的路由及其关联的 Guard

例如：打开 `auth.controller.ts` 文件并按下面所示进行更新：

```typescript
// auth.controller.ts

import {
  Body,
  Controller,
  Post,
  ValidationPipe,
  Get,
  UseGuards,
} from '@nestjs/common';
import { RegisterDto } from './dto/register.dto';
import { AuthService } from './auth.service';
import { LoginDto } from './dto/login.dto';
import { JwtAuthGuard } from './jwt-auth.guard';

@Controller('auth')
export class AuthController {
  constructor(private auth: AuthService) {}
  @Post('register')
  async register(@Body(new ValidationPipe()) registerDto: RegisterDto) {
    return this.auth.register(registerDto);
  }
  @Post('login')
  async login(@Body(new ValidationPipe()) LoginDto: LoginDto) {
    return this.auth.login(LoginDto);
  }
  @UseGuards(JwtAuthGuard)
  @Get('profile')
  getProfile() {
    return '成功';
  }
}
```

我们访问`/auth/profile`接口，必须携带token才可以
