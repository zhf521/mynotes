***

title: 登录注册
order: 1

***

## 1. 登录的流程

* 使用JWT实现：
  
  1. **用户登录**：
     
     * 用户在前端输入用户名和密码，并将其发送到后端进行验证。
     
     * 后端验证用户的凭据，并生成一个包含用户信息的 JWT。
  
  2. **JWT生成**：
     
     * 后端使用密钥对用户信息进行签名，生成一个 JWT。
     
     * JWT 包含了用户的一些信息以及用于验证的签名信息，通常会包含用户身份、权限等信息。
  
  3. **JWT返回**：
     
     * 后端将生成的 JWT 发送回前端应用程序。
  
  4. **前端存储**：
     
     * 前端应用程序接收到 JWT 后，将其存储在本地，通常是在浏览器的本地存储（如 Local Storage 或 Session Storage）中。
  
  5. **后续请求**：
     
     * 用户在前端应用程序执行其他操作时，前端会将 JWT 添加到每个请求的 Authorization 头中。
     
     * 后端服务器在收到请求后，会验证 JWT 的有效性，从而验证用户的身份和权限。

* 使用session实现：
  
  1. **用户登录**：
     
     * 用户在前端输入用户名和密码，并将其发送到后端进行验证。
     
     * 后端验证用户的凭据，并创建一个会话来存储用户的身份信息。
  
  2. **会话创建**：
     
     * 后端创建一个唯一的会话标识符（session ID），并将用户身份信息与该会话关联起来。
     
     * 会话可以在服务器端存储，通常会保存在内存、数据库或者缓存中。
  
  3. **会话标识返回**：
     
     * 后端将生成的会话标识符发送回前端应用程序，通常通过设置一个名为 `sessionID` 的 HTTP Cookie。
  
  4. **后续请求**：
     
     * 用户在前端应用程序执行其他操作时，浏览器会自动将包含会话标识符的 Cookie 添加到每个请求的头部中。
  
  5. **会话验证**：
     
     * 后端在收到请求时，会根据会话标识符找到对应的会话，并验证用户的身份信息以及权限。

* 使用OAuth实现：
  
  1. **用户登录**：
     
     * 用户在前端输入用户名和密码，并将其发送到后端进行验证。
  
  2. **OAuth认证请求**：
     
     * 后端服务器向认证服务器发起 OAuth 认证请求，包括包含客户端标识和重定向URI的认证请求。
  
  3. **用户授权**：
     
     * 认证服务器要求用户进行身份验证，然后询问用户是否授权客户端应用程序访问其受保护的资源。
     
     * 如果用户同意，认证服务器将发回一个授权码（authorization code）。
  
  4. **授权码交换令牌**：
     
     * 后端服务器使用授权码向认证服务器请求访问令牌（access token）。
     
     * 认证服务器验证授权码，并发回访问令牌和可能的刷新令牌。
  
  5. **访问令牌返回**：
     
     * 后端服务器将访问令牌发送回前端应用程序。
  
  6. **后续请求**：
     
     * 用户在前端应用程序执行其他操作时，前端应用程序将访问令牌添加到每个请求的 Authorization 头中。
     
     * 后端服务器验证访问令牌，以确保用户被授权执行请求的操作。

## 2. 注册的流程

* 使用JWT实现：
  
  1. **前端注册页面**：
     
     * 前端提供用户注册表单，用户输入注册所需的信息，如用户名、密码、邮箱等。
  
  2. **前端验证**：
     
     * 前端应用程序对用户输入的信息进行验证，确保格式正确并满足要求。
  
  3. **发送注册请求**：
     
     * 用户填写完注册信息后，前端应用程序将注册信息发送到后端进行处理。
  
  4. **后端处理注册请求**：
     
     * 后端服务器接收到注册请求后，验证用户提供的信息的有效性，如检查用户名是否已存在。
  
  5. **用户信息存储和JWT生成**：
     
     * 如果提供的信息有效，后端服务器将用户信息存储到数据库中，并生成一个包含用户信息的 JWT。
     
     * JWT 包含了用户的一些信息以及用于验证的签名信息，通常会包含用户身份、权限等信息。
  
  6. **JWT返回**：
     
     * 后端向前端发送包含生成的 JWT 的响应，通知用户注册成功。

* 使用session实现：
  
  1. **前端注册页面**：
     
     * 前端提供用户注册表单，用户输入注册所需的信息，如用户名、密码、邮箱等。
  
  2. **前端验证**：
     
     * 前端应用程序对用户输入的信息进行验证，确保格式正确并满足要求。
  
  3. **发送注册请求**：
     
     * 用户填写完注册信息后，前端应用程序将注册信息发送到后端进行处理。
  
  4. **后端处理注册请求**：
     
     * 后端服务器接收到注册请求后，验证用户提供的信息的有效性，如检查用户名是否已存在。
  
  5. **用户信息存储和会话创建**：
     
     * 如果提供的信息有效，后端服务器将用户信息存储到数据库中，并创建一个会话来存储用户的身份信息。
     
     * 后端服务器创建一个唯一的会话标识符（session ID），并将用户身份信息与该会话关联起来。
  
  6. **会话标识返回**：
     
     * 后端将生成的会话标识符发送回前端应用程序，通常通过设置一个名为 `sessionID` 的 HTTP Cookie。
  
  7. **注册成功反馈**：
     
     * 后端向前端发送注册成功的响应，通知用户注册成功。

## 3. Nest实现注册功能

### 1. 创建项目

```bash
nest new project-name
```

### 2. 连接数据库

使用Prisma连接MySQL数据库（细节见文档：[Prisma](https://docs.nestjs.cn/10/recipes?id=prisma)）

#### 1. 安装Prisma

安装 Prisma Cli：

```bash
npm install prisma --save-dev
```

使用 npx 在本地调用CLI：

```bash
npx prisma
```

创建初始的 Prisma 设置：

```bash
npx prisma init
```

#### 2. 设置数据库连接

将`schema.prisma`文件中内容更改为：

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}
```

将`.env`文件中内容更改为：

```env
DATABASE_URL="mysql://用户名:密码@域名:端口号/数据库名称"
```

例如：

```env
# .env

DATABASE_URL="mysql://root:123456@localhost:3306/nest-blog"
```

#### 3. 创建数据库表

我们创建一个User模型并添加到`schema.prisma`文件中：

```prisma
model user {
  id       Int    @id @default(autoincrement()) @db.UnsignedInt
  name     String @unique
  password String
}
```

例：

```prisma
// schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model user {
  id       Int    @id @default(autoincrement()) @db.UnsignedInt
  name     String @unique
  password String
}
```

创建Prisma模型后，可以生成SQL迁移文件并在数据库运行它们。在终端中运行以下命令：

```bash
npx prisma migrate dev
```

#### 4. 安装并生成Prisma客户端

```bash
npm install @prisma/client
```

请注意，在安装过程中，Prisma会自动为您调用 `prisma generate` 命令。将来，您需要在每次更改Prisma模型后运行此命令，以更新生成的Prisma客户端

### 3. 创建认证（auth）模块

创建模块：

```bash
nest generate module auth
```

创建控制器：

```bash
nest generate controller auth
```

创建服务：

```bash
nest generate service auth
```

### 4. 创建数据传输对象（DTO）

使用DTO（数据传输对象）的主要原因之一是帮助规范和验证数据的结构和内容，以及在不同层之间传递数据。DTO可以在Nest.js应用程序中用于定义请求和响应的数据结构，并通过验证来确保数据的完整性和有效性

在auth文件夹下创建dto文件夹，在文件夹中创建`register.dto.ts`文件：

```typescript
// register.dto.ts

export class RegisterDto {
  name: string;
  password: string;
  password_confirm: string;
}
```

### 5. 为DTO添加验证装饰器

管道有两个典型的应用场景:

- **转换**：管道将输入数据转换为所需的数据输出(例如，将字符串转换为整数)
- **验证**：对输入数据进行验证，如果验证成功继续传递; 验证失败则抛出异常

我们可以使用管道中的类验证器（[类验证器](https://docs.nestjs.cn/10/pipes?id=%e7%b1%bb%e9%aa%8c%e8%af%81%e5%99%a8)）来对输入数据进行验证，如果验证成功继续传递; 验证失败则抛出异常

我们使用`class-validator`库来实现

安装依赖：

```typescript
npm i --save class-validator class-transformer
```

使用装饰器来验证字段：

```typescript
// register.dto.ts

import { IsNotEmpty } from 'class-validator';

export class RegisterDto {
  @IsNotEmpty({ message: '用户名不能为空' })
  name: string;
  @IsNotEmpty({ message: '密码不能为空' })
  password: string;
  @IsNotEmpty({ message: '确认密码不能为空' })
  password_confirm: string;
}
```

在控制器中使用：

```typescript
// auth.controller.ts

import { Body, Controller, Post, ValidationPipe } from '@nestjs/common';
import { RegisterDto } from './dto/register.dto';

@Controller('auth')
export class AuthController {
  @Post('register')
  async register(@Body(new ValidationPipe()) registerDto: RegisterDto) {
    return registerDto;
  }
}
```

此时我们请求`/auth/register`，发送数据即可得到如下内容：

```json
{
    "name": "admin",
    "password": "123456",
    "password_confirm": "123456"
}
```

### 6. 为DTO添加自定义验证规则

要为 DTO（数据传输对象）添加自定义验证规则，可以使用 `class-validator` 库提供的自定义验证装饰器（[自定义验证装饰器](https://github.com/typestack/class-validator#custom-validation-decorators)）

我们创建一个`validate`文件夹来存放自定义验证规则，创建一个`is-exists.validator.ts`文件：

```typescript
// is-exists.validator.ts

```
