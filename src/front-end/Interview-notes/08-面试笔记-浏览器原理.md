---
title: 浏览器原理
order: 8
---

## 1. 浏览器的渲染过程

### 1. 基本过程

1. 解析HTML的所有标签，深度遍历生成DOM树

2. 解析CSS，构建层叠样式表模型CSSOM树

3. 构建Render Tree（渲染树）

   DOM和CSSOM根据一定的规则组合起来生成了Render Tree

4. 布局（Layout）

   确定各个元素的大小、位置。浏览器使用一种**流式**处理的方法，只需要**一次绘制**操作就可以布局所有的元素

5. 绘制（Painting）

   浏览器会遍历Render Tree渲染树，调用paint方法，将渲染树的各个节点绘制到屏幕上

### 2. 关于CSS、JS阻塞问题

- CSS 加载会不会阻塞 JS 的加载？（不会）
- CSS 加载会不会阻塞 JS 的执行？（会）
- CSS 加载会不会阻塞 DOM 的解析？（不会）
- CSS 加载会不会阻塞 DOM 的渲染？（会）
- JS 加载会不会阻塞 DOM 的解析？（会）
- JS 加载会不会阻塞 DOM 的渲染？（会）
- JS 执行会不会阻塞 DOM 的解析？（会）
- JS 执行会不会阻塞 DOM 的渲染？（会）

关于 css，js 的阻塞问题，都跟浏览器的渲染进程有关。而渲染进程又是多线程的

- JS 引擎线程（单线程）：负责解析 Javascript 脚本，运行代码
- GUI 渲染线程：负责渲染浏览器界面，解析 HTML，CSS，构建 DOM Tree，CSSOM Tree 和 Render Tree，布局和绘制等

> 注意：GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起，所以当 JS 加载和执行时，会阻塞住 DOM 的解析和渲染，导致白屏时间很长

> DOM Tree 和 CSSOM Tree 是并行构建的，所以 CSS 加载不会阻塞 DOM 的解析；由于 Render Tree 是依赖于 DOM Tree 和 CSSOM Tree 的，因此，CSS 加载会阻塞 DOM 的渲染

> GUI 渲染线程与 JS 引擎线程是互斥的，加载解析 CSS 时，JS 引擎会被挂起，所以 CSS 会阻塞 JS 的执行

1. 如果遇到普通（sync）JavaScript脚本加载：文档解析的过程中，如果遇到JavaScript脚本，就会停止页面的解析进行下载，当脚本都执行完毕后，才会继续解析页面
2. 如果遇到异步（async）JavaScript脚本加载：异步脚本会在HTML加载和解析完毕后执行
3. 如果遇到设置了推迟的JavaScript脚本加载：文档解析时，遇到设置了defer的脚本，就会在后台进行下载，但是并不会阻止文档的渲染，当页面解析和渲染完毕后，会等到所有的defer脚本加载完毕并按照顺序执行完毕才会触发

> **defer是“渲染完再执行”：**依赖于页面中的DOM元素（文档是否解析完毕），或者被其他脚本文件**依赖**
>
> **async是“下载完就执行”：**并不关心页面中的DOM元素（文档是否解析完毕），并且也不会产生其他脚本需要的数据

