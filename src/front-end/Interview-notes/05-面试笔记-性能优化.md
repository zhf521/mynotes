---
title: 性能优化
order: 5
---

## 1. 回流（重排）和重绘

> **回流必将引起重绘，重绘不一定会引起回流**

### 1.1 回流（重排）

当DOM结构中的元素改变尺寸、宽高、边框、内容、位置时，导致需要重新构建页面的过程

会导致回流的操作：

+ **增删可见的** DOM 元素时
+ 元素的**尺寸或位置**发生改变
+ 元素内容发生改变
+ 元素字体大小变化
+ 页面**首次渲染**
+ 浏览器窗口大小发生改变
+ 激活CSS伪类（例如`:hover`）
+ 获取一些特定属性的值
  + offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight
  + 这些属性有一个共性，就是需要通过即时计算得到。因此浏览器为了获取这些值，也会进行回流

### 1.2 重绘

当页面中元素的样式发生改变，但没有改变它在文档流中的位置时，导致浏览器重新绘制的过程

会导致重绘的操作：

+ 颜色的修改
+ 文本方向的修改
+ 阴影的修改

### 1.3 如何减少

- 如果想设定元素的样式，通过改变元素的 `class` 类名 (尽可能在 DOM 树的最里层)
- 避免设置多项内联样式
- 应用元素的动画，使用 `position` 属性的 `fixed` 值或 `absolute` 值
- 避免使用 `table` 布局，`table` 中每个元素的大小以及内容的改动，都会导致整个 `table` 的重新计算
- 对于那些复杂的动画，对其设置 `position: fixed/absolute`，尽可能地使元素脱离文档流，从而减少对其他元素的影响
- 使用CSS3硬件加速，可以让`transform`、`opacity`、`filters`这些动画不会引起回流重绘
- 避免使用 CSS 的 `JavaScript` 表达式

## 2. 服务端渲染与客户端渲染

### 2.1 基本概念

**SSR （server side rende**r）服务端渲染，是指由服务侧（server side）完成**页面的DOM结构拼接**，然后发送到浏览器，为其绑定状态与事件，成为完全可交互页面的过程
**CSR（client side rend**er）客户端渲染，是指由客户端（client side）JS完成页面和数据的拼接，生成DOM结构再交由浏览器渲染成页面的过程
**SPA（single page application）**单页面应用，只是局部更新内容。SPA实现的原理就采用了CSR，页面中所有内容由JS控制，需要浏览器进行JS解析才能显示出来
**SEO（search engine optimization）搜索引擎优化**，利用搜索**引擎的规则**提高网站在有关搜索引擎内的自然排名

### 2.2 服务端渲染

![面试笔记-性能优化01.png](https://zhf-picture.oss-cn-qingdao.aliyuncs.com/my-img/面试笔记-性能优化01.png)

**前端耗时少**：因为**后端拼接了html**，**浏览器**只需**直接渲染出来**

**不利于前后端分离**，开发效率低

有利于**SEO**：因为在后端有**完整的html页面**，所以**爬虫**更容易爬取获得信息，更有利于SEO

后端生成静态化文件。即生成**缓存**片段，这样就可以减少数据库查询浪费的时间了，且对于数据变化不大的页面非常高效

占用服务器端**资源**：无需占用客户端资源。即**解析**模板的工作完全交由**后端**来做

### 2.3 客户端渲染

![面试笔记-性能优化02.png](https://zhf-picture.oss-cn-qingdao.aliyuncs.com/my-img/面试笔记-性能优化02.png)

客户端渲染适合构建**交互性强**的应用，而服务端渲染适合需要更好的 SEO、更快的首屏渲染速度和更好的性能的应用

## 3. CDN

CDN (全称 Content Delivery Network)，即内容分发网络

CDN的原理是尽可能的在各个地方分布机房缓存数据，这样即使我们的根服务器在国外，在国内的用户也可以通过国内的机房迅速加载资源

CDN就是根据用户位置分配最近的资源

通过`CDN`的负载均衡系统，智能调度边缘节点提供服务，相当于`CDN`服务的大脑，而缓存系统相当于`CDN`的心脏，缓存命中直接返回给用户，否则回源

## 4. 懒加载

### 1. 什么是懒加载

懒加载也叫做延迟加载、按需加载，**可视化区域之外**的图片不会进行加载，在滚动屏幕时才加载，这样使得网页的加载速度更快，减少了服务器的负载。懒加载适用于图片（长列表）的场景中

### 2. 实现原理

图片的加载是由src引起的，当对src赋值时，浏览器就会请求图片资源。根据这个原理，我们使用HTML5 的data-xxx属性来储存图片的路径，在需要加载图片的时候，将data-xxx中图片的路径赋值给src，这样就实现了图片的按需加载，即懒加载

还可以给`img`的`loading`属性设为`lazy`

### 3. 代码实现

scroll版：

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>懒加载</title>
        <style>
            /* 一定记得设置图片高度 */
            img {
                display: block;
                margin-bottom: 50px;
                height: 200px;
            }
        </style>
    </head>
    <body>
        <img src="./风景图/default.jpg" data-src="./风景图/01.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/02.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/03.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/04.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/05.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/06.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/07.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/08.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/09.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/10.jpg" />
        <script>
            function lazyLoad() {
                // 用属性选择器返回属性名为data-src的img元素列表
                let imgs = document.querySelectorAll('img[data-src]');
                imgs.forEach((item) => {
                    if (item.dataset.src === '') return;
                    if (isElementInViewport(item)) {
                        item.src = item.dataset.src;
                        item.removeAttribute('data-src'); //移除属性，下次不再遍历
                    }
                });
            }
            function isElementInViewport(element) {
                const rect = element.getBoundingClientRect(); // 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置
                return (
                    rect.top >= 0 &&
                    rect.left >= 0 &&
                    rect.bottom <= (window.innerHeight ||
                            document.documentElement.clientHeight) &&
                    rect.right <=
                        (window.innerWidth ||
                            document.documentElement.clientWidth)
                );
            }
            lazyLoad(); //刚开始还没滚动屏幕时，要先触发一次函数，初始化首页的页面图片
            document.addEventListener('scroll', lazyLoad);
        </script>
    </body>
</html>
```

`window.innerHeight` 是浏览器可视区的高度

`document.body.scrollTop || document.documentElement.scrollTop` 是浏览器滚动的过的距离

`imgs.offsetTop` 是元素顶部距离文档顶部的高度（包括滚动条的距离）

图片加载条件：`img.offsetTop <= window.innerHeight + document.body.scrollTop;`

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>懒加载</title>
        <style>
            /* 一定记得设置图片高度 */
            img {
                display: block;
                margin-bottom: 50px;
                height: 200px;
            }
        </style>
    </head>
    <body>
        <img src="./风景图/default.jpg" data-src="./风景图/01.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/02.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/03.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/04.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/05.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/06.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/07.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/08.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/09.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/10.jpg" />
        <script>
            function lazyLoad() {
                // 用属性选择器返回属性名为data-src的img元素列表
                let imgs = document.querySelectorAll('img[data-src]');
                imgs.forEach((item) => {
                    if (item.dataset.src === '') return;
                    if (isElementInViewport(item)) {
                        item.src = item.dataset.src;
                        item.removeAttribute('data-src'); //移除属性，下次不再遍历
                    }
                });
            }
            function isElementInViewport(el) {
                // viewPortHeight 兼容所有浏览器写法
                const viewPortHeight =
                    window.innerHeight ||
                    document.documentElement.clientHeight ||
                    document.body.clientHeight;
                const offsetTop = el.offsetTop;
                const scrollTop = document.documentElement.scrollTop;
                return offsetTop <= viewPortHeight + scrollTop;
            }
            lazyLoad(); //刚开始还没滚动屏幕时，要先触发一次函数，初始化首页的页面图片
            document.addEventListener('scroll', lazyLoad);
        </script>
    </body>
</html>
```

IntersectionObserver版：

`Intersection Observer` 即重叠观察者，从这个命名就可以看出它用于判断两个元素是否重叠，因为不用进行事件的监听，性能方面相比`getBoundingClientRect`会好很多

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>懒加载</title>
        <style>
            /* 一定记得设置图片高度 */
            img {
                display: block;
                margin-bottom: 50px;
                height: 200px;
            }
        </style>
    </head>
    <body>
        <img src="./风景图/default.jpg" data-src="./风景图/01.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/02.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/03.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/04.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/05.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/06.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/07.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/08.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/09.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/10.jpg" />
        <script>
            const images = document.querySelectorAll('img[data-src]');
            function handleIntersection(entries, observer) {
                entries.forEach((entry) => {
                    if (entry.isIntersecting) {
                        const image = entry.target;
                        image.src = image.dataset.src;
                        image.removeAttribute('data-src');
                        observer.unobserve(image);
                    }
                });
            }
            const observer = new IntersectionObserver(handleIntersection);
            images.forEach((image) => {
                observer.observe(image);
            });
        </script>
    </body>
</html>
```







