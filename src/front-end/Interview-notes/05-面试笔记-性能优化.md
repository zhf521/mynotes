---
title: 性能优化
order: 5
---

## 1. 回流（重排）和重绘

> **回流必将引起重绘，重绘不一定会引起回流**

### 1. 回流（重排）

当DOM结构中的元素改变尺寸、宽高、边框、内容、位置时，导致需要重新构建页面的过程

会导致回流的操作：

+ **增删可见的** DOM 元素时
+ 元素的**尺寸或位置**发生改变
+ 元素内容发生改变
+ 元素字体大小变化
+ 页面**首次渲染**
+ 浏览器窗口大小发生改变
+ 激活CSS伪类（例如`:hover`）
+ 获取一些特定属性的值
  + offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight
  + 这些属性有一个共性，就是需要通过即时计算得到。因此浏览器为了获取这些值，也会进行回流

### 2. 重绘

当页面中元素的样式发生改变，但没有改变它在文档流中的位置时，导致浏览器重新绘制的过程

会导致重绘的操作：

+ 颜色的修改
+ 文本方向的修改
+ 阴影的修改

==注意：当触发回流时，一定会触发重绘，但是重绘不一定会引发回流==

### 3. 如何减少

- 如果想设定元素的样式，通过改变元素的 `class` 类名 (尽可能在 DOM 树的最里层)
- 避免设置多项内联样式
- 应用元素的动画，使用 `position` 属性的 `fixed` 值或 `absolute` 值
- 避免使用 `table` 布局，`table` 中每个元素的大小以及内容的改动，都会导致整个 `table` 的重新计算
- 对于那些复杂的动画，对其设置 `position: fixed/absolute`，尽可能地使元素脱离文档流，从而减少对其他元素的影响
- 使用CSS3硬件加速，可以让`transform`、`opacity`、`filters`这些动画不会引起回流重绘
- 避免使用 CSS 的 `JavaScript` 表达式

### 4. documentFragment 是什么？用它跟直接操作 DOM 的区别是什么？



## 2. 服务端渲染与客户端渲染

### 1. 基本概念

**SSR （server side rende**r）服务端渲染，是指由服务侧（server side）完成**页面的DOM结构拼接**，然后发送到浏览器，为其绑定状态与事件，成为完全可交互页面的过程
**CSR（client side rend**er）客户端渲染，是指由客户端（client side）JS完成页面和数据的拼接，生成DOM结构再交由浏览器渲染成页面的过程
**SPA（single page application）**单页面应用，只是局部更新内容。SPA实现的原理就采用了CSR，页面中所有内容由JS控制，需要浏览器进行JS解析才能显示出来
**SEO（search engine optimization）搜索引擎优化**，利用搜索**引擎的规则**提高网站在有关搜索引擎内的自然排名

### 2. 服务端渲染

![面试笔记-性能优化01.png](https://zhf-picture.oss-cn-qingdao.aliyuncs.com/my-img/面试笔记-性能优化01.png)

**前端耗时少**：因为**后端拼接了html**，**浏览器**只需**直接渲染出来**

**不利于前后端分离**，开发效率低

有利于**SEO**：因为在后端有**完整的html页面**，所以**爬虫**更容易爬取获得信息，更有利于SEO

后端生成静态化文件。即生成**缓存**片段，这样就可以减少数据库查询浪费的时间了，且对于数据变化不大的页面非常高效

占用服务器端**资源**：无需占用客户端资源。即**解析**模板的工作完全交由**后端**来做

### 3. 客户端渲染

![面试笔记-性能优化02.png](https://zhf-picture.oss-cn-qingdao.aliyuncs.com/my-img/面试笔记-性能优化02.png)

客户端渲染适合构建**交互性强**的应用，而服务端渲染适合需要更好的 SEO、更快的首屏渲染速度和更好的性能的应用

## 3. CDN

CDN (全称 Content Delivery Network)，即内容分发网络

CDN的原理是尽可能的在各个地方分布机房缓存数据，这样即使我们的根服务器在国外，在国内的用户也可以通过国内的机房迅速加载资源

CDN就是根据用户位置分配最近的资源

通过`CDN`的负载均衡系统，智能调度边缘节点提供服务，相当于`CDN`服务的大脑，而缓存系统相当于`CDN`的心脏，缓存命中直接返回给用户，否则回源

作用：

1. CDN有助于防御DDOS、MITM等网络攻击
2. 减少了服务器负载
3. 用户收到的内容来自最近的数据中心，延迟更低，内容加载更快

## 4. 懒加载

### 1. 什么是懒加载

懒加载也叫做延迟加载、按需加载，**可视化区域之外**的图片不会进行加载，在滚动屏幕时才加载，这样使得网页的加载速度更快，减少了服务器的负载。懒加载适用于图片（长列表）的场景中

### 2. 实现原理

图片的加载是由src引起的，当对src赋值时，浏览器就会请求图片资源。根据这个原理，我们使用HTML5 的data-xxx属性来储存图片的路径，在需要加载图片的时候，将data-xxx中图片的路径赋值给src，这样就实现了图片的按需加载，即懒加载

还可以给`img`的`loading`属性设为`lazy`

### 3. 代码实现

scroll版：

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>懒加载</title>
        <style>
            /* 一定记得设置图片高度 */
            img {
                display: block;
                margin-bottom: 50px;
                height: 200px;
            }
        </style>
    </head>
    <body>
        <img src="./风景图/default.jpg" data-src="./风景图/01.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/02.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/03.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/04.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/05.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/06.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/07.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/08.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/09.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/10.jpg" />
        <script>
            function lazyLoad() {
                // 用属性选择器返回属性名为data-src的img元素列表
                let imgs = document.querySelectorAll('img[data-src]');
                imgs.forEach((item) => {
                    if (item.dataset.src === '') return;
                    if (isElementInViewport(item)) {
                        item.src = item.dataset.src;
                        item.removeAttribute('data-src'); //移除属性，下次不再遍历
                    }
                });
            }
            function isElementInViewport(element) {
                const rect = element.getBoundingClientRect(); // 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置
                return (
                    rect.top >= 0 &&
                    rect.left >= 0 &&
                    rect.bottom <= (window.innerHeight ||
                            document.documentElement.clientHeight) &&
                    rect.right <=
                        (window.innerWidth ||
                            document.documentElement.clientWidth)
                );
            }
            lazyLoad(); //刚开始还没滚动屏幕时，要先触发一次函数，初始化首页的页面图片
            document.addEventListener('scroll', lazyLoad);
        </script>
    </body>
</html>
```

`window.innerHeight` 是浏览器可视区的高度

`document.body.scrollTop || document.documentElement.scrollTop` 是浏览器滚动的过的距离

`imgs.offsetTop` 是元素顶部距离文档顶部的高度（包括滚动条的距离）

图片加载条件：`img.offsetTop <= window.innerHeight + document.body.scrollTop;`

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>懒加载</title>
        <style>
            /* 一定记得设置图片高度 */
            img {
                display: block;
                margin-bottom: 50px;
                height: 200px;
            }
        </style>
    </head>
    <body>
        <img src="./风景图/default.jpg" data-src="./风景图/01.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/02.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/03.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/04.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/05.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/06.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/07.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/08.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/09.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/10.jpg" />
        <script>
            function lazyLoad() {
                // 用属性选择器返回属性名为data-src的img元素列表
                let imgs = document.querySelectorAll('img[data-src]');
                imgs.forEach((item) => {
                    if (item.dataset.src === '') return;
                    if (isElementInViewport(item)) {
                        item.src = item.dataset.src;
                        item.removeAttribute('data-src'); //移除属性，下次不再遍历
                    }
                });
            }
            function isElementInViewport(el) {
                // viewPortHeight 兼容所有浏览器写法
                const viewPortHeight =
                    window.innerHeight ||
                    document.documentElement.clientHeight ||
                    document.body.clientHeight;
                const offsetTop = el.offsetTop;
                const scrollTop = document.documentElement.scrollTop;
                return offsetTop <= viewPortHeight + scrollTop;
            }
            lazyLoad(); //刚开始还没滚动屏幕时，要先触发一次函数，初始化首页的页面图片
            document.addEventListener('scroll', lazyLoad);
        </script>
    </body>
</html>
```

IntersectionObserver版：

`Intersection Observer` 即重叠观察者，从这个命名就可以看出它用于判断两个元素是否重叠，因为不用进行事件的监听，性能方面相比`getBoundingClientRect`会好很多

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>懒加载</title>
        <style>
            /* 一定记得设置图片高度 */
            img {
                display: block;
                margin-bottom: 50px;
                height: 200px;
            }
        </style>
    </head>
    <body>
        <img src="./风景图/default.jpg" data-src="./风景图/01.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/02.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/03.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/04.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/05.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/06.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/07.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/08.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/09.jpg" />
        <img src="./风景图/default.jpg" data-src="./风景图/10.jpg" />
        <script>
            const images = document.querySelectorAll('img[data-src]');
            function handleIntersection(entries, observer) {
                entries.forEach((entry) => {
                    if (entry.isIntersecting) {
                        const image = entry.target;
                        image.src = image.dataset.src;
                        image.removeAttribute('data-src');
                        observer.unobserve(image);
                    }
                });
            }
            const observer = new IntersectionObserver(handleIntersection);
            images.forEach((image) => {
                observer.observe(image);
            });
        </script>
    </body>
</html>
```

## 5. 节流与防抖

详见：[节流与防抖](https://zhf521.github.io/mynotes/front-end/javascript-notes/27-JavaScript-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html)

## 6. 图片优化

### 1. 项目中图片的优化

1. 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替
2. 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片
3. 小图使用 base64 格式
4. 将多个图标文件整合到一张图片中（雪碧图）
5. 选择正确的图片格式：
   1. 对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好
   2. 小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替
   3. 照片使用 JPEG

### 2. 如何选择图片格式

| 图片格式 | 压缩方式 | 透明度 | 动画   | 浏览器兼容                                      | 适应场景                                           |
| -------- | -------- | ------ | ------ | ----------------------------------------------- | -------------------------------------------------- |
| JPEG     | 有损压缩 | 不支持 | 不支持 | 所有                                            | 复杂颜色及形状、尤其是照片                         |
| GIF      | 无损压缩 | 支持   | 支持   | 所有                                            | 简单颜色、动画                                     |
| PNG      | 无损压缩 | 支持   | 不支持 | 所有                                            | 需要透明度时                                       |
| APNG     | 无损压缩 | 支持   | 支持   | Firefox、Safari、IOS Safari                     | 需要半透明效果的动画                               |
| WebP     | 有损压缩 | 支持   | 支持   | Chrome、Opera、Android、Chrome Android、Browser | 复杂颜色以及形状，浏览器平台可预知                 |
| SVG      | 无损压缩 | 支持   | 支持   | 所有（IE8以上）                                 | 简单图形，需要良好的缩放体验，需要动态控制图片特效 |

## 7. 如何提高webpack的打包速度

- 优化`babel-loader`缓存

- `IgnorePlugin` 忽略某些包，避免引入无用模块（直接不引入，需要在代码中引入）

- `noParse` 避免重复打包（引入但不打包）

- 多线程打包，使用`thread-loader`

  - JS单线程的，开启多进程打包
  - 提高构建速度(特别是多核`CPU`)

- 自动刷新（开发环境）与热更新（开发环境）

  - 自动刷新：整个网页全部刷新，速度较慢，状态会丢失
  - 热更新：新代码生效，网页不刷新，状态不丢失

- 动态链接库`DLLPlugin`

  只适用于开发环境,因为生产环境下打包一次就完了,没有必要用于生产环境）

  - 前端框架如`react`、`vue`体积大，构建慢
  - 较稳定，不常升级版本，同一个版本只构建一次，不用每次都重新构建
  - `webpack`已内置`DllPlugin`，不需要安装
  - `DllPlugin`打包出`dll`文件
  - `DllReferencePlugin`引用`dll`文件

## 8. 如何减少webpack打包体积

1. 按需加载
2. Scope Hoisting，Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去
3. Tree Shaking，Tree Shaking 可以实现删除项目中未被引用的代码

