---
title: ES6~ES13
order: 27
---

## ES6

### 1.初识ES6

> ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言



-  1997年：ECMAScript 1.0

-  1998年：ECMAScript 2.0

-  1999年：ECMAScript 3.0

-  2006年：ECMAScript 4.0 未通过

-  2009年：ECMAScript 5.0

-  2015年：ECMAScript 6.0

-  至今，版本号改用年号的形式

### 2. let和const关键字

我们以前都是使用 `var` 关键字来声明变量的，在 ES6 的时候，多了两个关键字 `let` 和 `const`，也是用来声明变量的

`let`、`const`与`var`的区别：

1. `let` 和 `const` 不允许重复声明变量

   ```javascript
   // 使用 var 的时候重复声明变量是没问题的，只不过就是后面会把前面覆盖掉
   var num = 100
   var num = 200
   ```

   ```javascript
   // 使用 let 重复声明变量的时候就会报错了
   let num = 100
   let num = 200 // 这里就会报错了
   ```

   ```javascript
   // 使用 const 重复声明变量的时候就会报错
   const num = 100
   const num = 200 // 这里就会报错了
   ```

2. `let` 和 `const` 声明的变量不会在预解析的时候解析（也就是没有变量提升）

   ```javascript
   // 因为预解析（变量提升）的原因，在前面是有这个变量的，只不过没有赋值
   console.log(num) // undefined
   var num = 100
   ```

   ```javascript
   // 因为 let 不会进行预解析（变量提升），所以直接报错了
   console.log(num) // undefined
   let num = 100
   ```

   ```javascript
   // 因为 const 不会进行预解析（变量提升），所以直接报错了
   console.log(num) // undefined
   const num = 100
   ```

3. `let` 和 `const` 声明的变量会被所有代码块限制作用范围

   ```javascript
   // var 声明的变量只有函数能限制其作用域，其他的不能限制
   if (true) {
     var num = 100
   }
   console.log(num) // 100
   ```

   ```javascript
   // let 声明的变量，除了函数可以限制，所有的代码块都可以限制其作用域（if/while/for/...）
   if (true) {
     let num = 100
     console.log(num) // 100
   }
   console.log(num) // 报错
   ```

   ```javascript
   // const 声明的变量，除了函数可以限制，所有的代码块都可以限制其作用域（if/while/for/...）
   if (true) {
     const num = 100
     console.log(num) // 100
   }
   console.log(num) // 报错
   ```

`let` 和 `const` 的区别：

1. `let` 声明的变量的值可以改变，`const` 声明的变量的值不可以改变

   ```javascript
   let num = 100
   num = 200
   console.log(num) // 200
   ```

   ```javascript
   const num = 100
   num = 200 // 这里就会报错了，因为 const 声明的变量值不可以改变（我们也叫做常量）
   ```

2. `let` 声明的时候可以不赋值，`const` 声明的时候必须赋值，建议使用 `const` 来声明数组和对象

   ```javascript
   let num
   num = 100
   console.log(num) // 100
   ```

   ```javascript
   const num // 这里就会报错了，因为 const 声明的时候必须赋值
   ```

### 3. 展开运算符

ES6 里面号新添加了一个运算符 `...` ，叫做展开运算符

作用：

1. 把数组展开，不会修改原数组

   ```js
   let arr = [1, 2, 3, 4, 5]
   console.log(...arr) // 1 2 3 4 5
   ```

2. 合并数组的时候可以使用

   ```js
   let arr = [1, 2, 3, 4]
   let arr2 = [...arr, 5]
   console.log(arr2)
   ```

3. 也可以合并对象使用

   ```js
   let obj = {
     name: 'Jack',
     age: 18
   }
   let obj2 = {
     ...obj,
     gender: '男'
   }
   console.log(obj2)
   ```

4. 在函数传递参数的时候也可以使用

   ```js
   let arr = [1, 2, 3]
   function fn(a, b, c) {
     console.log(a)
     console.log(b)
     console.log(c)
   }
   fn(...arr)
   // 等价于 fn(1, 2, 3)
   ```

### 4. 解构赋值

解构赋值，就是快速的从对象或者数组中取出成员的一个语法方式

#### 4.1 数组解构

快速的从数组中获取成员

```javascript
// ES5 的方式从数组中获取成员
const arr = [1, 2, 3]
let a = arr[0]
let b = arr[1]
let c = arr[2]
console.log(a) // 1
console.log(b) // 2
console.log(c) // 3
```

```javascript
// 使用解构赋值的方式从数组中获取成员
const arr = [1, 2, 3]

// 前面的 [] 表示要从 arr 这个数组中获取成员了
// a b c 分别对应这数组中的索引 0 1 2
// arr 必须是一个数组
let [a, b, c] = arr
console.log(a) // 1
console.log(b) // 2
console.log(c) // 3
```

```js
// 数组解构的典型应用——交换两个变量的值
let a = 1
let b = 2  
;[a,b] = [b,a]     
console.log(a,b) //2 1

//注意：
//1. 必须加分号，因为是数组开头->相当于 let b = 2[a,b] = [b,a]，所以不加分号控制台会报错
//2. 由于我们在JavaScript中习惯语句结束不加分号，而数组开头比较特别，所以这个分号主要是起到标记语句结束的作用
//3. 也可以在采取下面加分号的方式 let b = 2;
```

```js
//数组解构的一些特殊情况——变量多，单元值少
const [a,b,c,d] = [1,2,3]
console.log(a,b,a,d) //1  2  3  undefined

//为此防止有undefined传递单元值的情况，可以设置默认值
const [x=0,y=0] = [1]
console.log(x)  //1
console.log(y)  //0
```

```js
//数组解构的一些特殊情况——变量少，单元值多\
const [a,b,...c] = [1,2,3,4,5]
console.log(a)  //1
console.log(b)  //2
console.log(c)  //[3,4,5]
  
//为此可以按需导入赋值
const [x,y,,z] = [1,2,3,4]
console.log(x,y,x)  //1  2  4
```

总结：

1. 赋值运算符 `=` 左侧的 `[]` 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量
2. 变量的顺序对应数组单元值的位置依次进行赋值操作
3. 变量的数量大于单元值数量时，多余的变量将被赋值为  `undefined`
4. 变量的数量小于单元值数量时，可以通过 `...` 获取剩余单元值，但只能置于最末位
5. 允许初始化变量的默认值，且只有单元值为 `undefined` 时默认值才会生效
6. 数组解构也支持多维解构赋值

#### 4.1 对象解构

快速的从对象中获取成员

```javascript
// ES5 的方法获取对象中的成员
const obj = {
  name: 'Jack',
  age: 18,
  gender: '男'
}

let name = obj.name
let age = obj.age
let gender = obj.gender
```

```javascript
// 解构赋值的方式从对象中获取成员
const obj = {
  name: 'Jack',
  age: 18,
  gender: '男'
}

// 前面的 {} 表示我要从 obj 这个对象中获取成员了
// name age gender 都得是 obj 中有的成员
// obj 必须是一个对象
let { name, age, gender } = obj
```

```js
// 对象解构的一些语法注意点    
// 对象解构的语法
const obj = {
    uname: '游戏',
    price: 58
}
const {uname,price} = {uname: '游戏', price: 58}
console.log(uname) //相当于uname = obj.uname
console.log(price) //相当于price = obj.price

// 解构的变量名必须与属性名一致
const {uname1,price1} = {uname: '游戏', price: 58}
console.log(uname1) //undefined
console.log(price1) //undefined

// 对象解构变量名更改  旧变量名:新变量名
const {uname:game,price:money} = {uname: '游戏', price: 58}
console.log(game)  //游戏
console.log(money) //58

//数组对象解构
const arr = [{uname1: '游戏', price1: 58}]
const [{p,n}] = [{n: '游戏', p: 58}]
console.log(p) //58
console.log(n) //游戏
```

总结：

1. 赋值运算符 `=` 左侧的 `{}` 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量
2. 对象属性的值将被赋值给与属性名相同的变量
3. 对象中找不到与变量名一致的属性时变量值为 `undefined`
4. 允许初始化变量的默认值，属性不存在或单元值为 `undefined` 时默认值才会生效
5. 对象解构也支持多维解构赋值

### 5. 模版字符串

ES5 中我们表示字符串的时候使用 `''` 或者 `""`，在 ES6 中，我们还有一个东西可以表示字符串，就是` `` ` （反引号）

```javascript
let str = `hello world`
console.log(typeof str) // string
```

反引号与单引号、双引号的区别：

1. 反引号可以换行书写

   ```javascript
   // 这个单引号或者双引号不能换行，换行就会报错了
   let str = 'hello world' 
   
   // 下面这个就报错了
   let str2 = 'hello 
   world'
   ```

   ```javascript
   let str = `
   	hello
   	world
   `
   
   console.log(str) // 是可以使用的
   ```

2. 反引号可以直接在字符串里面拼接变量

   ```javascript
   // ES5 需要字符串拼接变量的时候
   let num = 100
   let str = 'hello' + num + 'world' + num
   console.log(str) // hello100world100
   
   // 直接写在字符串里面不好使
   let str2 = 'hellonumworldnum'
   console.log(str2) // hellonumworldnum
   ```

   ```javascript
   // 模版字符串拼接变量
   let num = 100
   let str = `hello${num}world${num}`
   console.log(str) // hello100world100
   ```

   里面的 `${}` 就是用来书写变量的位置

## 箭头函数

箭头函数是 ES6 里面一个简写函数的语法方式

重点： **箭头函数只能简写函数表达式，不能简写声明式函数**

```javascript
function fn() {} // 不能简写
const fun = function () {} // 可以简写
const obj = {
  fn: function () {} // 可以简写
}
```

语法： `(函数的形参) => { 函数体内要执行的代码 }`

```javascript
const fn = function (a, b) {
  console.log(a)
  console.log(b)
}
// 可以使用箭头函数写成
const fun = (a, b) => {
  console.log(a)
  console.log(b)
}
```

```javascript
const obj = {
  fn: function (a, b) {
    console.log(a)
    console.log(b)
  }
}
// 可以使用箭头函数写成
const obj2 = {
  fn: (a, b) => {
    console.log(a)
    console.log(b)
  }
}
```

箭头函数的特殊性：

1. 箭头函数内部没有 this，箭头函数的 this 是上下文的 this

   ```js
   // 在箭头函数定义的位置往上数，这一行是可以打印出 this 的
   // 因为这里的 this 是 window
   // 所以箭头函数内部的 this 就是 window
   const obj = {
     fn: function () {
       console.log(this)
     },
     // 这个位置是箭头函数的上一行，但是不能打印出 this
     fun: () => {
       // 箭头函数内部的 this 是书写箭头函数的上一行一个可以打印出 this 的位置
       console.log(this)
     }
   }
   
   obj.fn()
   obj.fun()
   // 按照我们之前的 this 指向来判断，两个都应该指向 obj，但是 fun 因为是箭头函数，所以 this 不指向 obj，而是指向 fun 的外层，就是 window
   ```

2. 箭头函数内部没有 `arguments` 这个参数集合，只能使用`...`

   ```js
   const obj = {
     fn: function () {
       console.log(arguments)
     },
     fun: () => {
       console.log(arguments)
     }
   }
   obj.fn(1, 2, 3) // 会打印一个伪数组 [1, 2, 3]
   obj.fun(1, 2, 3) // 会直接报错
   ```

3. 函数的形参只有一个的时候可以不写 `()` 其余情况必须写

   ```js
   const obj = {
     fn: () => {
       console.log('没有参数，必须写小括号')
     },
     fn2: a => {
       console.log('一个形参，可以不写小括号')
     },
     fn3: (a, b) => {
       console.log('两个或两个以上参数，必须写小括号')
     }
   }
   ```

4. 函数体只有一行代码的时候，可以不写 `{}` ，并且会自动 return

   ```js
   const obj = {
     fn: a => {
       return a + 10
     },
     fun: a => a + 10
   }
   
   console.log(fn(10)) // 20
   console.log(fun(10)) // 20
   ```

## 函数传参时的默认值

我们在定义函数的时候，有的时候需要一个默认值出现，就是当我不传递参数的时候，使用默认值，传递参数了就使用传递的参数

```javascript
function fn(a) {
  a = a || 10
  console.log(a)
}
fn()   // 不传递参数的时候，函数内部的 a 就是 10
fn(20) // 传递了参数 20 的时候，函数内部的 a 就是 20
```

在 ES6 中我们可以直接把默认值写在函数的形参位置

```javascript
function fn(a = 10) {
  console.log(a)
}
fn()   // 不传递参数的时候，函数内部的 a 就是 10
fn(20) // 传递了参数 20 的时候，函数内部的 a 就是 20
```

这个默认值的方式箭头函数也可以使用

```javascript
const fn = (a = 10) => {
  console.log(a)
}
fn()   // 不传递参数的时候，函数内部的 a 就是 10
fn(20) // 传递了参数 20 的时候，函数内部的 a 就是 20
```

注意： **箭头函数如果你需要使用默认值的话，那么一个参数的时候也需要写()**
