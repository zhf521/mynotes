---
title: ES6~ES13
order: 26
---

## 1. ES6

### 1.1初识ES6

> ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言



-  1997年：ECMAScript 1.0

-  1998年：ECMAScript 2.0

-  1999年：ECMAScript 3.0

-  2006年：ECMAScript 4.0 未通过

-  2009年：ECMAScript 5.0

-  2015年：ECMAScript 6.0

-  至今，版本号改用年号的形式

### 1.2 let和const关键字

我们以前都是使用 `var` 关键字来声明变量的，在 ES6 的时候，多了两个关键字 `let` 和 `const`，也是用来声明变量的

`let`、`const`与`var`的区别：

1. `let` 和 `const` 不允许重复声明变量

   ```javascript
   // 使用 var 的时候重复声明变量是没问题的，只不过就是后面会把前面覆盖掉
   var num = 100
   var num = 200
   ```

   ```javascript
   // 使用 let 重复声明变量的时候就会报错了
   let num = 100
   let num = 200 // 这里就会报错了
   ```

   ```javascript
   // 使用 const 重复声明变量的时候就会报错
   const num = 100
   const num = 200 // 这里就会报错了
   ```

2. `let` 和 `const` 声明的变量不会在预解析的时候解析（也就是没有变量提升）

   ```javascript
   // 因为预解析（变量提升）的原因，在前面是有这个变量的，只不过没有赋值
   console.log(num) // undefined
   var num = 100
   ```

   ```javascript
   // 因为 let 不会进行预解析（变量提升），所以直接报错了
   console.log(num) // undefined
   let num = 100
   ```

   ```javascript
   // 因为 const 不会进行预解析（变量提升），所以直接报错了
   console.log(num) // undefined
   const num = 100
   ```

3. `let` 和 `const` 声明的变量会被所有代码块限制作用范围

   ```javascript
   // var 声明的变量只有函数能限制其作用域，其他的不能限制
   if (true) {
     var num = 100
   }
   console.log(num) // 100
   ```

   ```javascript
   // let 声明的变量，除了函数可以限制，所有的代码块都可以限制其作用域（if/while/for/...）
   if (true) {
     let num = 100
     console.log(num) // 100
   }
   console.log(num) // 报错
   ```

   ```javascript
   // const 声明的变量，除了函数可以限制，所有的代码块都可以限制其作用域（if/while/for/...）
   if (true) {
     const num = 100
     console.log(num) // 100
   }
   console.log(num) // 报错
   ```

`let` 和 `const` 的区别：

1. `let` 声明的变量的值可以改变，`const` 声明的变量的值不可以改变

   ```javascript
   let num = 100
   num = 200
   console.log(num) // 200
   ```

   ```javascript
   const num = 100
   num = 200 // 这里就会报错了，因为 const 声明的变量值不可以改变（我们也叫做常量）
   ```

2. `let` 声明的时候可以不赋值，`const` 声明的时候必须赋值，建议使用 `const` 来声明数组和对象

   ```javascript
   let num
   num = 100
   console.log(num) // 100
   ```

   ```javascript
   const num // 这里就会报错了，因为 const 声明的时候必须赋值
   ```

### 1.3 展开运算符

ES6 里面号新添加了一个运算符 `...` ，叫做展开运算符

作用：

1. 把数组展开，不会修改原数组

   ```js
   let arr = [1, 2, 3, 4, 5]
   console.log(...arr) // 1 2 3 4 5
   ```

2. 合并数组的时候可以使用

   ```js
   let arr = [1, 2, 3, 4]
   let arr2 = [...arr, 5]
   console.log(arr2)
   ```

3. 也可以合并对象使用

   ```js
   let obj = {
     name: 'Jack',
     age: 18
   }
   let obj2 = {
     ...obj,
     gender: '男'
   }
   console.log(obj2)
   ```

4. 在函数传递参数的时候也可以使用

   ```js
   let arr = [1, 2, 3]
   function fn(a, b, c) {
     console.log(a)
     console.log(b)
     console.log(c)
   }
   fn(...arr)
   // 等价于 fn(1, 2, 3)
   ```

### 1.4 解构赋值

解构赋值，就是快速的从对象或者数组中取出成员的一个语法方式

#### 1.4.1 数组解构

快速的从数组中获取成员

```javascript
// ES5 的方式从数组中获取成员
const arr = [1, 2, 3]
let a = arr[0]
let b = arr[1]
let c = arr[2]
console.log(a) // 1
console.log(b) // 2
console.log(c) // 3
```

```javascript
// 使用解构赋值的方式从数组中获取成员
const arr = [1, 2, 3]

// 前面的 [] 表示要从 arr 这个数组中获取成员了
// a b c 分别对应这数组中的索引 0 1 2
// arr 必须是一个数组
let [a, b, c] = arr
console.log(a) // 1
console.log(b) // 2
console.log(c) // 3
```

```js
// 数组解构的典型应用——交换两个变量的值
let a = 1
let b = 2  
;[a,b] = [b,a]     
console.log(a,b) //2 1

//注意：
//1. 必须加分号，因为是数组开头->相当于 let b = 2[a,b] = [b,a]，所以不加分号控制台会报错
//2. 由于我们在JavaScript中习惯语句结束不加分号，而数组开头比较特别，所以这个分号主要是起到标记语句结束的作用
//3. 也可以在采取下面加分号的方式 let b = 2;
```

```js
//数组解构的一些特殊情况——变量多，单元值少
const [a,b,c,d] = [1,2,3]
console.log(a,b,a,d) //1  2  3  undefined

//为此防止有undefined传递单元值的情况，可以设置默认值
const [x=0,y=0] = [1]
console.log(x)  //1
console.log(y)  //0
```

```js
//数组解构的一些特殊情况——变量少，单元值多\
const [a,b,...c] = [1,2,3,4,5]
console.log(a)  //1
console.log(b)  //2
console.log(c)  //[3,4,5]
  
//为此可以按需导入赋值
const [x,y,,z] = [1,2,3,4]
console.log(x,y,x)  //1  2  4
```

总结：

1. 赋值运算符 `=` 左侧的 `[]` 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量
2. 变量的顺序对应数组单元值的位置依次进行赋值操作
3. 变量的数量大于单元值数量时，多余的变量将被赋值为  `undefined`
4. 变量的数量小于单元值数量时，可以通过 `...` 获取剩余单元值，但只能置于最末位
5. 允许初始化变量的默认值，且只有单元值为 `undefined` 时默认值才会生效
6. 数组解构也支持多维解构赋值

#### 1.4.2 对象解构

快速的从对象中获取成员

```javascript
// ES5 的方法获取对象中的成员
const obj = {
  name: 'Jack',
  age: 18,
  gender: '男'
}

let name = obj.name
let age = obj.age
let gender = obj.gender
```

```javascript
// 解构赋值的方式从对象中获取成员
const obj = {
  name: 'Jack',
  age: 18,
  gender: '男'
}

// 前面的 {} 表示我要从 obj 这个对象中获取成员了
// name age gender 都得是 obj 中有的成员
// obj 必须是一个对象
let { name, age, gender } = obj
```

```js
// 对象解构的一些语法注意点    
// 对象解构的语法
const obj = {
    uname: '游戏',
    price: 58
}
const {uname,price} = {uname: '游戏', price: 58}
console.log(uname) //相当于uname = obj.uname
console.log(price) //相当于price = obj.price

// 解构的变量名必须与属性名一致
const {uname1,price1} = {uname: '游戏', price: 58}
console.log(uname1) //undefined
console.log(price1) //undefined

// 对象解构变量名更改  旧变量名:新变量名
const {uname:game,price:money} = {uname: '游戏', price: 58}
console.log(game)  //游戏
console.log(money) //58

//数组对象解构
const arr = [{uname1: '游戏', price1: 58}]
const [{p,n}] = [{n: '游戏', p: 58}]
console.log(p) //58
console.log(n) //游戏
```

总结：

1. 赋值运算符 `=` 左侧的 `{}` 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量
2. 对象属性的值将被赋值给与属性名相同的变量
3. 对象中找不到与变量名一致的属性时变量值为 `undefined`
4. 允许初始化变量的默认值，属性不存在或单元值为 `undefined` 时默认值才会生效
5. 对象解构也支持多维解构赋值

### 1.5 模版字符串

ES5 中我们表示字符串的时候使用 `''` 或者 `""`，在 ES6 中，我们还有一个东西可以表示字符串，就是` `` ` （反引号）

```javascript
let str = `hello world`
console.log(typeof str) // string
```

反引号与单引号、双引号的区别：

1. 反引号可以换行书写

   ```javascript
   // 这个单引号或者双引号不能换行，换行就会报错了
   let str = 'hello world' 
   
   // 下面这个就报错了
   let str2 = 'hello 
   world'
   ```

   ```javascript
   let str = `
   	hello
   	world
   `
   
   console.log(str) // 是可以使用的
   ```

2. 反引号可以直接在字符串里面拼接变量

   ```javascript
   // ES5 需要字符串拼接变量的时候
   let num = 100
   let str = 'hello' + num + 'world' + num
   console.log(str) // hello100world100
   
   // 直接写在字符串里面不好使
   let str2 = 'hellonumworldnum'
   console.log(str2) // hellonumworldnum
   ```

   ```javascript
   // 模版字符串拼接变量
   let num = 100
   let str = `hello${num}world${num}`
   console.log(str) // hello100world100
   ```

   里面的 `${}` 就是用来书写变量的位置

### 1.6字符串扩展

#### 1.6.1 includes函数

判断字符串中是否存在指定字符

```js
let myname = "kerwin"
console.log(myname.includes("e")) //true
console.log(myname.includes("ker")) //true
console.log(myname.includes("en")) //false
```

可以传入第二个参数，表示按索引值位置开始查找

```js
let myname = "kerwin"
console.log(myname.includes("e",1)) //true
console.log(myname.includes("e",3)) //false
```

#### 1.6.2 startsWith函数

判断字符串是否以某字符开头

```js
let myname = "kerwin"
console.log(myname.startsWith("k")) //true
console.log(myname.startsWith("ker")) //true
console.log(myname.startsWith("er")) //false
```

可以传入第二个参数，表示按索引值位置开始查找

```js
let myname = "kerwin"
console.log(myname.startsWith("k",0)) //true
console.log(myname.startsWith("k",2)) //false
```

#### 1.6.3 endsWith函数

判断字符串是否以某字符结束

```js
let myname = "kerwin"
console.log(myname.endsWith("n")) //true
console.log(myname.endsWith("in")) //true
console.log(myname.endsWith("k")) //false
```

可以传入第二个参数，表示按索引值位置开始往前查找

```js
let myname = "kerwin"
console.log(myname.startsWith("n",1)) //false
console.log(myname.startsWith("n",5)) //true
```

#### 1.6.4 repeat函数

`repeat()`方法返回一个新字符串,表示将原字符串重复n次

````js
let myname = "kerwin"
console.log(myname.repeat(3)) //kerwinkerwinkerwin
console.log(myname.repeat(0)) //"" 
console.log(myname.repeat(3.5)) //kerwinkerwinkerwin
console.log(myname.repeat("3"))//kerwinkerwinkerwin
````

### 1.7 数值扩展

#### 1.7.1 进制表示法 

```js
//十进制
let count1 = 100
//十六进制
let count2 = 0x100
//八进制
let count3 = 0o100
//二进制
let count4 = 0b100
```

#### 1.7.2 isFinite与isNaN方法

减少全局性方法，使得语言逐步模块化

```js
let num1 = Number.isFinite(100) 
console.log(num1) //true
let num2 = Number.isFinite(100/0) 
console.log(num2) //false
let num3 = Number.isFinite(Infinity)
console.log(num3) // false
let num4 = Number.isFinite("100")
console.log(num4) //false
```

```js
let num1 = Number.isNaN(100) 
console.log(num1) // false
let num2 = Number.isNaN(NaN)
console.log(num2) //true
let num3 = Number.isNaN("kerwin")
console.log(num3) //false
let num4 = Number.isNaN("100")
console.log(num4) // false
```

它们与传统的全局方法`isFinite()`和`isNaN()`的区别在于，传统方法先调用`Number()`将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，`Number.isFinite()`对于非数值一律返回false, `Number.isNaN()`只有对于NaN才返回true，非NaN一律返回false

#### 1.7.3 isInteger方法

用来判断一个数值是否为整数

```js
let num1 = Number.isInteger(100)
console.log(num1) //true
let num2 = Number.isInteger(100.0)
console.log(num2) //true
let num3 = Number.isInteger("kerwin")
console.log(num3) //false
let num4 = Number.isInteger("100")
console.log(num4) //false
let num5 = Number.isInteger(100.1)
console.log(num5) //false
```

#### 1.7.4 极小常量Number.EPSILON

它表示 1 与大于 1 的最小浮点数之间的差。2.220446049250313e-16

```js
function isEqual(a,b){
        return Math.abs(a-b)<Number.EPSILON
}

console.log(isEqual(0.1+0.2,0.3)) //true
console.log(0.1+0.2===0.3) //false
```

#### 1.7.5 Math.trunc

将小数部分抹掉,返回一个整数

```js
console.log(Math.trunc(1.2)) //1
console.log(Math.trunc(1.8))// 1
console.log(Math.trunc(-1.8)) //-1
console.log(Math.trunc(-1.2))//-1
```

#### 1.7.6 Math.sign

`Math.sign`方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值

```javascript
Math.sign(-100) // -1
Math.sign(100) // +1
Math.sign(0) // +0
Math.sign(-0) // -0
Math.sign("kerwin") // NaN
```

### 1.8 数组扩展

#### 1.8.1 Array.from

将类数组对象转换为真正数组

```js
function test(){
        console.log(Array.from(arguments))
}

test(1,2,3) // [1,2,3]
```

#### 1.8.2 Array.of

将一组值转化为数组，即新建数组

```js
let arr1 = Array(3)
console.log(arr1)// [,,]

let arr2 = Array.of(3)
console.log(arr2)// [3]
```

#### 1.8.3 find方法

该方法主要应用于查找第一个符合条件的数组元素 

它的参数是一个回调函数。在回调函数中可以写你要查找元素的条件，当条件成立为true时，返回该元素；如果没有符合条件的元素，返回值为undefined 

```js
let arr = [11,12,13,14,15]
let res1 = arr.find(function(item){
    return item>13
})
let res2 = arr.findIndex(function(item){
    return item>13
})
console.log(res1) //14
console.log(res2) //3
//findLast() findLastIndex() ES2022
let arr2 = [11,12,13,14,15]
let res3 = arr.findLast(function(item){
    return item>13
})
let res4 = arr.findLastIndex(function(item){
    return item>13
})
console.log(res3) //15
console.log(res4) //4
```

#### 1.8.4 fill方法

使用自己想要的参数替换原数组内容，但是会改变原来的数组

```js
let arr1 = new Array(3).fill("kerwin")
let arr2 = ['a', 'b', 'c'].fill("kerwin", 1, 2)
console.log(arr1)//['kerwin', 'kerwin', 'kerwin']
console.log(arr2)// ['a', 'kerwin', 'c']
```

#### 1.8.5 flat与flatMap方法

按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回

```js
let arr = [1,2,3,[4,5,6]]
let arr1 = arr.flat()
console.log(arr,arr1) //[1,2,3,4,5,6]

var obj = [{
                name: "A",
                list: ["鞍山", "安庆", "安阳"]
            },
            {
                name: "B",
                list: ["北京", "保定", "包头"]
            }
]
console.log(obj.flatMap(function(item){
    return item.list
}))// ['鞍山', '安庆', '安阳', '北京', '保定', '包头']
```

### 1.9 对象扩展

#### 1.9.1 对象简写

```js
//原写法
let name ="moduleA"
let obj = {
    name:name,
    test1:function(){
        
    },
    test2:function(){
        
    }
}

//简写
let name ="moduleA"
let obj = {
    name,
    test1(){

    },
    test2(){

    }
}
```

#### 1.9.2 属性名表达式

```js
let name ="moduleA"
let obj = {
    name,
    [name+"test1"](){

    },
    [name+"test2"](){

    }
}
console.log(obj) //{name: 'moduleA', moduleAtest1: ƒ, moduleAtest2: ƒ}
```

#### 1.9.3 Object.assign

`Object.assign(target, object1，object2)`的第一个参数是目标对象，后面可以跟一个或多个源对象作为参数

target：参数合并后存放的对象

object1：参数1

object2：参数2

```js
const obj = {}
const obj1 = {
    name: "kerwin"
}

const obj2 = {
    name:"tiechui"
}
const obj3 = {
    age:100
}

console.log(Object.assign(obj, obj1, obj2, obj3)) // {name: 'tiechui', age: 100}
```

#### 1.9.4 Object.is

方法判断两个值是否是相同的值

```js
// 之前存在的问题：
console.log(NaN===NaN) //false
console.log(+0===-0) //true

//解决：
console.log(Object.is(NaN,NaN)) //true
console.log(Object.is(+0,-0)) //false
```

### 1.10 函数扩展

#### 1.10.1 箭头函数

箭头函数是 ES6 里面一个简写函数的语法方式

重点： **箭头函数只能简写函数表达式，不能简写声明式函数**

```javascript
function fn() {} // 不能简写
const fun = function () {} // 可以简写
const obj = {
  fn: function () {} // 可以简写
}
```

语法： `(函数的行参) => { 函数体内要执行的代码 }`

```javascript
const fn = function (a, b) {
  console.log(a)
  console.log(b)
}
// 可以使用箭头函数写成
const fun = (a, b) => {
  console.log(a)
  console.log(b)
}
```

```javascript
const obj = {
  fn: function (a, b) {
    console.log(a)
    console.log(b)
  }
}
// 可以使用箭头函数写成
const obj2 = {
  fn: (a, b) => {
    console.log(a)
    console.log(b)
  }
}
```

#### 1.10.2 箭头函数的特殊性

1. 箭头函数内部没有 this，箭头函数的 this 是上下文的 this

   ```js
   // 在箭头函数定义的位置往上数，这一行是可以打印出 this 的
   // 因为这里的 this 是 window
   // 所以箭头函数内部的 this 就是 window
   const obj = {
     fn: function () {
       console.log(this)
     },
     // 这个位置是箭头函数的上一行，但是不能打印出 this
     fun: () => {
       // 箭头函数内部的 this 是书写箭头函数的上一行一个可以打印出 this 的位置
       console.log(this)
     }
   }
   
   obj.fn()
   obj.fun()
   ```

   按照我们之前的 this 指向来判断，两个都应该指向 obj，但是 fun 因为是箭头函数，所以 this 不指向 obj，而是指向 fun 的外层，就是 window

2. 箭头函数内部没有 `arguments` 这个参数集合

   ```js
   const obj = {
     fn: function () {
       console.log(arguments)
     },
     fun: () => {
       console.log(arguments)
     }
   }
   obj.fn(1, 2, 3) // 会打印一个伪数组 [1, 2, 3]
   obj.fun(1, 2, 3) // 会直接报错
   ```

3. 函数的行参只有一个的时候可以不写 `()` 其余情况必须写

   ```js
   const obj = {
     fn: () => {
       console.log('没有参数，必须写小括号')
     },
     fn2: a => {
       console.log('一个行参，可以不写小括号')
     },
     fn3: (a, b) => {
       console.log('两个或两个以上参数，必须写小括号')
     }
   }
   ```

4. 函数体只有一行代码的时候，可以不写 `{}` ，并且会自动 return

   ```js
   const obj = {
     fn: a => {
       return a + 10
     },
     fun: a => a + 10
   }
   
   console.log(fn(10)) // 20
   console.log(fun(10)) // 20
   ```

#### 1.10.3 函数参数默认值

我们在定义函数的时候，有的时候需要一个默认值出现，就是当我不传递参数的时候，使用默认值，传递参数了就使用传递的参数

```javascript
function fn(a) {
  a = a || 10
  console.log(a)
}
fn()   // 不传递参数的时候，函数内部的 a 就是 10
fn(20) // 传递了参数 20 的时候，函数内部的 a 就是 20
```

在 ES6 中我们可以直接把默认值写在函数的行参位置

```javascript
function fn(a = 10) {
  console.log(a)
}
fn()   // 不传递参数的时候，函数内部的 a 就是 10
fn(20) // 传递了参数 20 的时候，函数内部的 a 就是 20
```

这个默认值的方式箭头函数也可以使用

```javascript
const fn = (a = 10) => {
  console.log(a)
}
fn()   // 不传递参数的时候，函数内部的 a 就是 10
fn(20) // 传递了参数 20 的时候，函数内部的 a 就是 20
```

注意： **箭头函数如果你需要使用默认值的话，那么一个参数的时候也需要写 （）**

### 1.11 Symbol

> ES6 引入了一种新的原始数据类型`Symbol`，表示独一无二的值。它属于 JavaScript 语言的原生数据类型之一，其他数据类型是：`undefined`、`null`、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）

注意：symbol类型不能直接进行运算

1. 使用Symbol作为对象属性名

   ```js
   let name = Symbol() // 生成了一个symbol类型数据
   let age = Symbol()
   var obj  ={
       [name]:"kerwin",
       [age]:100
   }
   console.log(obj) // {Symbol(): 'kerwin', Symbol(): 100}
   console.log(obj.name) // undefined
   console.log(obj[name]) // kerwin
   ```

2. `Symbol()`函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述。这主要是为了在控制台显示，比较容易区分

   ```js
   let name = Symbol("name")
   let age = Symbol("age")
   var obj  ={
       [name]:"kerwin",
       [age]:100
   }
   console.log(obj) // {Symbol(name): 'kerwin', Symbol(age): 100}
   ```

3. 遍历问题

   ```js
   // 使用for in 无法遍历symbol定义的
   // 使用Object.getOwnPropertySymbols 可以遍历symbol定义的
   // 使用Reflect.ownKeys可以
   
   let keys = {
       name:Symbol("name"),
       age:Symbol("age")
   }
   var obj  ={
       [keys.name]:"kerwin",
       [keys.age]:100,
       a:1,
       b:2,
       c:3
   }
   
   Reflect.ownKeys(obj).forEach(item=>{
       console.log(item,obj[item])
   })
   // a 1
   // b 2
   // c 3
   // Symbol(name) 'kerwin'
   // Symbol(age) 100
   ```

4. `Symbol.for()`可以重新使用同一个 Symbol 值

   ```js
   var obj  ={
       [Symbol.for("name")]:"kerwin",
       [Symbol.for("age")]:100
   }
   
   console.log(obj[Symbol.for("name")])
   ```

5. `Symbol`可以作为常量

   ```js
   const VIDEO = Symbol()
   const AUDIO = Symbol()
   const IMAGE = Symbol()
   function play(type){
       switch(type){
           case VIDEO:
               console.log('视频播放')
               break
           case AUDIO:
               console.log('音频播放')
               break
           case IMAGE:
               console.log('图片播放')
               break
       }
   }
   play(VIDEO) // 视频播放
   ```

### 1.12 Iterator迭代器

> Iterator 的作用有三个：
>
> 1. 为各种数据结构，提供一个统一的、简便的访问接口
> 2. 使得数据结构的成员能够按某种次序排列
> 3. ES6 创造了一种新的遍历命令`for...of`循环，Iterator 接口主要供`for...of`循环

```js
let arr = ["kerwin", "tiechui", "gangdaner"]

for(let i of arr){
    console.log(i) // kerwin tiechui gangdaner
}
```

Iterator 的遍历过程是这样的：

1. 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象
2. 第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员
3. 第二次调用指针对象的next方法，指针就指向数据结构的第二个成员
4. 不断调用指针对象的next方法，直到它指向数据结构的结束位置

```js
let i = arr[Symbol.iterator]()
console.log(i.next()) // {value: 'kerwin', done: false}
console.log(i.next()) // {value: 'tiechui', done: false}
console.log(i.next()) // {value: 'gangdaner', done: false}
console.log(i.next()) // {value: undefined, done: true}
```

> ES6 规定，默认的 Iterator 接口部署在数据结构的`Symbol.iterator`属性，或者说，一个数据结构只要具有`Symbol.iterator`属性，就可以认为是“可遍历的”（iterable）。`Symbol.iterator`属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器

原生默认具备 Iterator 接口的数据结构如下：

- Array
- Set
- Map
- String
- arguments 对象
- NodeList 对象

**如何对对象进行`for of`遍历？**

```js
let obj = {
    0: "kerwin",
    1: "tiechui",
    2: "gangdaner",
    length: 3,
    [Symbol.iterator]: Array.prototype[Symbol.iterator]
}

for (let i of obj) {
    console.log(i)
}
// kerwin
// tiechui
// gangdaner

let obj2 = {
    data: ['kerwin', 'tiechui', "gangdaner"],
    // 迭代器
    [Symbol.iterator]() {
        // let _this = this
        let index = 0
        return {
            next: () => {
                if (index < this.data.length) {

                    return {
                        value: this.data[index++],
                        done: false
                    }
                } else {
                    return {
                        value: undefined,
                        done: true
                    }
                }
            }
        }
    }
}

for (let i of obj2) {
    console.log(i)
}
// kerwin
// tiechui
// gangdaner
```

`...`展开运算符会调用内置迭代器

```js
let obj2 = {
    data: ['kerwin', 'tiechui', "gangdaner"],
    // 迭代器
    [Symbol.iterator]() {
        // let _this = this
        let index = 0
        return {
            next: () => {
                if (index < this.data.length) {

                    return {
                        value: this.data[index++],
                        done: false
                    }
                } else {
                    return {
                        value: undefined,
                        done: true
                    }
                }
            }
        }
    }
}
console.log([...obj2]) // ['kerwin', 'tiechui', 'gangdaner']
```

### 1.13 Set结构

它类似于数组，但成员的值都是唯一的，没有重复的值

#### 1.13.1 初识Set

```js
// 可以实现数组去重
let s1 = new Set([1, 2, 3, 2, 3])
console.log(s1) // {1,2,3}
console.log([...s1]) // [1,2,3]

let s2 = new Set()
s2.add(1)
s2.add(2)
s2.add(3)
console.log(s2) // {1, 2, 3}
```

#### 1.13.2 实例的属性和方法

- size：返回Set实例的成员总数
- `Set.prototype.add(value)`：添加某个value
- `Set.prototype.delete(value)`：删除某个value，返回一个布尔值，表示删除是否成功
- `Set.prototype.has(value)`：返回一个布尔值，表示该值是否为`Set`的成员
- `Set.prototype.clear()`：清除所有成员，没有返回值

```js
let s1 = new Set([1, 2, 3, 2, 3])
console.log(s1.size) // 3
s1.add(4).add(5).add(6)
console.log(s1) // {1, 2, 3, 4, 5, 6}
console.log(s1.has(8)) // false
console.log(s1.has(5)) //true
s1.delete(5)
console.log(s1) // {1, 2, 3, 4, 6}
s1.clear()
console.log(s1) // {size: 0}
```

#### 1.13.3 遍历

- `Set.prototype.keys()`：返回键名的遍历器
- `Set.prototype.values()`：返回键值的遍历器
- `Set.prototype.entries()`：返回键值对的遍历器
- `Set.prototype.forEach()`：遍历每个成员

```js
let s1 = new Set([1, 2, 3, 2, 3])
for(let i of s1){
    console.log(i)
}
// 1
// 2
// 3
for(let i of s1.keys()){
    console.log(i)
}
// 1
// 2
// 3
for(let i of s1.values()){
    console.log(i)
}
// 1
// 2
// 3
for(let i of s1.entries()){
    console.log(i)
}
// [1,1]
// [2,2]
// [3,3]
```

#### 1.13.4 复杂数据结构去重

```js
function uni(arr) {
    let res = new Set()
    return arr.filter(item => {
        let id = JSON.stringify(item)
        if (res.has(id)) {
            return false
        } else {
            res.add(id)
            return true
        }
    })
}

var arr = [1, 2, 3, "data", {
    name: "kerwin"
}, {
    name: "kerwin"
},
           [1, 2],
           [3, 4],
           [3, 4]
          ]
console.log(uni(arr))
```
