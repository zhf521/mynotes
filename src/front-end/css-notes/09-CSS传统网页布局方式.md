---
title: CSS传统网页布局方式
order: 9
---

CSS 提供了三种传统布局方式 (简单说, 就是盒子如何进行排列)：
- 普通流（标准流）
- 浮动
- 定位

 这三种布局方式都是用来摆放盒子的，盒子摆放到合适位置，布局自然就完成了

注意：实际开发中，一个页面基本都包含了这三种布局方式

## 1. 标准流（普通流/文档流）

所谓的标准流:  就是标签按照规定好默认方式排列

+ 块级元素会独占一行，从上向下顺序排列
	+ 常用元素：`div`、`hr`、`p`、`h1`~`h6`、`ul`、`ol`、`dl`、`form`、`table`
+ 行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行
	+ 常用元素：`span`、`a`、`i`、`em` 等 

标准流是最基本的布局方式

## 2. 浮动

### 2.1 为什么需要浮动

有很多的布局效果，标准流没有办法完成，此时就可以利用浮动完成布局。因为浮动可以改变元素标签默认的排列方式

浮动最典型的应用：可以让多个块级元素一行内排列显示

==网页布局第一准则：多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动==

### 2.2 什么是浮动

float 属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及块或另一个浮动框的边缘

语法：
```css
 选择器 { float: 属性值; }
```

| 属性值 | 描述                 |
| ------ | -------------------- |
| none   | 元素不浮动（默认值） |
| left   | 元素向左浮动         |
| right       | 元素向右浮动                     |

### 2.3 浮动特性

加了浮动之后的元素, 会具有很多特性：

+ 浮动元素会脱离标准流 (脱标：浮动的盒子不再保留原先的位置)

  ![CSS传统网页布局方式01.png](https://zhf-picture.oss-cn-qingdao.aliyuncs.com/my-img/CSS传统网页布局方式01.png)

+ 浮动的元素会一行内显示并且元素顶部对齐
	+ 注意：浮动的元素是互相贴靠在一起的（不会有缝隙），如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐
+ 浮动的元素会具有行内块元素的特性
	+ 任何元素都可以浮动，如果块级盒子没有设置宽度，默认宽度和父级一样宽，但是添加浮动后，它的大小根据内容来决定
	+ 浮动的盒子中间是没有缝隙的

### 2.4 浮动布局注意点

+ 浮动和标准流的父盒子搭配

  + 为了约束浮动元素位置, 我们网页布局一般采取的策略是：先用标准流父元素排列上下位置, 之后内部子元素采取浮动排列左右位置，符合网页布局第一准侧

    ![CSS传统网页布局方式02.png](https://zhf-picture.oss-cn-qingdao.aliyuncs.com/my-img/CSS传统网页布局方式02.png)

  + 先用标准流的父元素排列上下位置, 之后内部子元素采取浮动排列左右位置

+ 一个元素浮动了，理论上其余的兄弟元素也要浮动
  + 一个盒子里面有多个子盒子，如果其中一个盒子浮动了，其他兄弟也应该浮动，以防止引起问题

+ 浮动的盒子只会影响浮动盒子后面的标准流, 不会影响前面的标准流

### 2.5 清除浮动

#### 2.5.1 为什么需要清除浮动

由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为 0 时，就会影响下面的标准流盒子

#### 2.5.2 清除浮动本质

清除浮动的本质是清除浮动元素造成的影响：浮动的子标签无法撑开父盒子的高度

注意：
- 如果父盒子本身有高度，则不需要清除浮动
- 清除浮动之后，父级就会根据浮动的子盒子自动检测高度，父级有了高度，就不会影响下面的标准流了

#### 2.5.3 清除浮动样式

语法：
```css
 选择器{clear:属性值;} 
```

| 属性值 | 描述                                       |
| ------ | ------------------------------------------ |
| left   | 不允许左侧有浮动元素（清除左侧浮动的影响） |
| right  | 不允许右侧有浮动元素（清除右侧浮动的影响） |
| both       |  同时清除左右两侧浮动的影响                                          |

清除浮动的策略是:  闭合浮动

#### 2.5.4 清除浮动的多种方式

##### 2.5.4.1 额外标签法

额外标签法也称为隔墙法，是 W3C 推荐的做法

使用方式：额外标签法会在浮动元素末尾添加一个空的标签

```html
例如 <div style="clear:both"></div>，或者其他标签（如<br/>等）
```

+ 优点： 通俗易懂，书写方便
+ 缺点： 添加许多无意义的标签，结构化较差
+ 注意： 要求这个新的空标签必须是块级元素

::: normal-demo Demo演示

```html
<style>
    div {
        background-color: #c5c2c2;
        width: 300px;
        padding: 10px;
      }
      h2 {
        text-align: center;
      }
      div span {
        display: block;
        width: 25%;
        float: left;
      }
      div p {
        color: white;
        background-color: lightblue;
        text-align: center;
        clear: both;
      }
</style>
<body>
    <div>
      <h2><a>浮动演示</a></h2>
      <span><a>1</a></span>
      <span><a>2</a></span>
      <span><a>3</a></span>
      <span><a>4</a></span>
      <span><a>5</a></span>
      <span><a>6</a></span>
      <span><a>7</a></span>
      <span><a>8</a></span>
      <p>我是一个p标签</p>
    </div>
</body>
```

:::

这里我们使用一个p标签来清除浮动

##### 2.5.4.2 父级添加overflow属性

可以给父级添加 overflow 属性，将其属性值设置为 hidden、 auto 或 scroll 

例如：
```css
overflow:hidden | auto | scroll;
```

+ 优点：代码简洁
+ 缺点：无法显示溢出的部分
+ 注意：是给父元素添加代码

::: normal-demo Demo演示

```html
<style>
    div {
        background-color: #c5c2c2;
        width: 300px;
        padding: 10px;
        overflow: hidden;
      }
      h2 {
        text-align: center;
      }
      div span {
        display: block;
        width: 25%;
        float: left;
      }
</style>
<body>
    <div>
      <h2><a>浮动演示</a></h2>
      <span><a>1</a></span>
      <span><a>2</a></span>
      <span><a>3</a></span>
      <span><a>4</a></span>
      <span><a>5</a></span>
      <span><a>6</a></span>
      <span><a>7</a></span>
      <span><a>8</a></span>
    </div>
</body>
```

:::

##### 2.5.4.3 父级添加after伪元素

`:after ` 方式是额外标签法的升级版，给父元素添加：

```css
 .clearfix:after {  
   content: ""; 
   display: block; 
   height: 0; 
   clear: both; 
   visibility: hidden;  
 } 
 .clearfix {  /* IE6、7 专有 */ 
   *zoom: 1;
 }   
```

+ 优点：没有增加标签，结构更简单
+ 缺点：兼容性问题

::: normal-demo Demo演示

```html
<style>
    div {
        background-color: #c5c2c2;
        width: 300px;
        padding: 10px;
      }
      h2 {
        text-align: center;
      }
      div span {
        display: block;
        width: 25%;
        float: left;
      }
      .clearfix:after {
        content: '';
        display: block;
        height: 0;
        clear: both;
        visibility: hidden;
      }
</style>
<body>
    <div class="clearfix">
      <h2><a>浮动演示</a></h2>
      <span><a>1</a></span>
      <span><a>2</a></span>
      <span><a>3</a></span>
      <span><a>4</a></span>
      <span><a>5</a></span>
      <span><a>6</a></span>
      <span><a>7</a></span>
      <span><a>8</a></span>
    </div>
</body>
```

:::

##### 2.5.4.4 父级添加双伪元素

给父元素添加：
```css
 .clearfix:before,.clearfix:after {
   content:"";
   display:table; 
 }
 .clearfix:after {
   clear:both;
 }
 .clearfix {
    *zoom:1;
     /* IE6、7 专有 */
 }   
```

+ 优点：代码更简洁
+ 缺点：兼容性问题

::: normal-demo Demo演示

```html
<style>
    div {
        background-color: #c5c2c2;
        width: 300px;
        padding: 10px;
      }
      h2 {
        text-align: center;
      }
      div span {
        display: block;
        width: 25%;
        float: left;
      }
      .clearfix:before,
      .clearfix:after {
        content: '';
        display: table;
      }
      .clearfix:after {
        clear: both;
      }
</style>
<body>
    <div class="clearfix">
      <h2><a>浮动演示</a></h2>
      <span><a>1</a></span>
      <span><a>2</a></span>
      <span><a>3</a></span>
      <span><a>4</a></span>
      <span><a>5</a></span>
      <span><a>6</a></span>
      <span><a>7</a></span>
      <span><a>8</a></span>
    </div>
</body>
```

:::

### 2.6 总结

为什么需要清除浮动？
1. 父级没高度
2. 子盒子浮动了
3. 影响下面布局了，我们就应该清除浮动了

| 清除浮动的方式          | 优点                 | 缺点                             |
| ----------------------- | -------------------- | -------------------------------- |
| 额外标签法              | 通俗易懂，书写方便   | 添加许多无意义的标签，结构化较差 |
| 父级 `overflow:hidden;` | 书写简单             | 溢出隐藏                         |
| 父级 `after` 伪元素     | 结构语义化，代码简洁 | 兼容性问题                       |
| 父级双伪元素                        |  结构语义化，代码简洁                    | 兼容性问题                                 |

## 3. 定位

### 3.1 为什么使用定位

浮动可以让多个块级盒子一行没有缝隙排列显示，经常用于横向排列盒子

定位则是可以让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子

### 3.2 定位组成

定位：将盒子定在某一个位置，所以**定位也是在摆放盒子，按照定位的方式移动盒子**

定位也是用来布局的，它有两部分组成：`定位 = 定位模式 + 边偏移`

**定位模式** 用于指定一个元素在文档中的定位方式

**边偏移**则决定了该元素的最终位置

#### 3.2.1 边偏移（方位名词）

**边偏移** 就是定位的盒子移动到最终位置。有 top、bottom、left 和 right  4 个属性

| 边偏移属性 | 示例           | 描述                                                   |
| ---------- | :------------- | ------------------------------------------------------ |
| `top`      | `top: 80px`    | **顶端**偏移量，定义元素相对于其父元素**上边线的距离** |
| `bottom`   | `bottom: 80px` | **底部**偏移量，定义元素相对于其父元素**下边线的距离** |
| `left`     | `left: 80px`   | **左侧**偏移量，定义元素相对于其父元素**左边线的距离** |
| `right`    | `right: 80px`  | **右侧**偏移量，定义元素相对于其父元素**右边线的距离** |

定位的盒子有了边偏移才有价值。一般情况下，凡是有定位的地方必有边偏移

#### 3.2.2 定位模式（position）

在 CSS 中，通过 `position` 属性定义元素的**定位模式**，语法如下：

```css
选择器 { 
    position: 属性值; 
}
```

定位模式是有不同分类的，在不同情况下，我们用到不同的定位模式

定位模式决定元素的定位方式，它通过 CSS 的 position 属性来设置，其值可以分为四个：

| 值         |     语义     |
| ---------- | :----------: |
| `static`   | **静态**定位 |
| `relative` | **相对**定位 |
| `absolute` | **绝对**定位 |
| `fixed`    | **固定**定位 |
| `sticky`   | **粘性**定位 |

##### 3.2.2.1 静态定位 (static) 

**静态定位**是元素的**默认**定位方式，**无定位的意思**，在不需要定位的时候用

语法：

```
选择器 { 
    position: static; 
}
```

静态定位按照标准流特性摆放位置，它没有边偏移，静态定位在布局时几乎不用

##### 3.2.2.2 相对定位 (relative) 

**相对定位**是元素在移动位置的时候，是相对于它自己**原来的位置**来说的

语法：

```
选择器 { 
	position: relative; 
}
```

相对定位的特点：（务必记住）

- 它是相对于自己原来的位置来移动的（移动位置的时候参照点是自己原来的位置）

+ **原来**在标准流的**位置**继续占有，后面的盒子仍然以标准流的方式对待它，因此，**相对定位并没有脱标**

##### 3.2.2.3 绝对定位 (absolute)

###### 3.2.2.3.1 绝对定位的介绍

**绝对定位**是元素在移动位置的时候，是相对于它**祖先元素**来说的

语法：

```
 选择器 { 
 	position: absolute; 
 }
```

绝对定位的特点：

+ **完全脱标** —— 完全不占位置
+ 如果没有祖先元素或者祖先元素没有定位，则以**浏览器**为准定位（Document 文档）
+ 如果祖先元素有定位 (相对、绝对、固定定位)，则以最近一级的有定位祖先元素为参考点移动位置

###### 3.2.2.3.2 定位口诀——子绝父相

==子级是绝对定位的话，父级要用相对定位==

+ 子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子
+ 父盒子需要加定位限制子盒子在父盒子内显示
+ 父盒子布局时，需要占有位置，因此父亲只能是相对定位

**父级要占有位置，子级要任意摆放**这就是子绝父相的由来，所以**相对定位经常用来作为绝对定位的父级**

总结： **因为父级需要占有位置，因此是相对定位， 子盒子不需要占有位置，则是绝对定位**

当然，子绝父相不是永远不变的，如果父元素不需要占有位置，**子绝父绝**也会遇到

##### 3.2.2.4 固定定位 (fixed) 

**固定定位**是元素**固定于浏览器可视区的位置**

主要使用场景：可以在浏览器页面滚动时元素的位置不会改变

语法：

```
 选择器 { 
 	position: fixed; 
 }
```

固定定位的特点：

- 以浏览器的可视窗口为参照点移动元素
- 跟父元素没有任何关系
- 不随滚动条滚动
- 固定定位**不再占有原先的位置**
- 固定定位也是**脱标**的，其实**固定定位也可以看做是一种特殊的绝对定位**

##### 3.2.2.5 粘性定位 (sticky) 

**粘性定位**可以被认为是相对定位和固定定位的混合

语法：

```
 选择器 { 
     position: sticky; 
     top: 10px; 
 }

```

粘性定位的特点：

- 以浏览器的可视窗口为参照点移动元素（固定定位特点）
- 粘性定位占有原先的位置（相对定位特点）
- 必须添加 top 、left、right、bottom **其中一个**才有效

##### 3.2.2.6 总结

| **定位模式**          | **是否脱标**         | **移动位置**           | **是否常用**                 |
| --------------------- | -------------------- | ---------------------- | ---------------------------- |
| static 静态定位       | 否 (占有位置)        | 不能使用边偏移         | 很少                         |
| **relative 相对定位** | **否 (占有位置)**    | **相对于自身位置移动** | **基本单独使用**             |
| **absolute 绝对定位** | **是（不占有位置）** | **带有定位的父级**     | **要和定位父级元素搭配使用** |
| **fixed 固定定位**    | **是（不占有位置）** | **浏览器可视区**       | **单独使用，不需要父级**     |
| sticky 粘性定位       | 否   (占有位置)      | 浏览器可视区           | 当前阶段少                   |

注意：

1. **边偏移**需要和**定位模式**联合使用，**单独使用无效**
2. `top` 和 `bottom` 不要同时使用
3. `left` 和 `right` 不要同时使用

### 3.3 定位的应用

固定定位小技巧： 固定在版心右侧位置

小算法：

1. 让固定定位的盒子 `left: 50%;`，走到浏览器可视区（也可以看做版心）的一半位置
2. 让固定定位的盒子 `margin-left: 版心宽度的一半距离;` 多走版心宽度的一半位置
3. 就可以让固定定位的盒子**贴着版心右侧对齐**了

### 3.4 定位堆叠顺序 (z-index)

在使用**定位**布局时，可能会**出现盒子重叠的情况**，此时，可以使用 `z-index` 来控制盒子的前后次序 (z轴)

语法：

```
选择器 { 
	z-index: 1; 
}
```

`z-index` 的特性如下：

- 属性值：正整数、负整数或0，默认值是0，数值越大，盒子越靠上
- 如果属性值相同，则按照书写顺序，后来者居上
- 数字后面==不能加单位==

==注意：`z-index` 只能应用于相对定位、绝对定位和固定定位的元素，其他标准流、浮动和静态定位无效==

### 3.5 定位的拓展

#### 3.5.1 绝对定位的盒子居中

注意：加了绝对定位/固定定位的盒子不能通过设置 `margin: auto` 设置水平居中，但是可以通过以下计算方法实现水平和垂直居中，可以按照下图的方法：

1. `left: 50%;` 让盒子的左侧移动到父级元素的水平中心位置
2. `margin-left: -x px;` 让盒子向左移动自身宽度的一半

::: normal-demo Demo 演示

```html
<style>
    .box{
        width:50px;
        height:50px;
        background-color:pink;
        position:absolute;
        left:50%;
        margin-left:-25px;
    }
</style>
<body>
    <div class="box"></div>
</body>
```

:::

#### 3.5.2 定位特殊特性

绝对定位和固定定位也和浮动类似：

1. 行内元素添加绝对或者固定定位，可以直接设置高度和宽度
2. 块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小

display 是显示模式，可以改变显示模式有以下方式:

+ 可以用 `inline-block`  转换为行内块
+ 可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的）
+ 绝对定位和固定定位也和浮动类似，默认转换的特性转换为行内块

> 所以说，一个行内的盒子，如果加了浮动、固定定位和绝对定位，不用转换，就可以给这个盒子直接设置宽度和高度等

#### 3.5.3 脱标的盒子不会触发外边距塌陷

浮动元素、绝对定位 (固定定位）元素的都不会触发外边距合并的问题

也就是说，我们给盒子改为了浮动或者定位，就不会有垂直外边距合并的问题

#### 3.5.4 绝对定位(固定定位)会完全压住盒子

浮动元素不同，只会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字，但是绝对定位（固定定位）会压住下面标准流所有的内容

浮动之所以不会压住文字，因为浮动产生的目的最初是为了做文字环绕效果的，文字会围绕浮动元素
